"use strict";
var ZoomCharts = ZoomCharts || {};
! function (t) {
    /*!
        @license
        DVSL Charting library, version 1.18.8.
        (c) 2013 - 2018 Data Visualization Software Lab
        
        https://zoomcharts.com
        
        Embedded 3rd party software libraries:
        
          CssColorParser.js
            author : Dean McNamee <dean@gmail.com>, 2012.
            license : MIT
            github.com/deanm/css-color-parser-js
        
          SHA-256 implementation in JavaScript
            author : Chris Veness
            license: MIT
            github.com/chrisveness/crypto
        
          jsrsasign (RSA-Sign JavaScript Library)
            version : 4.7.2
            author : Kenji Urushima
            license : MIT
            kjur.github.io/jsrsasign/
        
          jsbn (RSA and ECC in JavaScript)
            version : 1.4
            author : Tom Wu
            license : BSD (http://www-cs-students.stanford.edu/~tjw/jsbn/LICENSE)
            www-cs-students.stanford.edu/~tjw/jsbn/
        */
    var e = t.Configuration || (t.Configuration = {}),
        i = t.Internal || (t.Internal = {});
    t.PackageInfo = {
        LibraryName: "zoomcharts",
        Version: "1.18.8",
        Revision: "aede16f98826b334cc26aee63992c67260b48b38",
        Built: "2018-08-10"
    };
    var n = function (t, e) {
        function i() {
            this.constructor = t
        }
        t.__baseType = e;
        for (var n in e) e.hasOwnProperty(n) && (t[n] = e[n]);
        t.prototype = null === e ? Object.create(e) : (i.prototype = e.prototype, new i)
    };
    ! function (i) {
        var r = i.GeoChart || (i.GeoChart = {}),
            s = i.FacetChart || (i.FacetChart = {}),
            a = i.PieChart || (i.PieChart = {}),
            o = i.TimeChart || (i.TimeChart = {}),
            l = i.LinearChart || (i.LinearChart = {}),
            h = i.NetChart || (i.NetChart = {}),
            u = i.ItemsChart || (i.ItemsChart = {}),
            c = i.Resources || (i.Resources = {}),
            d = i.Base || (i.Base = {});
        "undefined" != typeof module && module.exports && (module.exports.Internal = i),
            function (r) {
                function s() {}

                function a(t, e) {
                    for (var i in e) e.hasOwnProperty(i) && !t.hasOwnProperty(i) && (t[i] = e[i])
                }
                var o = r.Bar || (r.Bar = {}),
                    l = Object.prototype.hasOwnProperty,
                    h = ("undefined" == typeof console ? null : console) || {};
                h.log || (h.log = s), h.warn || (h.warn = s), h.error || (h.error = s), h.info || (h.info = s), r.overlayConsole = !1;
                var u = "undefined" != typeof Document && !(document instanceof Document),
                    d = function () {
                        function t() {}
                        return t.exportSymbol = function (t, e) {
                            "undefined" != typeof window && (window[t] = e), "undefined" != typeof module && module.exports && (module.exports[t] = e)
                        }, t.extendStyleTo = function (t, e, i) {
                            void 0 === i && (i = !0);
                            for (var n = Object.keys(t), r = 0; r < n.length; r++) {
                                var s = n[r],
                                    a = t[s];
                                void 0 === a || !i && void 0 !== e[s] || (e[s] = a)
                            }
                        }, t.extendDataItem = function (e, i) {
                            for (var n = e, r = Object.keys(i), s = 0; s < r.length; s++) {
                                var a = r[s],
                                    o = i[a];
                                "style" === a ? n.style ? t.extendDeep(n.style, o) : n.style = t.realClone(o) : n[a] = o
                            }
                            return n
                        }, t.extendDeep = function (e, i) {
                            if (null == e) throw new Error("Target object is not defined.");
                            if (!t.isObjectOrArray(e)) throw new Error("Target is not an object.");
                            for (var n = Object.keys(i), r = 0; r < n.length; r++) {
                                var s = n[r],
                                    a = i[s],
                                    o = e[s];
                                null == o && t.isObjectOrArray(a) && !t.isDomObject(a) ? e[s] = this.realClone(a) : t.isObjectOrArray(o) && t.isObjectOrArray(a) && !t.isDomObject(o) && !t.isDomObject(a) ? this.extendDeep(o, a) : e[s] = a
                            }
                        }, t.extendCopy = function (t, e, i) {
                            if (void 0 === i && (i = null), !e) return t;
                            for (var n = Object.keys(e), r = 0; r < n.length; r++) {
                                var s = n[r],
                                    a = e[s];
                                if (i && (a = i(s, a)), void 0 !== a) {
                                    var o = t[s];
                                    this.isDomObject(a) ? t[s] = a : this.isObjectOrArray(o) && this.isObjectOrArray(a) ? this.extendCopy(o, a, i) : this.isObjectOrArray(a) ? Array.isArray(a) ? t[s] = this.extendCopy([], a, i) : t[s] = this.extendCopy({}, a, i) : t[s] = a
                                }
                            }
                            return t
                        }, t.clone = function (e) {
                            if (null == e) return e;
                            var i;
                            i = t.isObjectOrArray(e) ? new e.constructor : e.constructor();
                            for (var n = Object.keys(e), r = 0; r < n.length; r++) {
                                var s = n[r],
                                    a = e[s];
                                i[s] = a
                            }
                            return i
                        }, t.isObjectOrArray = function (t) {
                            return null !== t && "object" == typeof t
                        }, t.isDomObject = function (t) {
                            return t && (t instanceof Element || t instanceof CanvasGradient || t instanceof CanvasPattern || u && 2 === t.ATTRIBUTE_NODE)
                        }, t.isFunction = function (t) {
                            return "function" == typeof t
                        }, t.isNumber = function (t) {
                            return !isNaN(t) && ("number" == typeof t || t instanceof Number)
                        }, t.isString = function (t) {
                            return "string" == typeof t || t instanceof String
                        }, t.tryParseInt = function (t, e) {
                            void 0 === e && (e = 0);
                            var i = parseInt(t, 10);
                            return isNaN(i) ? e : i
                        }, t.tryParseFloat = function (t, e) {
                            void 0 === e && (e = 0);
                            var i = parseFloat(t);
                            return isNaN(i) ? e : i
                        }, t.hasProperty = function (t, e) {
                            return l.call(t, e)
                        }, t.hasProperties = function (t) {
                            return !!t && Object.keys(t).length > 0
                        }, t.removePropertyValue = function (t) {
                            var e = Object.keys(t);
                            if (0 === e.length) return null;
                            var i = e[0],
                                n = t[i];
                            return delete t[i], {
                                key: i,
                                value: n
                            }
                        }, t.countProperties = function (t) {
                            return Object.keys(t).length
                        }, t.realClone = function (t) {
                            if (this.isFunction(t) || this.isDomObject(t)) return t;
                            if (Array.isArray(t)) {
                                for (var e = new Array(t.length), i = 0; i < t.length; i++) e[i] = this.realClone(t[i]);
                                return e
                            }
                            if (this.isObjectOrArray(t)) {
                                for (var n = new t.constructor, r = Object.keys(t), i = 0; i < r.length; i++) {
                                    var s = r[i];
                                    n[s] = this.realClone(t[s])
                                }
                                return n
                            }
                            return t
                        }, t.realCloneSafe = function (t, e) {
                            if (void 0 === e && (e = []), this.isFunction(t) || this.isDomObject(t)) return t;
                            if (Array.isArray(t)) {
                                for (var i = 0; i < e.length; i++) {
                                    var n = e[i];
                                    if (n.from === t) return n.to
                                }
                                var r = new Array(t.length);
                                e.push({
                                    from: t,
                                    to: r
                                });
                                for (var i = 0; i < t.length; i++) r[i] = this.realCloneSafe(t[i], e);
                                return r
                            }
                            if (this.isObjectOrArray(t)) {
                                for (var i = 0; i < e.length; i++) {
                                    var n = e[i];
                                    if (n.from === t) return n.to
                                }
                                var s = new t.constructor;
                                e.push({
                                    from: t,
                                    to: s
                                });
                                for (var a = Object.keys(t), i = 0; i < a.length; i++) {
                                    var o = a[i];
                                    s[o] = this.realCloneSafe(t[o], e)
                                }
                                return s
                            }
                            return t
                        }, t.removeFromArray = function (t, e) {
                            for (var i, n = !1;
                                (i = t.indexOf(e)) > -1;) t.splice(i, 1), n = !0;
                            return n
                        }, t.removeFromArrayHasty = function (t, e) {
                            var i = t.indexOf(e);
                            if (i < 0) return !1;
                            var n = t.pop();
                            return i !== t.length && (t[i] = n), !0
                        }, t.arrayToMap = function (t, e) {
                            for (var i = {}, n = 0; n < t.length; n++) {
                                var r = t[n];
                                r.index = n, i[r[e]] = r
                            }
                            return i
                        }, t.overlayConsoleMessage = function (e, i, n) {
                            var r = document.getElementById("zoomChartsOverlayConsole");
                            r || (r = document.createElement("div"), r.id = "zoomChartsOverlayConsole", t.extendCopy(r.style, {
                                position: "absolute",
                                top: "10px",
                                left: "10px",
                                width: "50%",
                                height: "300px",
                                overflow: "auto",
                                backgroundColor: "rgba(255,255,255,0.75)",
                                border: "1px solid black",
                                zIndex: "99999"
                            }), document.body.appendChild(r));
                            var s = document.createElement("div");
                            s.style.color = "error" === e ? "red" : "warn" === e ? "yellow" : "black", s.innerText = i + n.map(function (t) {
                                return JSON.stringify(t)
                            }).join(""), r.appendChild(s), r.scrollTop = r.scrollHeight
                        }, t.log = function (e) {
                            for (var i = [], n = 1; n < arguments.length; n++) i[n - 1] = arguments[n];
                            r.overlayConsole ? t.overlayConsoleMessage("log", e, i) : i && i.length ? h.info.apply(h, [e].concat(i)) : h.info(e)
                        }, t.warn = function (e, i, n) {
                            if (void 0 === n && (n = null), n) {
                                var s = (new Date).getTime();
                                if (this._previousConsoleMessages[e] > s) return;
                                n === !0 && (n = 5e3), this._previousConsoleMessages[e] = s + n
                            }
                            r.overlayConsole ? t.overlayConsoleMessage("warn", e, i) : i && i.length ? h.warn.apply(h, [e].concat(i)) : h.warn(e)
                        }, t.error = function (e) {
                            for (var i = [], n = 1; n < arguments.length; n++) i[n - 1] = arguments[n];
                            // r.overlayConsole ? t.overlayConsoleMessage("error", e, i) : i && i.length ? h.error.apply(h, [e].concat(i)) : h.error(e)
                        }, t.createDom = function (t, e, i, n) {
                            void 0 === e && (e = null), void 0 === i && (i = null), void 0 === n && (n = null);
                            var r = document.createElement(t);
                            return null !== e && (r.className = e), null !== i && (r.innerHTML = i), null !== n && n.appendChild(r), r
                        }, t.addClass = function (t, e) {
                            if (e = (e || "").trim()) {
                                var i = e.indexOf(" ");
                                if (i > -1 && (this.addClass(t, e.substr(i + 1)), e = e.substr(0, i)), t.classList) t.classList.add(e);
                                else {
                                    var n = t.className.length > 0 && new RegExp("(^|s)" + e.replace(/[-[\]{}()*+?.,\\^$|#\s]/g, "\\$&") + "(s|$)").test(t.className);
                                    n || (t.className.length > 0 && (e = " " + e), t.className = e)
                                }
                            }
                        }, t.removeClass = function (t, e) {
                            if (e = (e || "").trim()) {
                                var i = e.indexOf(" ");
                                if (i > -1 && (this.removeClass(t, e.substr(i + 1)), e = e.substr(0, i)), t.classList) t.classList.remove(e);
                                else {
                                    var n = function (t, i) {
                                        return i === e ? "" : t
                                    };
                                    t.className = t.className.replace(/(\S+)\s*/g, n).trim()
                                }
                            }
                        }, t.isStyleSheetDefined = function (t, e) {
                            var i = document.createElement("dvsl-test"),
                                n = document.body;
                            n.appendChild(i);
                            try {
                                var r = window.getComputedStyle(i),
                                    s = r[e];
                                return i.className = t, n.removeChild(i), n.appendChild(i), s !== r[e]
                            } finally {
                                n.removeChild(i)
                            }
                        }, t.listen = function (t, e, i) {
                            t.addEventListener(e, i)
                        }, t.unlisten = function (t, e, i) {
                            t.removeEventListener(e, i)
                        }, t.stopPropagation = function (t) {
                            t.stopPropagation()
                        }, t.canvasScaling = function () {
                            var t, e;
                            return window.screen.deviceXDPI ? (t = window.screen.deviceXDPI / window.screen.logicalXDPI, e = window.screen.deviceYDPI / window.screen.logicalYDPI) : t = e = window.devicePixelRatio ? window.devicePixelRatio : 1, {
                                x: t,
                                y: e
                            }
                        }, t.convertPointFromPageToNode = function (t, e, i, n, r) {
                            if (window && window.webkitConvertPointFromPageToNode) {
                                var s = window.webkitConvertPointFromPageToNode(t, new WebKitPoint(e, i));
                                if (s) return s
                            }
                            var a = t.getBoundingClientRect();
                            return {
                                x: n - a.left,
                                y: r - a.top
                            }
                        }, t.elementPos = function (t) {
                            var e = t.getBoundingClientRect(),
                                i = e.top + (window.pageYOffset || document.documentElement.scrollTop) - (document.documentElement.clientTop || 0),
                                n = e.left + (window.pageXOffset || document.documentElement.scrollLeft) - (document.documentElement.clientLeft || 0);
                            return {
                                left: n,
                                top: i
                            }
                        }, t.isParentOf = function (t, e) {
                            for (; e;) {
                                if (e === t) return !0;
                                e = e.parentElement
                            }
                            return !1
                        }, t.getProp = function (t, e, i) {
                            void 0 === i && (i = !1);
                            for (var n = 0, r = e.split("."); n < r.length; n++) {
                                var s = r[n];
                                if (null == t || !this.hasProperty(t, s)) return;
                                if (i && n === r.length - 1) {
                                    var a = t[s];
                                    delete t[s], t = a
                                } else t = t[s]
                            }
                            return t
                        }, t.wrapValue = function (t, e) {
                            for (var i = t, n = e.split(".").reverse(), r = 0; r < n.length; r++) {
                                var s = n[r];
                                a = {}, a[s] = i, i = a
                            }
                            return i;
                            var a
                        }, t.hasProp = function (e, i) {
                            return void 0 !== t.getProp(e, i)
                        }, t.sign = function (t) {
                            return t ? t < 0 ? -1 : 1 : 0
                        }, t.reversePolyline = function (t) {
                            var e = [];
                            if (t.length % 2 !== 0) throw new Error("The length of a given polyline must be dividable by 2");
                            for (var i = t.length - 1; i >= 0; i += -2) e.push(t[i - 1], t[i]);
                            return e
                        }, t.toleranceMax = function (t, e, i) {
                            return t >= e * i ? t : e
                        }, t.toleranceMin = function (t, e, i) {
                            return t * i <= e ? t : e
                        }, t.getIdentifierStr = function () {
                            return t.SeparatorChar + (t.nextIdentifier++).toString()
                        }, t.doPostRequest = function (t, e, i, n, r) {
                            this.isString(i) || (i = JSON.stringify(i)), this.doRequestRaw(t, e, "POST", i, n, r)
                        }, t.doRequest = function (t, e, i, n, r) {
                            if (i && i.length) {
                                t += t.indexOf("?") !== -1 ? "&" : "?";
                                for (var s = 0; s < i.length; s++) {
                                    var a = i[s];
                                    s > 0 && (t += "&"), t += encodeURIComponent(a[0]) + "=" + encodeURIComponent(a[1])
                                }
                            }
                            this.doRequestRaw(t, e, "GET", "", n, r)
                        }, t.doRequestRaw = function (t, e, i, n, r, s) {
                            var a;
                            if ("undefined" == typeof XMLHttpRequest) throw new Error("Cannot create XMLHttpRequest. Please verify if the feature is not disabled in the browser configuration.");
                            a = new XMLHttpRequest, a.onreadystatechange = function () {
                                4 === a.readyState && (200 === a.status ? r(a.responseText) : s(a.responseText))
                            };
                            try {
                                a.open(i, t, !0), a.timeout = e, a.ontimeout = function () {
                                    s('{"error": "Request timeout."}')
                                }, a.send(n)
                            } catch (t) {
                                return void window.setTimeout(function () {
                                    return s(t)
                                }, 1)
                            }
                        }, t.openUrl = function (t, e) {
                            return window.open(t, e || "_blank")
                        }, t.parseData = function (e, i, n) {
                            void 0 === n && (n = !1);
                            var r = null,
                                s = null;
                            if (i = i.toLowerCase(), "json" === i || "geojson" === i)
                                if (t.isString(e)) try {
                                    s = JSON.parse(e)
                                } catch (t) {
                                    r = n ? e : "Failed to parse JSON response: " + t + ". Response text: " + e
                                } else s = e;
                                else r = "Unsupported data format: " + i;
                            return null == s && null == r && (r = "NULL response"), r ? {
                                error: r
                            } : s
                        }, t.numberFormat = function (t, e, i, n) {
                            void 0 === e && (e = 2), void 0 === i && (i = "."), void 0 === n && (n = "聽");
                            var r = parseFloat(t);
                            if (isNaN(r)) return "鈥�";
                            var s;
                            r < 0 ? (s = "-", r = -r) : s = "";
                            for (var a, o = Math.floor(r), l = r - o, h = e > 0 ? i + l.toFixed(e).substr(2) : "";;) {
                                if (a = o % 1e3, h = a.toFixed(0) + h, !(o >= 1e3)) break;
                                o = Math.floor(o / 1e3), a < 10 ? h = "00" + h : a < 100 && (h = "0" + h), h = n + h
                            }
                            return s + h
                        }, t.printPercentValue = function (t, e, i) {
                            void 0 === i && (i = "");
                            var n = "",
                                s = 0;
                            if (e[1]) {
                                var a = e[1];
                                n = a.charAt(0), s = a.length - 1
                            }
                            var o = e[2],
                                l = r.Helpers.numberFormat(100 * t, s, n);
                            return "" !== i && " " === o.charAt(0) && (i = " " + i), l + i + o
                        }, t.printCurrencyValue = function (t, e, i) {
                            void 0 === i && (i = "");
                            var n = "",
                                s = 0;
                            if (e[2]) {
                                var a = e[2];
                                n = a.charAt(0), s = a.length - 1
                            }
                            var o = e[1] ? e[1] : "",
                                l = e[3] ? e[3] : "",
                                h = r.Helpers.numberFormat(t, s, n);
                            return "" !== i && " " === l.charAt(0) && (i = " " + i), o && l && (l.indexOf("%") > -1 || o.indexOf("%") > -1) ? (this.warn("Incorrect valueFormat using '%'. To format as percentage, '%' must be used after digits without any prefix."), r.Helpers.numberFormat(t)) : o + h + i + l
                        }, t.matchPercentFormat = function (t) {
                            return /^0([.,]0+)?( ?%)$/.exec(t)
                        }, t.matchCurrencyFormat = function (t) {
                            return /^([^0-9]+)?0?([.,]0+)?([^0-9]+)?$/.exec(t)
                        }, t.buildImage = function (t, e, i, n) {
                            var r = this,
                                s = document.createElement("img"),
                                a = function () {
                                    return i(s)
                                },
                                o = function (a) {
                                    e ? r.buildImage(t, null, i, n) : n(s)
                                };
                            return e && (s.crossOrigin = e), s.src = t, s.complete ? s.width > 0 ? a() : setTimeout(a, 0) : (s.onload = a, s.onerror = o), s
                        }, t.sort = function (t, e) {
                            e || (e = function (t, e) {
                                return t - e
                            });
                            for (var i, n, r = t, s = 0 | r.length, a = 0; a <= s - 2; a += 2) i = r[a], n = r[a + 1], e(i, n) > 0 && (r[a] = n, r[a + 1] = i);
                            for (var o = r.slice(0), l = 2; l < s;) {
                                for (var h = l << 1, u = 0; u <= s - 1; u += h) {
                                    var c = u,
                                        d = u + l;
                                    if (d >= s)
                                        for (var a = c; a <= s - 1; a++) o[a] = r[a];
                                    else {
                                        var p = d,
                                            f = Math.min(d + l, s),
                                            g = u;
                                        for (i = r[c], n = r[d];;)
                                            if (e(i, n) <= 0) {
                                                if (o[g] = i, g = g + 1 | 0, c = c + 1 | 0, c === p) {
                                                    for (o[g] = n, g = g + 1 | 0, d = d + 1 | 0; d < f;) o[g] = r[d], g = g + 1 | 0, d = d + 1 | 0;
                                                    break
                                                }
                                                i = r[c]
                                            } else {
                                                if (o[g] = n, g = g + 1 | 0, d = d + 1 | 0, d === f) {
                                                    for (o[g] = i, g = g + 1 | 0, c = c + 1 | 0; c < p;) o[g] = r[c], g = g + 1 | 0, c = c + 1 | 0;
                                                    break
                                                }
                                                n = r[d]
                                            }
                                    }
                                }
                                l = h;
                                var m = o;
                                o = r, r = m
                            }
                            if (t !== r) {
                                for (var a = 0; a <= s - 1; a++) t[a] = r[a];
                                r.length = 0
                            } else o.length = 0;
                            return t
                        }, t.binSearch = function (t, e) {
                            for (var i = 0, n = t.length - 1; i < n;) {
                                var r = (n + i) / 2 | 0;
                                if (t[r] < e) i = r + 1;
                                else {
                                    if (!(t[r] > e)) {
                                        for (; r > 0 && t[r - 1] === e;) r -= 1;
                                        return r
                                    }
                                    n = r
                                }
                            }
                            return i < t.length && t[i] < e ? i + 1 : i
                        }, t.listenResize = function (e, i) {
                            var n = document.documentMode;
                            if (n && n < 11) e.onresize = i;
                            else {
                                var r = e,
                                    s = document.createElement("div"),
                                    a = function (e) {
                                        i(), t.updateResizeTriggers(s)
                                    };
                                "static" === window.getComputedStyle(r).position && (r.style.position = "relative"), r.__resizeTriggers__ = s, s.className = "DVSL-resize-triggers", s.innerHTML = '<div class="DVSL-expand-trigger"><div></div></div><div class="DVSL-contract-trigger"></div>', r.insertBefore(s, r.firstChild), t.updateResize(s), r.__resizeListener__ = a, r.addEventListener("scroll", a, !0)
                            }
                        }, t.updateResize = function (t) {
                            var e = t.__resizeTriggers__;
                            e && this.updateResizeTriggers(e)
                        }, t.updateResizeTriggers = function (t) {
                            var e = t.firstElementChild || t.firstChild,
                                i = t.lastElementChild || t.lastChild,
                                n = e.firstElementChild || e.firstChild;
                            i.scrollLeft = i.scrollWidth, i.scrollTop = i.scrollHeight, n.style.width = e.offsetWidth + 1 + "px", n.style.height = e.offsetHeight + 1 + "px", e.scrollLeft = e.scrollWidth, e.scrollTop = e.scrollHeight
                        }, t.unlistenResize = function (t) {
                            var e = t,
                                i = e.__resizeTriggers__;
                            i ? (e.removeEventListener("scroll", e.__resizeListener__, !0), i.parentNode && i.parentNode.removeChild(i), delete e.__resizeListener__, delete e.__resizeTriggers__) : delete t.onresize
                        }, t.decodeEntities = function (e) {
                            return e.indexOf("&") === -1 ? e : (t.decodeTextarea || (t.decodeTextarea = document.createElement("textarea")), t.decodeTextarea.innerHTML = e, t.decodeTextarea.value)
                        }, t.base64Encode = function (t) {
                            if (window.btoa) return window.btoa(t);
                            for (var e = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=", i = "", n = 0, r = 0; t.charAt(0 | r) || (e = "=", r % 1); i += e.charAt(63 & n >> 8 - r % 1 * 8)) {
                                var s = t.charCodeAt(r += .75);
                                if (s > 255) throw new Error("'btoa' failed: The string to be encoded contains characters outside of the Latin1 range.");
                                n = n << 8 | s
                            }
                            return i
                        }, t.compareVersions = function (t, e) {
                            for (var i = t.split("."), n = i.length, r = e.length, s = 0; s < Math.max(n, r); s++) {
                                var a = s < n ? parseInt(i[s], 10) : 0,
                                    o = s < r ? e[s] : 0;
                                if (a > o) return !0;
                                if (a < o) return !1
                            }
                            return !0
                        }, t.aggregate = function (t, e, i) {
                            for (var n = 0, r = this.aggregationCallbacks[t], s = r.start; e();) {
                                var a = i();
                                r.increment(s, a), n += 1
                            }
                            return n > 0 ? r.result(s, n) : null
                        }, t.getRelativeClientRect = function (t) {
                            if (!t) return null;
                            if (!t.offsetParent) return null;
                            var e = t.getBoundingClientRect(),
                                i = t.offsetParent.getBoundingClientRect();
                            return {
                                bottom: i.bottom - e.bottom,
                                height: e.height,
                                left: e.left - i.left,
                                right: i.right - e.right,
                                top: e.top - i.top,
                                width: e.width
                            }
                        }, t
                    }();
                if (d._previousConsoleMessages = {}, d.SeparatorChar = String.fromCharCode(63743), d.nextIdentifier = 0, d.decodeTextarea = null, d.aggregationCallbacks = {
                        sum: {
                            start: 0,
                            increment: function (t, e) {
                                return t + e
                            },
                            result: function (t, e) {
                                return t
                            }
                        },
                        min: {
                            start: 1 / 0,
                            increment: function (t, e) {
                                return Math.min(t, e)
                            },
                            result: function (t, e) {
                                return t
                            }
                        },
                        max: {
                            start: -(1 / 0),
                            increment: function (t, e) {
                                return Math.max(t, e)
                            },
                            result: function (t, e) {
                                return t
                            }
                        },
                        avg: {
                            start: 0,
                            increment: function (t, e) {
                                return t + e
                            },
                            result: function (t, e) {
                                return t / e
                            }
                        },
                        count: {
                            start: 0,
                            increment: function (t, e) {
                                return 0
                            },
                            result: function (t, e) {
                                return e
                            }
                        },
                        first: {
                            start: null,
                            increment: function (t, e) {
                                return null !== t && void 0 !== t ? t : e
                            },
                            result: function (t, e) {
                                return t
                            }
                        },
                        last: {
                            start: null,
                            increment: function (t, e) {
                                return null !== e && void 0 !== e ? e : t
                            },
                            result: function (t, e) {
                                return t
                            }
                        }
                    }, r.Helpers = d, "undefined" != typeof window) {
                    var p = window.requestAnimationFrame || window.mozRequestAnimationFrame || window.webkitRequestAnimationFrame || window.msRequestAnimationFrame || window.oRequestAnimationFrame,
                        f = window.cancelAnimationFrame || window.mozCancelAnimationFrame || window.webkitCancelAnimationFrame || window.msCancelRequestAnimationFrame || window.oCancelAnimationFrame;
                    if (!p) {
                        var g = 0;
                        p = function (t) {
                            var e = (new Date).getTime(),
                                i = Math.max(0, 16 - (e - g)),
                                n = window.setTimeout(function () {
                                    return t(e + i)
                                }, i);
                            return g = e + i, n
                        }, f = window.clearTimeout
                    }
                    f || (f = function () {}), d.requestAnimationFrame = function (t) {
                        return p.call(window, t)
                    }, d.cancelAnimationFrame = function (t) {
                        return f.call(window, t)
                    };
                    var m = (new Date).getTime();
                    "performance" in window == !1 ? d.performanceNow = function () {
                        return (new Date).getTime() - m
                    } : "now" in window.performance == !1 ? (performance.timing && performance.timing.navigationStart && (m = performance.timing.navigationStart), d.performanceNow = function () {
                        return (new Date).getTime() - m
                    }) : d.performanceNow = function () {
                        return window.performance.now()
                    };
                    var v = m - d.performanceNow();
                    d.timeToPerfNow = function (t) {
                        return t - v
                    }
                }
                var y = function () {
                    function t() {
                        this.id = "default", this.url = null, this.urlParameters = [], this.postprocessorFunction = null, this.preloaded = null, this.format = "JSON", this.requestTimeout = 4e4, this.numberOfParallelRequests = 3
                    }
                    return t
                }();
                r.SettingsData = y;
                var S = function () {
                    function t(t, e) {
                        this.removed = !1, this.requestScheduled = !1, this.requestsRunning = !1, this.requestCount = 0, this.dataSettings = e, this.chart = t, this.settings = t.settings
                    }
                    return t.doRequest = function (t, e, i, n, r) {
                        if (e.urlParameters.length) {
                            i = i.slice();
                            for (var s = 0; s < e.urlParameters.length; s++) {
                                var a = e.urlParameters[s];
                                i.push([a.name, a.value])
                            }
                        }
                        var o;
                        o = e.postprocessorFunction ? function (t) {
                            return n(e.postprocessorFunction(t))
                        } : n, d.doRequest(t, e.requestTimeout, i, o, r)
                    }, t.prototype.buildRequest = function () {
                        return null
                    }, t.prototype.verifyData = function (t, e) {
                        return !0
                    }, t.prototype.addVerifiedData = function (t, e) {
                        return {}
                    }, t.prototype.requestFailedPermanently = function (t) {}, t.prototype.remove = function () {
                        this.removed = !0
                    }, t.prototype.hasPendingRequests = function () {
                        return !this.removed && this.requestCount > 0
                    }, t.prototype.addData = function (t) {
                        this._dataArrived(null, t)
                    }, t.prototype.applyPreloadedData = function () {
                        this.dataSettings.preloaded && this._dataArrived(null, this.dataSettings.preloaded)
                    }, t.prototype.scheduleRequests = function (t) {
                        var e = this;
                        void 0 === t && (t = !1), t ? this._runRequests() : this.requestScheduled || (this.requestScheduled = !0, setTimeout(function () {
                            return e._runRequests()
                        }, 0))
                    }, t.prototype._runRequests = function () {
                        var t = this;
                        if (!this.removed && !this.requestsRunning) {
                            this.requestScheduled = !1;
                            var e;
                            try {
                                for (this.requestsRunning = !0; this.requestCount < this.dataSettings.numberOfParallelRequests && (e = this.buildRequest(), null !== e);) ! function (e) {
                                    var i = function (i) {
                                            return t._dataArrived(e, i)
                                        },
                                        n = function (i) {
                                            return t._dataError(e, i)
                                        };
                                    t.requestCount += 1, t.chart.log("Requesting data for", e), t.dataFunc(e, i, n)
                                }(e)
                            } finally {
                                this.requestsRunning = !1
                            }
                        }
                    }, t.prototype._dataError = function (t, e) {
                        if (!this.removed) {
                            var i = d.parseData(e, this.dataSettings.format, !0),
                                n = i.error ? i.error : "Unknown error";
                            t ? (this.requestCount -= 1, this.chart.error("Data request failed: " + n, t)) : this.chart.error("Data loading failed: " + n), this.requestFailedPermanently(t), this._runRequests()
                        }
                    }, t.prototype._dataArrived = function (t, e) {
                        if (!this.removed) {
                            var i = d.parseData(e, this.dataSettings.format);
                            if (t ? (this.requestCount -= 1, i.error ? this.chart.error("Data request succeeded, but contained an error: " + i.error, t) : this.chart.log("Data arrived for request", t)) : i.error ? this.chart.error("Loaded data contains error: " + i.error) : this.chart.log("Data loaded"), !i.error && this.verifyData(t, i)) {
                                var n = this.addVerifiedData(t, i);
                                n.dataArrived || (n.dataArrived = {}), n.dataArrived[this.dataSettings.id] = !0;
                                var r = this.chart.createEventArguments(null, "api");
                                r.dataArrived = i, r.dataRemoved = null, this.chart.notifyDataUpdated(r), this.chart.events.notifySceneChanges(n)
                            } else t && this.requestFailedPermanently(t);
                            this._runRequests()
                        }
                    }, t
                }();
                r.Data = S;
                var b = function () {
                    function t() {}
                    return t.detect = function () {
                        return this._cached || this.run()
                    }, t.run = function () {
                        var t, e = window,
                            i = document.body;
                        document.domain && (t = document.createElement("iframe"), i.appendChild(t), e = t.contentWindow);
                        var n;
                        try {
                            n = this.check(e)
                        } catch (t) {
                            n = this.check(window)
                        }
                        return this._cached = n, t && i.removeChild(t), n
                    }, t.check = function (t) {
                        return {
                            isSafariDesktop: !!t.safari && !!t.safari.pushNotification,
                            isChrome: !!t.chrome && !!t.chrome.loadTimes
                        }
                    }, t
                }();
                b._cached = null, r.Browser = b;
                var C = function () {
                    function t(t, e, i, n) {
                        this.consumed = !1, this.defaultPrevented = !1, this.x = 0, this.y = 0, this.dx = 0, this.dy = 0, this.wheely = 0, this.wheelx = 0, this.identifier = "0", this.pressed = !1, this.touch = !1, this.pageX = 0, this.pageY = 0, this.shiftKey = !1, this.altKey = !1, this.ctrlKey = !1, this.target = null, this.isRightMB = !1, this._vx = null, this._vy = null, this.velocityPointer = null, this._leaving = !1, this.swipeUp = !1, this.swipeDown = !1, this.swipeLeft = !1, this.swipeRight = !1, this.swipeSpeed = null, this.capture = !1, this.hovered = !1, this.cursor = null, this.changedPointerCount = 1, this.identifier = n, this.timeStamp = i, this.y = e, this.x = t
                    }
                    return t.prototype.preventDefault = function () {
                        this.defaultPrevented = !0
                    }, Object.defineProperty(t.prototype, "vx", {
                        get: function () {
                            return null === this._vx && null !== this.velocityPointer && this.velocityPointer.calculatePosAndSpeed(this), this._vx || 0
                        },
                        set: function (t) {
                            this._vx = t
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "vy", {
                        get: function () {
                            return null === this._vy && null !== this.velocityPointer && this.velocityPointer.calculatePosAndSpeed(this), this._vy || 0
                        },
                        set: function (t) {
                            this._vy = t
                        },
                        enumerable: !0,
                        configurable: !0
                    }), t.prototype.distance = function (t) {
                        return Math.sqrt((t.x - this.x) * (t.x - this.x) + (t.y - this.y) * (t.y - this.y))
                    }, t.prototype.isWithinDistance = function (t, e, i) {
                        if (!t) return !1;
                        var n = this.pageX - t.pageX,
                            r = this.pageY - t.pageY;
                        return n * n + r * r < e * e && (null == i || t.timeStamp + i > this.timeStamp)
                    }, t
                }();
                r.MouseEvent = C;
                var x = function () {
                        function t(t, e) {
                            this.noClick = !1, this.scrolling = !1, this.ptsIndex = 0, this.ptsLength = 3, this.ptsMax = 72, this.settings = e, this.identifier = t.identifier, this.touch = !1, this.x = t.x, this.y = t.y, this.pageX = t.pageX, this.pageY = t.pageY, this.timeStamp = t.timeStamp, "undefined" != typeof Int32Array ? this.pts = new Int32Array(this.ptsMax) : this.pts = new Array(this.ptsMax), this.pts[0] = 0 | this.x, this.pts[1] = 0 | this.y, this.pts[2] = 0
                        }
                        return t.prototype.moveTo = function (t) {
                            var e = this.ptsIndex + this.ptsLength,
                                i = t.timeStamp - this.timeStamp | 0,
                                n = this.ptsMax;
                            i === this.pts[e - 1] && (this.ptsLength -= 3, e -= 3), t.x || t.y ? (t.dx = t.x - this.x, t.dy = t.y - this.y, this.x = t.x, this.y = t.y) : (t.dx = 0, t.dy = 0, t.x = this.x, t.y = this.y), e === this.ptsMax && (e = 0), this.pts[e++] = 0 | this.x, this.pts[e++] = 0 | this.y, this.pts[e++] = 0 | i, (this.ptsLength += 3) > n && (this.ptsLength -= 3, n === (this.ptsIndex += 3) && (this.ptsIndex = 0))
                        }, t.prototype.getPosAndSpeed = function (t) {
                            t.touch = this.touch, t.velocityPointer = this, t.vx = null, t.vy = null
                        }, t.prototype.calculatePosAndSpeed = function (t) {
                            var e, i, n = this.pts,
                                r = this.ptsMax,
                                s = 10 * r,
                                a = 50,
                                o = (t.timeStamp - this.timeStamp | 0) - s;
                            for (e = this.ptsIndex; e < this.ptsIndex + this.ptsLength && (i = e % r, !(n[i + 2] > o)); e += 3);
                            return s = (t.timeStamp - this.timeStamp | 0) - n[i + 2], e === this.ptsIndex + this.ptsLength || s < a ? (t.vx = 0, void(t.vy = 0)) : (t.vx = (this.x - n[i + 0]) / s, void(t.vy = (this.y - n[i + 1]) / s))
                        }, t
                    }(),
                    w = function () {
                        function t(e, i, n) {
                            void 0 === n && (n = null);
                            var r = this;
                            this.scaleX = 1, this.scaleY = 1, this.nextFakeMouseId = 1, this.doubleClickTimeout = null, this.longPressTimeout = null, this.longPressInitiator = null, this.listeners = {}, this.downPointers = {}, this.inPointers = {}, this.containerList = [], this.clickCounter = 1, this.lastClickEvent = null, this.topWindowEvents = {}, this.ID_MOUSE = "mouse", this.settings = i, this.container = e, this.lastEvent = null, this.lastTouchEvent = null, this.clickEvent = null, this.containerEvents = {
                                contextmenu: function (t) {
                                    return r.filterEvent(t) && r.handleCMenu(t)
                                },
                                wheel: function (t) {
                                    return r.filterEvent(t) && r.handleMouseWheel(t)
                                },
                                dragover: function (t) {
                                    return r.filterEvent(t) && r.handleMouseMove(t)
                                }
                            };
                            var s = "undefined" != typeof PointerEvent,
                                a = "undefined" != typeof TouchEvent,
                                o = !s && "undefined" != typeof MSPointerEvent;
                            o ? (this.container.style.msTouchAction = "none", this.windowEvents = (u = {}, u.MSPointerDown = function (t) {
                                return r.filterEvent(t) && r.handlePointerDown(t)
                            }, u.MSPointerMove = function (t) {
                                return r.filterEvent(t) && r.handlePointerMove(t)
                            }, u.MSPointerUp = function (t) {
                                return r.filterEvent(t) && r.handlePointerUp(t)
                            }, u.MSPointerCancel = function (t) {
                                return r.filterEvent(t) && r.handlePointerCancel(t)
                            }, u.MSPointerOut = function (t) {
                                return r.filterEvent(t) && r.handlePointerLeave(t)
                            }, u)) : s && !a ? (this.container.style.touchAction = "none", this.windowEvents = (c = {}, c.pointerdown = function (t) {
                                return r.filterEvent(t) && r.handlePointerDown(t)
                            }, c.pointermove = function (t) {
                                return r.filterEvent(t) && r.handlePointerMove(t)
                            }, c.pointerup = function (t) {
                                return r.filterEvent(t) && r.handlePointerUp(t)
                            }, c.pointercancel = function (t) {
                                return r.filterEvent(t) && r.handlePointerCancel(t)
                            }, c.pointerout = function (t) {
                                return r.filterEvent(t) && r.handlePointerLeave(t)
                            }, c)) : (this.windowEvents = {
                                mousedown: function (t) {
                                    return r.filterEvent(t) && r.handleMouseDown(t)
                                },
                                mouseup: function (t) {
                                    return r.filterEvent(t) && r.handleMouseUp(t)
                                },
                                mousemove: function (t) {
                                    return r.filterEvent(t) && r.handleMouseMove(t)
                                },
                                mouseout: function (t) {
                                    return r.filterEvent(t) && r.handleMouseLeave(t)
                                },
                                touchstart: function (t) {
                                    return r.filterEvent(t) && r.handleTouchStart(t)
                                },
                                touchend: function (t) {
                                    return r.filterEvent(t) && r.handleTouchEnd(t)
                                },
                                touchcancel: function (t) {
                                    return r.filterEvent(t) && r.handleTouchCancel(t)
                                },
                                touchmove: function (t) {
                                    return r.filterEvent(t) && r.handleTouchMove(t)
                                }
                            }, this.topWindowEvents = {
                                mouseup: function (t) {
                                    return r.filterEvent(t) && r.handleMouseUp(t)
                                },
                                touchend: function (t) {
                                    return r.filterEvent(t) && r.handleTouchEnd(t)
                                }
                            }), !t._ignoreWindowTop && window.top && this.addTopWindowHandlers(), b.detect().isSafariDesktop && this.addSelectPrevention();
                            for (var l in this.windowEvents) d.listen(window, l, this.windowEvents[l]);
                            if (this.addContainer(e), n)
                                for (var h = 0; h < n.length; h++) this.addContainer(n[h]);
                            var u, c
                        }
                        return t.prototype.addSelectPrevention = function () {
                            var t = this;
                            document.addEventListener("selectstart", function (e) {
                                Object.keys(t.downPointers).length && e.preventDefault()
                            })
                        }, t.prototype.addTopWindowHandlers = function () {
                            try {
                                for (var e in this.topWindowEvents) d.listen(window.top, e, this.topWindowEvents[e])
                            } catch (e) {
                                t._ignoreWindowTop = !0
                            }
                        }, t.prototype.addContainer = function (t) {
                            this.containerList.push(t);
                            var e;
                            for (e in this.containerEvents) d.listen(t, e, this.containerEvents[e]);
                            for (e in this.windowEvents) d.listen(t, e, this.windowEvents[e])
                        }, t.prototype.remove = function () {
                            for (var e in this.windowEvents) d.unlisten(window, e, this.windowEvents[e]);
                            if (!t._ignoreWindowTop && window.top)
                                for (var e in this.topWindowEvents) d.unlisten(window.top, e, this.topWindowEvents[e]);
                            for (var i = 0; i < this.containerList.length; i++) {
                                var n = this.containerList[i];
                                for (var e in this.containerEvents) d.unlisten(n, e, this.containerEvents[e])
                            }
                        }, t.prototype.listen = function (t, e) {
                            this.listeners[t] = e
                        }, t.prototype.processConsumed = function (t, e, i) {
                            e && (d.stopPropagation(t), i && t.preventDefault())
                        }, t.prototype.capturePointer = function (t) {
                            var e = t.target;
                            e.setPointerCapture ? e.setPointerCapture(t.pointerId) : e.msSetPointerCapture ? e.msSetPointerCapture(t.pointerId) : this.captureMouse(t)
                        }, t.prototype.releasePointer = function (t) {
                            this.releaseMouse(t)
                        }, t.prototype.releaseMouse = function (t) {
                            document.releaseCapture && document.releaseCapture()
                        }, t.prototype.captureMouse = function (t) {
                            var e = t.target;
                            e.setCapture && e.setCapture(!0)
                        }, t.prototype.filterEvent = function (t) {
                            return t !== this.lastEvent && (this.lastEvent = t, !0)
                        }, t.prototype.handlePointerDown = function (t) {
                            var e = this.buildEvent(t, t.pointerId.toString(), t.timeStamp, t.buttons > 0);
                            t.currentTarget !== window && this.capturePointer(t), this.downHappened(e), this.processConsumed(t, e.consumed)
                        }, t.prototype.handlePointerMove = function (t) {
                            var e = this.buildEvent(t, t.pointerId.toString(), t.timeStamp, t.buttons > 0);
                            this.moveHappened(e), this.processConsumed(t, e.consumed, !0)
                        }, t.prototype.handlePointerUp = function (t) {
                            if (0 === t.buttons) {
                                var e = this.buildEvent(t, t.pointerId.toString(), t.timeStamp, !1);
                                this.releasePointer(t), this.upHappened(e), this.processConsumed(t, e.consumed)
                            }
                        }, t.prototype.handlePointerCancel = function (t) {
                            var e = this.buildEvent(t, t.pointerId.toString(), t.timeStamp, !1);
                            this.cancelHappened(e)
                        }, t.prototype.handleMouseDown = function (t) {
                            if (!(t.timeStamp < this.lastTouchEvent)) {
                                var e = this.buildEvent(t, this.ID_MOUSE, t.timeStamp, !0);
                                t.currentTarget !== window && this.captureMouse(t), this.downHappened(e), this.processConsumed(t, e.consumed)
                            }
                        }, t.prototype.handleCMenu = function (t) {
                            this.processConsumed(t, !0, !0)
                        }, t.prototype.handleMouseWheel = function (t) {
                            if (this.isTargetOkay(t.target) && (!this.settings.mouseWheelRequiresFocus || document.activeElement === this.container)) {
                                if (5 === t.mozInputSource || 0 === t.deltaX && 0 === t.deltaY) return void d.stopPropagation(t);
                                if (t.deltaMode !== t.DOM_DELTA_PAGE) {
                                    var e = this.buildEvent(t, this.ID_MOUSE, t.timeStamp, !0),
                                        i = t.deltaMode === t.DOM_DELTA_LINE ? -40 : -1;
                                    e.wheely = t.deltaY * i, e.wheelx = t.deltaX * i, this.wheelHappened(e), this.processConsumed(t, e.consumed, !0)
                                }
                            }
                        }, t.prototype.handleMouseUp = function (t) {
                            if (t.shiftKey && t.ctrlKey) return this.ID_MOUSE = "mouse" + this.nextFakeMouseId, void(this.nextFakeMouseId += 1);
                            var e = this.buildEvent(t, this.ID_MOUSE, t.timeStamp, !1);
                            this.releaseMouse(t), this.upHappened(e), this.processConsumed(t, e.consumed)
                        }, t.prototype.handlePointerLeave = function (t) {
                            var e = t.pointerId.toString();
                            this.inPointers[e] && !this.downPointers[e] && this.pointerLeave(this.buildEvent(t, e, t.timeStamp, !1))
                        }, t.prototype.handleMouseLeave = function (t) {
                            t.timeStamp < this.lastTouchEvent || this.inPointers[this.ID_MOUSE] && !this.downPointers[this.ID_MOUSE] && this.pointerLeave(this.buildEvent(t, this.ID_MOUSE, t.timeStamp, !1))
                        }, t.prototype.handleMouseMove = function (t) {
                            if (!(t.timeStamp < this.lastTouchEvent)) {
                                var e = this.buildEvent(t, this.ID_MOUSE, t.timeStamp, !1);
                                this.moveHappened(e), this.processConsumed(t, e.consumed, !0)
                            }
                        }, t.prototype.handleTouchStart = function (t) {
                            this.lastTouchEvent = t.timeStamp + 2e3, this.removeLostTouches(t, t.touches, t.changedTouches);
                            for (var e, i = !1, n = t.changedTouches || t.touches, r = 0; r < n.length; r++) {
                                var s = n[r];
                                e = this.buildTouchEvent(t, s, !0, n.length), this.downHappened(e), i = i || e.consumed
                            }
                            this.processConsumed(t, i)
                        }, t.prototype.handleTouchEnd = function (t) {
                            this.lastTouchEvent = t.timeStamp + 2e3;
                            for (var e = t.changedTouches || t.touches, i = !1, n = 0; n < e.length; n++) {
                                var r = e[n],
                                    s = this.buildTouchEvent(t, r, !1, e.length),
                                    a = this.buildTouchEvent(t, r, !1, e.length);
                                a.x = a.y = a.pageX = a.pageY = -1e9, this.upHappened(s), this.pointerLeave(a), i = i || s.consumed || a.consumed, this.removeLostTouches(t, t.touches)
                            }
                            this.processConsumed(t, i)
                        }, t.prototype.handleTouchCancel = function (t) {
                            this.lastTouchEvent = t.timeStamp + 2e3;
                            for (var e = t.changedTouches || t.touches, i = 0; i < e.length; i++) {
                                var n = e[i],
                                    r = this.buildTouchEvent(t, n, !1, e.length);
                                this.cancelHappened(r)
                            }
                            this.removeLostTouches(t, t.touches)
                        }, t.prototype.handleTouchMove = function (t) {
                            this.lastTouchEvent = t.timeStamp + 2e3;
                            var e = !1;
                            this.removeLostTouches(t, t.touches);
                            for (var i, n = t.changedTouches || t.touches, r = 0; r < n.length; r++) {
                                var s = n[r];
                                i = this.buildTouchEvent(t, s, !0, n.length), this.moveHappened(i), e = e || i.consumed
                            }
                            this.processConsumed(t, e, !0)
                        }, t.prototype.removeLostTouches = function (t, e, i) {
                            void 0 === i && (i = null);
                            for (var n = Object.create(null), r = 0; r < e.length; r++) {
                                var s = e[r];
                                n[s.identifier] = !0
                            }
                            for (var a in this.downPointers) {
                                var o = this.downPointers[a];
                                if (this.downPointers.hasOwnProperty(a) && !n[a]) {
                                    var l = this.rebuildEvent(t, o, !1);
                                    this.upHappened(l)
                                }
                            }
                            if (null !== i)
                                for (var r = 0; r < i.length; r++) {
                                    var s = i[r],
                                        o = this.downPointers[s.identifier];
                                    if (o) {
                                        var l = this.rebuildEvent(t, o, !1);
                                        this.upHappened(l)
                                    }
                                }
                        }, t.prototype.rebuildEvent = function (t, e, i) {
                            var n = new C(e.x, e.y, t.timeStamp, e.identifier);
                            return n.pageX = e.pageX, n.pageY = e.pageY, n.pressed = i, n.shiftKey = t.shiftKey, n.altKey = t.altKey, n.ctrlKey = t.ctrlKey, n
                        }, t.prototype.buildTouchEvent = function (t, e, i, n) {
                            var r = d.convertPointFromPageToNode(this.container, e.pageX, e.pageY, e.clientX, e.clientY),
                                s = r.x,
                                a = r.y,
                                o = new C(Math.round(s * this.scaleX), Math.round(a * this.scaleY), t.timeStamp, "" + e.identifier);
                            return o.target = e.target || t.target || t.srcElement, o.pageX = e.pageX, o.pageY = e.pageY, o.shiftKey = t.shiftKey, o.altKey = t.altKey, o.ctrlKey = t.ctrlKey, o.pressed = i, o.changedPointerCount = n, o.touch = !0, o
                        }, t.prototype.buildEvent = function (t, e, i, n, r) {
                            void 0 === r && (r = 1);
                            var s, a, o = t.pageX,
                                l = t.pageY,
                                h = (!t.currentTarget || t.currentTarget === this.container) && t.target === this.container;
                            if (h && void 0 !== t.offsetX) s = t.offsetX, a = t.offsetY;
                            else if (h && void 0 !== t.layerX) s = t.layerX, a = t.layerY;
                            else {
                                var u = d.convertPointFromPageToNode(this.container, o, l, t.clientX, t.clientY);
                                s = u.x, a = u.y
                            }
                            var c = new C(Math.round(s * this.scaleX), Math.round(a * this.scaleY), i, "" + e);
                            return c.target = t.target || t.srcElement, c.pageX = o, c.pageY = l, c.shiftKey = t.shiftKey, c.altKey = t.altKey, c.ctrlKey = t.ctrlKey, c.pressed = n, c.changedPointerCount = r, c.touch = "touch" === t.pointerType || 2 === t.pointerType, t.which ? c.isRightMB = 3 === t.which : c.isRightMB = 2 === t.button, c
                        }, t.prototype.downHappened = function (e) {
                            if (e.pressed = !0, this.fireEvent(t.EVENT_GLOBAL_DOWN, e), this.isTargetOkay(e.target) && !this.downPointers[e.identifier]) {
                                this.click_Hold();
                                var i = new x(e, this.settings);
                                this.downPointers[e.identifier] = i, i.touch = e.touch, this.inPointers[e.identifier] = !0, this.fireEvent(t.EVENT_DOWN, e), this.startLongPress(e)
                            }
                        }, t.prototype.upHappened = function (e) {
                            var i = this.downPointers[e.identifier];
                            if (i) {
                                this.cancelLongPress(), i.moveTo(e), i.getPosAndSpeed(e), delete this.downPointers[e.identifier];
                                var n = e.vx,
                                    r = e.vy,
                                    s = Math.abs(n),
                                    a = Math.abs(r);
                                s > 2 * a ? (e.swipeSpeed = s, n > 0 ? e.swipeLeft = !0 : e.swipeRight = !0) : a > 2 * s && (e.swipeSpeed = a, r < 0 ? e.swipeUp = !0 : e.swipeDown = !0), this.fireEvent(t.EVENT_UP, e), !i.noClick && e.isWithinDistance(i, this.settings.clickSensitivity, this.settings.doubleClickTimeout) && this.click_Next(e)
                            }
                        }, t.prototype.cancelHappened = function (e) {
                            this.downPointers[e.identifier] && (this.cancelLongPress(), delete this.downPointers[e.identifier], this.fireEvent(t.EVENT_CANCEL, e))
                        }, t.prototype.moveHappened = function (e) {
                            var i = this.downPointers[e.identifier];
                            e.pressed = void 0 !== i && null !== i, void 0 !== i && null !== i ? (this.cancelLongPress(e), i.scrolling = !0, i.moveTo(e), i.getPosAndSpeed(e), this.fireEvent(t.EVENT_DRAG, e), this.click_Cancel(e)) : this.click_OnMove(e) || (this.isTargetOkay(e.target) ? (this.inPointers[e.identifier] = !0, this.fireEvent(t.EVENT_MOVE, e)) : this.pointerLeave(e))
                        }, t.prototype.wheelHappened = function (e) {
                            this.fireEvent(t.EVENT_WHEEL, e)
                        }, t.prototype.pointerLeave = function (e) {
                            this.inPointers.hasOwnProperty(e.identifier) && (this.click_Cancel(e) || this.fireEvent(t.EVENT_LEAVE, e), delete this.inPointers[e.identifier])
                        }, t.prototype.click_Next = function (e) {
                            var i = this;
                            if (e.isRightMB) return void this.fireEvent(t.EVENT_RCLICK, e);
                            this.settings.scrollIntoView && this.container.scrollIntoView();
                            var n;
                            switch (this.clickCounter) {
                                case 1:
                                    n = t.EVENT_CLICK;
                                    break;
                                case 2:
                                    n = t.EVENT_DBLCLICK;
                                    break;
                                default:
                                case 3:
                                    n = t.EVENT_TPLCLICK
                            }
                            var r = null !== this.clickEvent && this.clickEvent.timeStamp + this.settings.doubleClickTimeout >= e.timeStamp && this.clickEvent.distance(e) < this.settings.doubleClickSensitivity;
                            r && clearTimeout(this.doubleClickTimeout), (r || 1 === this.clickCounter) && (this.settings.noClickOnDoubleClick && (this.doubleClickTimeout = setTimeout(function () {
                                return i.fireClick(n)
                            }, this.settings.doubleClickTimeout)), this.settings.noClickOnDoubleClick || this.fireEvent(n, e), this.lastClickEvent = n), this.fireEvent(t.EVENT_INSTACLICK, e), this.clickEvent = e, this.clickCounter++, this.settings.noClickOnDoubleClick || setTimeout(function () {
                                i.clickEvent = i.lastClickEvent = null, i.clickCounter = 1
                            }, this.settings.doubleClickTimeout)
                        }, t.prototype.click_Cancel = function (t) {
                            return !(!this.clickEvent || this.clickEvent.identifier !== t.identifier) && (this.clickEvent._leaving = !0, !0)
                        }, t.prototype.click_Hold = function () {
                            void 0 !== this.doubleClickTimeout && null !== this.doubleClickTimeout && (clearTimeout(this.doubleClickTimeout), this.doubleClickTimeout = null)
                        }, t.prototype.click_OnMove = function (t) {
                            return !(!this.clickEvent || !this.settings.noClickOnDoubleClick) && (this.clickEvent.distance(t) < this.settings.doubleClickSensitivity || (this.fireEvent(this.lastClickEvent, this.clickEvent), this.clickEvent = this.lastClickEvent = null, this.clickCounter = 1, !1))
                        }, t.prototype.fireClick = function (e) {
                            this.clickEvent && (this.fireEvent(e, this.clickEvent), this.clickEvent._leaving && this.fireEvent(t.EVENT_LEAVE, this.clickEvent), this.clickEvent = null, this.clickCounter = 1)
                        }, t.prototype.startLongPress = function (e) {
                            var i = this;
                            if (!e.isRightMB) {
                                var n = function () {
                                    i.longPressTimeout = null, e.consumed = !1, i.downPointers[e.identifier].noClick = !0, i.fireEvent(t.EVENT_LONGPRESS, e), e.consumed || (e.touch && i.cancelHappened(e), i.fireEvent(t.EVENT_RCLICK, e))
                                };
                                this.cancelLongPress(), this.longPressTimeout = setTimeout(n, this.settings.longPressTimeout), this.longPressInitiator = e
                            }
                        }, t.prototype.cancelLongPress = function (t) {
                            if (null !== this.longPressTimeout) {
                                if (t && t.isWithinDistance(this.longPressInitiator, this.settings.longPressSensitivity)) return;
                                clearTimeout(this.longPressTimeout), this.longPressTimeout = null
                            }
                        }, t.prototype.fireEvent = function (t, e) {
                            this.listeners[t] && this.listeners[t].call(this, e)
                        }, t.prototype.isTargetOkay = function (t) {
                            return this.containerList.indexOf(t) !== -1 || d.isParentOf(this.container, t)
                        }, t
                    }();
                w._ignoreWindowTop = !1, w.EVENT_MOVE = "move", w.EVENT_DOWN = "down", w.EVENT_GLOBAL_DOWN = "gdown", w.EVENT_DRAG = "drag", w.EVENT_CANCEL = "cancel", w.EVENT_UP = "up", w.EVENT_LEAVE = "leave", w.EVENT_CLICK = "click", w.EVENT_RCLICK = "rclick", w.EVENT_DBLCLICK = "dblclick", w.EVENT_INSTACLICK = "instaclick", w.EVENT_LONGPRESS = "longpress", w.EVENT_TPLCLICK = "tplclick", w.EVENT_WHEEL = "mwheel", w.EVENT_KEY = "key", r.MouseEvents = w;
                var L = function () {
                    function t() {
                        this.timeStamp = 0, this.dtime = 0, this.animating = !1, this.isExport = !1, this.context = null, this.scaleX = 1, this.scaleY = 1, this.labelRenderer = null, this.changes = {}
                    }
                    return t
                }();
                r.UpdateEvent = L;
                var T = function () {
                    function t() {
                        this.keyCode = null, this.capture = !1, this.consumed = !1, this.noDefault = !1, this.cursor = null, this.target = null
                    }
                    return t
                }();
                r.KeyEvent = T;
                var k = function () {
                    function t() {
                        this.animationOrder = 0, this.updateOrder = 0, this.paintOrder = 0
                    }
                    return t.prototype.remove = function () {}, t.prototype.onSceneChange = function (t) {}, t.prototype.getPanels = function (t) {
                        return []
                    }, t.prototype.doAnimations = function (t) {}, t.prototype.paintScene = function (t) {}, t.prototype.previewMouseEvent = function (t, e) {
                        this["preview" + t](e)
                    }, t.prototype.onMouseEvent = function (t, e) {
                        this["on" + t](e)
                    }, t.prototype.onClick = function (t) {}, t.prototype.onInstantClick = function (t) {}, t.prototype.onLongPress = function (t) {}, t.prototype.onRightClick = function (t) {}, t.prototype.onDoubleClick = function (t) {}, t.prototype.onTripleClick = function (t) {}, t.prototype.onPointerDown = function (t) {}, t.prototype.onPointerUp = function (t) {}, t.prototype.onPointerDrag = function (t) {}, t.prototype.onPointerMove = function (t) {}, t.prototype.onPointerOut = function (t) {}, t.prototype.onPointerCancel = function (t) {}, t.prototype.onWheel = function (t) {}, t.prototype.onKeyDown = function (t) {}, t.prototype.onGlobalPointerDown = function (t) {}, t.prototype.previewDoubleClick = function (t) {}, t.prototype.previewTripleClick = function (t) {}, t.prototype.previewRightClick = function (t) {}, t.prototype.previewClick = function (t) {}, t.prototype.previewInstantClick = function (t) {}, t.prototype.previewLongPress = function (t) {}, t.prototype.previewWheel = function (t) {}, t.prototype.previewGlobalPointerDown = function (t) {}, t.prototype.previewPointerDown = function (t) {}, t.prototype.previewPointerUp = function (t) {}, t.prototype.previewPointerDrag = function (t) {}, t.prototype.previewPointerMove = function (t) {}, t.prototype.previewPointerOut = function (t) {}, t.prototype.previewPointerCancel = function (t) {}, t.prototype.containsCoordinate = function (t, e) {
                        var i = this.getPanels(!1);
                        if (!i || !i.length) return !1;
                        for (var n = 0; n < i.length; n++) {
                            var r = i[n];
                            if (r.left < t && r.right > t && r.top < e && r.bottom > e) return !0
                        }
                        return !1
                    }, t
                }();
                r.ChartElement = k;
                var A = function () {
                    function t(t, e, i, n) {
                        this.side = "top", this.align = "fill", this.floating = !1, this.margin = 0, this.location = "outside", this.packingOrder = void 0, void 0 !== t && (this.side = t), void 0 !== e && (this.align = e), void 0 !== i && (this.margin = i), void 0 !== n && (this.packingOrder = n)
                    }
                    return t
                }();
                r.SettingsChartPanel = A;
                var M = function () {
                    function t() {
                        this.packingOrder = 0, this.location = "outside", this.side = "top", this.align = "fill", this.outsideEdge = !1, this.floating = !1, this.desiredWidth = 0, this.desiredHeight = 0, this.margin = 0, this.left = 0, this.top = 0, this.right = 0, this.bottom = 0, this.visible = !1, this.enableClipping = !1, this._tempData = null
                    }
                    return t.prototype.pushClip = function (t) {
                        this.enableClipping && r.Graphics.pushClip(t, this.left, this.top, this.right - this.left, this.bottom - this.top)
                    }, t.prototype.popClip = function (t) {
                        this.enableClipping && r.Graphics.popClip(t)
                    }, t.prototype.computeSize = function (t, e, i, n) {
                        return {
                            width: this.desiredWidth,
                            height: this.desiredHeight
                        }
                    }, t.prototype.placePanel = function (t, e, i, n) {
                        this.bottom = n, this.right = i, this.top = e, this.left = t
                    }, t
                }();
                r.ChartPanel = M;
                var I = function () {
                    function t(t) {
                        this.framesCount = 0, this.shell = t, this.measureFpsIters = 0, this.measureFpsT0 = 0, this.measureFpsIter = 0, this.measureFpsCallback = null
                    }
                    return t.prototype.hasPendingRequests = function () {
                        return this.shell.chart.hasPendingRequests()
                    }, t.prototype.measureFps = function (t, e) {
                        var i = this;
                        this.measureFpsCallback = e, this.measureFpsIters = t;
                        var n = this.shell.settings.advanced.useAnimationFrame;
                        if (n) {
                            this.shell.chart.updateSettings({
                                advanced: {
                                    useAnimationFrame: !1
                                }
                            });
                            var r = this.measureFpsCallback;
                            this.measureFpsCallback = function (t, e, n) {
                                i.shell.chart.updateSettings({
                                    advanced: {
                                        useAnimationFrame: !0
                                    }
                                }), r && r.call(window, t, e, n)
                            }
                        }
                        return this.measureFpsIter = 0, this.measureFpsT0 = (new Date).getTime(), this.shell.events.notifySceneChanges({
                            requestPaint: !0
                        }), !0
                    }, t.prototype.paintDone = function () {
                        if (this.framesCount += 1, this.measureFpsIters) {
                            this.measureFpsIter += 1;
                            var t = (new Date).getTime() - this.measureFpsT0;
                            if (this.measureFpsIter >= this.measureFpsIters && t > 4e3 || t > 1e4 && this.measureFpsIter >= 5) {
                                var e = 1e3 * this.measureFpsIter / Math.max(1e-4, t);
                                this.measureFpsCallback(e, this.measureFpsIter, t), this.measureFpsCallback = null, this.measureFpsIters = 0
                            } else this.shell.events.notifySceneChanges({
                                requestPaint: !0
                            })
                        }
                    }, t
                }();
                r.Profiler = I;
                var P = function () {
                        function t() {
                            this.subchart = null, this.element = null
                        }
                        return t
                    }(),
                    D = function () {
                        function t(t, e) {
                            this.sceneChanges = {}, this.forceFloating = !1, this._paintSuspended = 0, this.pointerState = {}, this.animationOrder = [], this.updateOrder = [], this.paintOrder = [], this.subcharts = [], this._lastPanelCount = [0, 0, 0], this.chartBounds = new mt(0, 0, 1, 1), this.chartOuterBounds = new mt(0, 0, 1, 1), this.chartBoundsIsOuter = !0, this.chart = t, this.shell = e, this.scene = t.scene
                        }
                        return t.panelSortCallback = function (t, e) {
                            return t.packingOrder - e.packingOrder
                        }, t.prototype.addElement = function (t) {
                            if (!t) throw new Error("`element` must be defined.");
                            return this.paintOrder.push(t), this.updateOrder.push(t), this.animationOrder.push(t), this.refreshElementOrder(), t
                        }, t.prototype.refreshElementOrder = function () {
                            this.animationOrder.sort(function (t, e) {
                                return t.animationOrder - e.animationOrder
                            }), this.paintOrder.sort(function (t, e) {
                                return t.paintOrder - e.paintOrder
                            }), this.updateOrder.sort(function (t, e) {
                                return t.updateOrder - e.updateOrder
                            })
                        }, t.prototype.removeElement = function (t) {
                            d.removeFromArray(this.paintOrder, t), d.removeFromArray(this.animationOrder, t), d.removeFromArray(this.updateOrder, t)
                        }, t.prototype.addSubchart = function (t) {
                            this.subcharts.push(t)
                        }, t.prototype.removeSubchart = function (t) {
                            d.removeFromArray(this.subcharts, t);
                            for (var e in this.pointerState) {
                                var i = this.pointerState[e];
                                i.subchart === t && (i.subchart = null)
                            }
                        }, t.prototype.suspendPaint = function () {
                            this._paintSuspended++
                        }, t.prototype.resumePaint = function () {
                            this._paintSuspended--, this._paintSuspended <= 0 && (this._paintSuspended = 0, this.requestPaint())
                        }, t.prototype.notifySceneChanges = function (t, e) {
                            if (d.hasProperties(t)) {
                                var i = t.settingsChanges;
                                void 0 !== i && i instanceof r.Settings ? (this.sceneChanges.settingsChanges = d.extendCopy(this.sceneChanges.settingsChanges || {}, i, function (t, e) {
                                    return "_" === t[0] || e
                                }), delete t.settingsChanges, d.extendDeep(this.sceneChanges, t), t.settingsChanges = i) : d.extendDeep(this.sceneChanges, t), this.requestPaint(e)
                            }
                        }, t.prototype.requestPaint = function (t) {
                            this._paintSuspended <= 0 && this.shell.requestPaint(t)
                        }, t.prototype.paintNow = function (t) {
                            void 0 === t && (t = !1), this.shell.paintNow(t = !1)
                        }, t.prototype.clearSceneChanges = function (t) {
                            for (var e in t) delete this.sceneChanges[e]
                        }, t.prototype.onMouseEvent = function (t, e) {
                            var i = e.name;
                            t.changes = {}, t.capture = !1;
                            var n, r, s = null,
                                a = null,
                                o = void 0,
                                l = t.identifier,
                                h = this.pointerState[l];
                            h || (h = new P, h.identifier = l, this.pointerState[l] = h);
                            for (var u = 0; u < this.updateOrder.length; u++) r = this.updateOrder[u], r.previewMouseEvent(i, t);
                            if (h.subchart) {
                                var c = h.subchart.events;
                                c.onMouseEvent(t, e), t.consumed || t.hovered || t.capture ? (a = h.subchart, t.capture = !0, o = t.cursor) : c.onMouseEvent(t, {
                                    ev: w.EVENT_LEAVE,
                                    name: "PointerOut"
                                })
                            }
                            if (n = r = h.element, r && (r.onMouseEvent(i, t), (t.consumed || t.capture || e.captures && e.needsCapture) && !e.releasesCapture && (s = r, t.capture = !0, o = t.cursor)), !t.capture && !e.needsCapture)
                                for (var d = this.subcharts.length - 1; d >= 0; d -= 1) {
                                    var p = this.subcharts[d],
                                        c = p.events;
                                    if (c.chartOuterBounds.containsPoint(t.x, t.y)) {
                                        if (c.onMouseEvent(t, e), t.consumed || t.hovered || t.capture) {
                                            a = p, t.capture = !0;
                                            break
                                        }
                                        c.onMouseEvent(t, {
                                            ev: w.EVENT_LEAVE,
                                            name: "PointerOut"
                                        })
                                    }
                                }
                            if (!t.capture && !e.needsCapture)
                                for (var u = 0; u < this.updateOrder.length; u++)
                                    if (r = this.updateOrder[u], r !== n && (r.onMouseEvent(i, t), t.consumed || t.capture)) {
                                        o = t.cursor, s = r, t.capture = !0;
                                        break
                                    }
                            void 0 !== o && (t.cursor = o), (e.releasesCapture || e.captures) && (h.element = e.captures ? s : null, h.subchart = e.captures ? a : null), this.notifySceneChanges(t.changes)
                        }, t.prototype.setNewSize = function (t, e, i) {
                            !i && this.chartBounds.equals(t) && e === this.chartBoundsIsOuter || (this.chartBounds = t.clone(), this.chartBoundsIsOuter = e, this.notifySceneChanges({
                                bounds: !0
                            }))
                        }, t.prototype.updateLayout = function (e) {
                            for (var i = this.scene, n = new Array(this._lastPanelCount[0]), r = new Array(this._lastPanelCount[1]), s = new Array(this._lastPanelCount[2]), a = 0, o = 0, l = 0, h = 0; h < this.paintOrder.length; h++)
                                for (var u = this.paintOrder[h], c = u.getPanels(e.isExport), p = 0; p < c.length; p++) {
                                    var f = c[p],
                                        g = f.location;
                                    "external" === g ? s[l++] = f : "outside" === g ? r[o++] = f : "inside" === g && (n[a++] = f)
                                }
                            this._lastPanelCount = [a, o, l], n.length = a, r.length = o, s.length = l, d.sort(n, t.panelSortCallback), d.sort(r, t.panelSortCallback), d.sort(s, t.panelSortCallback);
                            var m, v, y;
                            if (this.chartBoundsIsOuter) {
                                m = this.chartBounds.clone();
                                for (var S = 0; S < l; S++) this._placePanel(s[S], m, !0, e);
                                v = this.chartBounds.clone(), y = this.chartBounds.clone();
                                for (var S = 0; S < o; S++) this._placePanel(r[S], y, !1, e)
                            } else {
                                y = this.chartBounds.clone(), v = this.chartBounds.clone();
                                for (var S = 0; S < o; S++) this._placePanel(r[S], v, !0, e);
                                m = v.clone();
                                for (var S = 0; S < l; S++) this._placePanel(s[S], m, !0, e)
                            }
                            this.chartOuterBounds = v, i.chartLeft = v.x0, i.chartTop = v.y0, i.chartHeight = v.h(), i.chartWidth = v.w();
                            for (var S = 0; S < l; S++) this._placePanelFinal(s[S], y);
                            for (var S = 0; S < o; S++) {
                                var f = r[S];
                                this._placePanelFinal(f, f.outsideEdge ? v : y)
                            }
                            i.x0 === y.x0 && i.y0 === y.y0 && i.width === y.w() && i.height === y.h() || this.chart.events.notifySceneChanges({
                                bounds: !0
                            }), i.x0 = y.x0, i.y0 = y.y0, i.width = y.w(), i.height = y.h(), i.leftMargin = y.x0 - v.x0, i.rightMargin = v.x1 - y.x1, i.topMargin = y.y0 - v.y0, i.bottomMargin = v.y1 - y.y1;
                            for (var S = 0; S < a; S++) {
                                var f = n[S];
                                this._placePanel(f, y, !1, e), this._placePanelFinal(f, y)
                            }
                            return m
                        }, t.prototype._placePanel = function (t, e, i, n) {
                            var r = e.x0,
                                s = e.y0,
                                a = e.x1,
                                o = e.y1,
                                l = t.margin || 0,
                                h = t.computeSize(e.x1 - e.x0, e.y1 - e.y0, n.context, n.labelRenderer),
                                u = h.width || 0,
                                c = h.height || 0;
                            u += 2 * l, c += 2 * l, i ? "top" === t.side ? (o = s, s = o - c, t.floating || this.forceFloating || (e.y0 = s)) : "bottom" === t.side ? (s = o, o = s + c, t.floating || this.forceFloating || (e.y1 = o)) : "left" === t.side ? (a = r, r = a - u, t.floating || this.forceFloating || (e.x0 = r)) : "right" === t.side && (r = a, a = r + u, t.floating || this.forceFloating || (e.x1 = a)) : "top" === t.side ? (o = Math.min(o, s + c), t.floating || this.forceFloating || (e.y0 = o)) : "bottom" === t.side ? (s = Math.max(s, o - c), t.floating || this.forceFloating || (e.y1 = s)) : "left" === t.side ? (a = Math.min(a, r + u), t.floating || this.forceFloating || (e.x0 = a)) : "right" === t.side && (r = Math.max(r, a - u), t.floating || this.forceFloating || (e.x1 = r)), t._tempData = {
                                left: r,
                                right: a,
                                top: s,
                                bottom: o,
                                desiredWidth: u,
                                desiredHeight: c
                            }
                        }, t.prototype._placePanelFinal = function (t, e) {
                            var i = t._tempData.left,
                                n = t._tempData.right,
                                r = t._tempData.top,
                                s = t._tempData.bottom,
                                a = t._tempData.desiredWidth,
                                o = t._tempData.desiredHeight;
                            if ("outside" === t.location && ("top" === t.side || "bottom" === t.side ? (i = Math.max(i, e.x0), n = Math.min(n, e.x1)) : (r = Math.max(r, e.y0), s = Math.min(s, e.y1))), "left" === t.align) n = Math.min(n, i + a);
                            else if ("right" === t.align) i = Math.max(i, n - a);
                            else if ("top" === t.align) s = Math.min(s, r + o);
                            else if ("bottom" === t.align) r = Math.max(r, s - o);
                            else if ("center" === t.align) {
                                var l = Math.max(0, n - i - a) / 2,
                                    h = Math.max(0, s - r - o) / 2;
                                i += l, n -= l, r += h, s -= h
                            }
                            var u = t.margin;
                            t.placePanel(i + u, r + u, n - u, s - u)
                        }, t.prototype.animateFrame = function (t) {
                            this.shell.prepareContext(t), t.changes = this.sceneChanges, this.sceneChanges = {};
                            for (var e = 0; e < this.updateOrder.length; e++) {
                                var i = this.updateOrder[e];
                                i.onSceneChange(t)
                            }
                            t.changes.bounds && this.updateLayout(t);
                            for (var n = 0; n < this.animationOrder.length; n++) {
                                var r = this.animationOrder[n];
                                r.doAnimations(t)
                            }
                            for (var s = 0; s < this.paintOrder.length; s++) {
                                var a = this.paintOrder[s];
                                a.paintScene(t)
                            }
                            t.changes.position && this.chart.notifyPositionChange(this.chart.createEventArguments(null, "api")), t.changes = null;
                            var o = [];
                            for (var l in this.pointerState) {
                                var h = this.pointerState[l];
                                h.subchart && o.push(h.subchart)
                            }
                            for (var u = 0; u < this.subcharts.length; u += 1) {
                                var c = this.subcharts[u];
                                if (!(o.indexOf(c) > -1)) {
                                    var d = c.events;
                                    (d.sceneChanges.bounds || d.chartOuterBounds.overlaps(this.chartOuterBounds)) && d.animateFrame(t)
                                }
                            }
                            for (var u = 0; u < o.length; u += 1) {
                                var c = o[u];
                                c.events.animateFrame(t)
                            }
                            this.shell.finalizeContext(t)
                        }, t.prototype.doPaint = function (t) {
                            for (var e = 0; e < this.paintOrder.length; e++) {
                                var i = this.paintOrder[e];
                                i.paintScene(t)
                            }
                            for (var n = 0; n < this.subcharts.length; n += 1) {
                                var r = this.subcharts[n],
                                    s = r.events;
                                s.chartOuterBounds.overlaps(this.chartOuterBounds) && s.doPaint(t)
                            }
                        }, t
                    }();
                r.ChartEvents = D;
                var N = function () {
                    function t() {
                        this.enabled = !1, this.enabledOnExport = !1, this.url = "http://zoomcharts.com", this.urlTarget = "_blank", this.image = "builtin://logo-supported-by", this.imageScaling = .5, this.location = "outside", this.imageExport = null
                    }
                    return t
                }();
                r.SettingsCredits = N;
                var F = function (t) {
                    function e(e, i) {
                        var n = t.call(this) || this;
                        n.animationOrder = 2e3, n.paintOrder = 60, n.updateOrder = 400, n.settings = i, n.chart = e, n.scene = e.scene, (i.enabledOnExport || i.enabled) && (n.chart.assetsLoader.getAssetImage(n.settings.image, function (t) {
                            return n.imageLoaded(t)
                        }), n.settings.imageExport && n.settings.image !== n.settings.imageExport && n.chart.assetsLoader.getAssetImage(n.settings.imageExport, function (t) {
                            return n.imageLoaded(t)
                        }));
                        var r = n.panel = new M;
                        return r.packingOrder = 0, r.side = "bottom", r.align = "right", r.visible = !1, r.margin = 3, n
                    }
                    return n(e, t), e.prototype.onSceneChange = function (t) {
                        var e = t.changes;
                        e.settings && e.settingsChanges.credits && (e.bounds = !0)
                    }, e.prototype.getPanels = function (t) {
                        var e = this,
                            i = this.settings,
                            n = t ? i.enabledOnExport : i.enabled,
                            r = this.panel;
                        if (n) {
                            r.location = "outside", r.outsideEdge = !0, "outside" === i.location ? (r.floating = !1, t && !i.enabled && (r.location = "external")) : r.floating = !0;
                            var s = this.chart.assetsLoader.getAssetImage(i.image, function (t) {
                                return e.imageLoaded(t)
                            });
                            if (s) return r.desiredWidth = s.width * i.imageScaling, r.desiredHeight = s.height * i.imageScaling, r.visible = !0, [r]
                        }
                        return r.visible = !1, []
                    }, e.prototype.paintScene = function (t) {
                        var e = this,
                            i = this.panel;
                        if (i.visible) {
                            var n = this.chart.assetsLoader.getAssetImage(this.settings.image, function (t) {
                                    return e.imageLoaded(t)
                                }),
                                r = this.settings.imageExport ? this.chart.assetsLoader.getAssetImage(this.settings.imageExport, function (t) {
                                    return e.imageLoaded(t)
                                }) : n;
                            t.isExport && (n = r), n ? t.context.drawImage(n, 0, 0, n.width, n.height, i.left, i.top, i.right - i.left, i.bottom - i.top) : t.animating = !0
                        }
                    }, e.prototype.onPointerMove = function (t) {
                        var e = t.x,
                            i = t.y,
                            n = this.panel;
                        n.visible && e >= n.left && i >= n.top && e <= n.right && i <= n.bottom && this.settings.url && (t.cursor = "pointer")
                    }, e.prototype.onClick = function (t) {
                        var e = t.x,
                            i = t.y,
                            n = this.panel,
                            r = this.settings;
                        n.visible && e >= n.left && i >= n.top && e <= n.right && i <= n.bottom && r.url && (this.chart.notifyClick(t, this.buildEventArgs(t)), t.defaultPrevented || d.openUrl(r.url, r.urlTarget), t.consumed = !0)
                    }, e.prototype.imageLoaded = function (t) {
                        this.chart.updateSize(!0), this.chart.events.notifySceneChanges({
                            settings: !0,
                            settingsChanges: {
                                credits: !0
                            }
                        })
                    }, e.prototype.buildEventArgs = function (t) {
                        var e = this.chart.createEventArguments(t, "user");
                        return e.clickCredits = !0, e.credits = {
                            url: this.settings.url,
                            urlTarget: this.settings.urlTarget
                        }, e
                    }, e
                }(k);
                r.Credits = F;
                var O = function () {
                    function t() {}
                    return t.isLight = function (t) {
                        return null == t ? null : .299 * t.R + .587 * t.G + .114 * t.B > 128
                    }, t.format = function (t) {
                        return null == t ? null : "rgba(" + (0 | t.R) + "," + (0 | t.G) + "," + (0 | t.B) + "," + t.A.toFixed(3) + ")"
                    }, t.areEqual = function (t, e) {
                        return null == t ? null == e : null != e && (t.R === e.R && t.G === e.G && t.B === e.B && t.A === e.A)
                    }, t.parse = function (t) {
                        var e = E.parseCSSColor(t);
                        return null == e && t && d.warn("Color value '" + t + "' could not be parsed.", null, !0), e
                    }, t.normalize = function (t) {
                        return this.format(E.parseCSSColor(t))
                    }, t.derive = function (t, e, i) {
                        var n = "string" == typeof t,
                            r = n ? this.parse(t) : t,
                            s = 255 * (e - 1),
                            a = {
                                R: Math.round(Math.min(255, Math.max(0, r.R + s))),
                                G: Math.round(Math.min(255, Math.max(0, r.G + s))),
                                B: Math.round(Math.min(255, Math.max(0, r.B + s))),
                                A: Math.min(1, r.A * i)
                            };
                        return n ? this.format(a) : a
                    }, t.blend = function (t, e, i, n) {
                        void 0 === n && (n = !0);
                        var r, s = "string" == typeof t,
                            a = s ? this.parse(t) : t,
                            o = s ? this.parse(e) : e;
                        if (n) {
                            var l = 1 - i;
                            r = {
                                R: Math.round(o.R * i + a.R * l),
                                G: Math.round(o.G * i + a.G * l),
                                B: Math.round(o.B * i + a.B * l),
                                A: o.A * i + a.A * l
                            }
                        } else r = this._blendSlow(a, o, i);
                        return s ? this.format(r) : r
                    }, t._blendSlow = function (t, e, i) {
                        var n = this._rgb2lab(t),
                            r = this._rgb2lab(e),
                            s = 1 - i,
                            a = Math.round(r.L * i + n.L * s),
                            o = Math.round(r.A * i + n.A * s),
                            l = Math.round(r.B * i + n.B * s),
                            h = this._lab2rgb(a, o, l);
                        return h.R = Math.max(0, Math.min(255, h.R)), h.G = Math.max(0, Math.min(255, h.G)), h.B = Math.max(0, Math.min(255, h.B)), h.A = e.A * i + t.A * s, h
                    }, t.colorTone = function (t, e, i) {
                        var n = this.parse(t),
                            r = this.derive(n, e, i);
                        return {
                            color: this.format(r),
                            opacity: n.A
                        }
                    }, t.copyHue = function (t, e) {
                        var i = "string" == typeof t,
                            n = i ? this.parse(t) : t,
                            r = i ? this.parse(e) : e,
                            s = (n.R + n.G + n.B) / 765,
                            a = (r.R + r.G + r.B) / 765,
                            o = {
                                R: Math.round(n.R / s * a),
                                G: Math.round(n.G / s * a),
                                B: Math.round(n.B / s * a),
                                A: r.A
                            };
                        return i ? this.format(o) : o
                    }, t.inverse = function (t) {
                        var e = "string" == typeof t,
                            i = e ? this.parse(t) : t,
                            n = {
                                R: 255 - i.R,
                                G: 255 - i.G,
                                B: 255 - i.B,
                                A: i.A
                            };
                        return e ? this.format(n) : n
                    }, t._rgb2xyz = function (t) {
                        var e = t.R / 255,
                            i = t.G / 255,
                            n = t.B / 255;
                        return e = e > .04045 ? Math.pow((e + .055) / 1.055, 2.4) : e / 12.92, i = i > .04045 ? Math.pow((i + .055) / 1.055, 2.4) : i / 12.92, n = n > .04045 ? Math.pow((n + .055) / 1.055, 2.4) : n / 12.92, {
                            X: .4124 * e + .3576 * i + .1805 * n,
                            Y: .2126 * e + .7152 * i + .0722 * n,
                            Z: .0193 * e + .1192 * i + .9505 * n
                        }
                    }, t._rgb2lab = function (t) {
                        if (t._lab) return t._lab;
                        var e = this._rgb2xyz(t),
                            i = e.X / .95047,
                            n = e.Y,
                            r = e.Z / 1.08883;
                        return i = i > .008856 ? Math.pow(i, 1 / 3) : 7.787 * i + 16 / 116, n = n > .008856 ? Math.pow(n, 1 / 3) : 7.787 * n + 16 / 116, r = r > .008856 ? Math.pow(r, 1 / 3) : 7.787 * r + 16 / 116, t._lab = {
                            L: 116 * n - 16,
                            A: 500 * (i - n),
                            B: 200 * (n - r)
                        }
                    }, t._xyz2rgb = function (t, e, i) {
                        var n = 3.2406 * t + e * -1.5372 + i * -.4986,
                            r = t * -.9689 + 1.8758 * e + .0415 * i,
                            s = .0557 * t + e * -.204 + 1.057 * i;
                        return n = n > .0031308 ? 1.055 * Math.pow(n, 1 / 2.4) - .055 : 12.92 * n, r = r > .0031308 ? 1.055 * Math.pow(r, 1 / 2.4) - .055 : 12.92 * r, s = s > .0031308 ? 1.055 * Math.pow(s, 1 / 2.4) - .055 : 12.92 * s, {
                            R: Math.round(255 * n),
                            G: Math.round(255 * r),
                            B: Math.round(255 * s),
                            A: 1
                        }
                    }, t._lab2rgb = function (t, e, i) {
                        var n = (t + 16) / 116,
                            r = e / 500 + n,
                            s = n - i / 200;
                        n = n > this._lab2rgbConst ? Math.pow(n, 3) : (n - 16 / 116) / 7.787, r = r > this._lab2rgbConst ? Math.pow(r, 3) : (r - 16 / 116) / 7.787, s = s > this._lab2rgbConst ? Math.pow(s, 3) : (s - 16 / 116) / 7.787;
                        var a = this._xyz2rgb(.95047 * r, n, 1.08883 * s);
                        return a._lab = {
                            L: t,
                            A: e,
                            B: i
                        }, a
                    }, t
                }();
                O._lab2rgbConst = Math.pow(.008856, 1 / 3), r.Colors = O;
                var E = function () {
                    function t() {}
                    return t.clamp_css_byte = function (t) {
                        return t = Math.round(t), t < 0 ? 0 : t > 255 ? 255 : t
                    }, t.clamp_css_float = function (t) {
                        return t < 0 ? 0 : t > 1 ? 1 : t
                    }, t.parse_css_int = function (e) {
                        return "%" === e[e.length - 1] ? t.clamp_css_byte(parseFloat(e) / 100 * 255) : t.clamp_css_byte(parseInt(e, 10))
                    }, t.parse_css_float = function (e) {
                        return "%" === e[e.length - 1] ? t.clamp_css_float(parseFloat(e) / 100) : t.clamp_css_float(parseFloat(e))
                    }, t.css_hue_to_rgb = function (t, e, i) {
                        return i < 0 ? i += 1 : i > 1 && (i -= 1), 6 * i < 1 ? t + (e - t) * i * 6 : 2 * i < 1 ? e : 3 * i < 2 ? t + (e - t) * (2 / 3 - i) * 6 : t
                    }, t.parseCSSColor = function (e) {
                        if (null == e) return {
                            R: 0,
                            G: 0,
                            B: 0,
                            A: 0
                        };
                        var i = e.replace(RegExp(" ", "g"), "").toLowerCase();
                        if (i in t.kCSSColorTable) {
                            var n = t.kCSSColorTable[i];
                            return {
                                R: n[0],
                                G: n[1],
                                B: n[2],
                                A: n[3]
                            }
                        }
                        if ("#" === i[0]) {
                            if (4 === i.length) {
                                var r = parseInt(i.substr(1), 16);
                                return r >= 0 && r <= 4095 ? {
                                    R: (3840 & r) >> 4 | (3840 & r) >> 8,
                                    G: 240 & r | (240 & r) >> 4,
                                    B: 15 & r | (15 & r) << 4,
                                    A: 1
                                } : null
                            }
                            if (7 === i.length) {
                                var r = parseInt(i.substr(1), 16);
                                return r >= 0 && r <= 16777215 ? {
                                    R: (16711680 & r) >> 16,
                                    G: (65280 & r) >> 8,
                                    B: 255 & r,
                                    A: 1
                                } : null
                            }
                            return null
                        }
                        var s = i.indexOf("("),
                            a = i.indexOf(")");
                        if (s !== -1 && a + 1 === i.length) {
                            var o = i.substr(0, s),
                                l = i.substr(s + 1, a - (s + 1)).split(","),
                                h = 1;
                            if ("rgba" === o) {
                                if (4 !== l.length) return null;
                                h = t.parse_css_float(l.pop())
                            }
                            if ("rgba" === o || "rgb" === o) return 3 !== l.length ? null : {
                                R: t.parse_css_int(l[0]),
                                G: t.parse_css_int(l[1]),
                                B: t.parse_css_int(l[2]),
                                A: h
                            };
                            if ("hsla" === o) {
                                if (4 !== l.length) return null;
                                h = t.parse_css_float(l.pop())
                            }
                            if ("hsla" === o || "hsl" === o) {
                                if (3 !== l.length) return null;
                                var u = (parseFloat(l[0]) % 360 + 360) % 360 / 360,
                                    c = t.parse_css_float(l[1]),
                                    d = t.parse_css_float(l[2]),
                                    p = d <= .5 ? d * (c + 1) : d + c - d * c,
                                    f = 2 * d - p;
                                return {
                                    R: t.clamp_css_byte(255 * t.css_hue_to_rgb(f, p, u + 1 / 3)),
                                    G: t.clamp_css_byte(255 * t.css_hue_to_rgb(f, p, u)),
                                    B: t.clamp_css_byte(255 * t.css_hue_to_rgb(f, p, u - 1 / 3)),
                                    A: h
                                }
                            }
                        }
                        return null
                    }, t
                }();
                E.kCSSColorTable = {
                    transparent: [0, 0, 0, 0],
                    aliceblue: [240, 248, 255, 1],
                    antiquewhite: [250, 235, 215, 1],
                    aqua: [0, 255, 255, 1],
                    aquamarine: [127, 255, 212, 1],
                    azure: [240, 255, 255, 1],
                    beige: [245, 245, 220, 1],
                    bisque: [255, 228, 196, 1],
                    black: [0, 0, 0, 1],
                    blanchedalmond: [255, 235, 205, 1],
                    blue: [0, 0, 255, 1],
                    blueviolet: [138, 43, 226, 1],
                    brown: [165, 42, 42, 1],
                    burlywood: [222, 184, 135, 1],
                    cadetblue: [95, 158, 160, 1],
                    chartreuse: [127, 255, 0, 1],
                    chocolate: [210, 105, 30, 1],
                    coral: [255, 127, 80, 1],
                    cornflowerblue: [100, 149, 237, 1],
                    cornsilk: [255, 248, 220, 1],
                    crimson: [220, 20, 60, 1],
                    cyan: [0, 255, 255, 1],
                    darkblue: [0, 0, 139, 1],
                    darkcyan: [0, 139, 139, 1],
                    darkgoldenrod: [184, 134, 11, 1],
                    darkgray: [169, 169, 169, 1],
                    darkgreen: [0, 100, 0, 1],
                    darkgrey: [169, 169, 169, 1],
                    darkkhaki: [189, 183, 107, 1],
                    darkmagenta: [139, 0, 139, 1],
                    darkolivegreen: [85, 107, 47, 1],
                    darkorange: [255, 140, 0, 1],
                    darkorchid: [153, 50, 204, 1],
                    darkred: [139, 0, 0, 1],
                    darksalmon: [233, 150, 122, 1],
                    darkseagreen: [143, 188, 143, 1],
                    darkslateblue: [72, 61, 139, 1],
                    darkslategray: [47, 79, 79, 1],
                    darkslategrey: [47, 79, 79, 1],
                    darkturquoise: [0, 206, 209, 1],
                    darkviolet: [148, 0, 211, 1],
                    deeppink: [255, 20, 147, 1],
                    deepskyblue: [0, 191, 255, 1],
                    dimgray: [105, 105, 105, 1],
                    dimgrey: [105, 105, 105, 1],
                    dodgerblue: [30, 144, 255, 1],
                    firebrick: [178, 34, 34, 1],
                    floralwhite: [255, 250, 240, 1],
                    forestgreen: [34, 139, 34, 1],
                    fuchsia: [255, 0, 255, 1],
                    gainsboro: [220, 220, 220, 1],
                    ghostwhite: [248, 248, 255, 1],
                    gold: [255, 215, 0, 1],
                    goldenrod: [218, 165, 32, 1],
                    gray: [128, 128, 128, 1],
                    green: [0, 128, 0, 1],
                    greenyellow: [173, 255, 47, 1],
                    grey: [128, 128, 128, 1],
                    honeydew: [240, 255, 240, 1],
                    hotpink: [255, 105, 180, 1],
                    indianred: [205, 92, 92, 1],
                    indigo: [75, 0, 130, 1],
                    ivory: [255, 255, 240, 1],
                    khaki: [240, 230, 140, 1],
                    lavender: [230, 230, 250, 1],
                    lavenderblush: [255, 240, 245, 1],
                    lawngreen: [124, 252, 0, 1],
                    lemonchiffon: [255, 250, 205, 1],
                    lightblue: [173, 216, 230, 1],
                    lightcoral: [240, 128, 128, 1],
                    lightcyan: [224, 255, 255, 1],
                    lightgoldenrodyellow: [250, 250, 210, 1],
                    lightgray: [211, 211, 211, 1],
                    lightgreen: [144, 238, 144, 1],
                    lightgrey: [211, 211, 211, 1],
                    lightpink: [255, 182, 193, 1],
                    lightsalmon: [255, 160, 122, 1],
                    lightseagreen: [32, 178, 170, 1],
                    lightskyblue: [135, 206, 250, 1],
                    lightslategray: [119, 136, 153, 1],
                    lightslategrey: [119, 136, 153, 1],
                    lightsteelblue: [176, 196, 222, 1],
                    lightyellow: [255, 255, 224, 1],
                    lime: [0, 255, 0, 1],
                    limegreen: [50, 205, 50, 1],
                    linen: [250, 240, 230, 1],
                    magenta: [255, 0, 255, 1],
                    maroon: [128, 0, 0, 1],
                    mediumaquamarine: [102, 205, 170, 1],
                    mediumblue: [0, 0, 205, 1],
                    mediumorchid: [186, 85, 211, 1],
                    mediumpurple: [147, 112, 219, 1],
                    mediumseagreen: [60, 179, 113, 1],
                    mediumslateblue: [123, 104, 238, 1],
                    mediumspringgreen: [0, 250, 154, 1],
                    mediumturquoise: [72, 209, 204, 1],
                    mediumvioletred: [199, 21, 133, 1],
                    midnightblue: [25, 25, 112, 1],
                    mintcream: [245, 255, 250, 1],
                    mistyrose: [255, 228, 225, 1],
                    moccasin: [255, 228, 181, 1],
                    navajowhite: [255, 222, 173, 1],
                    navy: [0, 0, 128, 1],
                    oldlace: [253, 245, 230, 1],
                    olive: [128, 128, 0, 1],
                    olivedrab: [107, 142, 35, 1],
                    orange: [255, 165, 0, 1],
                    orangered: [255, 69, 0, 1],
                    orchid: [218, 112, 214, 1],
                    palegoldenrod: [238, 232, 170, 1],
                    palegreen: [152, 251, 152, 1],
                    paleturquoise: [175, 238, 238, 1],
                    palevioletred: [219, 112, 147, 1],
                    papayawhip: [255, 239, 213, 1],
                    peachpuff: [255, 218, 185, 1],
                    peru: [205, 133, 63, 1],
                    pink: [255, 192, 203, 1],
                    plum: [221, 160, 221, 1],
                    powderblue: [176, 224, 230, 1],
                    purple: [128, 0, 128, 1],
                    red: [255, 0, 0, 1],
                    rosybrown: [188, 143, 143, 1],
                    royalblue: [65, 105, 225, 1],
                    saddlebrown: [139, 69, 19, 1],
                    salmon: [250, 128, 114, 1],
                    sandybrown: [244, 164, 96, 1],
                    seagreen: [46, 139, 87, 1],
                    seashell: [255, 245, 238, 1],
                    sienna: [160, 82, 45, 1],
                    silver: [192, 192, 192, 1],
                    skyblue: [135, 206, 235, 1],
                    slateblue: [106, 90, 205, 1],
                    slategray: [112, 128, 144, 1],
                    slategrey: [112, 128, 144, 1],
                    snow: [255, 250, 250, 1],
                    springgreen: [0, 255, 127, 1],
                    steelblue: [70, 130, 180, 1],
                    tan: [210, 180, 140, 1],
                    teal: [0, 128, 128, 1],
                    thistle: [216, 191, 216, 1],
                    tomato: [255, 99, 71, 1],
                    turquoise: [64, 224, 208, 1],
                    violet: [238, 130, 238, 1],
                    wheat: [245, 222, 179, 1],
                    white: [255, 255, 255, 1],
                    whitesmoke: [245, 245, 245, 1],
                    yellow: [255, 255, 0, 1],
                    yellowgreen: [154, 205, 50, 1]
                };
                var R = function () {
                    function t(t, e, i) {
                        this.isFilling = i, this.lineDash = e, this.g = t, this.beginPath()
                    }
                    return t.prototype.beginPath = function () {
                        this.remaining = this.lineDash[0], this.dashes = [], this.pos = 0, this.x0 = 0, this.y0 = 0, this.x = 0, this.y = 0, this.hasPos = !1
                    }, t.prototype.moveTo = function (t, e) {
                        this.y = e, this.x = t, this.isFilling && this.dashes.push(0, t, e), this.g.moveTo(t, e), this.x0 = t, this.y0 = e, this.hasPos = !0
                    }, t.prototype.rect = function (t, e, i, n) {
                        this.moveTo(t, e), this.lineTo(t + i, n), this.lineTo(t + i, e + n), this.lineTo(t, e + n), this.lineTo(t, e)
                    }, t.prototype.lineTo = function (t, e) {
                        this.isFilling && this.g.lineTo(t, e);
                        var i = t - this.x,
                            n = e - this.y,
                            r = this.x,
                            s = this.y;
                        this.x = t, this.y = e;
                        var a = Math.sqrt(i * i + n * n),
                            o = 1 / a;
                        i *= o, n *= o;
                        for (var l = this.lineDash.length, h = this.pos, u = this.remaining;;) {
                            var c = Math.min(a, u);
                            if (r += i * c, s += n * c, h % 2 === 0 ? this.isFilling ? this.dashes.push(1, r, s) : this.g.lineTo(r, s) : this.isFilling ? this.dashes.push(0, r, s) : this.g.moveTo(r, s), !(a > c)) {
                                u -= c;
                                break
                            }
                            h = (h + 1) % l, u = this.lineDash[h], a -= c
                        }
                        this.pos = h, this.remaining = u, this.hasPos = !0
                    }, t.prototype.arc = function (t, e, i, n, r, s) {
                        var a = 2 * Math.PI,
                            o = Math.min(.6, 2 / i),
                            l = Math.cos(o),
                            h = Math.sin(o),
                            u = Math.sin(n) * i,
                            c = Math.cos(n) * i,
                            d = Math.sin(r) * i,
                            p = Math.cos(r) * i;
                        if (this.hasPos || (this.moveTo(t + c, e + u), this.hasPos = !0), s) {
                            n < r && (n += a);
                            for (var f = (n - r) / o, g = f; g >= 0; g--) {
                                if (g - 1 <= 0) {
                                    this.lineTo(t + p, e + d);
                                    break
                                }
                                this.lineTo(t + c, e + u);
                                var m = c * l + u * h,
                                    v = -c * h + u * l;
                                c = m, u = v
                            }
                        } else {
                            n > r && (n -= 2 * Math.PI);
                            for (var f = (r - n) / o, g = f; g >= 0; g--) {
                                if (g - 1 <= 0) {
                                    this.lineTo(t + p, e + d);
                                    break
                                }
                                this.lineTo(t + c, e + u);
                                var m = c * l - u * h,
                                    v = c * h + u * l;
                                c = m, u = v
                            }
                        }
                    }, t.prototype.quadraticCurveTo = function (e, i, n, r) {
                        this.g.quadraticCurveTo(e, i, n, r), t.bezierWarning || (t.bezierWarning = !0, d.warn("Dashed BÃ©zier curves not supported in this browser!"))
                    }, t.prototype.bezierCurveTo = function (e, i, n, r, s, a) {
                        this.g.bezierCurveTo(e, i, n, r, s, a), t.bezierWarning || (t.bezierWarning = !0, d.warn("Dashed BÃ©zier curves not supported in this browser!"))
                    }, t.prototype.closePath = function () {
                        this.lineTo(this.x0, this.y0)
                    }, t.prototype.strokeDashes = function () {
                        for (var t = this.dashes, e = 0; e < t.length; e += 3) {
                            var i = t[e],
                                n = t[e + 1],
                                r = t[e + 2];
                            0 === i ? this.g.moveTo(n, r) : this.g.lineTo(n, r)
                        }
                    }, t
                }();
                R.bezierWarning = !1, r.GraphicsDashedLineContext = R;
                var H = function () {
                    function t() {}
                    return t.stroke = function (t, e) {
                            0 !== e.lineWidth && e.lineColor && (t.lineWidth = e.lineWidth || 1, t.strokeStyle = e.lineColor, e.lineDash && e.lineDash.length > 0 && "undefined" != typeof t.setLineDash ? (t.setLineDash(e.lineDash), t.stroke(), t.setLineDash([])) : t.stroke(), e.lineWidth && (t.lineWidth = 1))
                        }, t.strokeWithShadow = function (t, e) {
                            0 !== e.lineWidth && e.lineColor && !e.shadowColor && (e.shadowColor && (t.shadowOffsetX = e.shadowOffsetX, t.shadowOffsetY = e.shadowOffsetY, t.shadowBlur = e.shadowBlur, t.shadowColor = e.shadowColor), t.lineWidth = e.lineWidth || 1, t.strokeStyle = e.lineColor, t.stroke(), e.lineWidth && (t.lineWidth = 1), e.shadowColor && (t.shadowBlur = 0, t.shadowColor = "transparent"))
                        }, t.beginStroke = function (t, e, i) {
                            return void 0 === i && (i = !1), t.beginPath(), e.lineColor && e.lineDash && e.lineDash.length > 1 && "undefined" == typeof t.setLineDash ? (i && !e.fillColor && (i = !1), new R(t, e.lineDash, i)) : t
                        }, t.endStroke = function (e, i, n, r) {
                            void 0 === r && (r = !1), i instanceof R ? (i.isFilling && (t.fill(e, n), e.beginPath(), i.strokeDashes()), t.strokeWithShadow(e, n)) : r ? t.paint(e, n) : t.stroke(e, n)
                        }, t.beginStrokeAndFill = function (e, i) {
                            return t.beginStroke(e, i, !0)
                        }, t.endStrokeAndFill = function (e, i, n) {
                            return t.endStroke(e, i, n, !0)
                        }, t.fill = function (t, e) {
                            e.fillColor && (t.fillStyle = e.fillColor, e.shadowColor && (t.shadowOffsetX = e.shadowOffsetX, t.shadowOffsetY = e.shadowOffsetY, t.shadowBlur = e.shadowBlur, t.shadowColor = e.shadowColor), t.fill(), e.shadowColor && (t.shadowBlur = 0, t.shadowColor = "transparent"))
                        },
                        t.paint = function (t, e) {
                            e.shadowColor && (t.shadowOffsetX = e.shadowOffsetX, t.shadowOffsetY = e.shadowOffsetY, t.shadowBlur = e.shadowBlur, t.shadowColor = e.shadowColor), e.fillColor && (t.fillStyle = e.fillColor, t.fill()), 0 !== e.lineWidth && e.lineColor && (t.lineWidth = e.lineWidth || 1, t.strokeStyle = e.lineColor, e.lineDash && "undefined" != typeof t.setLineDash ? (t.setLineDash(e.lineDash), t.stroke(), t.setLineDash([])) : t.stroke()), e.shadowColor && (t.shadowBlur = 0, t.shadowColor = "transparent")
                        }, t.textStyle = function (t, e) {
                            t.__textStyle && this.resetTextStyle(t);
                            var i = e.fillColor;
                            void 0 === i && (i = "#000"), t.fillStyle = i, t.__font = t.font = e.font || null, e.shadowColor && (t.shadowOffsetX = e.shadowOffsetX, t.shadowOffsetY = e.shadowOffsetY, t.shadowBlur = e.shadowBlur, t.shadowColor = e.shadowColor), e.outlineColor && (t.strokeStyle = e.outlineColor, t.lineWidth = 2 * (e.outlineWidth || 1), t.lineJoin = e.outlineJoin || "miter", t.miterLimit = 2), t.__textStyle = e
                        }, t.getTextWidth = function (t, e, i) {
                            if (e) {
                                var n = e.font;
                                t.__font !== n && (t.__textStyle = null, t.__font = t.font = n || null)
                            }
                            var r = t.measureText(i).width;
                            return e.outlineColor && (r += 2 * (e.outlineWidth || 1)), r
                        }, t.drawText = function (t, e, i, n, r) {
                            t.__textStyle !== e && this.textStyle(t, e), null != i && i.length && (e.outlineColor && t.strokeText(i, n, r), t.fillText(i, n, r))
                        }, t.resetTextStyle = function (t) {
                            t.__font = null;
                            var e = t.__textStyle;
                            e && (e.shadowColor && (t.shadowColor = "transparent", t.shadowBlur = 0), e.outlineColor && (t.lineJoin = "miter", t.miterLimit = 10, t.lineWidth = 1), t.__textStyle = null)
                        }, t.restore = function (t) {
                            this.resetTextStyle(t), t.restore()
                        }, t.rectStyle = function (t, e) {
                            void 0 !== e.lineColor && (t.strokeStyle = e.lineColor), void 0 !== e.fillColor && (t.fillStyle = e.fillColor), void 0 !== e.lineWidth && (t.lineWidth = e.lineWidth)
                        }, t.pushClip = function (t, e, i, n, r) {
                            var s = t.context,
                                a = t.scaleX,
                                o = t.scaleY;
                            1 === a && 1 === o || !window.screen.deviceXDPI ? (s.save(), s.beginPath(), s.rect(e, i, n, r), s.clip()) : (s.save(), s.setTransform(1, 0, 0, 1, 0, 0), s.beginPath(), s.rect(e * a | 0, i * o | 0, n * a | 0, r * o | 0), s.clip(), s.setTransform(a, 0, 0, o, 0, 0))
                        }, t.popClip = function (t) {
                            this.restore(t.context)
                        }, t.arcBetweenTwoPoints = function (t, e, i, n, r, s, a, o) {
                            var l = (r + a) / 2,
                                h = (s + o) / 2,
                                u = o - s,
                                c = r - a,
                                d = u * u + c * c;
                            if (0 !== d) {
                                var p = Math.sqrt(d);
                                n = Math.min(Math.max(n, p / 2), 3 * p);
                                var f = Math.sqrt(n * n / d - .25),
                                    g = l + u * f,
                                    m = h + c * f,
                                    v = l - u * f,
                                    y = h - c * f,
                                    S = (g - e) * (g - e) + (m - i) * (m - i),
                                    b = (v - e) * (v - e) + (y - i) * (y - i);
                                S > b ? (e = v, i = y) : (e = g, i = m);
                                var C = Math.atan2(s - i, r - e),
                                    x = Math.atan2(o - i, a - e);
                                x < C && (x += 2 * Math.PI);
                                var w = Math.abs(C - x) > Math.PI;
                                t.arc(e, i, n, C, x, w)
                            }
                        }, t.strokeMarker = function (e, i, n, r, s) {
                            var a = 1.41421356237 * s;
                            switch (i) {
                                case "rect":
                                case "square":
                                    e.moveTo(n - s, r - s), e.lineTo(n + s, r - s), e.lineTo(n + s, r + s), e.lineTo(n - s, r + s), e.lineTo(n - s, r - s);
                                    break;
                                case "romb":
                                case "rhombus":
                                    a = .9 * a, e.moveTo(n - a, r), e.lineTo(n, r - a), e.lineTo(n + a, r), e.lineTo(n, r + a), e.lineTo(n - a, r);
                                    break;
                                case "triangle":
                                    var o = t.SQRT3D6 * (3 * s);
                                    e.moveTo(n - s, r + o), e.lineTo(n + s, r + o), e.lineTo(n, r - o), e.lineTo(n - s, r + o);
                                    break;
                                case "triangle2":
                                    e.moveTo(n - a, r - a), e.lineTo(n + a, r - a), e.lineTo(n, r + a), e.lineTo(n - a, r - a);
                                    break;
                                case "circle":
                                    e.moveTo(n + s, r), e.arc(n, r, s, 0, 2 * Math.PI, !1);
                                    break;
                                default:
                                    throw new Error("Unknown marker shape " + i + ". Valid values are `square`, `rhombus`, `triangle`, `triangle2`, `circle`.")
                            }
                        }, t.strokeBalloon = function (t, e, i, n, r) {
                            n = Math.max(n, 2 * r);
                            var s = 5,
                                a = 4,
                                o = (r + 2 * a) / 2,
                                l = e,
                                h = i;
                            t.moveTo(l, h), l += 3, h += s + 1, t.lineTo(l, h), l += n - a, t.lineTo(l, h), t.arc(l, h + o, o, -Math.PI / 2, Math.PI / 2), h += 2 * o, l -= n - a, t.lineTo(l, h), t.arc(l, h - o, o, .5 * Math.PI, 1.3 * Math.PI), t.closePath()
                        }, t.strokeBalloon2 = function (t, e, i, n, r) {
                            var s = 4,
                                a = (r + 2 * s) / 2;
                            n = Math.max(n, 2 * r) / 2 - s;
                            var o = e + n,
                                l = i - a;
                            t.moveTo(o, l), t.arc(o, l + a, a, -Math.PI / 2, Math.PI / 2, !1), l += 2 * a, o -= 2 * n, t.lineTo(o, l), t.arc(o, l - a, a, .5 * Math.PI, 1.5 * Math.PI, !1), t.closePath()
                        }, t.applyColorToImage = function (t, e, i) {
                            void 0 === i && (i = !0);
                            var n = O.parse(e),
                                r = n.R,
                                s = n.G,
                                a = n.B,
                                o = document.createElement("canvas"),
                                l = o.width = t.width,
                                h = o.height = t.height,
                                u = o.getContext("2d");
                            u.drawImage(t, 0, 0);
                            var c = u.getImageData(0, 0, l, h),
                                d = c.data;
                            if (i)
                                for (var p = 0; p <= d.length; p += 4) 255 === d[p + 3] && (d[p] = d[p] * r >> 8, d[p + 1] = d[p + 1] * s >> 8, d[p + 2] = d[p + 2] * a >> 8);
                            else
                                for (var p = 0; p <= d.length; p += 4) d[p] = d[p] * r >> 8, d[p + 1] = d[p + 1] * s >> 8, d[p + 2] = d[p + 2] * a >> 8;
                            return u.putImageData(c, 0, 0), o
                        }, t.cropImageToCircle = function (t, e) {
                            var i = Math.min(t.width, t.height),
                                n = Math.max(t.width, t.height),
                                r = Math.min(n, 2 * i),
                                s = document.createElement("canvas");
                            s.width = r, s.height = r;
                            var a = s.getContext("2d"),
                                o = t.width,
                                l = t.height;
                            a.fillStyle = "rgba(0,0,0,1)", a.beginPath(), a.arc(r / 2, r / 2, r / 2, 0, 2 * -Math.PI, !1), a.fill();
                            var h = a.globalCompositeOperation;
                            if (a.globalCompositeOperation = "source-in", "crop" === e) {
                                var u = Math.min(o, l) / 2;
                                a.drawImage(t, o / 2 - u, l / 2 - u, 2 * u, 2 * u, 0, 0, r, r)
                            } else if ("letterbox" === e) {
                                a.fillStyle = "black", a.fillRect(0, 0, r, r);
                                var c = r / Math.max(o, l);
                                a.drawImage(t, 0, 0, o, l, r / 2 - o / 2 * c, r / 2 - l / 2 * c, o * c, l * c)
                            } else if ("fit" === e) {
                                a.fillStyle = "black", a.fillRect(0, 0, r, r);
                                var c = r / Math.sqrt(o * o + l * l);
                                a.drawImage(t, 0, 0, o, l, r / 2 - o / 2 * c, r / 2 - l / 2 * c, o * c, l * c)
                            } else a.drawImage(t, 0, 0, o, l, 0, 0, r, r);
                            return a.globalCompositeOperation = h, s
                        }, t.applyShadow = function (t, e) {
                            e.shadowColor && (t.shadowOffsetX = e.shadowOffsetX, t.shadowOffsetY = e.shadowOffsetY, t.shadowBlur = e.shadowBlur, t.shadowColor = e.shadowColor)
                        }, t.clearShadow = function (t) {
                            t.shadowBlur = 0, t.shadowColor = "transparent"
                        }, t.drawImageInSquare = function (t, e, i, n, r, s, a, o, l) {
                            var h = l / Math.max(r, s),
                                u = r * h,
                                c = s * h;
                            this.drawImageHighQuality(t, e, i, n, r, s, a - u, o - c, 2 * u, 2 * c)
                        }, t.drawImageHighQuality = function (t, e, i, n, r, s, a, o, l, h) {
                            void 0 === a && (a = i, o = n, l = r, h = s, r = e.width, s = e.height, i = 0, n = 0);
                            var u = t.__scaleX || 1,
                                c = t.__scaleY || 1;
                            if (!(h < 1 / c || l < 1 / u)) {
                                for (var d = r, p = s, f = e, g = 1, m = "__size:" + i + "/" + n + "/" + r + "/" + s + "/"; d >= l * u * 2 && p >= h * c * 2;) {
                                    var v = Math.round(d / 2),
                                        y = Math.round(p / 2);
                                    g /= 2;
                                    var S = m + g,
                                        b = e[S];
                                    if (!b) {
                                        b = e[S] = document.createElement("canvas"), b.width = v, b.height = y;
                                        var C = b.getContext("2d");
                                        C.drawImage(f, i, n, d, p, 0, 0, v, y)
                                    }
                                    i = 0, n = 0, f = b, p = y, d = v
                                }
                                t.drawImage(f, i, n, 0 | d, 0 | p, a, o, l, h)
                            }
                        }, t.getTextHeight = function (e, i) {
                            var n = t._heightCache;
                            if (n.hasOwnProperty(i)) return n[i];
                            var s = t._heightElem;
                            if (!s) {
                                var a = document.createElement("div");
                                a.className = "DVSL-font-height", t._heightElem = s = document.createElement("div"), s.appendChild(document.createTextNode("Mg9!")), a.appendChild(s), document.body.appendChild(a)
                            }
                            s.style.font = i;
                            var o = s.getBoundingClientRect();
                            return o.top >= 0 && o.left >= 0 ? (r.Helpers.error("getTextHeight called before CSS loaded"), o.height) : n[i] = o.height
                        }, t
                }();
                H.SQRT3D6 = Math.sqrt(3) / 6, H._heightElem = null, H._heightCache = {}, r.Graphics = H;
                var B = function () {
                    function t() {
                        this.enabled = !0, this.enabledOnExport = !0, this.align = "center", this.margin = 25, this.style = {
                            font: "20px Arial",
                            fillColor: "#000"
                        }, this.text = "", this.advanced = {
                            addAfterToolbar: !1
                        }
                    }
                    return t
                }();
                r.SettingsTitle = B;
                var z = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.lineSpacing = 0, i.animationOrder = 2e3, i.paintOrder = 55, i.updateOrder = 500, i.chart = e, i.scene = e.scene, i.settings = i.scene.settings.title, i.panel = new M, i.panel.packingOrder = 10, i.settings.advanced && i.settings.advanced.addAfterToolbar === !0 && (i.panel.packingOrder = 20), i.panel.side = "top", i.panel.outsideEdge = !0, i.panel.align = "fill", i.panel.visible = !1, i.panel.computeSize = function (t, e, n) {
                            return i.computePanelSize(t, e, n)
                        }, i.lines = null, i
                    }
                    return n(e, t), e.prototype.onSceneChange = function (t) {
                        var e = t.changes;
                        e.settings && e.settingsChanges.title && (e.bounds = !0)
                    }, e.prototype.getPanels = function (t) {
                        var e = this.settings;
                        return this.panel.visible = !!e.text && (t ? e.enabledOnExport : e.enabled), this.panel.visible ? (this.panel.margin = e.margin, t && !e.enabled ? this.panel.location = "external" : this.panel.location = "outside", [this.panel]) : []
                    }, e.prototype.computePanelSize = function (t, e, i) {
                        if (!this.chart.assetsLoaded) return {
                            width: 0,
                            height: 0
                        };
                        this.lines = [];
                        var n = this.settings.text,
                            r = this.settings.style;
                        i.save();
                        var s = H.getTextWidth(i, r, n),
                            a = H.getTextHeight(i, r.font);
                        if (this.lineSpacing = 1.15 * a, s > t) {
                            for (var o = 0, l = n.split(" "), h = l[0], u = H.getTextWidth(i, r, h), c = 1; c <= l.length - 1; c++) {
                                var d = h + " " + l[c],
                                    p = H.getTextWidth(i, r, d);
                                p <= t ? (h = d, u = p) : (this.lines.push(h), s = Math.max(s, u), h = l[c], u = H.getTextWidth(i, r, h))
                            }
                            this.lines.push(h), s = Math.max(o, u)
                        } else this.lines.push(n);
                        return H.restore(i), a = (this.lines.length - 1) * this.lineSpacing + a, {
                            width: s,
                            height: a
                        }
                    }, e.prototype.paintScene = function (t) {
                        if (this.panel.visible && this.lines) {
                            var e = this.settings,
                                i = t.context,
                                n = this.panel.left,
                                r = this.panel.right,
                                s = this.panel.top,
                                a = e.style;
                            i.textBaseline = "top";
                            var o;
                            "left" === e.align ? (i.textAlign = "start", o = n) : "right" === e.align ? (i.textAlign = "end", o = r) : (i.textAlign = "center", o = (n + r) / 2);
                            for (var l = 0; l < this.lines.length; l++) H.drawText(i, a, this.lines[l], o, s), s += this.lineSpacing;
                            H.resetTextStyle(i)
                        }
                    }, e
                }(k);
                r.Title = z;
                var U = function () {
                    function t(t, e) {
                        void 0 === e && (e = !1), this.style = {
                            textStyle: {}
                        }, this._textOverride = void 0, this.visible = !0, this.allowCache = !0, this.shouldBeVisible = !0, this.userPlaced = !1, this.rows = null, this.lineHeight = 0, this.lineHeightM = 0, this.hwidth = null, this.hheight = null, this.currentBounds = null, this.x = null, this.originX = null, this.y = null, this.prop = null, this._pendingImage = !1, this._textCache = null, this._measureStyles = null, t.textStyle || (t.textStyle = {}), null == t.lineSpacing && (t.lineSpacing = .2), e ? this.style = t : this.style = r.Helpers.realClone(t)
                    }
                    return Object.defineProperty(t.prototype, "text", {
                        get: function () {
                            var t = this._textOverride;
                            return void 0 === t && (t = this.style.text, null != t && "string" != typeof t && (t = "" + t)), t
                        },
                        set: function (t) {
                            void 0 === t && (t = null), null != t && "string" != typeof t && (t = "" + t), this._textOverride = t
                        },
                        enumerable: !0,
                        configurable: !0
                    }), t.prototype.needTextParsing = function () {
                        var t = this._textCache;
                        return !t || t.sourceText !== this.text || t.sourceFont !== this.style.textStyle.font
                    }, t.prototype.needMeasure = function () {
                        var t = this._measureStyles,
                            e = t && t.customMeasure;
                        if (this._pendingImage) return !e || null;
                        var i = this.style,
                            n = i.textStyle,
                            r = !t || t.align !== i.align || t.text !== this.text || t.aspectRatio !== i.aspectRatio || t.borderRadius !== i.borderRadius || t.font !== n.font || t.image !== i.image || t.imageSlicing !== "" + i.imageSlicing || t.margin !== i.margin || t.maxWidth !== i.maxWidth || t.padding !== i.padding;
                        return r && e ? null : r
                    }, t.prototype.measureComplete = function (t) {
                        var e = this.style,
                            i = e.textStyle;
                        this._measureStyles = {
                            customMeasure: t,
                            text: this.text,
                            align: e.align,
                            aspectRatio: e.aspectRatio,
                            borderRadius: e.borderRadius,
                            font: i.font,
                            image: e.image,
                            imageSlicing: "" + e.imageSlicing,
                            lineSpacing: e.lineSpacing,
                            margin: e.margin,
                            maxWidth: e.maxWidth,
                            padding: e.padding
                        }
                    }, t
                }();
                r.Label = U;
                var G = function () {
                    function t(t, e, i) {
                        if (this.cache = {}, this.frameLabels = {}, this.numPaints = 0, this.numCachedPaints = 0, this.allowCache = !0, this.chartArea = 0, this.scaleX = 0, this.scaleY = 0, this.settings = t, this.assetsLoader = e, !i) throw new Error("chartContainer must be specified");
                        this.chartContainer = i
                    }
                    return t.prototype.startFrame = function (t, e, i, n) {
                        this.chartArea = t * e, this.scaleX = i, this.scaleY = n
                    }, t.prototype.finishFrame = function () {
                        var t = d.countProperties(this.cache);
                        if (!(t < 1e3)) {
                            var e = d.countProperties(this.frameLabels);
                            if (t > 3 * e)
                                for (var i in this.cache) this.frameLabels[i] || delete this.cache[i];
                            this.frameLabels = {}
                        }
                    }, t.prototype.measure = function (t, e) {
                        var i = e.needMeasure();
                        if (i === !0) {
                            var n = e.style,
                                r = (new j).totalPadding(n),
                                s = 0,
                                a = 0;
                            if (e.text) {
                                var o = this.measureText(t, e),
                                    l = o.w,
                                    h = o.h;
                                a = Math.max(a, h), s += l
                            } else e.rows = {
                                subLines: [],
                                rowWidths: []
                            };
                            if (n.image) {
                                var u = n.imageSlicing;
                                if (u) s += u[2], a = Math.max(a, u[3]);
                                else {
                                    var c = this.assetsLoader.getAssetImage(n.image, null);
                                    c && c.width ? (s += c.width, a = Math.max(a, c.height)) : e._pendingImage = !0
                                }
                            }
                            if (0 === s && (s = 10, a = 10), s += 2 * r, a += 2 * r, n.borderRadius > 0 && e.text) {
                                var d = Math.min(n.borderRadius, a / 2);
                                s += .45 * d, n.image || (s += .45 * d)
                            }
                            e.hwidth = s / 2, e.hheight = a / 2, e.measureComplete(!1)
                        } else if (null === i) throw new Error("Label.needMeasure assert.")
                    }, t.prototype.measureText = function (t, e) {
                        var i, n, r = e.style,
                            s = r.aspectRatio,
                            a = r.maxWidth,
                            o = new j,
                            l = o.styleTagParser(t, e);
                        if ((s > 0 || a > 0) && l.maxLines > 1) {
                            s || (s = 1e9), a || (a = 1e9);
                            var h = function (t) {
                                return {
                                    x: 0,
                                    y: 0,
                                    dx: 0,
                                    dy: 0,
                                    width: Math.min(a, t * (s + .2))
                                }
                            };
                            o.fitLabelInRect(t, e, h, !1), i = 2 * e.hwidth, n = 2 * e.hheight
                        } else {
                            for (var u = l.words, c = l.breaks, d = 0; d < c.length; d++) c[d] = c[d] - 1;
                            var p = o.stringsByFont(u, c);
                            e.lineHeight = n = H.getTextHeight(t, r.textStyle.font), e.rows = p, i = p.rowWidths.reduce(function (t, e) {
                                return Math.max(t, e)
                            }), n = n * (1 + (r.lineSpacing || 0)) * p.rowWidths.length
                        }
                        return {
                            w: i,
                            h: n
                        }
                    }, t.prototype.canCache = function (t, e) {
                        var i = this.settings.advanced,
                            n = t.style;
                        if (!this.allowCache || !t.allowCache || !i.labelCache) return !1;
                        if (n.angle && !i.labelCacheRotated) return !1;
                        var r = 2 * (t.hwidth * t.hheight * e * e);
                        if (this.chartArea / r < 10) return !1;
                        if (n.image) {
                            var s = this.assetsLoader.getAssetImage(n.image, null);
                            if (!s) return !1
                        }
                        return !0
                    }, t.prototype.styleRequiresDocumentCanvas = function (t) {
                        return !!(t && t.font && /[0-9]+em/.test(t.font))
                    }, t.prototype.realPaint = function (t, e, i, n) {
                        var r = n.hwidth,
                            s = n.hheight,
                            a = n.style,
                            o = a.backgroundStyle,
                            l = (new j).totalPadding(a),
                            h = Math.min(a.borderRadius || 0, s);
                        if (o) {
                            var u = o.lineWidth;
                            u = null == u && o.lineColor ? .5 : (u || 0) / 2, r -= u, s -= u;
                            var c = H.beginStrokeAndFill(t, o);
                            if (h >= s) {
                                var d = e + r - s;
                                c.moveTo(d, i - s), c.arc(d, i, s, -Math.PI / 2, Math.PI / 2, !1), d = e - r + s, c.lineTo(d, i + s), c.arc(d, i, s, Math.PI / 2, -Math.PI / 2, !1), c.closePath()
                            } else h > 0 ? (c.moveTo(e - r + h, i - s), c.lineTo(e + r - h, i - s), c.arc(e + r - h, i - s + h, h, -Math.PI / 2, 0, !1), c.lineTo(e + r, i + s - h), c.arc(e + r - h, i + s - h, h, 0, +Math.PI / 2, !1), c.lineTo(e - r + h, i + s), c.arc(e - r + h, i + s - h, h, +Math.PI / 2, Math.PI, !1), c.lineTo(e - r, i - s + h), c.arc(e - r + h, i - s + h, h, Math.PI, Math.PI + Math.PI / 2, !1)) : (c.moveTo(e - r, i - s), c.lineTo(e + r, i - s), c.lineTo(e + r, i + s), c.lineTo(e - r, i + s), c.closePath());
                            H.endStrokeAndFill(t, c, o), r += u, s += u
                        }
                        var p = a.image;
                        r -= l, s -= l;
                        var f = e - r,
                            g = e + r;
                        if (p) {
                            var m = this.assetsLoader.getAssetImage(p);
                            if (m) {
                                var v = a.imageSlicing;
                                v ? (H.drawImageHighQuality(t, m, v[0], v[1], v[2], v[3], e - r, i - s, v[2], v[3]), f += v[2]) : (t.drawImage(m, e - r, i - s), f += m.width)
                            }
                        }
                        var y = n.rows.subLines,
                            S = n.rows.rowWidths,
                            b = S.length;
                        if (y.length > 0) {
                            var C = n.lineHeight * (1 + (a.lineSpacing || 0)),
                                x = a.align,
                                w = void 0,
                                L = void 0;
                            t.textBaseline = "bottom";
                            var T = i - (b + 1) * C / 2 + .58 * n.lineHeight;
                            "left" === x ? (L = f, p || (L += .45 * h), w = "start") : "right" === x ? (L = g - .45 * h, w = "end") : (L = (f + g) / 2, w = "center");
                            var k = a.textStyle,
                                A = -1,
                                M = 0;
                            t.textAlign = w;
                            var I = void 0;
                            H.textStyle(t, k);
                            for (var P = k.font, D = 0; D < y.length; D++) {
                                var N = y[D],
                                    F = M;
                                if (M += N.width, A !== N.row) {
                                    A = N.row, T += C, F = 0, M = N.width;
                                    var O = S[A];
                                    I = "center" === w ? L - O / 2 : "start" === w ? L : L - O
                                }
                                t.textAlign = "left", P !== N.font && (t.font = P = N.font), F += I, H.drawText(t, k, N.text, F, T)
                            }
                            H.resetTextStyle(t)
                        }
                    }, t.prototype.paint = function (t, e, i, n, s) {
                        this.measure(t, s);
                        var a = s.style,
                            o = (a.angle || 0) / 180 * Math.PI,
                            l = this.scaleX,
                            h = this.scaleY,
                            u = 0 === (a.angle || 0) ? 1 : 1.7,
                            c = l * n * u,
                            d = h * n * u,
                            p = this.canCache(s, n),
                            f = s.hwidth,
                            g = s.hheight,
                            m = 3 / h;
                        if (s.currentBounds = new mt(e - f * n, i - g * n, e + f * n, i + g * n), p) {
                            var v = c,
                                y = d;
                            g * d < m && (y = m / g, v = c / d * y);
                            var S = s.text + JSON.stringify(s.style) + v.toFixed(2) + "," + y.toFixed(2) + "," + s.hwidth + "," + s.hheight,
                                b = this.cache[S] || null,
                                C = void 0,
                                x = void 0,
                                w = void 0,
                                L = void 0;
                            if (b) C = b.width, x = b.height, w = C / 2, L = x / 2, this.numCachedPaints += 1;
                            else {
                                var T = a.backgroundStyle,
                                    k = T && T.lineWidth ? T.lineWidth : 0;
                                C = Math.ceil((2 * f + k + 1) * v), x = Math.ceil((2 * g + k + 1) * y), b = document.createElement("canvas"), C += C % 2, x += x % 2, w = C / 2, L = x / 2, b.width = C, b.height = x;
                                var A = this.styleRequiresDocumentCanvas(a.textStyle),
                                    M = void 0;
                                A && (M = this.chartContainer, M.ownerDocument || (r.Helpers.warn("chartContainer must be appended to the document in order to use `em` when specifying font size."), M = document.body), b.style.display = "none", M.appendChild(b));
                                var I = b.getContext("2d");
                                I.transform(v, 0, 0, y, w, L), this.realPaint(I, 0, 0, s), A && M.removeChild(b), this.cache[S] = b, this.numPaints += 1
                            }
                            var P = C / c * n,
                                D = x / d * n;
                            v !== c && (P = P / v * c, D = D / y * d), P = Math.round(P / 2 * 1e3) / 1e3, D = Math.round(D / 2 * 1e3) / 1e3;
                            var N = e - P,
                                F = i - D;
                            0 !== o ? (t.save(), t.translate(e, i), t.rotate(o), N = -P, F = -D) : v === c && (N = Math.round(N * l) / l, F = Math.round(F * h) / h), H.drawImageHighQuality(t, b, 0, 0, C, x, N, F, 2 * P, 2 * D), this.frameLabels[S] = 1, 0 !== o && H.restore(t)
                        } else {
                            var O = 1 !== n || 0 !== o;
                            O && (t.save(), t.transform(n, 0, 0, n, e, i), 0 !== o && t.rotate(o), e = 0, i = 0), this.realPaint(t, e, i, s), this.numPaints += 1, O && H.restore(t)
                        }
                    }, t
                }();
                r.LabelRenderer = G;
                var j = function () {
                    function t() {}
                    return t.prototype.totalPadding = function (t) {
                        var e = t.padding || 0,
                            i = t.backgroundStyle;
                        if (i) {
                            var n = i.lineWidth;
                            e += null == n && i.lineColor ? 1 : n || 0
                        }
                        return e
                    }, t.prototype.fitLabelInRect = function (t, e, i, n) {
                        void 0 === n && (n = !0);
                        var r = e.style,
                            s = r.margin || 0,
                            a = this.totalPadding(r),
                            o = H.getTextHeight(t, r.textStyle.font),
                            l = r.lineSpacing || 0,
                            h = o * (l + 1),
                            u = -o * l;
                        e.needTextParsing() && this.styleTagParser(t, e);
                        for (var c, d, p = e._textCache.words, f = e._textCache.breaks, g = e._textCache.maxLines, m = -(1 / 0), v = null, y = 0, S = 0, b = 0, C = 0, x = Math.min(g, f.length); x <= g; x++) {
                            var w = u + h * x,
                                L = i(w / 2 + s + a),
                                T = L.width;
                            T -= 2 * (s + a);
                            var k = this.splitWordsToLines(p, f, x, function () {
                                    return T
                                }),
                                A = k.prop,
                                M = k.actualWidthForLines,
                                I = k.positions;
                            if (A > m) {
                                v = I, m = A, c = L.dx, d = L.dy, y = L.x, S = L.y, b = T, C = 0;
                                for (var P = 0; P < M.length; P++) {
                                    var D = M[P];
                                    C = Math.max(D, C)
                                }
                            }
                            if (A >= 1) break
                        }
                        if (v) {
                            if (!e.userPlaced) {
                                var N = e.style.align,
                                    F = void 0;
                                F = "left" === N ? (C - b) / 2 : "right" === N ? (b - C) / 2 : 0, y += c * F, S += d * F
                            }
                            n && (e.x = y, e.y = S), e.rows = this.stringsByFont(p, v), e.hheight = (u + h * v.length) / 2 + a, e.lineHeight = o, e.lineHeightM = h, e.hwidth = C / 2 + a, e.visible = !0, e.measureComplete(!0), r.borderRadius > 0 && (e.hwidth += .45 * Math.min(r.borderRadius, e.hheight))
                        } else e.rows = {
                            subLines: [],
                            rowWidths: []
                        }, e.visible = !1;
                        return m
                    }, t.prototype.styleTagParser = function (t, e) {
                        return e.needTextParsing() && (e._textCache = this.styleTagParser2(t, e.text, e.style.textStyle)), e._textCache
                    }, t.prototype.styleTagParser2 = function (e, i, n) {
                        var r = n.font,
                            s = null;
                        r ? (e.font = r, s = e.font) : r = "11px Arial";
                        var a = t._spaceWidth;
                        a[r] || (a[r] = H.getTextWidth(e, {
                            font: r
                        }, " "));
                        var o = r,
                            l = 0,
                            h = 0,
                            u = !0,
                            c = i;
                        i = null == i ? "" : "" + i;
                        var p = 0,
                            f = 0,
                            g = [],
                            m = [],
                            v = -1;
                        g.push({
                            word: "",
                            width: 0,
                            font: o,
                            spaceWidth: 0
                        });
                        var y = {
                            word: "",
                            width: 0,
                            font: o,
                            spaceWidth: 0
                        };
                        g.push(y);
                        for (var S = i.length, b = 0 === S ? -1 : i.charCodeAt(0); p < S;) switch (b) {
                            case 32:
                                for (; 32 === b && ++p < S;) b = i.charCodeAt(p);
                                u || (y.spaceWidth = a[o], u = !0), f = p;
                                break;
                            case 60:
                                if (p + 4 > S) {
                                    b = -1;
                                    break
                                }
                                var C = p,
                                    x = i.charCodeAt(++p),
                                    w = 47 === x ? -1 : 1;
                                w < 0 && (x = i.charCodeAt(++p));
                                var L = i.charCodeAt(++p),
                                    T = -1;
                                if (98 === x || 66 === x ? 82 === L || 114 === L ? (L = ++p === S ? -1 : i.charCodeAt(p), T = 2) : T = 0 : 73 !== x && 105 !== x || (T = 1), T > -1 && 62 === L) {
                                    b = ++p === S ? -1 : i.charCodeAt(p), f = p;
                                    var k = !1,
                                        A = y.word || y.spaceWidth > 0;
                                    if (2 === T) v === g.length - 1 && (A = !0), m.push(v = g.length - (A ? 0 : 1)), u = !0, k = !0;
                                    else {
                                        1 === T ? h = Math.max(0, h + w) : l = Math.max(0, l + w);
                                        var M = (h ? "italic " : "") + (l ? "bold " : "") + r;
                                        M !== o && (k = !0, o = M, a[o] || (a[o] = H.getTextWidth(e, {
                                            font: o
                                        }, " ")))
                                    }
                                    k && (A ? (y = {
                                        word: "",
                                        width: 0,
                                        font: o,
                                        spaceWidth: 0
                                    }, g.push(y)) : y.font = o)
                                } else p = C, b = -1;
                                break;
                            default:
                                for (var I = !1; 32 !== b && 60 !== b && ++p < S;) I = I || 38 === b, b = i.charCodeAt(p);
                                var P = i.substring(f, p);
                                I && (P = d.decodeEntities(P)), y.spaceWidth > 0 || y.font !== o ? (y = {
                                    word: P,
                                    width: 0,
                                    font: o,
                                    spaceWidth: 0
                                }, g.push(y)) : y.word += P, u = !1, f = p
                        }
                        for (var D = 0; D < g.length; D++) {
                            var N = g[D];
                            N.word && (N.width = H.getTextWidth(e, {
                                font: N.font
                            }, N.word))
                        }
                        H.resetTextStyle(e);
                        var F = g.length;
                        m[m.length - 1] !== F && m.push(F);
                        var O = F;
                        0 === g[0].width && O--;
                        for (var D = F - 1; D >= 0; D--) {
                            var N = g[D];
                            if (N.width > 0) break;
                            O--
                        }
                        return {
                            sourceText: c,
                            sourceFont: n.font,
                            breaks: m,
                            maxLines: O,
                            words: g
                        }
                    }, t.prototype.stringsByFont = function (t, e) {
                        for (var i = t[0].font, n = e.slice(0), r = [], s = [], a = 0, o = 0, l = "", h = 0, u = 0, c = 0; c <= t.length - 1; c++) {
                            var d = t[c];
                            u = d.spaceWidth;
                            var p = c === n[0];
                            d.font !== i && (o && r.push({
                                text: l,
                                width: o,
                                font: i,
                                row: h
                            }), i = d.font, l = "", o = 0), o += d.width, l += d.word, a += d.width + d.spaceWidth, p && (r.push({
                                text: l,
                                width: o,
                                font: i,
                                row: h
                            }), s.push(a - d.spaceWidth), l = "", h++, o = a = 0, n.shift()), p || d.spaceWidth && (o += d.spaceWidth, l += " ")
                        }
                        return l && (r.push({
                            text: l,
                            width: o,
                            font: i,
                            row: h
                        }), s.push(a - u)), {
                            subLines: r,
                            rowWidths: s
                        }
                    }, t.prototype.fitLabelInLines = function (t, e, i, n, r, s, a) {
                        var o = e.style,
                            l = o.margin || 0,
                            h = this.totalPadding(o),
                            u = H.getTextHeight(t, o.textStyle.font),
                            c = o.lineSpacing || 0,
                            d = u * (c + 1),
                            p = -u * c;
                        this.styleTagParser(t, e);
                        var f = e._textCache.words,
                            g = e._textCache.breaks,
                            m = e._textCache.maxLines,
                            v = -(1 / 0),
                            y = null,
                            S = null,
                            b = null,
                            C = 0,
                            x = [],
                            w = [];
                        w.push(a(i, n));
                        for (var L = 1; L <= g.length - 1; L++) {
                            var T = p + d * L,
                                k = void 0;
                            k = L % 2 === 1 ? x : w;
                            var A = a(i, n - T / 2 - l);
                            k.unshift([A[0] - l, A[1] - l]), A = a(i, n + T / 2 + l), k.push([A[0] - l, A[1] - l])
                        }
                        for (var L = Math.min(m, g.length); L <= m; L++) {
                            var M, T = p + d * L;
                            M = L % 2 === 1 ? x : w;
                            var A = a(i, n - T / 2 - l);
                            M.unshift([A[0] - l, A[1] - l]), A = a(i, n + T / 2 + l), M.push([A[0] - l, A[1] - l]);
                            var I = function (t) {
                                    return Math.min(M[t][0] + M[t][1], M[t + 1][0] + M[t + 1][1])
                                },
                                P = this.splitWordsToLines(f, g, L, I),
                                D = P.prop,
                                N = P.actualWidthForLines,
                                F = P.positions;
                            if (D > v && (C = n - T / 2, y = F, v = D, S = N, b = M.slice(0), F.length + 1 > M.length)) throw new Error("Internal error - fitLabelInLines");
                            if (D >= 1) break
                        }
                        if (y) {
                            var O = 0,
                                E = 0,
                                R = void 0,
                                B = void 0;
                            if ("left" === r) {
                                for (var z = 1e30, U = 0; U <= y.length; U++) z = Math.min(b[U][0]);
                                var G = -z;
                                R = G, B = G;
                                for (var U = 0; U <= y.length - 1; U++) {
                                    var j = S[U],
                                        W = Math.min(b[U][1], b[U + 1][1]);
                                    B = Math.max(G + j), E = Math.max(E, j - (W - G))
                                }
                            } else if ("right" === r) {
                                for (var W = 1e30, U = 0; U <= y.length; U++) W = Math.min(b[U][1]);
                                var V = W;
                                R = V, B = V;
                                for (var U = 0; U <= y.length - 1; U++) {
                                    var j = S[U];
                                    R = Math.min(V - j), O = Math.max(O, j - (W + V))
                                }
                            } else if ("center" === r) {
                                for (var z = 1e30, W = 1e30, U = 0; U <= y.length - 1; U++) {
                                    var j = S[U] / 2;
                                    z = Math.min(b[U][0] - j, Math.min(b[U + 1][0] - j, z)), W = Math.min(b[U][1] - j, Math.min(b[U + 1][1] - j, W))
                                }
                                var Z = void 0;
                                Z = z > 0 && W > 0 ? 0 : z > -W ? W : W > -z ? -z : (W - z) / 2, R = Z, B = Z;
                                for (var U = 0; U <= y.length - 1; U++) {
                                    var j = S[U];
                                    z = Math.min(b[U][0], b[U + 1][0]), W = Math.min(b[U][1], b[U + 1][1]), R = Math.min(R, Z - j / 2), B = Math.max(B, Z + j / 2), O = Math.max(O, j / 2 - z - Z), E = Math.max(E, j / 2 - W + Z)
                                }
                            }
                            if ("left" === s && O > 0) R += O, B += O;
                            else if ("right" === s && E > 0) R -= E, B -= E;
                            else if ("center" === s) {
                                var Y = (O - E) / 2;
                                R += Y, B += Y
                            }
                            e.rows = this.stringsByFont(f, y), e.hwidth = (B - R) / 2 + h, e.hheight = (p + d * y.length) / 2 + h, e.lineHeight = u, e.lineHeightM = d, e.visible = !0, e.measureComplete(!0), o.borderRadius > 0 && (e.hwidth += .45 * Math.min(o.borderRadius, e.hheight)), e.userPlaced || (e.x = i + (R + B) / 2, e.y = C + e.hheight)
                        } else e.rows = {
                            subLines: [],
                            rowWidths: []
                        }, e.visible = !1;
                        return v
                    }, t.prototype.splitWordsToLines = function (t, e, i, n) {
                        for (var r = 100, s = [], a = [], o = 0, l = e[o], h = i - e.length, u = t[0], c = 0, d = n(0), p = 0, f = 1; f <= t.length - 1; f++) {
                            var g = t[f],
                                m = c + (u.spaceWidth + g.width);
                            l === f || u.spaceWidth > 0 && m > d && h > 0 ? (a.push(f - 1), s.push(c), r = Math.min(r, d / c), c = g.width, p += 1, d = n(p), l !== f ? h -= 1 : (o += 1, l = e[o])) : c = m, u = g
                        }
                        return a.push(t.length), s.push(c), r = Math.min(r, d / c), {
                            prop: r,
                            actualWidthForLines: s,
                            positions: a
                        }
                    }, t.prototype.getFormatedText = function (t, e, i, n, r) {
                        var s, a = e.style,
                            o = a.textStyle,
                            l = H.getTextHeight(t, a.textStyle.font),
                            h = a.lineSpacing || 0,
                            u = l * (h + 1),
                            c = a.margin || 0,
                            d = this.totalPadding(a),
                            p = !a.angle || 0 === a.angle,
                            f = 90 === a.angle || a.angle === -90,
                            g = p || f;
                        if (f) s = n - 2 * c, n = i - c;
                        else {
                            n -= c;
                            var m = r(l / 2 + d, i - 2 * c, n - c);
                            s = m.width
                        }
                        var v = this.getIncludingPart(t, o, e.text, "", s, 0),
                            y = e.text,
                            S = null,
                            b = !1,
                            C = H.getTextWidth(t, e.style.textStyle, "â€¦");
                        if (g)
                            for (var x = Math.floor(n / l) - 2, w = 0; w <= x;) {
                                if (y = y.replace(/\s+$/g, ""), v = this.getIncludingPart(t, o, y, "", s, 0), v === y) {
                                    this.addLine(t, e, v, w, b);
                                    break
                                }
                                if (b = !0, v.length <= 1) {
                                    v = y.slice(0, 1), b = e.text !== v, this.addLine(t, e, v, w, b), S = e.rows.rowWidths[0];
                                    break
                                }
                                if (w === x) v = this.getIncludingPart(t, o, y, "", s - C, 0);
                                else {
                                    var L = v.lastIndexOf(" "),
                                        T = void 0;
                                    if (L === -1) {
                                        T = y.indexOf(" ");
                                        var k = T === -1 ? y : y.substring(0, T);
                                        b = v !== k, b && (v = this.getIncludingPart(t, o, y, "", s - C, 0).replace(/\s+$/g, ""), T = y.indexOf(" "), k = T === -1 ? y : y.substring(0, T)), y = y.substr(v.length), T = y.indexOf(" "), y = T === -1 ? "" : y.substr(T + 1)
                                    } else v = v.substr(0, L), y = y.substr(L + 1), b = !1
                                }
                                if (v.length <= 1) {
                                    if (0 !== w) break;
                                    v = e.text.slice(0, 1)
                                }
                                if (this.addLine(t, e, v, w, b), "" === y) break;
                                y = y.trim(), b = !1, w++
                            } else b = v !== y, b && (v = this.getIncludingPart(t, o, y, "", s - C, 0).replace(/\s+$/g, "")), this.addLine(t, e, v, 0, b);
                        e.rows || this.addLine(t, e, "", 0, !1);
                        var A = (u * e.rows.subLines.length - l * h) / 2,
                            M = 0;
                        if ("left" === a.align || "right" === a.align) {
                            var I = Math.max.apply(Math, e.rows.rowWidths),
                                P = (s - I) / 2;
                            M = "right" === a.align ? P : -P
                        }
                        a.angle && (S = Math.max.apply(Math, e.rows.rowWidths));
                        var D = r(A, S || i, n);
                        e.x = D.x + D.dx * M, e.y = c + D.y, e.hheight = A + d, e.hwidth = Math.max.apply(Math, e.rows.rowWidths) / 2 + d, e.lineHeight = l, e.lineHeightM = u, e.visible = !0, e.measureComplete(!0), a.borderRadius > 0 && (e.hwidth += .45 * Math.min(a.borderRadius, e.hheight))
                    }, t.prototype.addLine = function (t, e, i, n, r) {
                        r && (i = i.replace(/\s+$/g, "") + "â€¦");
                        var s = e.style.textStyle,
                            a = H.getTextWidth(t, s, i);
                        null == e.rows && (e.rows = {
                            rowWidths: [],
                            subLines: []
                        }), e.rows.rowWidths.push(a), e.rows.subLines.push({
                            font: s.font,
                            row: n,
                            text: i,
                            width: a
                        })
                    }, t.prototype.getIncludingPart = function (t, e, i, n, r, s) {
                        if (i.length <= 1) {
                            var a = H.getTextWidth(t, e, i);
                            return s + a <= r && (n += i), n
                        }
                        var o = i.slice(0, i.length / 2),
                            l = H.getTextWidth(t, e, o);
                        if (s + l <= r && (n += o), s + l === r) return n;
                        if (s + l < r) {
                            var h = i.slice(i.length / 2, i.length);
                            return s += l, this.getIncludingPart(t, e, h, n, r, s)
                        }
                        return this.getIncludingPart(t, e, o, n, r, s)
                    }, t
                }();
                j._spaceWidth = {}, r.LabelLayoutBase = j;
                var W = function () {
                    function t(t, e, i, n) {
                        this.labelEnabled = null, this.labelDisabled = null, this.groupId = null, this.hoverCount = 0, this.enabled = !0, this.labelText = t, this.textColorEnabled = e, this.textColorDisabled = i, this.groupId = n
                    }
                    return t.prototype.isHovered = function () {
                        return this.hoverCount > 0
                    }, t.prototype.isEnabled = function () {
                        return this.enabled
                    }, t
                }();
                r.LegendEntry = W;
                var V = function () {
                    function t() {
                        this.enabled = !1, this.width = null, this.height = null, this.minWidth = null, this.minHeight = null, this.numberOfRows = null, this.numberOfColumns = null, this.margin = 1, this.padding = 5, this.maxLineSymbols = 15, this.lineSpacing = .2, this.text = {
                            font: "12px Arial",
                            fillColor: "#000"
                        }, this.marker = new _, this.equalizeRowsColumns = !0, this.panel = new q("left", "fill", 1), this.advanced = new Y, this.interaction = new Z
                    }
                    return t
                }();
                r.SettingsLegend = V;
                var Z = function () {
                    function t() {
                        this.click = !0
                    }
                    return t
                }();
                r.SettingsLegendInteraction = Z;
                var Y = function () {
                    function t() {
                        this.selectedBackground = "rgba(208,233,255,0.3)", this.selectedBorder = "rgba(208,233,255,0.3)"
                    }
                    return t
                }();
                r.SettingsLegendAdvanced = Y;
                var q = function (t) {
                    function e(e, i, n, r, s) {
                        var a = t.call(this, e, i, n, r) || this;
                        return a.padding = 0, void 0 !== s && (a.padding = s), a
                    }
                    return n(e, t), e
                }(r.SettingsChartPanel);
                r.SettingsLegendPanel = q;
                var _ = function () {
                    function t() {
                        this.size = 20, this.alignment = "left", this.lineColor = "#fff"
                    }
                    return t
                }();
                r.SettingsLegendMarker = _;
                var X = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.animationOrder = 300, i.entries = [], i.hoverPointers = {}, i.hoverOrder = [], i.entryWidth = 0, i.textHeight = 0, i.columns = null, i.rows = null, i.contentWidth = 0, i.contentHeight = 0, i.markerSize = 0, i.drawingEntries = 0, i.lastInsensitive = !1, i.needsMeasure = !1, i.chart = e, i.settings = e.settings.legend, i.panel = new M, i.panel.packingOrder = 50, i.panel.location = "outside", i.panel.computeSize = function (t, e, n, r) {
                            return i.computePanelSize(t, e, n, r)
                        }, d.extendDeep(i.panel, i.settings.panel), i.orientation = "left" === i.settings.panel.side || "right" === i.settings.panel.side ? "vertical" : "horizontal", i
                    }
                    return n(e, t), e.prototype.onSceneChange = function (t) {
                        var e = t.changes;
                        e.settings && e.settingsChanges.legend && (e.bounds = !0, d.extendDeep(this.panel, this.settings.panel))
                    }, e.prototype.getPanels = function () {
                        return this.settings.enabled ? [this.panel] : []
                    }, e.prototype.computePanelSize = function (t, e, i, n) {
                        if (this.needsMeasure = !1, !this.settings.enabled || 0 === this.entries.length || !this.chart.assetsLoaded) return {
                            width: 0,
                            height: 0
                        };
                        for (var r = H.getTextWidth(i, this.settings.text, "M") * this.settings.maxLineSymbols, s = 0, a = this.settings.numberOfRows, o = this.settings.numberOfColumns, l = 2 * (this.settings.margin + this.settings.padding), h = 2 * (this.settings.panel.margin + this.settings.panel.padding), u = 0; u < this.entries.length; u++) {
                            var c = this.entries[u],
                                d = {
                                    lineSpacing: this.settings.lineSpacing,
                                    textStyle: this.settings.text,
                                    text: c.labelText,
                                    maxWidth: r,
                                    align: "left",
                                    padding: 0,
                                    aspectRatio: null
                                };
                            c.labelEnabled = new U(d), c.labelEnabled.style.textStyle.fillColor = c.textColorEnabled, c.labelDisabled = new U(d), c.labelDisabled.style.textStyle.fillColor = c.textColorDisabled, n.measure(i, c.labelEnabled), n.measure(i, c.labelDisabled), s = Math.max(s, 2 * c.labelEnabled.hheight, 2 * c.labelDisabled.hheight)
                        }
                        this.textHeight = this.entries[0].labelEnabled.lineHeight, this.markerSize = this.settings.marker.size || this.textHeight, s = Math.max(s, this.markerSize), this.entryHeight = Math.max(s, this.markerSize) + l, this.entryWidth = r + this.markerSize + this.settings.padding + l;
                        var p, f, g = (this.settings.width > 0 ? Math.min(t, Math.max(this.settings.width, this.entryWidth) + h) : t) - h,
                            m = (this.settings.height > 0 ? Math.min(e, Math.max(this.settings.height, this.entryHeight) + h) : e) - h;
                        if ("vertical" === this.orientation) {
                            this.rows = Math.floor(m / this.entryHeight);
                            var v = Math.min(Math.ceil(this.entries.length / this.rows), Math.max(1, Math.floor(g / this.entryWidth)));
                            this.columns = o > 0 ? Math.min(o, v) : v, this.drawingEntries = Math.min(Math.floor(m / this.entryHeight) * this.columns, this.entries.length), f = this.columns * this.entryWidth, this.drawingEntries > this.rows ? (this.settings.equalizeRowsColumns && (this.rows = Math.ceil(this.drawingEntries / this.columns)), p = this.rows * this.entryHeight) : p = this.drawingEntries * this.entryHeight
                        }
                        if ("horizontal" === this.orientation) {
                            this.columns = Math.floor(g / this.entryWidth);
                            var y = Math.min(Math.ceil(this.entries.length / this.columns), Math.max(1, Math.floor(m / this.entryHeight)));
                            this.rows = a > 0 ? Math.min(a, y) : y, this.drawingEntries = Math.min(Math.floor(g / this.entryWidth) * this.rows, this.entries.length), p = this.rows * this.entryHeight, this.drawingEntries > this.columns ? (this.settings.equalizeRowsColumns && (this.columns = Math.ceil(this.drawingEntries / this.rows)), f = this.columns * this.entryWidth) : f = this.drawingEntries * this.entryWidth
                        }
                        if (f <= 0 || p <= 0) return {
                            width: this.settings.minWidth ? this.settings.minWidth : 0,
                            height: this.settings.minHeight ? this.settings.minHeight : 0
                        };
                        this.contentHeight = p, this.contentWidth = f;
                        var S = this.settings.panel.padding;
                        return this.resetHovers(), {
                            width: Math.max(this.settings.minWidth ? this.settings.minWidth : 0, f + 2 * S),
                            height: Math.max(this.settings.minHeight ? this.settings.minHeight : 0, p + 2 * S)
                        }
                    }, e.prototype.paintScene = function (t) {
                        if (!(this.needsMeasure || !this.settings.enabled || this.entries.length < 1 || this.drawingEntries < 1)) {
                            this.lastInsensitive = !1;
                            for (var e = t.context, i = t.labelRenderer, n = this.panel.top, s = this.panel.left, a = this.settings.margin, o = this.settings.padding, l = this.settings.panel.padding, h = 0, u = 0, c = 0; c < this.drawingEntries; c++) {
                                var d = l + a,
                                    p = s + d + h * this.entryWidth,
                                    f = n + d + u * this.entryHeight,
                                    g = this.entries[c],
                                    m = g.isEnabled() ? g.labelEnabled : g.labelDisabled,
                                    v = void 0,
                                    y = void 0;
                                "right" === this.settings.marker.alignment ? (v = p + o + m.hwidth, y = p + this.entryWidth - 2 * (a + o) - this.markerSize / 2) : (v = p + this.markerSize + 2 * o + m.hwidth, y = p + o + this.markerSize / 2);
                                var S = m.hheight > this.markerSize / 2 ? 0 : this.markerSize / 2 - this.textHeight / 2,
                                    b = f + o + this.markerSize / 2,
                                    C = f + S + o + m.hheight;
                                if (this.drawingEntries < this.entries.length && c + 1 === this.drawingEntries) {
                                    this.lastInsensitive = !0, r.Graphics.resetTextStyle(e), e.fillStyle = "#000", e.textAlign = "left", e.font = "bold 12px Arial", e.fillText(". . .", v - m.hwidth, C);
                                    break
                                }
                                if (g.isHovered() && this.rect(e, p, f, this.settings.advanced.selectedBorder, this.settings.advanced.selectedBackground, this.entryWidth - 2 * a, this.entryHeight - 2 * a), i.paint(e, v, C, 1, m), this.paintMarker(t, y, b, this.markerSize / 2, g), "vertical" === this.orientation) {
                                    if (u += 1, u === this.rows && (u = 0, h += 1), h === this.columns) break
                                } else if (h += 1, h === this.columns && (h = 0, u += 1), u === this.rows) break
                            }
                        }
                    }, e.prototype.findItemAt = function (t, e) {
                        if (0 === this.entries.length) return null;
                        var i = this.panel.top + this.settings.panel.padding,
                            n = this.panel.left + this.settings.panel.padding,
                            r = t < n || t > n + this.contentWidth || e < i || e > i + this.contentHeight;
                        if (r) return null;
                        var s, a, o = "vertical" === this.orientation ? Math.abs(this.contentHeight / this.entryHeight) : Math.abs(this.contentWidth / this.entryWidth);
                        "vertical" === this.orientation ? (s = Math.floor((t - n) / this.entryWidth), a = Math.floor((e - i) / this.entryHeight)) : (s = Math.floor((e - i) / this.entryHeight), a = Math.floor((t - n) / this.entryWidth));
                        var l = Math.floor(o * s + a);
                        return l > this.drawingEntries - 1 ? null : this.lastInsensitive && l === this.drawingEntries - 1 ? null : this.entries[l]
                    }, e.prototype.rect = function (t, e, i, n, r, s, a) {
                        t.beginPath(), t.rect(e, i, s, a), t.fillStyle = r, t.fill(), t.lineWidth = 1, t.strokeStyle = n, t.stroke()
                    }, e.prototype.resetEntries = function (t) {
                        this.entries = t, this.needsMeasure = !0
                    }, e.prototype.getLastHoveredEntry = function () {
                        return this.hoverOrder.length < 1 ? null : this.hoverOrder[this.hoverOrder.length - 1].entry
                    }, e.prototype.resetHovers = function () {
                        for (var t = this.hoverOrder.length - 1; t >= 0; t--) {
                            var e = this.hoverOrder[t],
                                i = this.findItemAt(e.lastX, e.lastY);
                            e.entry !== i && (i ? (this.itemUnhovered(null, e.entry), e.entry = i, this.itemHovered(null, i)) : (this.itemUnhovered(null, e.entry), delete this.hoverPointers[e.id], this.hoverOrder.splice(t, 1)))
                        }
                    }, e.prototype.pointerHoverIn = function (t) {
                        var e = this.hoverPointers[t.identifier],
                            i = this.findItemAt(t.x, t.y);
                        return i ? (this.settings.interaction.click && (t.cursor = "pointer"),
                            void(e ? (e.lastX = t.x, e.lastY = t.y, e.entry !== i && (this.itemUnhovered(t, e.entry), e.entry = i, this.hoverOrder.splice(this.hoverOrder.indexOf(e), 1), this.hoverOrder.push(e), this.itemHovered(t, i))) : (e = {
                                id: t.identifier,
                                lastX: t.x,
                                lastY: t.y,
                                entry: i
                            }, this.hoverPointers[t.identifier] = e, this.hoverOrder.push(e), this.itemHovered(t, i)))) : void(e && (this.itemUnhovered(t, e.entry), delete this.hoverPointers[t.identifier], this.hoverOrder.splice(this.hoverOrder.indexOf(e), 1)))
                    }, e.prototype.pointerHoverOut = function (t) {
                        var e = this.hoverPointers[t.identifier];
                        e && (this.itemUnhovered(t, e.entry), delete this.hoverPointers[t.identifier], this.hoverOrder.splice(this.hoverOrder.indexOf(e), 1))
                    }, e.prototype.itemHovered = function (t, e) {
                        e.hoverCount++, 1 === e.hoverCount && this.chart.events.notifySceneChanges({
                            hover: !0
                        })
                    }, e.prototype.itemUnhovered = function (t, e) {
                        e.hoverCount--, 0 === e.hoverCount && this.chart.events.notifySceneChanges({
                            hover: !0
                        })
                    }, e.prototype.itemClicked = function (t, e) {
                        if (this.chart.events.requestPaint(), this.chart.notifyChartUpdate("user", !0), t.consumed = !0, t.preventDefault(), null == e.groupId || !e.enabled) return void(e.enabled = !e.enabled);
                        var i = this.entries.filter(function (t) {
                            return t.groupId === e.groupId
                        });
                        if (i.length < 2) return void(e.enabled = !e.enabled);
                        for (var n = !1, r = !1, s = 0; s < i.length; s++)
                            if (i[s] !== e)
                                if (i[s].enabled) {
                                    if (n = !0, r) break
                                } else if (r = !0, n) break;
                        if (n)
                            if (r) e.enabled = !e.enabled;
                            else
                                for (var s = 0; s < i.length; s++) i[s] !== e && (i[s].enabled = !1);
                        else
                            for (var s = 0; s < i.length; s++) i[s].enabled = !0
                    }, e.prototype.previewPointerMove = function (t) {
                        this.pointerHoverIn(t)
                    }, e.prototype.previewPointerCancel = function (t) {
                        this.pointerHoverOut(t)
                    }, e.prototype.previewPointerOut = function (t) {
                        this.pointerHoverOut(t)
                    }, e.prototype.previewPointerUp = function (t) {
                        t.touch ? this.pointerHoverOut(t) : this.pointerHoverIn(t)
                    }, e.prototype.previewPointerDown = function (t) {
                        this.pointerHoverIn(t), this.settings.interaction.click && this.hoverPointers[t.identifier] && (t.consumed = !0)
                    }, e.prototype.previewInstantClick = function (t) {
                        if (this.settings.interaction.click) {
                            var e = this.findItemAt(t.x, t.y);
                            e && this.itemClicked(t, e)
                        }
                    }, e
                }(k);
                r.Legend = X,
                    function (t) {
                        var e = function () {
                            function t(t, e) {
                                this.chart = t, this.domElement = null, e instanceof K ? this.options = e : (this.options = new K, st.updateRecursive(this.options, e, nt.BaseSettingsToolbarItem, {}))
                            }
                            return t.prototype.onSceneChange = function (t) {}, t.prototype.doAnimations = function (t) {}, t.prototype.previewPointerDown = function (t) {}, t
                        }();
                        t.Item = e;
                        var i = function (t) {
                            function e(e, i, n, r) {
                                void 0 === r && (r = !0);
                                var s = t.call(this, e, i) || this;
                                return s.captureClick = r, s.onClickProxy = function (t) {
                                    return s.onClick(t)
                                }, s.createButton(n), s
                            }
                            return n(e, t), e.prototype.createButton = function (t) {
                                this.domElement = d.createDom("li", null, null, null), this.a = d.createDom("a", null, null, this.domElement), this.p = t ? this.a : d.createDom("p", null, null, this.a), d.listen(this.a, "click", this.onClickProxy), this.updateSettings()
                            }, e.prototype.updateSettings = function () {
                                var t = this.options,
                                    e = t.title || t.label || "",
                                    i = t.image;
                                this.a.title = e;
                                var n = "DVSL-bar-btn " + (t.cssClass ? t.cssClass : i ? "DVSL-bar-btn-image" : "DVSL-bar-btn-none");
                                t.enabled || (n += " DVSL-bar-disabled"), this.a.className = n, this.p.innerHTML = t.showLabel !== !1 && t.label || "", this.p.style.backgroundImage = i ? 'url("' + encodeURI(i) + '")' : null
                            }, e.prototype.remove = function () {
                                d.unlisten(this.a, "click", this.onClickProxy)
                            }, e.prototype.onClick = function (t) {
                                var e = this.options;
                                e.enabled && e.onClick && (e.onClick(t, this.chart.api), this.captureClick && d.stopPropagation(t))
                            }, e
                        }(e);
                        t.Button = i;
                        var r = function (t) {
                            function e(e, i) {
                                return t.call(this, e, i) || this
                            }
                            return n(e, t), e.prototype.createButton = function () {
                                t.prototype.createButton.call(this), d.createDom("span", null, null, this.a), d.addClass(this.a, "DVSL-bar-show-more")
                            }, e.prototype.buildDropdownList = function () {
                                return []
                            }, e.prototype.onHideDropdown = function () {}, e.prototype.onClick = function (e) {
                                this.dropdown ? this.hideDropdown() : this.showDropdown(), t.prototype.onClick.call(this, e), d.stopPropagation(e)
                            }, e.prototype.showDropdown = function () {
                                var t = this.dropdown = d.createDom("div", "DVSL-bar-dropdown", null, this.domElement);
                                t.style.display = "block";
                                for (var e = d.createDom("ul", null, null, t), i = this.buildDropdownList(), n = 0; n < i.length; n++) {
                                    var r = i[n];
                                    e.appendChild(r)
                                }
                                var s = t.getBoundingClientRect();
                                if (s.top < 0) t.style.marginBottom = (0 | s.top) + "px", t.className += " DVSL-no-triangle";
                                else {
                                    var a = Math.max(window.innerHeight - s.bottom, -s.top);
                                    a < 0 && (t.style.marginTop = (0 | a) + "px", t.className += " DVSL-no-triangle")
                                }
                            }, e.prototype.hideDropdown = function () {
                                this.onHideDropdown(), this.dropdown.parentNode.removeChild(this.dropdown), this.dropdown = null, this.chart.shell.forceChromeRedraw()
                            }, e.prototype.previewPointerDown = function (t) {
                                var e = d.isParentOf(this.domElement, t.target);
                                if (this.dropdown && !e) {
                                    var i = d.elementPos(this.chart.shell.interactiveContainer),
                                        n = i.left,
                                        r = i.top;
                                    i = d.elementPos(this.dropdown);
                                    var s = i.left,
                                        a = i.top;
                                    s -= n, a -= r;
                                    var o = s + this.dropdown.offsetWidth,
                                        l = a + this.dropdown.offsetHeight;
                                    (s > t.x || a > t.y || l < t.y || o < t.x) && this.hideDropdown()
                                }
                            }, e
                        }(i);
                        t.DropdownBase = r;
                        var s = function (e) {
                            function i(i, n) {
                                var r = e.call(this, i, n) || this;
                                r.htmlItems = [], r.clickProxy = function () {
                                    r.hideDropdown()
                                };
                                var s = n.dropDownItems;
                                r.items = new Array(s.length);
                                for (var a = 0; a < s.length; a++) r.items[a] = new t.Button(i, s[a], !0, !1);
                                return r
                            }
                            return n(i, e), i.prototype.buildDropdownList = function () {
                                this.htmlItems = new Array(this.items.length);
                                for (var t = 0; t < this.items.length; t++) {
                                    var e = this.items[t];
                                    d.listen(e.domElement, "click", this.clickProxy), this.htmlItems[t] = e.domElement
                                }
                                return this.htmlItems
                            }, i.prototype.onHideDropdown = function () {
                                if (this.htmlItems) {
                                    for (var t = 0; t < this.htmlItems.length; t++) {
                                        var e = this.htmlItems[t];
                                        e.parentNode.removeChild(e), d.unlisten(e, "click", this.clickProxy)
                                    }
                                    this.htmlItems = null
                                }
                            }, i
                        }(r);
                        t.Dropdown = s;
                        var a = function (t) {
                            function e(e, i) {
                                var n = t.call(this, e, i) || this;
                                return n._lastLabel = "", n
                            }
                            return n(e, t), e.prototype.buildDropdownList = function () {
                                for (var t = this, e = [], i = 0, n = this.getItems(); i < n.length; i++) {
                                    var r = n[i],
                                        s = d.createDom("li", null, null, null),
                                        a = d.createDom("a", null, r.name, s);
                                    r.selected && (a.className = "DVSL-bar-dropdown-active"), r.disabled ? a.className = "DVSL-bar-dropdown-disabled" : ! function (e, i) {
                                        return d.listen(e, "click", function () {
                                            return t.userSelected(i)
                                        })
                                    }(a, r), e.push(s)
                                }
                                return e
                            }, e.prototype.userSelected = function (t) {
                                this.hideDropdown(), this.setSelectedItem(t), this.onSelectionChange(t)
                            }, e.prototype.setSelectedItem = function (t) {
                                var e = t.name || "";
                                this.options.showLabel !== !1 && this._lastLabel !== e && (this.p.innerHTML = this._lastLabel = e)
                            }, e
                        }(r);
                        t.Combobox = a;
                        var o = function (t) {
                            function e(e, i, n) {
                                var r = t.call(this, e, i) || this;
                                return r.additionalOptions = n, r.curState = null, r.onSceneChange({}), r
                            }
                            return n(e, t), e.prototype.onSceneChange = function (t) {
                                var e = this.additionalOptions.getChartState();
                                if (e !== this.curState) {
                                    var i = this.options,
                                        n = this.additionalOptions;
                                    this.curState = e, i.cssClass = e && n.cssClassEnabled || n.cssClassDisabled, i.label = e && n.labelEnabled || n.labelDisabled, i.title = e && n.titleEnabled || n.titleDisabled, this.updateSettings()
                                }
                            }, e.prototype.onClick = function (e) {
                                this.options.enabled && (this.curState ? this.additionalOptions.onDisable() : this.additionalOptions.onEnable()), this.onSceneChange(null), t.prototype.onClick.call(this, e), d.stopPropagation(e)
                            }, e
                        }(i);
                        t.ToggleButton = o, t.ToolbarItemNames = {}
                    }(o = r.Bar || (r.Bar = {}));
                var Q = function () {
                    function t(t, e, i, n, r) {
                        void 0 === t && (t = !1), this.enabled = !1, this.location = "inside", this.side = "top", this.align = "right", this.showLabels = !0, this.cssClass = null, this.items = [], this.extraItems = [], this.back = !0, this.export = !0, this.fullscreen = !1, this.exportOptions = null, this.zoomOut = !1, this.enabled = t, void 0 !== e && (this.items = e), void 0 !== i && (this.side = i), void 0 !== n && (this.align = n), void 0 !== r && (this.showLabels = r)
                    }
                    return t
                }();
                r.SettingsToolbar = Q;
                var J = function () {
                    function t() {
                        this.label = null, this.title = null, this.image = null, this.enabled = !0, this.onClick = null, this.cssClass = null
                    }
                    return t
                }();
                r.SettingsToolbarItemBase = J;
                var K = function (t) {
                    function e(e, i, n, r) {
                        var s = t.call(this) || this;
                        return s.location = void 0, s.side = void 0, s.align = void 0, s.showLabel = void 0, s.item = null, s.dropDownItems = null, void 0 !== e && (s.item = e), void 0 !== i && (s.align = i), void 0 !== n && (s.side = n), void 0 !== r && (s.location = r), s
                    }
                    return n(e, t), e
                }(J);
                r.SettingsToolbarItem = K;
                var $ = function (t) {
                    function e(e, i) {
                        var n = t.call(this) || this;
                        return n.panels = {}, n.panelList = [], n.items = [], n.animationOrder = 2e3, n.options = i, n.chart = e, n.scene = n.chart.scene, n.addItems(), n.chart.events.addElement(n), n.chart.events.notifySceneChanges({
                            bounds: !0
                        }), n
                    }
                    return n(e, t), e.prototype.rebuildItems = function () {
                        this.removeItems(), this.addItems()
                    }, e.prototype.addItems = function () {
                        if (this.options.enabled) {
                            for (var t = 0; t < this.options.items.length; t++) {
                                var e = this.options.items[t];
                                this.addItem(e)
                            }
                            for (var t = 0; t < this.options.extraItems.length; t++) {
                                var e = this.options.extraItems[t];
                                this.addItem(e)
                            }
                        }
                    }, e.prototype.removeItems = function () {
                        for (var t = 0; t < this.items.length; t++) {
                            var e = this.items[t];
                            e.remove()
                        }
                        for (var i = 0; i < this.panelList.length; i++) {
                            var n = this.panelList[i];
                            n.clear()
                        }
                        this.items = []
                    }, e.prototype.remove = function () {
                        this.removeItems();
                        for (var t = 0; t < this.panelList.length; t++) {
                            var e = this.panelList[t];
                            e.remove()
                        }
                        this.chart.events.removeElement(this)
                    }, e.prototype.addItem = function (t) {
                        var e, i = this.options;
                        d.isString(t) ? e = new K(t, i.align, i.side, i.location) : (e = d.clone(t), e.align = e.align || this.options.align, e.side = e.side || this.options.side, e.location = e.location || this.options.location);
                        var n, r = e.location + e.side;
                        this.panels.hasOwnProperty(r) ? n = this.panels[r] : (n = new tt(this, e.location, e.side, this.chart), this.panelList.push(n), this.panels[r] = n), null != e.showLabel || !n.hideLabels && i.showLabels || (e.showLabel = !1);
                        var s;
                        if (null != e.item) {
                            var a = e.item;
                            if (this.options[a] === !1) return;
                            if (!o.ToolbarItemNames.hasOwnProperty(a)) return void this.chart.error("Toolbar item name '" + a + "' not recognized.");
                            s = o.ToolbarItemNames[a](this.chart, e)
                        } else s = e.dropDownItems ? new o.Dropdown(this.chart, e) : new o.Button(this.chart, e);
                        n.addItem(s, e.align), this.items.push(s)
                    }, e.prototype.getPanels = function () {
                        return this.panelList
                    }, e.prototype.onSceneChange = function (t) {
                        for (var e = 0; e < this.items.length; e++) {
                            var i = this.items[e];
                            i.onSceneChange(t.changes)
                        }
                    }, e.prototype.doAnimations = function (t) {
                        for (var e = 0; e < this.items.length; e++) {
                            var i = this.items[e];
                            i.doAnimations(t)
                        }
                    }, e.prototype.previewGlobalPointerDown = function (t) {
                        for (var e = 0; e < this.items.length; e++) this.items[e].previewPointerDown(t)
                    }, e
                }(k);
                r.Toolbar = $;
                var tt = function (t) {
                    function e(e, i, n, r) {
                        var s = t.call(this) || this;
                        s.hideLabels = !1, s.chart = r, s.side = n, s.location = i, s.toolbar = e, s.packingOrder = "inside" === i ? 1e3 : 15, s.container = s.toolbar.chart.shell.menuContainer, s.floating = !1, s.align = "fill";
                        var a = e.options.cssClass ? e.options.cssClass + " " : "";
                        return "top" === s.side ? (s.vertical = !1, s.leftPanel = d.createDom("ul", a + "DVSL-bar-left DVSL-bar-top DVSL-bar-horizontal", null, s.container), s.rightPanel = d.createDom("ul", a + "DVSL-bar-right DVSL-bar-top DVSL-bar-horizontal", null, s.container)) : "bottom" === s.side ? (s.vertical = !1, s.leftPanel = d.createDom("ul", a + "DVSL-bar-left DVSL-bar-bottom DVSL-bar-horizontal", null, s.container), s.rightPanel = d.createDom("ul", a + "DVSL-bar-right DVSL-bar-bottom DVSL-bar-horizontal", null, s.container)) : "left" === s.side ? (s.vertical = !0, s.leftPanel = d.createDom("ul", a + "DVSL-bar-left DVSL-bar-top DVSL-bar-vertical", null, s.container), s.rightPanel = d.createDom("ul", a + "DVSL-bar-left DVSL-bar-bottom DVSL-bar-vertical", null, s.container)) : "right" === s.side ? (s.vertical = !0, s.leftPanel = d.createDom("ul", a + "DVSL-bar-right DVSL-bar-top DVSL-bar-vertical", null, s.container), s.rightPanel = d.createDom("ul", a + "DVSL-bar-right DVSL-bar-bottom DVSL-bar-vertical", null, s.container)) : s.chart.error("Unrecognized side: '" + s.side + "'"), s.leftPanel.style.visibility = "hidden", s.rightPanel.style.visibility = "hidden", s
                    }
                    return n(e, t), e.prototype.addItem = function (t, e) {
                        "left" === e || "top" === e ? this.leftPanel.appendChild(t.domElement) : "right" === e || "bottom" === e ? this.rightPanel.appendChild(t.domElement) : this.chart.error("Unrecognized align: '" + e + "'")
                    }, e.prototype.clear = function () {
                        this.leftPanel.innerHTML = "", this.rightPanel.innerHTML = ""
                    }, e.prototype.computeSize = function (t, e, i) {
                        var n = 0;
                        if ("outside" == this.location) {
                            var r = d.getRelativeClientRect(this.leftPanel),
                                s = d.getRelativeClientRect(this.rightPanel);
                            this.leftPanel && r && (n += r.left), this.rightPanel && s && (n += s.right)
                        }
                        if (!this.vertical) {
                            this.hideLabels || (this.contentWidthWithLabels = this.leftPanel.offsetWidth + this.rightPanel.offsetWidth);
                            var a = (t - this.contentWidthWithLabels - n, this.contentWidthWithLabels > 0 && this.contentWidthWithLabels + n > t);
                            a !== this.hideLabels && (this.hideLabels = a, this.toolbar.rebuildItems())
                        }
                        return this.vertical ? {
                            width: Math.max(this.leftPanel.offsetWidth, this.rightPanel.offsetWidth),
                            height: 0
                        } : {
                            width: 0,
                            height: Math.max(this.leftPanel.offsetHeight, this.rightPanel.offsetHeight)
                        }
                    }, e.prototype.placePanel = function (t, e, i, n) {
                        var r = this.leftPanel,
                            s = this.rightPanel,
                            a = r.style,
                            o = s.style,
                            l = "px",
                            h = this.toolbar.scene,
                            u = h.chartHeight,
                            c = h.chartWidth;
                        if (this.vertical) a.top = e + l, o.bottom = u - n + l, "left" === this.side ? (a.left = t + l, o.left = t + l) : (a.right = c - i + l, o.right = c - i + l);
                        else {
                            a.left = t + l, o.right = c - i + l;
                            var d = "top" === this.side;
                            if (d ? (a.top = e + l, o.top = e + l) : (a.bottom = u - n + l, o.bottom = u - n + l), this.hideLabels) {
                                var p = r.offsetLeft + r.offsetWidth;
                                o.marginLeft = p + "px", s.offsetLeft < p && (d ? o.top = e + r.offsetHeight + l : o.bottom = u - n + r.offsetHeight + l)
                            }
                        }
                        r.offsetWidth > 0 && (a.visibility = "visible"), s.offsetWidth > 0 && (o.visibility = "visible")
                    }, e.prototype.remove = function () {
                        this.container.removeChild(this.leftPanel), this.container.removeChild(this.rightPanel)
                    }, e
                }(M);
                r.ToolbarPanel = tt;
                var et = function () {
                    function t() {
                        this.enabled = !0, this.fixedAspect = !1, this.visibilityDistance = 45, this.grabDistance = 10
                    }
                    return t
                }();
                r.SettingsResizer = et;
                var it = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.animationOrder = 2e3, i.paintOrder = 65, i.updateOrder = 300, i.oh = 0, i.sy = 0, i.barVisible = !1, i.resizing = !1, i.aspect = null, i.chart = e, i.scene = i.chart.scene, i.options = i.scene.settings.interaction.resizing, i.resizerBar = r.Helpers.createDom("div", "DVSL-resizer", null, i.chart.shell.interactiveContainer), i
                    }
                    return n(e, t), e.prototype.onSceneChange = function (t) {
                        this.options.enabled || this.hideUI()
                    }, e.prototype.doAnimations = function (t) {
                        t.changes.bounds && this.resizerBar && (this.resizerBar.style.width = this.scene.chartWidth + "px")
                    }, e.prototype.onPointerOut = function (t) {
                        this.options.enabled && this.hideUI()
                    }, e.prototype.onPointerMove = function (t) {
                        if (this.options.enabled) {
                            var e = this.scene.chartHeight - t.y;
                            e < this.options.visibilityDistance ? (this.barVisible || this.showUI(), e < this.options.grabDistance && (t.consumed = !0, t.cursor = "ns-resize")) : this.barVisible && this.hideUI()
                        }
                    }, e.prototype.onPointerDown = function (t) {
                        if (this.options.enabled) {
                            this.sy = t.y;
                            var e = this.scene.chartHeight - t.y;
                            this.resizing = e < this.options.grabDistance && t.y <= this.scene.chartHeight, this.resizing && (this.options.fixedAspect ? this.aspect = Math.max(1, this.chart.scene.chartWidth) / Math.max(1, this.chart.scene.chartHeight) : this.aspect = 0, this.oh = this.scene.chartHeight, this.showUI(), t.cursor = "ns-resize", t.consumed = !0)
                        }
                    }, e.prototype.onDoubleClick = function (t) {
                        this.resizing && this.chart.setFullscreen(!this.chart.isFullscreen())
                    }, e.prototype.onPointerDrag = function (t) {
                        if (this.options.enabled)
                            if (this.chart.isFullscreen()) this.chart.setFullscreen(!1), this.hideUI(), t.consumed = !0;
                            else if (this.resizing) {
                            var e = this.scene.settings.area;
                            t.consumed = !0, this.wasMaximized = !1, e.height = Math.min(e.maxHeight, Math.max(e.minHeight, this.oh + (t.y - this.sy))), this.aspect && (e.width = e.height * this.aspect), this.chart.updateSize(!0)
                        }
                    }, e.prototype.showUI = function () {
                        this.barVisible || (this.barVisible = !0, this.resizerBar.style.display = "block")
                    }, e.prototype.hideUI = function () {
                        this.barVisible && (this.barVisible = !1, this.resizing = !1, this.resizerBar.style.display = "none")
                    }, e
                }(k);
                r.Resizer = it;
                var nt = function () {
                    function t() {}
                    return t
                }();
                nt.BaseIChartErrorEventArguments = {}, nt.BaseIChartEventArguments = {}, nt.BaseIChartSettingsChangeEventArguments = {}, nt.BaseIDataErrorResponse = {
                    error: {
                        t: 0
                    }
                }, nt.BaseIDataObjectBase = {
                    extra: {
                        t: 10
                    }
                }, nt.BaseISettingsClassMap = {}, nt.BaseSettings = {
                    advanced: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsAdvanced
                        },
                        x: function () {
                            return i.Base.SettingsAdvanced
                        }
                    },
                    area: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsArea
                        },
                        x: function () {
                            return i.Base.SettingsArea
                        }
                    },
                    assetsUrlBase: {
                        t: 0
                    },
                    container: {
                        t: 3
                    },
                    credits: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsCredits
                        },
                        x: function () {
                            return i.Base.SettingsCredits
                        }
                    },
                    data: {
                        t: 6,
                        u: 4,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.BaseSettingsData
                            },
                            x: function () {
                                return i.Base.SettingsData
                            }
                        }]
                    },
                    events: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsEvents(nt.BaseIChartEventArguments, nt.BaseIChartEventArguments)
                        },
                        x: function () {
                            return i.Base.SettingsEvents
                        }
                    },
                    interaction: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsInteraction
                        },
                        x: function () {
                            return i.Base.SettingsInteraction
                        }
                    },
                    legend: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsLegend
                        },
                        x: function () {
                            return i.Base.SettingsLegend
                        }
                    },
                    localization: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsLocalization
                        },
                        x: function () {
                            return i.Base.SettingsLocalization
                        }
                    },
                    parentChart: {
                        t: 5
                    },
                    theme: {
                        t: 5,
                        c: function () {
                            return nt.BaseSettings
                        },
                        x: function () {
                            return i.Base.Settings
                        },
                        y: !0
                    },
                    title: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsTitle
                        },
                        x: function () {
                            return i.Base.SettingsTitle
                        }
                    },
                    toolbar: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsToolbar
                        },
                        x: function () {
                            return i.Base.SettingsToolbar
                        }
                    }
                }, nt.BaseSettingsAdvanced = {
                    assets: {
                        t: 6,
                        u: 3,
                        b: [{
                            t: 7,
                            u: 0,
                            b: [{
                                t: 5,
                                u: 0,
                                c: function () {
                                    return {
                                        url: {
                                            t: 0
                                        },
                                        required: {
                                            t: 4
                                        }
                                    }
                                }
                            }, {
                                t: 0
                            }]
                        }]
                    },
                    crossOriginHeader: {
                        t: 7,
                        b: [{
                            t: 0
                        }]
                    },
                    dataExportFunction: {
                        t: 4
                    },
                    exportPdfSize: {
                        t: 12,
                        b: [{
                            t: 1
                        }, {
                            t: 1
                        }]
                    },
                    exportProxyURL: {
                        t: 0,
                        d: 5
                    },
                    highDPI: {
                        t: 7,
                        b: [{
                            t: 9
                        }, {
                            t: 1
                        }]
                    },
                    labelCache: {
                        t: 9
                    },
                    labelCacheRotated: {
                        t: 9
                    },
                    logging: {
                        t: 9
                    },
                    maxCanvasHeight: {
                        t: 1,
                        d: 0
                    },
                    maxCanvasWidth: {
                        t: 1,
                        d: 0
                    },
                    pointer: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsAdvancedPointer
                        },
                        x: function () {
                            return i.Base.SettingsAdvancedPointer
                        }
                    },
                    showFPS: {
                        t: 9
                    },
                    showTimestamp: {
                        t: 9
                    },
                    showTouchTrail: {
                        t: 9
                    },
                    showTouches: {
                        t: 9
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsAdvancedStyle
                        },
                        x: function () {
                            return i.Base.SettingsAdvancedStyle
                        }
                    },
                    themeCSSClass: {
                        t: 0
                    },
                    useAnimationFrame: {
                        t: 9
                    }
                }, nt.BaseSettingsAdvancedPointer = {
                    clickSensitivity: {
                        t: 1
                    },
                    doubleClickSensitivity: {
                        t: 1
                    },
                    doubleClickTimeout: {
                        t: 1,
                        d: 0
                    },
                    longPressSensitivity: {
                        t: 1,
                        d: 0
                    },
                    longPressTimeout: {
                        t: 1,
                        d: 0
                    },
                    mouseWheelRequiresFocus: {
                        t: 9
                    },
                    noClickOnDoubleClick: {
                        t: 9
                    },
                    scrollIntoView: {
                        t: 9
                    },
                    speedAveragingPeriod: {
                        t: 1,
                        d: 0
                    }
                }, nt.BaseSettingsAdvancedStyle = {
                    loadingArcStyle: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                lineColor: {
                                    t: 0
                                },
                                lineWidth: {
                                    t: 1
                                },
                                location: {
                                    t: 0,
                                    d: 6
                                },
                                r: {
                                    t: 1
                                }
                            }
                        }
                    },
                    messageBackgroundStyle: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsAdvancedStyleMessageBackground
                        }
                    },
                    messageTextStyle: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsTextStyle
                        }
                    }
                }, nt.BaseSettingsAdvancedStyleMessageBackground = {
                    padding: {
                        t: 1
                    }
                }, nt.BaseSettingsArea = {
                    height: {
                        t: 1
                    },
                    left: {
                        t: 1
                    },
                    maxHeight: {
                        t: 1
                    },
                    maxWidth: {
                        t: 1
                    },
                    minHeight: {
                        t: 1
                    },
                    minWidth: {
                        t: 1
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsAreaStyle
                        },
                        x: function () {
                            return i.Base.SettingsAreaStyle
                        }
                    },
                    top: {
                        t: 1
                    },
                    width: {
                        t: 1
                    }
                }, nt.BaseSettingsAreaStyle = {
                    fillColor: {
                        t: 0,
                        d: 3
                    },
                    image: {
                        t: 0,
                        d: 4
                    },
                    overlayColor: {
                        t: 0,
                        d: 3
                    }
                }, nt.BaseSettingsBackgroundStyle = {
                    fillColor: {
                        t: 7,
                        b: [{
                            t: 14
                        }, {
                            t: 0
                        }]
                    },
                    shadowBlur: {
                        t: 1
                    },
                    shadowColor: {
                        t: 0
                    },
                    shadowOffsetX: {
                        t: 1
                    },
                    shadowOffsetY: {
                        t: 1
                    }
                }, nt.BaseSettingsChartPanel = {
                    align: {
                        t: 0,
                        d: 6
                    },
                    floating: {
                        t: 9
                    },
                    location: {
                        t: 0,
                        d: 6
                    },
                    margin: {
                        t: 1
                    },
                    side: {
                        t: 0,
                        d: 6
                    }
                }, nt.BaseSettingsCredits = {
                    enabled: {
                        t: 9
                    },
                    enabledOnExport: {
                        t: 9
                    },
                    image: {
                        t: 0,
                        d: 4
                    },
                    imageExport: {
                        t: 0,
                        d: 4
                    },
                    imageScaling: {
                        t: 1
                    },
                    location: {
                        t: 0,
                        d: 6
                    },
                    url: {
                        t: 0,
                        d: 5
                    },
                    urlTarget: {
                        t: 0
                    }
                }, nt.BaseSettingsData = {
                    format: {
                        t: 7,
                        b: [{
                            t: 0
                        }]
                    },
                    id: {
                        t: 0
                    },
                    numberOfParallelRequests: {
                        t: 1,
                        d: 0
                    },
                    postprocessorFunction: {
                        t: 4
                    },
                    preloaded: {
                        t: 5,
                        c: function () {
                            return nt.BaseIDataErrorResponse
                        }
                    },
                    requestTimeout: {
                        t: 1,
                        d: 0
                    },
                    url: {
                        t: 0,
                        d: 5
                    },
                    urlParameters: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return {
                                    name: {
                                        t: 0
                                    },
                                    value: {
                                        t: 0
                                    }
                                }
                            }
                        }]
                    }
                }, nt.BaseSettingsEvents = function (t, e) {
                    return {
                        chartUpdateDelay: {
                            t: 1,
                            d: 0
                        },
                        onChartUpdate: {
                            t: 4
                        },
                        onClick: {
                            t: 4
                        },
                        onDoubleClick: {
                            t: 4
                        },
                        onError: {
                            t: 4
                        },
                        onHoverChange: {
                            t: 4
                        },
                        onPositionChange: {
                            t: 4
                        },
                        onRightClick: {
                            t: 4
                        },
                        onSelectionChange: {
                            t: 4
                        },
                        onSettingsChange: {
                            t: 4
                        },
                        onTripleClick: {
                            t: 4
                        }
                    }
                }, nt.BaseSettingsInteraction = {
                    resizing: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsResizer
                        },
                        x: function () {
                            return i.Base.SettingsResizer
                        }
                    }
                }, nt.BaseSettingsLabelStyle = {
                    align: {
                        t: 7,
                        b: [{
                            t: 0
                        }]
                    },
                    angle: {
                        t: 1,
                        d: 0
                    },
                    aspectRatio: {
                        t: 1
                    },
                    backgroundStyle: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsBackgroundStyle
                        }
                    },
                    borderRadius: {
                        t: 1
                    },
                    extra: {
                        t: 10
                    },
                    image: {
                        t: 0,
                        d: 4
                    },
                    imageSlicing: {
                        t: 12,
                        b: [{
                            t: 1
                        }, {
                            t: 1
                        }, {
                            t: 1
                        }, {
                            t: 1
                        }]
                    },
                    lineSpacing: {
                        t: 1
                    },
                    margin: {
                        t: 1
                    },
                    maxWidth: {
                        t: 1
                    },
                    padding: {
                        t: 1
                    },
                    text: {
                        t: 0
                    },
                    textStyle: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsTextStyle
                        }
                    }
                }, nt.BaseSettingsLegend = {
                    advanced: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsLegendAdvanced
                        },
                        x: function () {
                            return i.Base.SettingsLegendAdvanced
                        }
                    },
                    enabled: {
                        t: 9
                    },
                    equalizeRowsColumns: {
                        t: 9
                    },
                    height: {
                        t: 1
                    },
                    interaction: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsLegendInteraction
                        },
                        x: function () {
                            return i.Base.SettingsLegendInteraction
                        }
                    },
                    lineSpacing: {
                        t: 1
                    },
                    margin: {
                        t: 1
                    },
                    marker: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsLegendMarker
                        },
                        x: function () {
                            return i.Base.SettingsLegendMarker
                        }
                    },
                    maxLineSymbols: {
                        t: 1,
                        d: 0
                    },
                    minHeight: {
                        t: 1
                    },
                    minWidth: {
                        t: 1
                    },
                    numberOfColumns: {
                        t: 1,
                        d: 0
                    },
                    numberOfRows: {
                        t: 1,
                        d: 0
                    },
                    padding: {
                        t: 1
                    },
                    panel: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsLegendPanel
                        },
                        x: function () {
                            return i.Base.SettingsLegendPanel
                        }
                    },
                    text: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsTextStyle
                        }
                    },
                    width: {
                        t: 1
                    }
                }, nt.BaseSettingsLegendAdvanced = {
                    selectedBackground: {
                        t: 0,
                        d: 3
                    },
                    selectedBorder: {
                        t: 0,
                        d: 3
                    }
                }, nt.BaseSettingsLegendInteraction = {
                    click: {
                        t: 9
                    }
                }, nt.BaseSettingsLegendMarker = {
                    alignment: {
                        t: 0,
                        d: 6
                    },
                    lineColor: {
                        t: 0,
                        d: 3
                    },
                    size: {
                        t: 1
                    }
                }, nt.BaseSettingsLegendPanel = {
                    padding: {
                        t: 1
                    }
                }, nt.BaseSettingsLineStyle = {
                    lineColor: {
                        t: 0
                    },
                    lineDash: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 1
                        }]
                    },
                    lineWidth: {
                        t: 1
                    }
                }, nt.BaseSettingsLocalization = {
                    closeButton: {
                        t: 0
                    },
                    dataRequestFailed: {
                        t: 0
                    },
                    exportNotAvailable: {
                        t: 0
                    },
                    loadingLabel: {
                        t: 0
                    },
                    toolbar: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsLocalizationToolbar
                        },
                        x: function () {
                            return i.Base.SettingsLocalizationToolbar
                        }
                    }
                }, nt.BaseSettingsLocalizationToolbar = {
                    backButton: {
                        t: 0
                    },
                    backTitle: {
                        t: 0
                    },
                    exportButton: {
                        t: 0
                    },
                    exportCSV: {
                        t: 0
                    },
                    exportJpeg: {
                        t: 0
                    },
                    exportPDF: {
                        t: 0
                    },
                    exportPNG: {
                        t: 0
                    },
                    exportTitle: {
                        t: 0
                    },
                    exportXLS: {
                        t: 0
                    },
                    fullscreenButton: {
                        t: 0
                    },
                    fullscreenTitle: {
                        t: 0
                    },
                    zoomoutButton: {
                        t: 0
                    },
                    zoomoutTitle: {
                        t: 0
                    }
                }, nt.BaseSettingsResizer = {
                    enabled: {
                        t: 9
                    },
                    fixedAspect: {
                        t: 9
                    },
                    grabDistance: {
                        t: 1
                    },
                    visibilityDistance: {
                        t: 1
                    }
                }, nt.BaseSettingsTextStyle = {
                    fillColor: {
                        t: 0
                    },
                    font: {
                        t: 0
                    },
                    outlineColor: {
                        t: 0
                    },
                    outlineJoin: {
                        t: 0,
                        d: 6
                    },
                    outlineWidth: {
                        t: 1
                    },
                    shadowBlur: {
                        t: 1
                    },
                    shadowColor: {
                        t: 0
                    },
                    shadowOffsetX: {
                        t: 1
                    },
                    shadowOffsetY: {
                        t: 1
                    }
                }, nt.BaseSettingsTitle = {
                    advanced: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                addAfterToolbar: {
                                    t: 9
                                }
                            }
                        }
                    },
                    align: {
                        t: 0,
                        d: 6
                    },
                    enabled: {
                        t: 9
                    },
                    enabledOnExport: {
                        t: 9
                    },
                    margin: {
                        t: 1
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                fillColor: {
                                    t: 0
                                },
                                font: {
                                    t: 0
                                }
                            }
                        }
                    },
                    text: {
                        t: 0
                    }
                }, nt.BaseSettingsToolbar = {
                    align: {
                        t: 0,
                        d: 6
                    },
                    back: {
                        t: 9
                    },
                    cssClass: {
                        t: 0
                    },
                    enabled: {
                        t: 9
                    },
                    export: {
                        t: 9
                    },
                    exportOptions: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 7,
                            b: [{
                                t: 0
                            }]
                        }]
                    },
                    extraItems: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 7,
                            u: 0,
                            b: [{
                                t: 5,
                                u: 0,
                                c: function () {
                                    return nt.BaseSettingsToolbarItem
                                },
                                x: function () {
                                    return i.Base.SettingsToolbarItem
                                }
                            }, {
                                t: 0
                            }]
                        }]
                    },
                    fullscreen: {
                        t: 9
                    },
                    items: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 7,
                            u: 0,
                            b: [{
                                t: 5,
                                u: 0,
                                c: function () {
                                    return nt.BaseSettingsToolbarItem
                                },
                                x: function () {
                                    return i.Base.SettingsToolbarItem
                                }
                            }, {
                                t: 0
                            }]
                        }]
                    },
                    location: {
                        t: 0,
                        d: 6
                    },
                    showLabels: {
                        t: 9
                    },
                    side: {
                        t: 0,
                        d: 6
                    },
                    zoomOut: {
                        t: 9
                    }
                }, nt.BaseSettingsToolbarItem = {
                    align: {
                        t: 0,
                        d: 6
                    },
                    dropDownItems: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.BaseSettingsToolbarItemBase
                            },
                            x: function () {
                                return i.Base.SettingsToolbarItemBase
                            }
                        }]
                    },
                    item: {
                        t: 0,
                        d: 6
                    },
                    location: {
                        t: 0,
                        d: 6
                    },
                    showLabel: {
                        t: 9
                    },
                    side: {
                        t: 0,
                        d: 6
                    }
                }, nt.BaseSettingsToolbarItemBase = {
                    cssClass: {
                        t: 0
                    },
                    enabled: {
                        t: 9
                    },
                    image: {
                        t: 0,
                        d: 4
                    },
                    label: {
                        t: 0
                    },
                    onClick: {
                        t: 4
                    },
                    title: {
                        t: 0
                    }
                }, nt.FacetChartIChartClickEventArguments = {}, nt.FacetChartIChartEventArguments = {}, nt.FacetChartIDataObject = {
                    id: {
                        t: 0
                    },
                    name: {
                        t: 0
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.FacetChartSettingsFacetStyle
                        },
                        x: function () {
                            return i.FacetChart.SettingsFacetStyle
                        }
                    },
                    subvalues: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.FacetChartIDataObject
                            }
                        }]
                    },
                    value: {
                        t: 1
                    }
                }, nt.FacetChartIDataObjectCommon = {
                    id: {
                        t: 0
                    },
                    name: {
                        t: 0
                    },
                    subvalues: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.FacetChartIDataObject
                            }
                        }]
                    }
                }, nt.FacetChartIDataObjectRoot = {
                    afterSum: {
                        t: 1
                    },
                    beforeSum: {
                        t: 1
                    },
                    id: {
                        t: 0
                    },
                    limit: {
                        t: 1
                    },
                    name: {
                        t: 0
                    },
                    offset: {
                        t: 1
                    },
                    subvalues: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.FacetChartIDataObject
                            }
                        }]
                    },
                    sum: {
                        t: 1
                    }
                }, nt.FacetChartSettings = {
                    area: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.FacetChartSettingsArea
                        },
                        x: function () {
                            return i.FacetChart.SettingsArea
                        }
                    },
                    chartTypes: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                columns: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.FacetChartSettingsSeriesColumns
                                    },
                                    x: function () {
                                        return i.FacetChart.SettingsSeriesColumns
                                    },
                                    y: !0
                                },
                                line: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.FacetChartSettingsSeriesLines
                                    },
                                    x: function () {
                                        return i.FacetChart.SettingsSeriesLines
                                    },
                                    y: !0
                                }
                            }
                        }
                    },
                    data: {
                        t: 6,
                        u: 4,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.FacetChartSettingsData
                            },
                            x: function () {
                                return i.FacetChart.SettingsData
                            }
                        }]
                    },
                    events: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsEvents(nt.FacetChartIChartEventArguments, nt.FacetChartIChartClickEventArguments)
                        },
                        x: function () {
                            return i.LinearChart.SettingsEvents
                        }
                    },
                    facetAxis: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.FacetChartSettingsFacetAxis
                        },
                        x: function () {
                            return i.FacetChart.SettingsFacetAxis
                        }
                    },
                    filters: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                allowZeroValues: {
                                    t: 9
                                },
                                sliceFilter: {
                                    t: 4
                                }
                            }
                        }
                    },
                    interaction: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.FacetChartSettingsInteraction
                        },
                        x: function () {
                            return i.FacetChart.SettingsInteraction
                        }
                    },
                    items: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                style: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return {
                                            expandable: {
                                                t: 9
                                            },
                                            label: {
                                                t: 0
                                            }
                                        }
                                    }
                                },
                                styleFunction: {
                                    t: 4
                                }
                            }
                        }
                    },
                    legend: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsLegend
                        },
                        x: function () {
                            return i.LinearChart.SettingsLegend
                        }
                    },
                    navigation: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                initialDrilldown: {
                                    t: 6,
                                    u: 0,
                                    b: [{
                                        t: 0
                                    }]
                                },
                                initialOffset: {
                                    t: 1,
                                    d: 0
                                }
                            }
                        }
                    },
                    scrollButtons: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.FacetChartSettingsScrollButtons
                        },
                        x: function () {
                            return i.FacetChart.SettingsScrollButtons
                        }
                    },
                    series: {
                        t: 6,
                        u: 4,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.FacetChartSettingsSeries
                            },
                            x: function () {
                                return i.FacetChart.SettingsSeries
                            },
                            y: !0
                        }]
                    },
                    seriesDefault: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.FacetChartSettingsSeries
                        },
                        x: function () {
                            return i.FacetChart.SettingsSeries
                        },
                        y: !0
                    },
                    theme: {
                        t: 5,
                        c: function () {
                            return nt.FacetChartSettings
                        },
                        x: function () {
                            return i.FacetChart.Settings
                        },
                        y: !0
                    },
                    toolbar: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.FacetChartSettingsToolbar
                        },
                        x: function () {
                            return i.FacetChart.SettingsToolbar
                        }
                    }
                }, nt.FacetChartSettingsArea = {
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.FacetChartSettingsAreaStyle
                        },
                        x: function () {
                            return i.FacetChart.SettingsAreaStyle
                        }
                    }
                }, nt.FacetChartSettingsAreaStyle = {
                    selection: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.FacetChartSettingsAreaStyleSelection
                        },
                        x: function () {
                            return i.FacetChart.SettingsAreaStyleSelection
                        }
                    }
                }, nt.FacetChartSettingsAreaStyleSelection = {
                    behindSeries: {
                        t: 9
                    },
                    fillColor: {
                        t: 0
                    },
                    lineColor: {
                        t: 0
                    },
                    lineWidth: {
                        t: 1
                    }
                }, nt.FacetChartSettingsData = {
                    dataFunction: {
                        t: 4
                    },
                    preloaded: {
                        t: 5,
                        c: function () {
                            return nt.FacetChartIDataObjectRoot
                        }
                    },
                    sortField: {
                        t: 7,
                        u: 0,
                        b: [{
                            t: 4
                        }, {
                            t: 6,
                            u: 0,
                            b: [{
                                t: 0
                            }]
                        }, {
                            t: 0
                        }]
                    }
                }, nt.FacetChartSettingsFacetAxis = {
                    defaultUnitWidth: {
                        t: 1
                    },
                    enabled: {
                        t: 9
                    },
                    labels: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.FacetChartSettingsFacetAxisLabels
                        }
                    },
                    maxUnitWidth: {
                        t: 1
                    },
                    size: {
                        t: 1
                    },
                    title: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.FacetChartSettingsFacetAxisTitleStyle
                        }
                    },
                    zoomOutUnitWidth: {
                        t: 1
                    }
                }, nt.FacetChartSettingsFacetAxisLabels = {
                    allowOverflow: {
                        t: 9
                    },
                    enabled: {
                        t: 9
                    },
                    interLabelSpacing: {
                        t: 1
                    },
                    text: {
                        t: 0
                    }
                }, nt.FacetChartSettingsFacetAxisTitleStyle = {
                    enabled: {
                        t: 9
                    },
                    text: {
                        t: 0
                    },
                    useFacetName: {
                        t: 9
                    }
                }, nt.FacetChartSettingsFacetStyle = {
                    expandable: {
                        t: 9
                    }
                }, nt.FacetChartSettingsInteraction = {
                    animation: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                scrollDuration: {
                                    t: 1,
                                    d: 0
                                }
                            }
                        }
                    },
                    mode: {
                        t: 7,
                        b: [{
                            t: 0
                        }]
                    },
                    selection: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.FacetChartSettingsInteractionSelection
                        },
                        x: function () {
                            return i.FacetChart.SettingsInteractionSelection
                        }
                    }
                }, nt.FacetChartSettingsInteractionSelection = {
                    enabled: {
                        t: 9
                    },
                    tolerance: {
                        t: 1
                    }
                }, nt.FacetChartSettingsScrollButtons = {
                    enabled: {
                        t: 9
                    },
                    enabledOnExport: {
                        t: 9
                    },
                    size: {
                        t: 1
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                fillColor: {
                                    t: 0
                                },
                                hoverFillColor: {
                                    t: 0
                                },
                                hoverLineColor: {
                                    t: 0
                                },
                                lineColor: {
                                    t: 0
                                }
                            }
                        }
                    }
                }, nt.FacetChartSettingsSeries = {
                    data: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.FacetChartSettingsSeriesData
                        },
                        x: function () {
                            return i.FacetChart.SettingsSeriesData
                        }
                    },
                    type: {
                        t: 0,
                        d: 6
                    }
                }, nt.FacetChartSettingsSeriesColumns = {
                    data: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.FacetChartSettingsSeriesData
                        },
                        x: function () {
                            return i.FacetChart.SettingsSeriesData
                        }
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.FacetChartSettingsSeriesColumnsStyle
                        },
                        x: function () {
                            return i.FacetChart.SettingsSeriesColumnsStyle
                        }
                    }
                }, nt.FacetChartSettingsSeriesColumnsStyle = {
                    previewContents: {
                        t: 9
                    },
                    previewLineColor: {
                        t: 0
                    }
                }, nt.FacetChartSettingsSeriesData = {
                    field: {
                        t: 0
                    },
                    valueFunction: {
                        t: 4
                    }
                }, nt.FacetChartSettingsSeriesLines = {
                    data: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.FacetChartSettingsSeriesData
                        },
                        x: function () {
                            return i.FacetChart.SettingsSeriesData
                        }
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.FacetChartSettingsSeriesLinesStyle
                        },
                        x: function () {
                            return i.FacetChart.SettingsSeriesLinesStyle
                        }
                    }
                }, nt.FacetChartSettingsSeriesLinesStyle = {
                    markerStyleFunction: {
                        t: 4
                    }
                }, nt.FacetChartSettingsToolbar = {
                    enabled: {
                        t: 9
                    },
                    items: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.BaseSettingsToolbarItem
                            },
                            x: function () {
                                return i.Base.SettingsToolbarItem
                            }
                        }]
                    },
                    logScale: {
                        t: 9
                    },
                    zoomOut: {
                        t: 9
                    }
                }, nt.GeoChartIAggregationDataObjectNode = {
                    aggregatedNodes: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.GeoChartIGeoDataObjectNode
                            }
                        }]
                    },
                    aggregatedWeight: {
                        t: 1
                    }
                }, nt.GeoChartIDataObject = {
                    clearCache: {
                        t: 9
                    },
                    east: {
                        t: 1
                    },
                    links: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.GeoChartIGeoDataObjectLink
                            }
                        }]
                    },
                    nodes: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.GeoChartIGeoDataObjectNode
                            }
                        }]
                    },
                    north: {
                        t: 1
                    },
                    south: {
                        t: 1
                    },
                    west: {
                        t: 1
                    }
                }, nt.GeoChartIGeoDataObjectLink = {}, nt.GeoChartIGeoDataObjectNode = {
                    aggregate: {
                        t: 9
                    },
                    coordinates: {
                        t: 7,
                        u: 0,
                        b: [{
                            t: 6,
                            u: 0,
                            b: [{
                                t: 6,
                                u: 0,
                                b: [{
                                    t: 1
                                }]
                            }]
                        }, {
                            t: 12,
                            b: [{
                                t: 1
                            }, {
                                t: 1
                            }]
                        }]
                    },
                    count: {
                        t: 1
                    },
                    shapeFeature: {
                        t: 10
                    },
                    shapeGeometry: {
                        t: 10
                    },
                    type: {
                        t: 0
                    }
                }, nt.GeoChartSettings = {
                    area: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.GeoChartSettingsArea
                        },
                        x: function () {
                            return i.GeoChart.SettingsArea
                        }
                    },
                    background: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.GeoChartSettingsBackground
                        },
                        x: function () {
                            return i.GeoChart.SettingsBackground
                        }
                    },
                    data: {
                        t: 6,
                        u: 4,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.GeoChartSettingsData
                            },
                            x: function () {
                                return i.GeoChart.SettingsData
                            }
                        }]
                    },
                    filters: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                nodeFilter: {
                                    t: 4
                                }
                            }
                        }
                    },
                    interaction: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.GeoChartSettingsInteraction
                        },
                        x: function () {
                            return i.GeoChart.SettingsInteraction
                        }
                    },
                    layerTypes: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                aggregateOnShapes: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.GeoChartSettingsLayerAggregated
                                    },
                                    x: function () {
                                        return i.GeoChart.SettingsLayerAggregated
                                    },
                                    y: !0
                                },
                                charts: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.GeoChartSettingsLayerCharts
                                    },
                                    x: function () {
                                        return i.GeoChart.SettingsLayerCharts
                                    },
                                    y: !0
                                },
                                items: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.GeoChartSettingsLayerItems
                                    },
                                    x: function () {
                                        return i.GeoChart.SettingsLayerItems
                                    },
                                    y: !0
                                },
                                shapes: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.GeoChartSettingsLayerShapes
                                    },
                                    x: function () {
                                        return i.GeoChart.SettingsLayerShapes
                                    },
                                    y: !0
                                }
                            }
                        }
                    },
                    layers: {
                        t: 6,
                        u: 4,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.GeoChartSettingsLayerBase
                            },
                            x: function () {
                                return i.GeoChart.SettingsLayerBase
                            },
                            y: !0
                        }]
                    },
                    layersDefault: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.GeoChartSettingsLayerBase
                        },
                        x: function () {
                            return i.GeoChart.SettingsLayerBase
                        },
                        y: !0
                    },
                    navigation: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                drilldownLayer: {
                                    t: 0
                                },
                                initialDrilldown: {
                                    t: 6,
                                    u: 0,
                                    b: [{
                                        t: 0
                                    }]
                                },
                                initialLat: {
                                    t: 1
                                },
                                initialLng: {
                                    t: 1
                                },
                                initialZoom: {
                                    t: 1
                                },
                                maxBounds: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return {
                                            east: {
                                                t: 1
                                            },
                                            north: {
                                                t: 1
                                            },
                                            south: {
                                                t: 1
                                            },
                                            west: {
                                                t: 1
                                            }
                                        }
                                    }
                                },
                                maxZoom: {
                                    t: 1
                                },
                                minZoom: {
                                    t: 1
                                }
                            }
                        }
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                fadeTime: {
                                    t: 1
                                },
                                selection: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return {
                                            fillColor: {
                                                t: 0
                                            },
                                            sizeConstant: {
                                                t: 1
                                            },
                                            sizeProportional: {
                                                t: 1
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    },
                    theme: {
                        t: 5,
                        c: function () {
                            return nt.GeoChartSettings
                        },
                        x: function () {
                            return i.GeoChart.Settings
                        },
                        y: !0
                    },
                    toolbar: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsToolbar
                        },
                        x: function () {
                            return i.Base.SettingsToolbar
                        }
                    }
                }, nt.GeoChartSettingsAggregatedShapeStyle = {
                    mode: {
                        t: 2,
                        e: function () {
                            return e.GeoChartSettingsAggregatedShapeStyleMode
                        }
                    }
                }, nt.GeoChartSettingsAggregation = {
                    distance: {
                        t: 1,
                        d: 0
                    },
                    enabled: {
                        t: 9
                    },
                    ignoreZeroWeight: {
                        t: 9
                    },
                    maxZoom: {
                        t: 1,
                        d: 0
                    },
                    postProcessAggregatedNodes: {
                        t: 4
                    },
                    weightFunction: {
                        t: 4
                    }
                }, nt.GeoChartSettingsArea = {
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.GeoChartSettingsAreaStyle
                        },
                        x: function () {
                            return i.GeoChart.SettingsAreaStyle
                        }
                    }
                }, nt.GeoChartSettingsAreaStyle = {}, nt.GeoChartSettingsBackground = {
                    enabled: {
                        t: 9
                    },
                    params: {
                        t: 7,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.GeoChartSettingsBackgroundParams
                            }
                        }, {
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.GeoChartSettingsWmsParams
                            }
                        }]
                    },
                    type: {
                        t: 7,
                        b: [{
                            t: 0
                        }]
                    },
                    url: {
                        t: 0
                    }
                }, nt.GeoChartSettingsBackgroundParams = {
                    attribution: {
                        t: 0
                    },
                    continuousWorld: {
                        t: 9
                    },
                    detectRetina: {
                        t: 9
                    },
                    errorTileUrl: {
                        t: 0
                    },
                    maxNativeZoom: {
                        t: 1
                    },
                    maxZoom: {
                        t: 1
                    },
                    minZoom: {
                        t: 1
                    },
                    noWrap: {
                        t: 9
                    },
                    opacity: {
                        t: 1
                    },
                    reuseTiles: {
                        t: 9
                    },
                    subdomains: {
                        t: 7,
                        u: 0,
                        b: [{
                            t: 6,
                            u: 0,
                            b: [{
                                t: 0
                            }]
                        }, {
                            t: 0
                        }]
                    },
                    tileSize: {
                        t: 1
                    },
                    tms: {
                        t: 9
                    },
                    unloadInvisibleTiles: {
                        t: 9
                    },
                    updateWhenIdle: {
                        t: 9
                    },
                    zIndex: {
                        t: 1
                    },
                    zoomOffset: {
                        t: 1
                    },
                    zoomReverse: {
                        t: 9
                    }
                }, nt.GeoChartSettingsData = {
                    aggregationGridSize: {
                        t: 1
                    },
                    aggregationMinCount: {
                        t: 1
                    },
                    bounds: {
                        t: 12,
                        b: [{
                            t: 1
                        }, {
                            t: 1
                        }, {
                            t: 1
                        }, {
                            t: 1
                        }]
                    },
                    dataFunction: {
                        t: 4
                    },
                    maxRequestRect: {
                        t: 12,
                        b: [{
                            t: 1
                        }, {
                            t: 1
                        }]
                    },
                    perBoundsData: {
                        t: 9
                    },
                    perDrilldownData: {
                        t: 9
                    },
                    perZoomData: {
                        t: 9
                    },
                    prefetchRatio: {
                        t: 1
                    },
                    preloaded: {
                        t: 5,
                        c: function () {
                            return nt.GeoChartIDataObject
                        }
                    },
                    useGridBasedAggregation: {
                        t: 9
                    },
                    wrapLng: {
                        t: 9
                    }
                }, nt.GeoChartSettingsInteraction = {
                    mode: {
                        t: 0,
                        d: 6
                    },
                    zooming: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.GeoChartSettingsInteractionZooming
                        },
                        x: function () {
                            return i.GeoChart.SettingsInteractionZooming
                        }
                    }
                }, nt.GeoChartSettingsInteractionZooming = {
                    zoomInOnDoubleClick: {
                        t: 9
                    }
                }, nt.GeoChartSettingsLayerAggregated = {
                    aggregation: {
                        t: 0,
                        d: 6
                    },
                    aggregationField: {
                        t: 0
                    },
                    aggregationFunction: {
                        t: 4
                    },
                    shapesLayer: {
                        t: 0
                    },
                    styleFunction: {
                        t: 4
                    }
                }, nt.GeoChartSettingsLayerBase = {
                    data: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                id: {
                                    t: 0
                                }
                            }
                        }
                    },
                    enabled: {
                        t: 9
                    },
                    id: {
                        t: 0
                    },
                    maxZoom: {
                        t: 1,
                        d: 0
                    },
                    minZoom: {
                        t: 1,
                        d: 0
                    },
                    name: {
                        t: 0
                    },
                    perZoomStyle: {
                        t: 9
                    },
                    type: {
                        t: 0,
                        d: 6
                    }
                }, nt.GeoChartSettingsLayerCharts = {
                    chartType: {
                        t: 0,
                        d: 6
                    },
                    data: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                id: {
                                    t: 0
                                }
                            }
                        }
                    },
                    settings: {
                        t: 7,
                        b: [{
                            t: 5,
                            c: function () {
                                return nt.FacetChartSettings
                            },
                            x: function () {
                                return i.FacetChart.Settings
                            },
                            y: !0
                        }, {
                            t: 5,
                            c: function () {
                                return nt.PieChartSettings
                            },
                            x: function () {
                                return i.PieChart.Settings
                            },
                            y: !0
                        }, {
                            t: 5,
                            c: function () {
                                return nt.TimeChartSettings
                            },
                            x: function () {
                                return i.TimeChart.Settings
                            },
                            y: !0
                        }]
                    },
                    settingsFunction: {
                        t: 4
                    },
                    shapesLayer: {
                        t: 0
                    }
                }, nt.GeoChartSettingsLayerItems = {
                    aggregation: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.GeoChartSettingsAggregation
                        },
                        x: function () {
                            return i.GeoChart.SettingsAggregation
                        }
                    },
                    auras: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsNodesLayerAuras
                        },
                        x: function () {
                            return i.ItemsChart.SettingsNodesLayerAuras
                        }
                    },
                    layout: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.GeoChartSettingsNodesLayout
                        },
                        x: function () {
                            return i.GeoChart.SettingsNodesLayout
                        }
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.GeoChartSettingsNodesLayerStyle
                        },
                        x: function () {
                            return i.GeoChart.SettingsNodesLayerStyle
                        }
                    }
                }, nt.GeoChartSettingsLayerOverlay = {
                    shapesLayer: {
                        t: 0
                    }
                }, nt.GeoChartSettingsLayerShapes = {
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.GeoChartSettingsShapesLayerStyle
                        },
                        x: function () {
                            return i.GeoChart.SettingsShapesLayerStyle
                        }
                    }
                }, nt.GeoChartSettingsNodesLayerStyle = {
                    aggregatedShape: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.GeoChartSettingsAggregatedShapeStyle
                        }
                    }
                }, nt.GeoChartSettingsNodesLayout = {
                    anchorStrength: {
                        t: 1
                    },
                    mode: {
                        t: 0,
                        d: 6
                    },
                    nodeSpacing: {
                        t: 1,
                        d: 0
                    }
                }, nt.GeoChartSettingsShapesLayerNodeStyle = {
                    expandable: {
                        t: 9
                    }
                }, nt.GeoChartSettingsShapesLayerStyle = {
                    node: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.GeoChartSettingsShapesLayerNodeStyle
                        }
                    },
                    shapeSimplificationPrecision: {
                        t: 1
                    }
                }, nt.GeoChartSettingsWmsParams = {
                    format: {
                        t: 0
                    },
                    layers: {
                        t: 0
                    },
                    styles: {
                        t: 0
                    },
                    transparent: {
                        t: 9
                    },
                    version: {
                        t: 0
                    }
                }, nt.ItemsChartIChartClickEventArguments = {}, nt.ItemsChartIChartEventArguments = {}, nt.ItemsChartIDataObjectBase = {}, nt.ItemsChartIDataObjectLink = {
                    className: {
                        t: 0
                    },
                    from: {
                        t: 0
                    },
                    id: {
                        t: 0
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsLinkStyle
                        }
                    },
                    to: {
                        t: 0
                    }
                }, nt.ItemsChartIDataObjectNode = {
                    className: {
                        t: 0
                    },
                    id: {
                        t: 0
                    },
                    loaded: {
                        t: 9
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsNodeStyle
                        }
                    }
                }, nt.ItemsChartSettings = {
                    advanced: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsAdvanced
                        },
                        x: function () {
                            return i.ItemsChart.SettingsAdvanced
                        }
                    },
                    data: {
                        t: 6,
                        u: 4,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.ItemsChartSettingsData
                            },
                            x: function () {
                                return i.ItemsChart.SettingsData
                            }
                        }]
                    },
                    events: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsEvents(nt.ItemsChartIChartEventArguments, nt.ItemsChartIChartClickEventArguments)
                        },
                        x: function () {
                            return i.Base.SettingsEvents
                        }
                    },
                    info: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                enabled: {
                                    t: 9
                                },
                                linkContentsFunction: {
                                    t: 4
                                },
                                nodeContentsFunction: {
                                    t: 4
                                }
                            }
                        }
                    },
                    interaction: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsInteraction
                        },
                        x: function () {
                            return i.ItemsChart.SettingsInteraction
                        }
                    },
                    linkMenu: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsLinkMenu
                        },
                        x: function () {
                            return i.ItemsChart.SettingsLinkMenu
                        }
                    },
                    nodeMenu: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsNodeMenu
                        },
                        x: function () {
                            return i.ItemsChart.SettingsNodeMenu
                        }
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {}
                        }
                    }
                }, nt.ItemsChartSettingsAdvanced = {
                    perNodeLoadingIndicator: {
                        t: 9
                    }
                }, nt.ItemsChartSettingsAuraStyle = {
                    enabled: {
                        t: 9
                    },
                    legendGroupId: {
                        t: 0
                    },
                    nameLegend: {
                        t: 0
                    },
                    showInLegend: {
                        t: 9
                    },
                    zIndex: {
                        t: 1
                    }
                }, nt.ItemsChartSettingsCustomShape = {
                    distanceToEdge: {
                        t: 4
                    },
                    hitTest: {
                        t: 4
                    },
                    onUpdate: {
                        t: 4
                    },
                    paint: {
                        t: 4
                    },
                    paintSelection: {
                        t: 4
                    }
                }, nt.ItemsChartSettingsData = {
                    cacheSize: {
                        t: 1,
                        d: 0
                    },
                    random: {
                        t: 0,
                        d: 6
                    },
                    randomGridLinkProbability: {
                        t: 1
                    },
                    randomLinks: {
                        t: 1,
                        d: 0
                    },
                    randomNodes: {
                        t: 1,
                        d: 0
                    },
                    randomTreeDensity: {
                        t: 1
                    },
                    requestMaxUnits: {
                        t: 1,
                        d: 0
                    }
                }, nt.ItemsChartSettingsInteraction = {
                    nodesMovable: {
                        t: 9
                    },
                    panning: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                enabled: {
                                    t: 9
                                }
                            }
                        }
                    },
                    selection: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsInteractionSelection
                        },
                        x: function () {
                            return i.ItemsChart.SettingsInteractionSelection
                        }
                    },
                    zooming: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsInteractionZooming
                        },
                        x: function () {
                            return i.ItemsChart.SettingsInteractionZooming
                        }
                    }
                }, nt.ItemsChartSettingsInteractionSelection = {
                    allowMoveNodesOffscreen: {
                        t: 9
                    },
                    enabled: {
                        t: 9
                    },
                    linksSelectable: {
                        t: 9
                    },
                    lockNodesOnMove: {
                        t: 9
                    },
                    nodesSelectable: {
                        t: 9
                    },
                    tolerance: {
                        t: 1
                    }
                }, nt.ItemsChartSettingsInteractionZooming = {
                    autoZoomAfterClick: {
                        t: 9
                    },
                    doubleClickZoom: {
                        t: 1
                    },
                    fingers: {
                        t: 9
                    },
                    sensitivity: {
                        t: 1
                    },
                    wheel: {
                        t: 9
                    },
                    zoomInOnDoubleClick: {
                        t: 9
                    }
                }, nt.ItemsChartSettingsItemClass = {
                    className: {
                        t: 0
                    },
                    legendGroupId: {
                        t: 0
                    },
                    nameLegend: {
                        t: 0
                    },
                    showInLegend: {
                        t: 9
                    }
                }, nt.ItemsChartSettingsItemsLayerItemStyle = {
                    hoverEffect: {
                        t: 9
                    },
                    zIndex: {
                        t: 1
                    }
                }, nt.ItemsChartSettingsItemsLayerLabelStyle = {
                    scaleWithSize: {
                        t: 9
                    },
                    scaleWithZoom: {
                        t: 9
                    }
                }, nt.ItemsChartSettingsItemsLayerLinkLabelStyle = {
                    rotateWithLink: {
                        t: 9
                    }
                }, nt.ItemsChartSettingsItemsLayerStyle = {
                    allObjectsStyleFunction: {
                        t: 4
                    },
                    item: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsItemsLayerItemStyle
                        }
                    },
                    link: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsLinkStyle
                        }
                    },
                    linkClasses: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.ItemsChartSettingsLinkClass
                            },
                            x: function () {
                                return i.ItemsChart.SettingsLinkClass
                            }
                        }]
                    },
                    linkDecorationMinSize: {
                        t: 1
                    },
                    linkDecorationScale: {
                        t: 1
                    },
                    linkDetailMinSize: {
                        t: 1
                    },
                    linkDetailMinZoom: {
                        t: 1
                    },
                    linkHovered: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsLinkStyle
                        }
                    },
                    linkLabel: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsItemsLayerLinkLabelStyle
                        }
                    },
                    linkLabelScaleBase: {
                        t: 1
                    },
                    linkRules: {
                        t: 8,
                        u: 0,
                        b: [{
                            t: 4
                        }]
                    },
                    linkSelected: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsLinkStyle
                        }
                    },
                    linkStyleFunction: {
                        t: 4
                    },
                    node: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeAnchor: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsNodeAnchorStyle
                        }
                    },
                    nodeBackground: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeClasses: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.ItemsChartSettingsNodeClass
                            },
                            x: function () {
                                return i.ItemsChart.SettingsNodeClass
                            }
                        }]
                    },
                    nodeDetailMinSize: {
                        t: 1
                    },
                    nodeDetailMinZoom: {
                        t: 1
                    },
                    nodeExpanded: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeFocused: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeHovered: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeLabel: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsItemsLayerLabelStyle
                        }
                    },
                    nodeLabelScaleBase: {
                        t: 1
                    },
                    nodeLocked: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeNotLoaded: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeRules: {
                        t: 8,
                        u: 0,
                        b: [{
                            t: 4
                        }]
                    },
                    nodeSelected: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsNodeStyle
                        }
                    },
                    nodeStyleFunction: {
                        t: 4
                    },
                    removedColor: {
                        t: 0,
                        d: 3
                    },
                    scaleLinksWithZoom: {
                        t: 9
                    },
                    scaleObjectsWithZoom: {
                        t: 9
                    },
                    selection: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                enabled: {
                                    t: 9
                                },
                                fillColor: {
                                    t: 0
                                },
                                lineColor: {
                                    t: 0
                                },
                                lineWidth: {
                                    t: 1
                                },
                                shadowBlur: {
                                    t: 1
                                },
                                shadowColor: {
                                    t: 0
                                },
                                shadowOffsetX: {
                                    t: 1
                                },
                                shadowOffsetY: {
                                    t: 1
                                },
                                sizeConstant: {
                                    t: 1
                                },
                                sizeProportional: {
                                    t: 1
                                }
                            }
                        }
                    }
                }, nt.ItemsChartSettingsLinkClass = {
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsLinkStyle
                        }
                    }
                }, nt.ItemsChartSettingsLinkItem = {
                    lx: {
                        t: 1
                    },
                    ly: {
                        t: 1
                    },
                    px: {
                        t: 1
                    },
                    py: {
                        t: 1
                    },
                    rotateWithLink: {
                        t: 9
                    },
                    x: {
                        t: 1
                    },
                    y: {
                        t: 1
                    }
                }, nt.ItemsChartSettingsLinkMenu = {
                    buttons: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.ItemsChartSettingsMenuButton
                            },
                            x: function () {
                                return i.ItemsChart.SettingsMenuButton
                            }
                        }]
                    },
                    contentsFunction: {
                        t: 4
                    }
                }, nt.ItemsChartSettingsLinkStyle = {
                    cursor: {
                        t: 0
                    },
                    direction: {
                        t: 0
                    },
                    fillColor: {
                        t: 0
                    },
                    fromDecoration: {
                        t: 0,
                        d: 6
                    },
                    invisible: {
                        t: 9
                    },
                    items: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.ItemsChartSettingsLinkItem
                            }
                        }]
                    },
                    label: {
                        t: 0
                    },
                    length: {
                        t: 1
                    },
                    lineDash: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 1
                        }]
                    },
                    lineDashBackgroundFillColor: {
                        t: 0
                    },
                    lineDashShape: {
                        t: 7,
                        b: [{
                            t: 0
                        }]
                    },
                    radius: {
                        t: 1
                    },
                    shadowBlur: {
                        t: 1
                    },
                    shadowColor: {
                        t: 0
                    },
                    shadowOffsetX: {
                        t: 1
                    },
                    shadowOffsetY: {
                        t: 1
                    },
                    strength: {
                        t: 1
                    },
                    toDecoration: {
                        t: 0,
                        d: 6
                    },
                    toPieColor: {
                        t: 0
                    },
                    toPieValue: {
                        t: 1
                    }
                }, nt.ItemsChartSettingsMenu = {
                    buttons: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 7,
                            u: 0,
                            b: [{
                                t: 5,
                                u: 0,
                                c: function () {
                                    return nt.ItemsChartSettingsMenuButton
                                },
                                x: function () {
                                    return i.ItemsChart.SettingsMenuButton
                                }
                            }, {
                                t: 0
                            }]
                        }]
                    },
                    contentsFunction: {
                        t: 4
                    },
                    enabled: {
                        t: 9
                    },
                    showData: {
                        t: 9
                    }
                }, nt.ItemsChartSettingsMenuButton = {
                    className: {
                        t: 0
                    },
                    onClick: {
                        t: 4
                    },
                    onInit: {
                        t: 4
                    },
                    onRefresh: {
                        t: 4
                    },
                    text: {
                        t: 0
                    },
                    title: {
                        t: 0
                    }
                }, nt.ItemsChartSettingsNodeAnchorStyle = {
                    lineColor: {
                        t: 0
                    },
                    lineDash: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 1
                        }]
                    },
                    lineWidth: {
                        t: 1
                    },
                    shadowBlur: {
                        t: 1
                    },
                    shadowColor: {
                        t: 0
                    },
                    shadowOffsetX: {
                        t: 1
                    },
                    shadowOffsetY: {
                        t: 1
                    }
                }, nt.ItemsChartSettingsNodeClass = {
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsNodeStyle
                        }
                    }
                }, nt.ItemsChartSettingsNodeItem = {
                    px: {
                        t: 1
                    },
                    py: {
                        t: 1
                    },
                    x: {
                        t: 1
                    },
                    y: {
                        t: 1
                    }
                }, nt.ItemsChartSettingsNodeMenu = {
                    buttons: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 7,
                            u: 0,
                            b: [{
                                t: 5,
                                u: 0,
                                c: function () {
                                    return nt.ItemsChartSettingsMenuButton
                                },
                                x: function () {
                                    return i.ItemsChart.SettingsMenuButton
                                }
                            }, {
                                t: 0
                            }]
                        }]
                    },
                    contentsFunction: {
                        t: 4
                    }
                }, nt.ItemsChartSettingsNodeStyle = {
                    anchorMode: {
                        t: 2,
                        e: function () {
                            return i.ItemsChart.NodeAnchorMode
                        }
                    },
                    anchorStyle: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsNodeAnchorStyle
                        }
                    },
                    anchorX: {
                        t: 1
                    },
                    anchorY: {
                        t: 1
                    },
                    aspectRatio: {
                        t: 1
                    },
                    aura: {
                        t: 7,
                        u: 0,
                        b: [{
                            t: 6,
                            u: 0,
                            b: [{
                                t: 0
                            }]
                        }, {
                            t: 0
                        }]
                    },
                    coordinates: {
                        t: 7,
                        u: 0,
                        b: [{
                            t: 6,
                            u: 0,
                            b: [{
                                t: 6,
                                u: 0,
                                b: [{
                                    t: 1
                                }]
                            }]
                        }, {
                            t: 6,
                            u: 0,
                            b: [{
                                t: 1
                            }]
                        }]
                    },
                    cursor: {
                        t: 0,
                        d: 7
                    },
                    customShape: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsCustomShape
                        }
                    },
                    display: {
                        t: 0
                    },
                    draggable: {
                        t: 9
                    },
                    fillColor: {
                        t: 0
                    },
                    image: {
                        t: 0
                    },
                    imageCropping: {
                        t: 7,
                        b: [{
                            t: 0
                        }, {
                            t: 9
                        }]
                    },
                    invisible: {
                        t: 9
                    },
                    items: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.ItemsChartSettingsNodeItem
                            }
                        }]
                    },
                    label: {
                        t: 0
                    },
                    labelStyle: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsItemsLayerLabelStyle
                        }
                    },
                    lineColor: {
                        t: 0
                    },
                    lineDash: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 1
                        }]
                    },
                    lineWidth: {
                        t: 1
                    },
                    opacity: {
                        t: 1
                    },
                    radius: {
                        t: 1
                    },
                    shadowBlur: {
                        t: 1
                    },
                    shadowColor: {
                        t: 0
                    },
                    shadowOffsetX: {
                        t: 1
                    },
                    shadowOffsetY: {
                        t: 1
                    }
                }, nt.ItemsChartSettingsNodesLayerAuras = {
                    cellSize: {
                        t: 1
                    },
                    defaultColors: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 0
                        }]
                    },
                    defaultStyle: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsAuraStyle
                        }
                    },
                    drawLimit: {
                        t: 1
                    },
                    enabled: {
                        t: 9
                    },
                    intensity: {
                        t: 1
                    },
                    overlap: {
                        t: 9
                    },
                    style: {
                        t: 8,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.ItemsChartSettingsAuraStyle
                            }
                        }]
                    }
                }, nt.ItemsChartSettingsNodesLayerStyle = {
                    fadeTime: {
                        t: 1,
                        d: 0
                    },
                    hiddenLinks: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                lineColor: {
                                    t: 0
                                },
                                lineWidth: {
                                    t: 1
                                },
                                size: {
                                    t: 1
                                }
                            }
                        }
                    },
                    linkAutoScaling: {
                        t: 0,
                        d: 6
                    },
                    linkLengthAutoScaling: {
                        t: 0,
                        d: 6
                    },
                    linkLengthExtent: {
                        t: 12,
                        b: [{
                            t: 1
                        }, {
                            t: 1
                        }]
                    },
                    linkRadiusExtent: {
                        t: 12,
                        b: [{
                            t: 1
                        }, {
                            t: 1
                        }]
                    },
                    linkStrengthAutoScaling: {
                        t: 0,
                        d: 6
                    },
                    linkStrengthExtent: {
                        t: 12,
                        b: [{
                            t: 1
                        }, {
                            t: 1
                        }]
                    },
                    multilinkSpacing: {
                        t: 1
                    },
                    nodeAutoScaling: {
                        t: 7,
                        b: [{
                            t: 0
                        }]
                    },
                    nodeRadiusExtent: {
                        t: 12,
                        b: [{
                            t: 1,
                            d: 0
                        }, {
                            t: 1,
                            d: 0
                        }]
                    },
                    selfLinkAngle: {
                        t: 1
                    },
                    selfLinkHeightFactor: {
                        t: 1
                    },
                    selfLinkShape: {
                        t: 7,
                        b: [{
                            t: 0
                        }]
                    },
                    selfLinkWidthFactor: {
                        t: 1
                    }
                }, nt.LinearChartSettings = {
                    area: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsArea
                        },
                        x: function () {
                            return i.LinearChart.SettingsArea
                        }
                    },
                    chartTypes: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                candlestick: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.LinearChartSettingsSeriesCandleStick
                                    },
                                    x: function () {
                                        return i.LinearChart.SettingsSeriesCandleStick
                                    },
                                    y: !0
                                },
                                columns: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.LinearChartSettingsSeriesColumns
                                    },
                                    x: function () {
                                        return i.LinearChart.SettingsSeriesColumns
                                    },
                                    y: !0
                                },
                                line: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.LinearChartSettingsSeriesLines
                                    },
                                    x: function () {
                                        return i.LinearChart.SettingsSeriesLines
                                    },
                                    y: !0
                                }
                            }
                        }
                    },
                    events: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsEvents(nt.BaseIChartEventArguments, nt.BaseIChartEventArguments)
                        },
                        x: function () {
                            return i.LinearChart.SettingsEvents
                        }
                    },
                    info: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsInfoPopup
                        },
                        x: function () {
                            return i.LinearChart.SettingsInfoPopup
                        }
                    },
                    interaction: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsInteraction
                        },
                        x: function () {
                            return i.LinearChart.SettingsInteraction
                        }
                    },
                    legend: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsLegend
                        },
                        x: function () {
                            return i.LinearChart.SettingsLegend
                        }
                    },
                    localization: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsLocalization
                        },
                        x: function () {
                            return i.LinearChart.SettingsLocalization
                        }
                    },
                    series: {
                        t: 6,
                        u: 4,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.LinearChartSettingsSeries
                            },
                            x: function () {
                                return i.LinearChart.SettingsSeries
                            },
                            y: !0
                        }]
                    },
                    seriesDefault: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsSeries
                        },
                        x: function () {
                            return i.LinearChart.SettingsSeries
                        },
                        y: !0
                    },
                    stacks: {
                        t: 8,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.LinearChartSettingsStack
                            },
                            x: function () {
                                return i.LinearChart.SettingsStack
                            }
                        }]
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                columnColors: {
                                    t: 6,
                                    u: 0,
                                    b: [{
                                        t: 0
                                    }]
                                },
                                lineColors: {
                                    t: 6,
                                    u: 0,
                                    b: [{
                                        t: 0
                                    }]
                                }
                            }
                        }
                    },
                    valueAxis: {
                        t: 8,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.LinearChartSettingsValueAxis
                            },
                            x: function () {
                                return i.LinearChart.SettingsValueAxis
                            },
                            y: !0
                        }]
                    },
                    valueAxisDefault: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsValueAxis
                        },
                        x: function () {
                            return i.LinearChart.SettingsValueAxis
                        }
                    }
                }, nt.LinearChartSettingsArea = {
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsAreaStyle
                        },
                        x: function () {
                            return i.LinearChart.SettingsAreaStyle
                        }
                    }
                }, nt.LinearChartSettingsAreaStyle = {
                    noData: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                fillColor: {
                                    t: 0
                                },
                                image: {
                                    t: 0,
                                    d: 5
                                }
                            }
                        }
                    },
                    zoomHighlight: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsHighlightStyle
                        }
                    },
                    zoomHighlightInactive: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                fillColor: {
                                    t: 0
                                }
                            }
                        }
                    }
                }, nt.LinearChartSettingsCandleStickMotionStyle = {
                    bar: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                lineColor: {
                                    t: 0
                                },
                                lineDash: {
                                    t: 6,
                                    u: 0,
                                    b: [{
                                        t: 1
                                    }]
                                },
                                lineWidth: {
                                    t: 1
                                },
                                shadowBlur: {
                                    t: 1
                                },
                                shadowColor: {
                                    t: 0
                                },
                                shadowOffsetX: {
                                    t: 1
                                },
                                shadowOffsetY: {
                                    t: 1
                                }
                            }
                        }
                    },
                    candlestick: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                fillColor: {
                                    t: 0
                                },
                                lineColor: {
                                    t: 0,
                                    d: 3
                                },
                                lineDash: {
                                    t: 6,
                                    u: 0,
                                    b: [{
                                        t: 1
                                    }]
                                },
                                lineWidth: {
                                    t: 1
                                },
                                shadowBlur: {
                                    t: 1
                                },
                                shadowColor: {
                                    t: 0
                                },
                                shadowOffsetX: {
                                    t: 1
                                },
                                shadowOffsetY: {
                                    t: 1
                                }
                            }
                        }
                    }
                }, nt.LinearChartSettingsEvents = function (t, e) {
                    return {
                        onAnimationDone: {
                            t: 4
                        }
                    }
                }, nt.LinearChartSettingsHighlightStyle = {
                    fadeIn: {
                        t: 1,
                        d: 0
                    },
                    fadeOut: {
                        t: 1,
                        d: 0
                    },
                    fillColor: {
                        t: 0
                    }
                }, nt.LinearChartSettingsInfoPopup = {
                    advanced: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                contentsFunction: {
                                    t: 4
                                },
                                scope: {
                                    t: 0,
                                    d: 6
                                },
                                showHeader: {
                                    t: 9
                                },
                                showOnlyHoveredSeries: {
                                    t: 9
                                }
                            }
                        }
                    },
                    aggregations: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 0,
                            d: 6
                        }]
                    },
                    enabled: {
                        t: 9
                    },
                    position: {
                        t: 7,
                        b: [{
                            t: 0
                        }]
                    },
                    showNoData: {
                        t: 9
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                highlight: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.LinearChartSettingsHighlightStyle
                                    }
                                }
                            }
                        }
                    },
                    valueFormatterFunction: {
                        t: 4
                    }
                }, nt.LinearChartSettingsInteraction = {
                    ignoreBottomAxis: {
                        t: 9
                    },
                    scrolling: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsInteractionScrolling
                        },
                        x: function () {
                            return i.LinearChart.SettingsInteractionScrolling
                        }
                    },
                    swipeSensitivity: {
                        t: 1
                    },
                    zooming: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsInteractionZooming
                        },
                        x: function () {
                            return i.LinearChart.SettingsInteractionZooming
                        }
                    }
                }, nt.LinearChartSettingsInteractionScrolling = {
                    enabled: {
                        t: 9
                    },
                    kineticFriction: {
                        t: 1
                    },
                    maxAnimationLength: {
                        t: 1,
                        d: 0
                    },
                    swipePageFlipping: {
                        t: 9
                    }
                }, nt.LinearChartSettingsInteractionZooming = {
                    enabled: {
                        t: 9
                    },
                    fingers: {
                        t: 9
                    },
                    fingersMaxZoom: {
                        t: 1
                    },
                    sensitivity: {
                        t: 1
                    },
                    swipe: {
                        t: 9
                    },
                    upDownTreshold: {
                        t: 1
                    },
                    wheel: {
                        t: 9
                    },
                    wheelSensitivity: {
                        t: 1
                    },
                    zoomHighlightThreshold: {
                        t: 1
                    }
                }, nt.LinearChartSettingsLegend = {
                    advanced: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsLegendAdvanced
                        },
                        x: function () {
                            return i.LinearChart.SettingsLegendAdvanced
                        }
                    },
                    marker: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsLegendMarker
                        },
                        x: function () {
                            return i.LinearChart.SettingsLegendMarker
                        }
                    },
                    panel: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsLegendPanel
                        },
                        x: function () {
                            return i.Base.SettingsLegendPanel
                        }
                    }
                }, nt.LinearChartSettingsLegendAdvanced = {
                    disabledSeries: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                fillColor: {
                                    t: 0
                                },
                                lineColor: {
                                    t: 0
                                },
                                textColor: {
                                    t: 0
                                }
                            }
                        }
                    }
                }, nt.LinearChartSettingsLegendMarker = {
                    shape: {
                        t: 7,
                        d: 6,
                        b: [{
                            t: 0
                        }]
                    }
                }, nt.LinearChartSettingsLocalization = {
                    noDataLabel: {
                        t: 0
                    },
                    toolbar: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsLocalizationToolbar
                        },
                        x: function () {
                            return i.LinearChart.SettingsLocalizationToolbar
                        }
                    },
                    unnamedSeries: {
                        t: 0
                    },
                    valueUnits: {
                        t: 8,
                        u: 0,
                        b: [{
                            t: 1,
                            d: 0
                        }]
                    }
                }, nt.LinearChartSettingsLocalizationToolbar = {
                    linButton: {
                        t: 0
                    },
                    linLogTitle: {
                        t: 0
                    },
                    logButton: {
                        t: 0
                    }
                }, nt.LinearChartSettingsSeries = {
                    cluster: {
                        t: 0
                    },
                    data: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsSeriesData
                        },
                        x: function () {
                            return i.LinearChart.SettingsSeriesData
                        }
                    },
                    enabled: {
                        t: 9
                    },
                    extra: {
                        t: 10
                    },
                    id: {
                        t: 0
                    },
                    legendGroupId: {
                        t: 0
                    },
                    name: {
                        t: 0
                    },
                    nameLegend: {
                        t: 0
                    },
                    showInLegend: {
                        t: 9
                    },
                    stack: {
                        t: 0
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsSeriesStyle
                        },
                        x: function () {
                            return i.LinearChart.SettingsSeriesStyle
                        }
                    },
                    type: {
                        t: 0,
                        d: 6
                    },
                    valueAxis: {
                        t: 0
                    }
                }, nt.LinearChartSettingsSeriesCandleStick = {
                    localization: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                close: {
                                    t: 0
                                },
                                high: {
                                    t: 0
                                },
                                low: {
                                    t: 0
                                },
                                open: {
                                    t: 0
                                }
                            }
                        }
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsSeriesCandleStickStyle
                        },
                        x: function () {
                            return i.LinearChart.SettingsSeriesCandleStickStyle
                        }
                    }
                }, nt.LinearChartSettingsSeriesCandleStickStyle = {
                    decrease: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsCandleStickMotionStyle
                        }
                    },
                    increase: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsCandleStickMotionStyle
                        }
                    },
                    padding: {
                        t: 12,
                        b: [{
                            t: 1,
                            d: 0
                        }, {
                            t: 1,
                            d: 0
                        }]
                    },
                    pattern: {
                        t: 0,
                        d: 6
                    }
                }, nt.LinearChartSettingsSeriesColumns = {
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsSeriesColumnsStyle
                        },
                        x: function () {
                            return i.LinearChart.SettingsSeriesColumnsStyle
                        }
                    },
                    valueLabels: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsValueLabels
                        }
                    }
                }, nt.LinearChartSettingsSeriesColumnsStyle = {
                    depth: {
                        t: 1
                    },
                    depthBrightness: {
                        t: 1
                    },
                    fillGradientMode: {
                        t: 7,
                        b: [{
                            t: 0
                        }]
                    },
                    fillGradientType: {
                        t: 0
                    },
                    gradient: {
                        t: 1
                    },
                    lineColor: {
                        t: 0,
                        d: 3
                    },
                    minHeight: {
                        t: 1,
                        d: 0
                    },
                    padding: {
                        t: 12,
                        b: [{
                            t: 1,
                            d: 0
                        }, {
                            t: 1,
                            d: 0
                        }]
                    },
                    radius: {
                        t: 12,
                        b: [{
                            t: 1,
                            d: 0
                        }, {
                            t: 1,
                            d: 0
                        }, {
                            t: 1,
                            d: 0
                        }, {
                            t: 1,
                            d: 0
                        }]
                    },
                    shadowBlur: {
                        t: 1,
                        d: 0
                    }
                }, nt.LinearChartSettingsSeriesData = {
                    aggregatedValueFunction: {
                        t: 4
                    },
                    aggregation: {
                        t: 0,
                        d: 6
                    },
                    noDataPolicy: {
                        t: 0,
                        d: 6
                    },
                    source: {
                        t: 0
                    },
                    valueFunction: {
                        t: 4
                    }
                }, nt.LinearChartSettingsSeriesLines = {
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsSeriesLinesStyle
                        },
                        x: function () {
                            return i.LinearChart.SettingsSeriesLinesStyle
                        }
                    },
                    valueLabels: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsValueLabels
                        }
                    }
                }, nt.LinearChartSettingsSeriesLinesStyle = {
                    marker: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.LinearChartSettingsSeriesStyleMarker
                        }
                    },
                    markerStyleFunction: {
                        t: 4
                    },
                    shadowBlur: {
                        t: 1,
                        d: 0
                    },
                    smoothing: {
                        t: 9
                    },
                    steps: {
                        t: 9
                    }
                }, nt.LinearChartSettingsSeriesStyle = {
                    depth: {
                        t: 1
                    },
                    fillColor: {
                        t: 0,
                        d: 3
                    },
                    fillGradient: {
                        t: 11
                    },
                    fillPattern: {
                        t: 0
                    },
                    legend: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                marker: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.LinearChartSettingsSeriesStyleMarker
                                    }
                                },
                                textColor: {
                                    t: 0,
                                    d: 3
                                }
                            }
                        }
                    },
                    lineColor: {
                        t: 0
                    },
                    lineDash: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 1
                        }]
                    },
                    lineWidth: {
                        t: 1
                    },
                    shadowColor: {
                        t: 0,
                        d: 3
                    },
                    shadowOffsetX: {
                        t: 1,
                        d: 0
                    },
                    shadowOffsetY: {
                        t: 1,
                        d: 0
                    }
                }, nt.LinearChartSettingsSeriesStyleMarker = {
                    fillColor: {
                        t: 0,
                        d: 3
                    },
                    lineColor: {
                        t: 0,
                        d: 3
                    },
                    lineWidth: {
                        t: 1
                    },
                    shape: {
                        t: 7,
                        d: 6,
                        b: [{
                            t: 0
                        }]
                    },
                    width: {
                        t: 1,
                        d: 0
                    }
                }, nt.LinearChartSettingsStack = {
                    name: {
                        t: 0
                    },
                    separateNegativeValues: {
                        t: 9
                    },
                    type: {
                        t: 0,
                        d: 6
                    }
                }, nt.LinearChartSettingsValueAxis = {
                    animate: {
                        t: 0,
                        d: 6
                    },
                    axisLine: {
                        t: 9
                    },
                    enabled: {
                        t: 9
                    },
                    hgrid: {
                        t: 9
                    },
                    initialAnimationValue: {
                        t: 1
                    },
                    initialAnimationValueMultiplier: {
                        t: 1
                    },
                    logScale: {
                        t: 9
                    },
                    maxValue: {
                        t: 1
                    },
                    minValue: {
                        t: 1
                    },
                    position: {
                        t: 0,
                        d: 6
                    },
                    scaleAdjustmentAnimation: {
                        t: 0,
                        d: 6
                    },
                    scaleAdjustmentAnimationDelay: {
                        t: 1,
                        d: 0
                    },
                    scaleAdjustmentTolerance: {
                        t: 1
                    },
                    scaleMinStep: {
                        t: 1
                    },
                    scaleStep: {
                        t: 1
                    },
                    side: {
                        t: 7,
                        b: [{
                            t: 0
                        }]
                    },
                    size: {
                        t: 1,
                        d: 0
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                axisLine: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.BaseSettingsLineStyle
                                    }
                                },
                                baseLine: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.LinearChartSettingsValueAxisBaseLineStyle
                                    }
                                },
                                hgrid: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.BaseSettingsLineStyle
                                    }
                                },
                                labelSpacing: {
                                    t: 1
                                },
                                tick: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.BaseSettingsLineStyle
                                    }
                                },
                                title: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.LinearChartSettingsValueAxisTitleStyle
                                    }
                                },
                                valueLabel: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.BaseSettingsLabelStyle
                                    }
                                }
                            }
                        }
                    },
                    thresholds: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.LinearChartSettingsValueAxisThreshold
                            },
                            x: function () {
                                return i.LinearChart.SettingsValueAxisThreshold
                            }
                        }]
                    },
                    title: {
                        t: 0
                    },
                    valueFormat: {
                        t: 0
                    },
                    valueFormatterFunction: {
                        t: 4
                    },
                    zeroLine: {
                        t: 0,
                        d: 6
                    }
                }, nt.LinearChartSettingsValueAxisBaseLineStyle = {
                    depthColor: {
                        t: 0,
                        d: 3
                    },
                    lineDepth: {
                        t: 1,
                        d: 0
                    },
                    showLabel: {
                        t: 2,
                        e: function () {
                            return e.LinearChartSettingsValueAxisBaseLineLabelMode
                        }
                    }
                }, nt.LinearChartSettingsValueAxisThreshold = {
                    from: {
                        t: 1
                    },
                    position: {
                        t: 0,
                        d: 6
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                fillColor: {
                                    t: 0,
                                    d: 3
                                },
                                lineColor: {
                                    t: 0,
                                    d: 3
                                },
                                lineDash: {
                                    t: 6,
                                    u: 0,
                                    b: [{
                                        t: 1
                                    }]
                                },
                                lineWidth: {
                                    t: 1
                                }
                            }
                        }
                    },
                    to: {
                        t: 1
                    }
                }, nt.LinearChartSettingsValueAxisTitleStyle = {
                    reverseDirection: {
                        t: 9
                    }
                }, nt.LinearChartSettingsValueLabels = {
                    contentsFunction: {
                        t: 4
                    },
                    enabled: {
                        t: 9
                    },
                    minFontSize: {
                        t: 1
                    },
                    position: {
                        t: 0,
                        d: 6
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsLabelStyle
                        }
                    },
                    useStackedValue: {
                        t: 9
                    }
                }, nt.NetChartBarSettingsLocalizationToolbar = {
                    fitButton: {
                        t: 0
                    },
                    fitTitle: {
                        t: 0
                    },
                    freezeButton: {
                        t: 0
                    },
                    freezeTitle: {
                        t: 0
                    },
                    rearrangeButton: {
                        t: 0
                    },
                    rearrangeTitle: {
                        t: 0
                    },
                    unfreezeTitle: {
                        t: 0
                    }
                }, nt.NetChartBarSettingsToolbar = {
                    zoomControl: {
                        t: 9
                    }
                }, nt.NetChartGravitySettings = {
                    from: {
                        t: 7,
                        d: 6,
                        b: [{
                            t: 0
                        }]
                    },
                    fromCenter: {
                        t: 7,
                        d: 6,
                        b: [{
                            t: 0
                        }]
                    },
                    strength: {
                        t: 1
                    },
                    to: {
                        t: 7,
                        d: 6,
                        b: [{
                            t: 0
                        }]
                    },
                    toCenter: {
                        t: 7,
                        d: 6,
                        b: [{
                            t: 0
                        }]
                    }
                }, nt.NetChartIChartClickEventArguments = {}, nt.NetChartIChartEventArguments = {}, nt.NetChartIDataObject = {
                    links: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.NetChartIDataObjectLink
                            }
                        }]
                    },
                    nodes: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.NetChartIDataObjectNode
                            }
                        }]
                    }
                }, nt.NetChartIDataObjectLink = {}, nt.NetChartIDataObjectNode = {
                    locked: {
                        t: 9
                    },
                    x: {
                        t: 1
                    },
                    y: {
                        t: 1
                    }
                }, nt.NetChartSettings = {
                    area: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.NetChartSettingsArea
                        },
                        x: function () {
                            return i.NetChart.SettingsArea
                        }
                    },
                    auras: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.ItemsChartSettingsNodesLayerAuras
                        },
                        x: function () {
                            return i.ItemsChart.SettingsNodesLayerAuras
                        }
                    },
                    data: {
                        t: 6,
                        u: 4,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.NetChartSettingsData
                            },
                            x: function () {
                                return i.NetChart.SettingsData
                            }
                        }]
                    },
                    events: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.NetChartSettingsEvents
                        },
                        x: function () {
                            return i.NetChart.SettingsEvents
                        }
                    },
                    filters: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                linkFilter: {
                                    t: 4
                                },
                                multilinkProcessor: {
                                    t: 4
                                },
                                nodeFilter: {
                                    t: 4
                                },
                                nodeLinksProcessor: {
                                    t: 4
                                }
                            }
                        }
                    },
                    interaction: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.NetChartSettingsInteraction
                        },
                        x: function () {
                            return i.NetChart.SettingsInteraction
                        }
                    },
                    layout: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.NetChartSettingsLayout
                        },
                        x: function () {
                            return i.NetChart.SettingsLayout
                        }
                    },
                    legend: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.NetChartSettingsLegend
                        },
                        x: function () {
                            return i.NetChart.SettingsLegend
                        }
                    },
                    localization: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.NetChartSettingsLocalization
                        },
                        x: function () {
                            return i.NetChart.SettingsLocalization
                        }
                    },
                    navigation: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.NetChartSettingsNavigation
                        },
                        x: function () {
                            return i.NetChart.SettingsNavigation
                        }
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.NetChartSettingsStyle
                        },
                        x: function () {
                            return i.NetChart.SettingsStyle
                        }
                    },
                    theme: {
                        t: 5,
                        c: function () {
                            return nt.NetChartSettings
                        },
                        x: function () {
                            return i.NetChart.Settings
                        },
                        y: !0
                    },
                    toolbar: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.NetChartBarSettingsToolbar
                        },
                        x: function () {
                            return i.NetChart.Bar.SettingsToolbar
                        }
                    }
                }, nt.NetChartSettingsArea = {
                    centerX: {
                        t: 1
                    },
                    centerY: {
                        t: 1
                    },
                    paddingBottom: {
                        t: 1
                    },
                    paddingLeft: {
                        t: 1
                    },
                    paddingRight: {
                        t: 1
                    },
                    paddingTop: {
                        t: 1
                    }
                }, nt.NetChartSettingsData = {
                    dataFunction: {
                        t: 4
                    },
                    preloaded: {
                        t: 5,
                        c: function () {
                            return nt.NetChartIDataObject
                        }
                    }
                }, nt.NetChartSettingsEvents = {
                    onDataUpdated: {
                        t: 4
                    },
                    onPointerDown: {
                        t: 4
                    },
                    onPointerDrag: {
                        t: 4
                    },
                    onPointerMove: {
                        t: 4
                    },
                    onPointerUp: {
                        t: 4
                    }
                }, nt.NetChartSettingsInteraction = {
                    rotation: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                fingers: {
                                    t: 9
                                }
                            }
                        }
                    },
                    selection: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.NetChartSettingsInteractionSelection
                        },
                        x: function () {
                            return i.NetChart.SettingsInteractionSelection
                        }
                    },
                    zooming: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.NetChartSettingsInteractionZooming
                        },
                        x: function () {
                            return i.NetChart.SettingsInteractionZooming
                        }
                    }
                }, nt.NetChartSettingsInteractionSelection = {
                    dragSelect: {
                        t: 9
                    }
                }, nt.NetChartSettingsInteractionZooming = {
                    autoZoomExtent: {
                        t: 12,
                        b: [{
                            t: 1
                        }, {
                            t: 1
                        }]
                    },
                    autoZoomPositionElasticity: {
                        t: 1
                    },
                    autoZoomSize: {
                        t: 1
                    },
                    initialAutoZoom: {
                        t: 7,
                        b: [{
                            t: 9
                        }, {
                            t: 0
                        }]
                    },
                    zoomExtent: {
                        t: 12,
                        b: [{
                            t: 1
                        }, {
                            t: 1
                        }]
                    }
                }, nt.NetChartSettingsLayout = {
                    advanced: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                adaptiveFreezeTreshold: {
                                    t: 1
                                }
                            }
                        }
                    },
                    aspectRatio: {
                        t: 9
                    },
                    globalLayoutOnChanges: {
                        t: 9
                    },
                    gravity: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.NetChartGravitySettings
                        },
                        x: function () {
                            return i.NetChart.GravitySettings
                        }
                    },
                    groupSpacing: {
                        t: 1,
                        d: 0
                    },
                    incrementalLayoutMaxTime: {
                        t: 1,
                        d: 0
                    },
                    initialLayoutMaxTime: {
                        t: 1,
                        d: 0
                    },
                    layoutFreezeMinTimeout: {
                        t: 1,
                        d: 0
                    },
                    layoutFreezeTimeout: {
                        t: 1,
                        d: 0
                    },
                    mode: {
                        t: 7,
                        d: 6,
                        b: [{
                            t: 0
                        }]
                    },
                    nodeSpacing: {
                        t: 1,
                        d: 0
                    },
                    rotation: {
                        t: 1
                    },
                    rowSpacing: {
                        t: 1,
                        d: 0
                    },
                    twoRingRadialLayout: {
                        t: 9
                    }
                }, nt.NetChartSettingsLegend = {
                    advanced: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.NetChartSettingsLegendAdvanced
                        },
                        x: function () {
                            return i.NetChart.SettingsLegendAdvanced
                        }
                    },
                    panel: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsLegendPanel
                        },
                        x: function () {
                            return i.Base.SettingsLegendPanel
                        }
                    }
                }, nt.NetChartSettingsLegendAdvanced = {
                    showItemsWithClasses: {
                        t: 7,
                        d: 6,
                        b: [{
                            t: 0
                        }]
                    },
                    textColorDisabled: {
                        t: 0
                    }
                }, nt.NetChartSettingsLocalization = {
                    menu: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                close: {
                                    t: 0
                                },
                                collapse: {
                                    t: 0
                                },
                                dynamic: {
                                    t: 0
                                },
                                expand: {
                                    t: 0
                                },
                                fixed: {
                                    t: 0
                                },
                                focus: {
                                    t: 0
                                },
                                hide: {
                                    t: 0
                                },
                                unfocus: {
                                    t: 0
                                },
                                add: {
                                    t: 0
                                }
                            }
                        }
                    },
                    toolbar: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.NetChartBarSettingsLocalizationToolbar
                        },
                        x: function () {
                            return i.NetChart.Bar.SettingsLocalizationToolbar
                        }
                    }
                }, nt.NetChartSettingsNavigation = {
                    autoUnfocus: {
                        t: 9
                    },
                    autoZoomOnFocus: {
                        t: 9
                    },
                    expandDelay: {
                        t: 1,
                        d: 0
                    },
                    expandOnClick: {
                        t: 9
                    },
                    focusAutoFadeout: {
                        t: 9
                    },
                    focusNodeExpansionRadius: {
                        t: 1
                    },
                    focusNodeTailExpansionRadius: {
                        t: 1
                    },
                    initialNodes: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 0
                        }]
                    },
                    minNumberOfFocusNodes: {
                        t: 1,
                        d: 0
                    },
                    mode: {
                        t: 7,
                        d: 6,
                        b: [{
                            t: 0
                        }]
                    },
                    numberOfFocusNodes: {
                        t: 1,
                        d: 0
                    }
                }, nt.NetChartSettingsStyle = {
                    dragSelection: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsBackgroundStyle
                        }
                    }
                }, nt.PieChartIChartClickEventArguments = {}, nt.PieChartIChartEventArguments = {}, nt.PieChartIDataObject = {
                    id: {
                        t: 0
                    },
                    name: {
                        t: 0
                    },
                    nameLegend: {
                        t: 0
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.PieChartSettingsSliceStyle
                        }
                    },
                    subvalues: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.PieChartIDataObject
                            }
                        }]
                    },
                    value: {
                        t: 1
                    }
                }, nt.PieChartIDataObjectCommon = {
                    id: {
                        t: 0
                    },
                    name: {
                        t: 0
                    },
                    subvalues: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.PieChartIDataObject
                            }
                        }]
                    }
                }, nt.PieChartIDataObjectRoot = {
                    afterSum: {
                        t: 1
                    },
                    beforeSum: {
                        t: 1
                    },
                    id: {
                        t: 0
                    },
                    limit: {
                        t: 1
                    },
                    name: {
                        t: 0
                    },
                    offset: {
                        t: 1
                    },
                    subvalues: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.PieChartIDataObject
                            }
                        }]
                    },
                    sum: {
                        t: 1
                    }
                }, nt.PieChartSettings = {
                    advanced: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.PieChartSettingsAdvanced
                        },
                        x: function () {
                            return i.PieChart.SettingsAdvanced
                        }
                    },
                    data: {
                        t: 6,
                        u: 4,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.PieChartSettingsData
                            },
                            x: function () {
                                return i.PieChart.SettingsData
                            }
                        }]
                    },
                    events: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.PieChartSettingsEvents
                        },
                        x: function () {
                            return i.PieChart.SettingsEvents
                        }
                    },
                    filters: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                allowZeroValues: {
                                    t: 9
                                },
                                sliceFilter: {
                                    t: 4
                                }
                            }
                        }
                    },
                    icons: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                autohideWhenTooSmall: {
                                    t: 9
                                },
                                placement: {
                                    t: 0,
                                    d: 6
                                },
                                sizeExtent: {
                                    t: 12,
                                    b: [{
                                        t: 1
                                    }, {
                                        t: 1
                                    }]
                                }
                            }
                        }
                    },
                    info: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                contentsFunction: {
                                    t: 4
                                },
                                enabled: {
                                    t: 9
                                }
                            }
                        }
                    },
                    interaction: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.PieChartSettingsInteraction
                        },
                        x: function () {
                            return i.PieChart.SettingsInteraction
                        }
                    },
                    labels: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.PieChartSettingsLabels
                        },
                        x: function () {
                            return i.PieChart.SettingsLabels
                        }
                    },
                    legend: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.PieChartSettingsLegend
                        },
                        x: function () {
                            return i.PieChart.SettingsLegend
                        }
                    },
                    localization: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.PieChartSettingsLocalization
                        },
                        x: function () {
                            return i.PieChart.SettingsLocalization
                        }
                    },
                    navigation: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                initialDrilldown: {
                                    t: 6,
                                    u: 0,
                                    b: [{
                                        t: 0
                                    }]
                                },
                                initialOffset: {
                                    t: 1,
                                    d: 0
                                }
                            }
                        }
                    },
                    pie: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                adaptiveRadius: {
                                    t: 9
                                },
                                backgroundHoveredStyle: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.PieChartSettingsPieStyle
                                    }
                                },
                                backgroundStyle: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.PieChartSettingsPieStyle
                                    }
                                },
                                centerMargin: {
                                    t: 1,
                                    d: 0
                                },
                                depth: {
                                    t: 1,
                                    d: 0
                                },
                                endAngle: {
                                    t: 1
                                },
                                innerRadius: {
                                    t: 1
                                },
                                innerRadiusWhenDrilldown: {
                                    t: 1
                                },
                                margin: {
                                    t: 1
                                },
                                noDataStyle: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.PieChartSettingsPieStyle
                                    }
                                },
                                outerMargin: {
                                    t: 1
                                },
                                radius: {
                                    t: 1
                                },
                                rotationSpeed: {
                                    t: 1
                                },
                                showInnerPies: {
                                    t: 9
                                },
                                showInnerPiesExport: {
                                    t: 9
                                },
                                startAngle: {
                                    t: 1
                                },
                                style: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.PieChartSettingsPieStyle
                                    }
                                },
                                styleFunction: {
                                    t: 4
                                },
                                theme: {
                                    t: 0,
                                    d: 6
                                },
                                x: {
                                    t: 1
                                },
                                y: {
                                    t: 1
                                }
                            }
                        }
                    },
                    slice: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                backgroundActiveStyle: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return {
                                            brightness: {
                                                t: 1
                                            }
                                        }
                                    }
                                },
                                backgroundStyle: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return {
                                            fillColor: {
                                                t: 0
                                            },
                                            fillColor2: {
                                                t: 0,
                                                d: 3
                                            }
                                        }
                                    }
                                },
                                connectorStyle: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.BaseSettingsLineStyle
                                    }
                                },
                                expandableMarkStyle: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return {
                                            distance: {
                                                t: 1
                                            },
                                            lineColor: {
                                                t: 0
                                            },
                                            lineDash: {
                                                t: 6,
                                                u: 0,
                                                b: [{
                                                    t: 1
                                                }]
                                            },
                                            lineWidth: {
                                                t: 1
                                            }
                                        }
                                    }
                                },
                                hoverStyle: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.PieChartSettingsSliceStyle
                                    }
                                },
                                margin: {
                                    t: 1
                                },
                                minFraction: {
                                    t: 1
                                },
                                othersStyle: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return {
                                            fillColor: {
                                                t: 0
                                            },
                                            lineDecoration: {
                                                t: 0,
                                                d: 6
                                            }
                                        }
                                    }
                                },
                                previousStyle: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return {
                                            fillColor: {
                                                t: 0
                                            },
                                            lineDecoration: {
                                                t: 0,
                                                d: 6
                                            }
                                        }
                                    }
                                },
                                selectedStyle: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.PieChartSettingsSliceStyle
                                    }
                                },
                                style: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.PieChartSettingsSliceStyle
                                    }
                                },
                                styleFunction: {
                                    t: 4
                                }
                            }
                        }
                    },
                    theme: {
                        t: 5,
                        c: function () {
                            return nt.PieChartSettings
                        },
                        x: function () {
                            return i.PieChart.Settings
                        },
                        y: !0
                    },
                    toolbar: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsToolbar
                        },
                        x: function () {
                            return i.Base.SettingsToolbar
                        }
                    }
                }, nt.PieChartSettingsAdvanced = {
                    backAlwaysVisible: {
                        t: 9
                    },
                    backImage: {
                        t: 0,
                        d: 4
                    },
                    backImageBackground: {
                        t: 0
                    },
                    iconMinSize: {
                        t: 1
                    },
                    initialAnimation: {
                        t: 9
                    },
                    labelInsideTreshold: {
                        t: 1,
                        d: 0
                    },
                    renderQuality: {
                        t: 1,
                        d: 0
                    }
                }, nt.PieChartSettingsData = {
                    autoCategories: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 7,
                            b: [{
                                t: 4
                            }, {
                                t: 0
                            }]
                        }]
                    },
                    dataFunction: {
                        t: 4
                    },
                    itemsToLoad: {
                        t: 1,
                        d: 0
                    },
                    partialLoad: {
                        t: 9
                    },
                    preloaded: {
                        t: 5,
                        c: function () {
                            return nt.PieChartIDataObjectRoot
                        }
                    },
                    sortField: {
                        t: 7,
                        u: 0,
                        b: [{
                            t: 4
                        }, {
                            t: 6,
                            u: 0,
                            b: [{
                                t: 0
                            }]
                        }, {
                            t: 0
                        }]
                    }
                }, nt.PieChartSettingsEvents = {
                    onPieChange: {
                        t: 4
                    },
                    onPieReadyStateChanged: {
                        t: 4
                    }
                }, nt.PieChartSettingsInteraction = {
                    animation: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                hoverDuration: {
                                    t: 1,
                                    d: 0
                                },
                                scrollDuration: {
                                    t: 1,
                                    d: 0
                                }
                            }
                        }
                    },
                    coverCenter: {
                        t: 9
                    },
                    mode: {
                        t: 0,
                        d: 6
                    },
                    others: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                centerGoesToPrevious: {
                                    t: 9
                                },
                                enabled: {
                                    t: 9
                                },
                                maxOthersFraction: {
                                    t: 1
                                },
                                maxSlicesVisible: {
                                    t: 1,
                                    d: 0
                                },
                                minSliceFraction: {
                                    t: 1
                                },
                                minSlices: {
                                    t: 1
                                },
                                navigationFraction: {
                                    t: 1
                                }
                            }
                        }
                    },
                    scrolling: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                enabled: {
                                    t: 9
                                }
                            }
                        }
                    },
                    selection: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                enabled: {
                                    t: 9
                                },
                                maxSwipeDistance: {
                                    t: 1
                                },
                                partialSwipe: {
                                    t: 9
                                },
                                swipe: {
                                    t: 9
                                },
                                swipeSensitivity: {
                                    t: 1
                                },
                                tolerance: {
                                    t: 1
                                }
                            }
                        }
                    }
                }, nt.PieChartSettingsLabels = {
                    angle: {
                        t: 1,
                        d: 0
                    },
                    connectorLength: {
                        t: 1,
                        d: 0
                    },
                    connectors: {
                        t: 9
                    },
                    enabled: {
                        t: 9
                    },
                    insideLabel: {
                        t: 0,
                        d: 6
                    },
                    insideLabelVisibilityFraction: {
                        t: 1
                    },
                    interLabelSpacing: {
                        t: 1
                    },
                    placement: {
                        t: 0,
                        d: 6
                    }
                }, nt.PieChartSettingsLegend = {
                    marker: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.PieChartSettingsLegendMarker
                        },
                        x: function () {
                            return i.PieChart.SettingsLegendMarker
                        }
                    },
                    showOthers: {
                        t: 9
                    }
                }, nt.PieChartSettingsLegendMarker = {
                    shape: {
                        t: 7,
                        d: 6,
                        b: [{
                            t: 0
                        }]
                    }
                }, nt.PieChartSettingsLocalization = {
                    othersLabel: {
                        t: 0
                    },
                    previousLabel: {
                        t: 0
                    }
                }, nt.PieChartSettingsPieStyle = {
                    background: {
                        t: 9
                    },
                    brightness: {
                        t: 1
                    },
                    colorDistribution: {
                        t: 0,
                        d: 6
                    },
                    fillColor: {
                        t: 0,
                        d: 3
                    },
                    sliceColors: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 0,
                            d: 3
                        }]
                    }
                }, nt.PieChartSettingsSliceStyle = {
                    brightness: {
                        t: 1
                    },
                    cutoutDistance: {
                        t: 1
                    },
                    expandable: {
                        t: 9
                    },
                    fillColor: {
                        t: 0,
                        d: 3
                    },
                    icon: {
                        t: 0,
                        d: 4
                    },
                    insideLabel: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsLabelStyle
                        }
                    },
                    label: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsLabelStyle
                        }
                    },
                    lineBrightness: {
                        t: 1,
                        d: 0
                    },
                    lineColor: {
                        t: 0,
                        d: 3
                    },
                    lineDash: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 1
                        }]
                    },
                    lineWidth: {
                        t: 1,
                        d: 0
                    },
                    url: {
                        t: 0,
                        d: 5
                    }
                }, nt.TimeChartIChartEventArguments = {}, nt.TimeChartIDataObject = {
                    data: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 6,
                            u: 0,
                            b: [{
                                t: 7,
                                b: [{
                                    t: 1
                                }, {
                                    t: 0
                                }]
                            }]
                        }]
                    },
                    dataLimitFrom: {
                        t: 7,
                        b: [{
                            t: 1
                        }, {
                            t: 0
                        }]
                    },
                    dataLimitTo: {
                        t: 7,
                        b: [{
                            t: 1
                        }, {
                            t: 0
                        }]
                    },
                    from: {
                        t: 7,
                        b: [{
                            t: 1
                        }, {
                            t: 0
                        }]
                    },
                    timeZone: {
                        t: 0
                    },
                    to: {
                        t: 7,
                        b: [{
                            t: 1
                        }, {
                            t: 0
                        }]
                    },
                    unit: {
                        t: 0
                    },
                    values: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 7,
                            u: 0,
                            b: [{
                                t: 18
                            }, {
                                t: 17
                            }, {
                                t: 16
                            }, {
                                t: 15
                            }, {
                                t: 6,
                                u: 0,
                                b: [{
                                    t: 7,
                                    b: [{
                                        t: 1
                                    }, {
                                        t: 0
                                    }]
                                }]
                            }]
                        }]
                    }
                }, nt.TimeChartSettings = {
                    advanced: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.TimeChartSettingsAdvanced
                        },
                        x: function () {
                            return i.TimeChart.SettingsAdvanced
                        }
                    },
                    area: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.TimeChartSettingsArea
                        },
                        x: function () {
                            return i.TimeChart.SettingsArea
                        }
                    },
                    chartTypes: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                candlestick: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.TimeChartSettingsSeriesCandleStick
                                    },
                                    x: function () {
                                        return i.TimeChart.SettingsSeriesCandleStick
                                    },
                                    y: !0
                                },
                                columns: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.TimeChartSettingsSeriesColumns
                                    },
                                    x: function () {
                                        return i.TimeChart.SettingsSeriesColumns
                                    },
                                    y: !0
                                },
                                line: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.TimeChartSettingsSeriesLines
                                    },
                                    x: function () {
                                        return i.TimeChart.SettingsSeriesLines
                                    },
                                    y: !0
                                }
                            }
                        }
                    },
                    currentTime: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.TimeChartSettingsCurrentTime
                        },
                        x: function () {
                            return i.TimeChart.SettingsCurrentTime
                        }
                    },
                    data: {
                        t: 6,
                        u: 4,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.TimeChartSettingsData
                            },
                            x: function () {
                                return i.TimeChart.SettingsData
                            }
                        }]
                    },
                    events: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.TimeChartSettingsEvents
                        },
                        x: function () {
                            return i.TimeChart.SettingsEvents
                        }
                    },
                    interaction: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.TimeChartSettingsInteraction
                        },
                        x: function () {
                            return i.TimeChart.SettingsInteraction
                        }
                    },
                    localization: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.TimeChartSettingsLocalization
                        },
                        x: function () {
                            return i.TimeChart.SettingsLocalization
                        }
                    },
                    milestones: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.TimeChartSettingsMarker
                            },
                            x: function () {
                                return i.TimeChart.SettingsMarker
                            }
                        }]
                    },
                    navigation: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                followAnchor: {
                                    t: 9
                                },
                                initialDisplayAnchor: {
                                    t: 7,
                                    b: [{
                                        t: 0
                                    }, {
                                        t: 1
                                    }]
                                },
                                initialDisplayPeriod: {
                                    t: 0
                                },
                                initialDisplayUnit: {
                                    t: 0
                                }
                            }
                        }
                    },
                    series: {
                        t: 6,
                        u: 4,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.TimeChartSettingsSeries
                            },
                            x: function () {
                                return i.TimeChart.SettingsSeries
                            },
                            y: !0
                        }]
                    },
                    seriesDefault: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.TimeChartSettingsSeries
                        },
                        x: function () {
                            return i.TimeChart.SettingsSeries
                        },
                        y: !0
                    },
                    theme: {
                        t: 5,
                        c: function () {
                            return nt.TimeChartSettings
                        },
                        x: function () {
                            return i.TimeChart.Settings
                        },
                        y: !0
                    },
                    timeAxis: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.TimeChartSettingsTimeAxis
                        },
                        x: function () {
                            return i.TimeChart.SettingsTimeAxis
                        }
                    },
                    toolbar: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.TimeChartSettingsToolbar
                        },
                        x: function () {
                            return i.TimeChart.SettingsToolbar
                        }
                    }
                }, nt.TimeChartSettingsAdvanced = {
                    dataUpdateInterval: {
                        t: 1,
                        d: 0
                    },
                    maxUnitsToDisplay: {
                        t: 1
                    },
                    timeUpdateInterval: {
                        t: 1,
                        d: 0
                    }
                }, nt.TimeChartSettingsArea = {
                    displayPeriods: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return {
                                    unit: {
                                        t: 0
                                    }
                                }
                            }
                        }]
                    },
                    displayUnits: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return {
                                    unit: {
                                        t: 0
                                    },
                                    name: {
                                        t: 0
                                    }
                                }
                            }
                        }]
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.TimeChartSettingsAreaStyle
                        },
                        x: function () {
                            return i.TimeChart.SettingsAreaStyle
                        }
                    }
                }, nt.TimeChartSettingsAreaDisplayPeriod = {
                    displayAnchor: {
                        t: 7,
                        b: [{
                            t: 0
                        }, {
                            t: 1
                        }]
                    },
                    displayPeriod: {
                        t: 0
                    },
                    displayUnit: {
                        t: 0
                    },
                    name: {
                        t: 0
                    }
                }, nt.TimeChartSettingsAreaStyle = {
                    markerText: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsTextStyle
                        }
                    },
                    selection: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.TimeChartSettingsAreaStyleSelection
                        },
                        x: function () {
                            return i.TimeChart.SettingsAreaStyleSelection
                        }
                    },
                    selectionLabel: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsTextStyle
                        }
                    }
                }, nt.TimeChartSettingsAreaStyleSelection = {
                    behindSeries: {
                        t: 9
                    },
                    fillColor: {
                        t: 0
                    },
                    lineColor: {
                        t: 0
                    },
                    lineWidth: {
                        t: 1
                    }
                }, nt.TimeChartSettingsCurrentTime = {
                    align: {
                        t: 7,
                        b: [{
                            t: 0
                        }]
                    },
                    label: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsLabelStyle
                        }
                    },
                    showTime: {
                        t: 9
                    },
                    side: {
                        t: 7,
                        b: [{
                            t: 0
                        }]
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsLineStyle
                        }
                    }
                }, nt.TimeChartSettingsData = {
                    cacheSize: {
                        t: 1,
                        d: 0
                    },
                    dataFunction: {
                        t: 4
                    },
                    minimizeRequests: {
                        t: 9
                    },
                    prefetchRatio: {
                        t: 1
                    },
                    preloaded: {
                        t: 5,
                        c: function () {
                            return nt.TimeChartIDataObject
                        }
                    },
                    requestMaxUnits: {
                        t: 1,
                        d: 0
                    },
                    stringTimestampFormat: {
                        t: 7,
                        u: 0,
                        b: [{
                            t: 6,
                            u: 0,
                            b: [{
                                t: 0
                            }]
                        }, {
                            t: 0
                        }]
                    },
                    suppressWarnings: {
                        t: 9
                    },
                    timeZoneOffset: {
                        t: 7,
                        b: [{
                            t: 1
                        }, {
                            t: 0
                        }]
                    },
                    timestampInSeconds: {
                        t: 9
                    },
                    units: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 0
                        }]
                    },
                    url: {
                        t: 0,
                        d: 5
                    },
                    urlByUnit: {
                        t: 8,
                        u: 0,
                        b: [{
                            t: 0
                        }]
                    },
                    useSmallerUnitCache: {
                        t: 9
                    }
                }, nt.TimeChartSettingsEvents = {
                    onTimeChange: {
                        t: 4
                    },
                    selectionChangeDuringInteraction: {
                        t: 9
                    }
                }, nt.TimeChartSettingsInteraction = {
                    scrolling: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.TimeChartSettingsInteractionScrolling
                        },
                        x: function () {
                            return i.TimeChart.SettingsInteractionScrolling
                        }
                    },
                    selection: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.TimeChartSettingsInteractionSelection
                        },
                        x: function () {
                            return i.TimeChart.SettingsInteractionSelection
                        }
                    },
                    snapMode: {
                        t: 0,
                        d: 6
                    },
                    zooming: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.TimeChartSettingsInteractionZooming
                        },
                        x: function () {
                            return i.TimeChart.SettingsInteractionZooming
                        }
                    }
                }, nt.TimeChartSettingsInteractionScrolling = {
                    limitFrom: {
                        t: 7,
                        b: [{
                            t: 0
                        }, {
                            t: 1
                        }]
                    },
                    limitMode: {
                        t: 0,
                        d: 6
                    },
                    limitTo: {
                        t: 7,
                        b: [{
                            t: 0
                        }, {
                            t: 1
                        }]
                    },
                    overscrollProportion: {
                        t: 1
                    }
                }, nt.TimeChartSettingsInteractionSelection = {
                    clearOnRightClick: {
                        t: 9
                    },
                    enabled: {
                        t: 9
                    },
                    moveByDragging: {
                        t: 9
                    },
                    resizeSensitivity: {
                        t: 1
                    },
                    resizeTolerance: {
                        t: 1
                    },
                    tolerance: {
                        t: 1
                    }
                }, nt.TimeChartSettingsInteractionZooming = {
                    click: {
                        t: 9
                    },
                    enabled: {
                        t: 9
                    }
                }, nt.TimeChartSettingsLocalization = {
                    calendar: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.TimeChartSettingsLocalizationCalendar
                        }
                    },
                    determiningDataBounds: {
                        t: 0
                    },
                    holidayWeekdays: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 1,
                            d: 0
                        }]
                    },
                    infoDates: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                fullTimeFormats: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.TimeChartSettingsLocalizationTimeUnits
                                    }
                                },
                                majorTimeFormats: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.TimeChartSettingsLocalizationTimeUnits
                                    }
                                },
                                minorTimeFormats: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.TimeChartSettingsLocalizationTimeUnits
                                    }
                                }
                            }
                        }
                    },
                    loadingLabel: {
                        t: 0
                    },
                    markerDates: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                timeFormats: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.TimeChartSettingsLocalizationTimeUnits
                                    }
                                }
                            }
                        }
                    },
                    timeAxisDates: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                majorLabelFullTimeFormats: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.TimeChartSettingsLocalizationTimeUnits
                                    }
                                },
                                majorLabelTimeFormats: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.TimeChartSettingsLocalizationTimeUnits
                                    }
                                },
                                minorLabelTimeFormats: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.TimeChartSettingsLocalizationTimeUnits
                                    }
                                }
                            }
                        }
                    },
                    timeUnitsNames: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.TimeChartSettingsLocalizationTimeUnits
                        }
                    },
                    timeUnitsNamesPlural: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.TimeChartSettingsLocalizationTimeUnits
                        }
                    },
                    toolbar: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.TimeChartSettingsLocalizationToolbar
                        },
                        x: function () {
                            return i.TimeChart.SettingsLocalizationToolbar
                        }
                    }
                }, nt.TimeChartSettingsLocalizationCalendar = {
                    months: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 0
                        }]
                    },
                    monthsShort: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 0
                        }]
                    },
                    parentLocale: {
                        t: 0
                    },
                    week: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                dow: {
                                    t: 1,
                                    d: 0
                                },
                                doy: {
                                    t: 1
                                }
                            }
                        }
                    },
                    weekdays: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 0
                        }]
                    },
                    weekdaysMin: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 0
                        }]
                    },
                    weekdaysShort: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 0
                        }]
                    }
                }, nt.TimeChartSettingsLocalizationTimeUnits = {
                    M: {
                        t: 0
                    },
                    d: {
                        t: 0
                    },
                    h: {
                        t: 0
                    },
                    m: {
                        t: 0
                    },
                    ms: {
                        t: 0
                    },
                    s: {
                        t: 0
                    },
                    w: {
                        t: 0
                    },
                    y: {
                        t: 0
                    }
                };
                nt.TimeChartSettingsLocalizationToolbar = {
                    customPeriod: {
                        t: 0
                    },
                    periodDropdownTitle: {
                        t: 0
                    },
                    unavailableUnitTitle: {
                        t: 0
                    },
                    unitDropdownTitle: {
                        t: 0
                    },
                    zoomoutButton: {
                        t: 0
                    },
                    zoomoutTitle: {
                        t: 0
                    }
                };
                nt.TimeChartSettingsMarker = {
                    align: {
                        t: 7,
                        b: [{
                            t: 0
                        }]
                    },
                    enabled: {
                        t: 9
                    },
                    label: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsLabelStyle
                        }
                    },
                    overrideLimits: {
                        t: 9
                    },
                    showTime: {
                        t: 9
                    },
                    side: {
                        t: 7,
                        b: [{
                            t: 0
                        }]
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.BaseSettingsLineStyle
                        }
                    },
                    time: {
                        t: 1,
                        d: 0
                    }
                }, nt.TimeChartSettingsSeries = {
                    data: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.TimeChartSettingsSeriesData
                        },
                        x: function () {
                            return i.TimeChart.SettingsSeriesData
                        }
                    }
                }, nt.TimeChartSettingsSeriesCandleStick = {
                    data: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.TimeChartSettingsSeriesCandleStickData
                        },
                        x: function () {
                            return i.TimeChart.SettingsSeriesCandleStickData
                        }
                    }
                }, nt.TimeChartSettingsSeriesCandleStickData = {
                    close: {
                        t: 1
                    },
                    high: {
                        t: 1
                    },
                    low: {
                        t: 1
                    },
                    open: {
                        t: 1
                    }
                }, nt.TimeChartSettingsSeriesColumns = {
                    data: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.TimeChartSettingsSeriesData
                        },
                        x: function () {
                            return i.TimeChart.SettingsSeriesData
                        }
                    }
                }, nt.TimeChartSettingsSeriesData = {
                    countIndex: {
                        t: 1
                    },
                    index: {
                        t: 1,
                        d: 0
                    }
                }, nt.TimeChartSettingsSeriesLines = {
                    data: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.TimeChartSettingsSeriesData
                        },
                        x: function () {
                            return i.TimeChart.SettingsSeriesData
                        }
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return nt.TimeChartSettingsSeriesLinesStyle
                        },
                        x: function () {
                            return i.TimeChart.SettingsSeriesLinesStyle
                        }
                    }
                }, nt.TimeChartSettingsSeriesLinesStyle = {
                    markerStyleFunction: {
                        t: 4
                    }
                }, nt.TimeChartSettingsTimeAxis = {
                    enabled: {
                        t: 9
                    },
                    maxUnitWidth: {
                        t: 1
                    },
                    minUnitWidth: {
                        t: 1
                    },
                    miniTimeRuler: {
                        t: 9
                    },
                    showHolidays: {
                        t: 9
                    },
                    style: {
                        t: 5,
                        u: 0,
                        c: function () {
                            return {
                                dateHolidays: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.BaseSettingsBackgroundStyle
                                    }
                                },
                                dateLighten: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return {
                                            fillColor: {
                                                t: 0
                                            }
                                        }
                                    }
                                },
                                majorTimeBalloonStyle: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.BaseSettingsBackgroundStyle
                                    }
                                },
                                majorTimeLabel: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.BaseSettingsTextStyle
                                    }
                                },
                                minorTimeBalloonStyle: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.BaseSettingsBackgroundStyle
                                    }
                                },
                                minorTimeLabel: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.BaseSettingsTextStyle
                                    }
                                },
                                minorTimeRuler: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.BaseSettingsLineStyle
                                    }
                                },
                                showMajorTimeBalloons: {
                                    t: 9
                                },
                                showMinorTimeBalloons: {
                                    t: 9
                                },
                                vgrid: {
                                    t: 5,
                                    u: 0,
                                    c: function () {
                                        return nt.BaseSettingsLineStyle
                                    }
                                }
                            }
                        }
                    },
                    timeZone: {
                        t: 0
                    },
                    timeZoneOffset: {
                        t: 7,
                        b: [{
                            t: 1
                        }, {
                            t: 0
                        }]
                    },
                    unitSizePolicy: {
                        t: 0,
                        d: 6
                    },
                    vgrid: {
                        t: 9
                    }
                }, nt.TimeChartSettingsToolbar = {
                    displayPeriod: {
                        t: 9
                    },
                    displayUnit: {
                        t: 9
                    },
                    enabled: {
                        t: 9
                    },
                    items: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 7,
                            u: 0,
                            b: [{
                                t: 5,
                                u: 0,
                                c: function () {
                                    return nt.BaseSettingsToolbarItem
                                },
                                x: function () {
                                    return i.Base.SettingsToolbarItem
                                }
                            }, {
                                t: 0
                            }]
                        }]
                    },
                    logScale: {
                        t: 9
                    },
                    periods: {
                        t: 6,
                        u: 0,
                        b: [{
                            t: 5,
                            u: 0,
                            c: function () {
                                return nt.TimeChartSettingsAreaDisplayPeriod
                            },
                            x: function () {
                                return i.TimeChart.SettingsAreaDisplayPeriod
                            }
                        }]
                    },
                    zoomOut: {
                        t: 9
                    },
                    zoomOutFunction: {
                        t: 4
                    }
                }, r.SettingsMapping = nt, a(nt.BaseIChartErrorEventArguments, nt.BaseIChartEventArguments), a(nt.BaseIChartSettingsChangeEventArguments, nt.BaseIChartEventArguments), a(nt.BaseIDataErrorResponse, nt.BaseIDataObjectBase), a(nt.BaseSettingsBackgroundStyle, nt.BaseSettingsLineStyle), a(nt.BaseSettingsAdvancedStyleMessageBackground, nt.BaseSettingsBackgroundStyle), a(nt.BaseSettingsLegendPanel, nt.BaseSettingsChartPanel), a(nt.BaseSettingsToolbarItem, nt.BaseSettingsToolbarItemBase), a(nt.FacetChartIChartEventArguments, nt.BaseIChartEventArguments), a(nt.FacetChartIChartClickEventArguments, nt.FacetChartIChartEventArguments), a(nt.FacetChartIDataObjectCommon, nt.BaseIDataObjectBase), a(nt.FacetChartIDataObject, nt.FacetChartIDataObjectCommon), a(nt.FacetChartIDataObjectRoot, nt.FacetChartIDataObjectCommon), a(nt.FacetChartIDataObjectRoot, nt.BaseIDataErrorResponse), a(nt.LinearChartSettings, nt.BaseSettings), a(nt.FacetChartSettings, nt.LinearChartSettings), a(nt.LinearChartSettingsArea, nt.BaseSettingsArea), a(nt.FacetChartSettingsArea, nt.LinearChartSettingsArea), a(nt.LinearChartSettingsAreaStyle, nt.BaseSettingsAreaStyle), a(nt.FacetChartSettingsAreaStyle, nt.LinearChartSettingsAreaStyle), a(nt.PieChartSettingsData, nt.BaseSettingsData), a(nt.FacetChartSettingsData, nt.PieChartSettingsData), a(nt.FacetChartSettingsFacetAxisLabels, nt.BaseSettingsLabelStyle), a(nt.FacetChartSettingsFacetAxisTitleStyle, nt.BaseSettingsLabelStyle), a(nt.LinearChartSettingsSeriesColumnsStyle, nt.LinearChartSettingsSeriesStyle), a(nt.FacetChartSettingsSeriesColumnsStyle, nt.LinearChartSettingsSeriesColumnsStyle), a(nt.FacetChartSettingsFacetStyle, nt.FacetChartSettingsSeriesColumnsStyle), a(nt.LinearChartSettingsInteraction, nt.BaseSettingsInteraction), a(nt.FacetChartSettingsInteraction, nt.LinearChartSettingsInteraction), a(nt.FacetChartSettingsSeries, nt.LinearChartSettingsSeries), a(nt.LinearChartSettingsSeriesColumns, nt.LinearChartSettingsSeries), a(nt.FacetChartSettingsSeriesColumns, nt.LinearChartSettingsSeriesColumns), a(nt.FacetChartSettingsSeriesData, nt.LinearChartSettingsSeriesData), a(nt.LinearChartSettingsSeriesLines, nt.LinearChartSettingsSeries), a(nt.FacetChartSettingsSeriesLines, nt.LinearChartSettingsSeriesLines), a(nt.LinearChartSettingsSeriesLinesStyle, nt.LinearChartSettingsSeriesStyle), a(nt.FacetChartSettingsSeriesLinesStyle, nt.LinearChartSettingsSeriesLinesStyle), a(nt.FacetChartSettingsToolbar, nt.BaseSettingsToolbar), a(nt.ItemsChartIDataObjectBase, nt.BaseIDataErrorResponse), a(nt.ItemsChartIDataObjectNode, nt.ItemsChartIDataObjectBase), a(nt.GeoChartIGeoDataObjectNode, nt.ItemsChartIDataObjectNode), a(nt.GeoChartIAggregationDataObjectNode, nt.GeoChartIGeoDataObjectNode), a(nt.GeoChartIDataObject, nt.BaseIDataErrorResponse), a(nt.ItemsChartIDataObjectLink, nt.ItemsChartIDataObjectBase), a(nt.GeoChartIGeoDataObjectLink, nt.ItemsChartIDataObjectLink), a(nt.ItemsChartSettings, nt.BaseSettings), a(nt.GeoChartSettings, nt.ItemsChartSettings), a(nt.GeoChartSettingsAggregatedShapeStyle, nt.BaseSettingsBackgroundStyle), a(nt.GeoChartSettingsArea, nt.BaseSettingsArea), a(nt.GeoChartSettingsAreaStyle, nt.BaseSettingsAreaStyle), a(nt.ItemsChartSettingsData, nt.BaseSettingsData), a(nt.GeoChartSettingsData, nt.ItemsChartSettingsData), a(nt.ItemsChartSettingsInteraction, nt.BaseSettingsInteraction), a(nt.GeoChartSettingsInteraction, nt.ItemsChartSettingsInteraction), a(nt.GeoChartSettingsInteractionZooming, nt.ItemsChartSettingsInteractionZooming), a(nt.GeoChartSettingsLayerOverlay, nt.GeoChartSettingsLayerBase), a(nt.GeoChartSettingsLayerAggregated, nt.GeoChartSettingsLayerOverlay), a(nt.GeoChartSettingsLayerCharts, nt.GeoChartSettingsLayerOverlay), a(nt.GeoChartSettingsLayerItems, nt.GeoChartSettingsLayerBase), a(nt.GeoChartSettingsLayerShapes, nt.GeoChartSettingsLayerBase), a(nt.ItemsChartSettingsNodesLayerStyle, nt.ItemsChartSettingsItemsLayerStyle), a(nt.GeoChartSettingsNodesLayerStyle, nt.ItemsChartSettingsNodesLayerStyle), a(nt.GeoChartSettingsShapesLayerNodeStyle, nt.ItemsChartSettingsNodeStyle), a(nt.GeoChartSettingsShapesLayerStyle, nt.GeoChartSettingsNodesLayerStyle), a(nt.ItemsChartIChartEventArguments, nt.BaseIChartEventArguments), a(nt.ItemsChartIChartClickEventArguments, nt.ItemsChartIChartEventArguments), a(nt.ItemsChartSettingsAdvanced, nt.BaseSettingsAdvanced), a(nt.ItemsChartSettingsAuraStyle, nt.BaseSettingsBackgroundStyle), a(nt.ItemsChartSettingsItemsLayerLabelStyle, nt.BaseSettingsLabelStyle), a(nt.ItemsChartSettingsItemsLayerItemStyle, nt.ItemsChartSettingsItemsLayerLabelStyle), a(nt.ItemsChartSettingsItemsLayerLinkLabelStyle, nt.ItemsChartSettingsItemsLayerLabelStyle), a(nt.ItemsChartSettingsLinkClass, nt.ItemsChartSettingsItemClass), a(nt.ItemsChartSettingsLinkItem, nt.ItemsChartSettingsItemsLayerItemStyle), a(nt.ItemsChartSettingsLinkMenu, nt.ItemsChartSettingsMenu), a(nt.ItemsChartSettingsNodeClass, nt.ItemsChartSettingsItemClass), a(nt.ItemsChartSettingsNodeItem, nt.ItemsChartSettingsItemsLayerItemStyle), a(nt.ItemsChartSettingsNodeMenu, nt.ItemsChartSettingsMenu);
                var rt = nt.LinearChartSettingsEvents;
                nt.LinearChartSettingsEvents = function (t, e) {
                    var i = rt(t, e);
                    return a(i, nt.BaseSettingsEvents(t, e)), i
                }, a(nt.LinearChartSettingsLegend, nt.BaseSettingsLegend), a(nt.LinearChartSettingsLegendAdvanced, nt.BaseSettingsLegendAdvanced), a(nt.LinearChartSettingsLegendMarker, nt.BaseSettingsLegendMarker), a(nt.LinearChartSettingsLocalization, nt.BaseSettingsLocalization), a(nt.LinearChartSettingsLocalizationToolbar, nt.BaseSettingsLocalizationToolbar), a(nt.LinearChartSettingsSeriesCandleStick, nt.LinearChartSettingsSeries), a(nt.LinearChartSettingsSeriesCandleStickStyle, nt.LinearChartSettingsSeriesStyle), a(nt.LinearChartSettingsValueAxisBaseLineStyle, nt.BaseSettingsLineStyle), a(nt.LinearChartSettingsValueAxisTitleStyle, nt.BaseSettingsLabelStyle), a(nt.NetChartBarSettingsLocalizationToolbar, nt.BaseSettingsLocalizationToolbar), a(nt.NetChartBarSettingsToolbar, nt.BaseSettingsToolbar), a(nt.NetChartIChartEventArguments, nt.ItemsChartIChartEventArguments), a(nt.NetChartIChartClickEventArguments, nt.NetChartIChartEventArguments), a(nt.NetChartIDataObject, nt.BaseIDataErrorResponse), a(nt.NetChartIDataObjectLink, nt.ItemsChartIDataObjectLink), a(nt.NetChartIDataObjectNode, nt.ItemsChartIDataObjectNode), a(nt.NetChartSettings, nt.ItemsChartSettings), a(nt.NetChartSettingsArea, nt.BaseSettingsArea), a(nt.NetChartSettingsData, nt.ItemsChartSettingsData), a(nt.NetChartSettingsEvents, nt.BaseSettingsEvents(nt.NetChartIChartEventArguments, nt.NetChartIChartClickEventArguments)), a(nt.NetChartSettingsInteraction, nt.ItemsChartSettingsInteraction), a(nt.NetChartSettingsInteractionSelection, nt.ItemsChartSettingsInteractionSelection), a(nt.NetChartSettingsInteractionZooming, nt.ItemsChartSettingsInteractionZooming), a(nt.NetChartSettingsLegend, nt.BaseSettingsLegend), a(nt.NetChartSettingsLegendAdvanced, nt.BaseSettingsLegendAdvanced), a(nt.NetChartSettingsLocalization, nt.BaseSettingsLocalization), a(nt.NetChartSettingsStyle, nt.ItemsChartSettingsNodesLayerStyle), a(nt.PieChartIChartEventArguments, nt.BaseIChartEventArguments), a(nt.PieChartIChartClickEventArguments, nt.PieChartIChartEventArguments), a(nt.PieChartIDataObjectCommon, nt.BaseIDataObjectBase), a(nt.PieChartIDataObject, nt.PieChartIDataObjectCommon), a(nt.PieChartIDataObjectRoot, nt.PieChartIDataObjectCommon), a(nt.PieChartIDataObjectRoot, nt.BaseIDataErrorResponse), a(nt.PieChartSettings, nt.BaseSettings), a(nt.PieChartSettingsAdvanced, nt.BaseSettingsAdvanced), a(nt.PieChartSettingsEvents, nt.BaseSettingsEvents(nt.PieChartIChartEventArguments, nt.PieChartIChartClickEventArguments)), a(nt.PieChartSettingsInteraction, nt.BaseSettingsInteraction), a(nt.PieChartSettingsLegend, nt.BaseSettingsLegend), a(nt.PieChartSettingsLegendMarker, nt.BaseSettingsLegendMarker), a(nt.PieChartSettingsLocalization, nt.BaseSettingsLocalization), a(nt.TimeChartIChartEventArguments, nt.BaseIChartEventArguments), a(nt.TimeChartIDataObject, nt.BaseIDataErrorResponse), a(nt.TimeChartSettings, nt.LinearChartSettings), a(nt.TimeChartSettingsAdvanced, nt.BaseSettingsAdvanced), a(nt.TimeChartSettingsArea, nt.LinearChartSettingsArea), a(nt.TimeChartSettingsAreaStyle, nt.LinearChartSettingsAreaStyle), a(nt.TimeChartSettingsCurrentTime, nt.TimeChartSettingsMarker), a(nt.TimeChartSettingsData, nt.BaseSettingsData), a(nt.TimeChartSettingsEvents, nt.LinearChartSettingsEvents(nt.TimeChartIChartEventArguments, nt.TimeChartIChartEventArguments)), a(nt.TimeChartSettingsInteraction, nt.LinearChartSettingsInteraction), a(nt.TimeChartSettingsInteractionScrolling, nt.LinearChartSettingsInteractionScrolling), a(nt.TimeChartSettingsInteractionZooming, nt.LinearChartSettingsInteractionZooming), a(nt.TimeChartSettingsLocalization, nt.LinearChartSettingsLocalization), a(nt.TimeChartSettingsLocalizationToolbar, nt.LinearChartSettingsLocalizationToolbar), a(nt.TimeChartSettingsSeries, nt.LinearChartSettingsSeries), a(nt.TimeChartSettingsSeriesCandleStick, nt.LinearChartSettingsSeriesCandleStick), a(nt.TimeChartSettingsSeriesData, nt.LinearChartSettingsSeriesData), a(nt.TimeChartSettingsSeriesCandleStickData, nt.TimeChartSettingsSeriesData), a(nt.TimeChartSettingsSeriesColumns, nt.LinearChartSettingsSeriesColumns), a(nt.TimeChartSettingsSeriesLines, nt.LinearChartSettingsSeriesLines), a(nt.TimeChartSettingsSeriesLinesStyle, nt.LinearChartSettingsSeriesLinesStyle), a(nt.TimeChartSettingsToolbar, nt.BaseSettingsToolbar);
                var st = function () {
                    function t() {}
                    return t.mergeDefaultValues = function (e, i, n, r, s, a) {
                        var o = i ? i.type : null;
                        if (!e || 0 === e.length) {
                            if (!o) return [];
                            e = [{
                                type: o
                            }]
                        }
                        for (var l = [], h = 0; h < e.length; h++) {
                            var u = e[h],
                                c = a + "[" + h + "]";
                            if (d.isObjectOrArray(u)) {
                                var p = u.type || o;
                                if (!p) throw new Error("`type` property must be specified in the settings for value: " + c);
                                var f = r(u, p),
                                    g = n[p];
                                i && (delete i.type, t.updateRecursive(f, i, s(f, i), {}, c), i.type = o), g && t.updateRecursive(f, g, s(f, g), {}, c), t.updateRecursive(f, u, s(f, u), {}, c), l.push(f)
                            }
                        }
                        return l
                    }, t.updateRecursive = function (t, e, i, n, r) {
                        if (void 0 === r && (r = ""), !t) throw new Error("Cannot update settings path '" + r + "' because the target object is not defined.");
                        if (e)
                            for (var s in e)
                                if (e.hasOwnProperty(s)) {
                                    var a = e[s],
                                        o = (r.length ? r + "." : "") + s,
                                        l = this.findPropertyConfiguration(s, i, o);
                                    null !== l && void 0 !== a && this.copyValue(t, s, a, l, n, o)
                                }
                    }, t.copyValueMergeByID = function (t, e, i, n, r, s) {
                        if (null != i) {
                            if (6 !== n.t) throw new Error("Property '" + s + "' is set to use merge-by-ID update mode which is only supported on arrays.");
                            if (this.replacingSettings) return this.copyValueRecursive(t, e, i, n, r, s);
                            var a = t[e];
                            null == a && (t[e] = a = []);
                            for (var o = {}, l = 0; l < a.length; l++) o[a[l].id] = a[l];
                            for (var h = 0; h < i.length; h++) {
                                var u = i[h];
                                if (null != u) {
                                    u.id || (u.id = d.getIdentifierStr());
                                    var c = o[u.id];
                                    r[e] || (r[e] = {}), this.copyValue(o, u.id, u, n.b[0], r[e], s + "[" + u.id + "]"), c || a.push(o[u.id])
                                }
                            }
                        }
                    }, t.retrieveOwnMethod = function (t, e) {
                        if (!t) return null;
                        var i = t[e],
                            n = t.__baseType;
                        return n && n[e] === i ? null : i
                    }, t.copyValueRecursive = function (t, e, i, n, r, s) {
                        if (null != i) {
                            var a = t[e];
                            if (n.c) {
                                var o = n.x ? n.x() : null,
                                    l = this.retrieveOwnMethod(o, "getMapping"),
                                    h = l ? l(a, i) : n.c();
                                if (null == a) {
                                    if (!o || n.y || this._ignoringCtor) a = {};
                                    else {
                                        var u = this.retrieveOwnMethod(o, "createInstance");
                                        a = u ? u(i) : new o
                                    }
                                    t[e] = a
                                }
                                if (n.y) try {
                                    this._ignoringCtor++, this.updateRecursive(a, i, h, r[e] = {}, s)
                                } finally {
                                    this._ignoringCtor--
                                } else this.updateRecursive(a, i, h, r[e] = {}, s)
                            } else if (6 === n.t) t[e] = a = [], this.copyArray(a, i, n.b[0], r[e] = [], s);
                            else {
                                if (8 !== n.t) throw new Error("Property '" + s + "' is set to use recursive update but does not define target object mapping.");
                                (null == a || this.replacingSettings) && (t[e] = a = {}), this.copyDictionary(a, i, n.b[0], r[e] = {}, s)
                            }
                        }
                    }, t.copyValue = function (t, e, i, n, r, s) {
                        if (void 0 === i) return delete t[e], void(r[e] = !0);
                        var a = this.ensurePropertyType(i, n, s);
                        if (a) {
                            i = a.value, n = a.configuration || n;
                            var o = t[e];
                            if (1 === n.u || void 0 === n.u) o !== i && (r[e] = i, t[e] = i);
                            else if (2 === n.u) i = JSON.parse(JSON.stringify(i)), r[e] = i, t[e] = i;
                            else if (4 === n.u) this.copyValueMergeByID(t, e, i, n, r, s);
                            else if (3 === n.u) {
                                if (null != i) {
                                    if (6 !== n.t) throw new Error("Property '" + s + "' is set to use concat update which is only supported for arrays.");
                                    o && !this.replacingSettings || (t[e] = o = []), this.copyArray(o, i, n.b[0], r[e] = [], s)
                                }
                            } else {
                                if (0 !== n.u) throw new Error("Property '" + s + "' does not have an update mode defined in the settings mapping or it is not implemented.");
                                this.copyValueRecursive(t, e, i, n, r, s)
                            }
                        }
                    }, t.copyDictionary = function (t, e, i, n, r) {
                        for (var s = Object.keys(e), a = 0; a < s.length; a++) {
                            var o = s[a],
                                l = {};
                            this.copyValue(t, o, e[o], i, l, r + "." + o), d.hasProperties(l) && (n[o] = l)
                        }
                    }, t.copyArray = function (t, e, i, n, r) {
                        for (var s = 0; s < e.length; s++) this.copyValue(t, t.length, e[s], i, n, r + "[" + s + "]")
                    }, t.ensurePropertyType = function (t, e, i, n) {
                        if (void 0 === n && (n = !1), null == t) return {
                            value: t
                        };
                        var r = null,
                            s = null,
                            a = void 0,
                            o = null;
                        switch (e.t) {
                            case 0:
                                t instanceof String && (t = t.valueOf()), d.isString(t) || (r = "String");
                                break;
                            case 1:
                                if (t instanceof Number && (t = t.valueOf()), 0 === e.d) {
                                    a = parseFloat(t);
                                    var l = Math.round(a);
                                    if (isNaN(a)) r = "Integer";
                                    else if (l !== a) {
                                        var h = Math.abs(l - a);
                                        n || d.warn("Settings value '" + i + "' expected to be an Integer but contains a decimal point: " + a + "."), h < 1e-8 && (a = l)
                                    }
                                } else a = parseFloat(t), isNaN(a) && (r = "Float");
                                break;
                            case 3:
                                d.isString(t) ? (a = document.getElementById(t), a || (s = "the property expects either a reference to a DOM element or a string containing the ID of the element. There is no element with the given ID '" + t + "'.")) : d.isDomObject(t) || (s = "the property expects either a reference to a DOM element or a string containing the ID of the element.");
                                break;
                            case 4:
                                d.isFunction(t) || (r = "Function");
                                break;
                            case 6:
                                Array.isArray(t) || (n ? r = "Array" : (d.warn("Settings value '" + i + "' expected to be an array but found " + typeof t + ". The value will be wrapped in an array."), a = [t]));
                                break;
                            case 16:
                                "undefined" != typeof Float32Array && t instanceof Float32Array || (r = "Float32Array");
                                break;
                            case 16:
                                "undefined" != typeof Float32Array && t instanceof Float32Array || (r = "Float32Array");
                                break;
                            case 17:
                                "undefined" != typeof Int32Array && t instanceof Int32Array || (r = "Int32Array");
                                break;
                            case 18:
                                "undefined" != typeof Uint32Array && t instanceof Uint32Array || (r = "UInt32Array");
                                break;
                            case 11:
                                if (Array.isArray(t))
                                    for (var u = 0; u < t.length; u++) {
                                        var c = t[u];
                                        if (!Array.isArray(c) || 2 !== c.length || !d.isNumber(c[0]) || !d.isString(c[1])) {
                                            s = "the property at index " + u + " has to be an array with two elements - a number and a string.";
                                            break
                                        }
                                    } else s = "the property has to be an array where each item is an array with two elements - a number and a string.";
                                break;
                            case 2:
                                var p = e.e(),
                                    f = d.isNumber(t);
                                f || d.isString(t) ? (a = p[t], void 0 === a && (s = "'" + t + "' is not a valid enumeration value. Please review the documentation for valid values.", t = p), f && (a = t)) : (s = "the value must be a number or a string (the preferred way is to use the enumeration from 'ZoomCharts.Configuration' namespace).", t = p);
                                break;
                            case 14:
                                t instanceof CanvasGradient || (r = "CanvasGradient");
                                break;
                            case 12:
                                if (Array.isArray(t) && t.length === e.b.length)
                                    for (var g = 0; g < t.length; g++) {
                                        var m = this.ensurePropertyType(t[g], e.b[g], i + "[" + g + "]", n);
                                        if (!m) return null;
                                        t[g] = m.value
                                    } else s = "the property expects an array with exactly " + e.b.length + " elements.";
                                break;
                            case 7:
                                for (var v = !1, y = 0; y < e.b.length; y++) {
                                    var S = this.ensurePropertyType(t, e.b[y], i, !0);
                                    if (S) {
                                        a = S.value, o = S.configuration || e.b[y], v = !0;
                                        break
                                    }
                                }
                                v || (s = "the the given value does not match any constituent of the union type. Please review the documentation on the correct type.");
                                break;
                            case 5:
                            case 8:
                                d.isObjectOrArray(t) || (r = "Object");
                                break;
                            case 9:
                                t instanceof Boolean && (t = t.valueOf()), null !== t && t !== !0 && t !== !1 && (r = "Boolean");
                                break;
                            case 10:
                                break;
                            default:
                                throw new Error("Unsupported data type: " + e.t)
                        }
                        return null !== r && null === s && (s = "the given value '" + t + "' is not of type '" + r + "'."), null !== s ? (n || d.error("Cannot update settings value '" + i + "' because " + s, t), null) : (void 0 !== a && (t = a), {
                            value: t,
                            configuration: o
                        })
                    }, t.findPropertyConfiguration = function (t, e, i) {
                        var n = e[t];
                        return void 0 !== n ? n : (d.warn("Cannot update settings value '" + i + "' because such property does not exist.", null, !0), null)
                    }, t
                }();
                st._ignoringCtor = 0, st.replacingSettings = !1, r.SettingsHelper = st;
                var at = function () {
                    function t(t) {
                        this._mapping = null, this._computedDataMap = {}, this._initializing = !0, this.container = null, this.theme = null, this.assetsUrlBase = "", this.area = new ut, this.data = [], this.advanced = new pt, this.events = new ot, this.interaction = new dt, this.localization = new lt, this.toolbar = new Q, this.title = new B, this.credits = new N, this.legend = new V, this._mapping = t
                    }
                    return t.prototype.applyGlobalCustomizations = function () {
                        this.theme && st.updateRecursive(this, this.theme, this._mapping, {})
                    }, t.prototype.applyCompatibility = function (t, e, i) {
                        i = null == i ? "" : i + ".";
                        for (var n = 0; n < e.length; n++) {
                            var r = e[n],
                                s = r.from,
                                a = d.getProp(t, s, !!r.to && !r.filter);
                            if (void 0 !== a && (!r.filter || r.filter(a)))
                                if (r.to) r.transform && (a = r.transform(a)), d.extendDeep(t, d.wrapValue(a, r.to)), d.warn("Setting `" + i + s + "` is being deprecated. Compatibility layer moved the value automatically to `" + i + r.to + "`. Please update the configuration to avoid using the obsolete property.", null, !0);
                                else {
                                    var o = r.alternativeAsWarning,
                                        l = "Setting `" + i + s + "` " + (o ? "is being deprecated" : "is no longer supported") + ". Consider using `" + r.alternative + "` instead.";
                                    o ? d.warn(l, null, !0) : d.error(l)
                                }
                        }
                    }, t.prototype.apply = function (t) {
                        this.applyCompatibility(t, [{
                            from: "width",
                            to: "area.width"
                        }, {
                            from: "height",
                            to: "area.height"
                        }, {
                            from: "minHeight",
                            to: "area.minHeight"
                        }, {
                            from: "maxHeight",
                            to: "area.maxHeight"
                        }, {
                            from: "minWidth",
                            to: "area.minWidth"
                        }, {
                            from: "maxWidth",
                            to: "area.maxWidth"
                        }]);
                        var e = {},
                            i = !1;
                        if (this._initializing) this.applyGlobalCustomizations(), t || (t = {}), t.data || (t.data = [{}]);
                        else if (!t) return e;
                        if (t.data) {
                            Array.isArray(t.data) || (t.data = [t.data], i = !0);
                            for (var n = 0; n < t.data.length; n++) {
                                var r = t.data[n];
                                r.id || (r.name ? (d.warn("The property `name` in the data object configuration is deprecated in favor of `id` property. Please update the configuration to avoid using the obsolete property.", null, !0), r.id = r.name, delete r.name) : 0 === n ? r.id = "default" : r.id = "default-" + n.toString(10))
                            }
                        }
                        if (st.updateRecursive(this, t.theme, this._mapping, e), st.updateRecursive(this, t, this._mapping, e), i && (t.data = t.data[0]), e.data || this._initializing) {
                            this._computedDataMap = {};
                            for (var n = 0; n < this.data.length; n++) {
                                var s = this.data[n];
                                this._computedDataMap[s.id] = s
                            }
                        }
                        return e
                    }, t
                }();
                r.Settings = at;
                var ot = function () {
                    function t() {
                        this.onError = null, this.onSettingsChange = null, this.onClick = null, this.onDoubleClick = null, this.onTripleClick = null, this.onRightClick = null, this.onHoverChange = null, this.onSelectionChange = null, this.onChartUpdate = null, this.onPositionChange = null, this.chartUpdateDelay = 0
                    }
                    return t
                }();
                r.SettingsEvents = ot;
                var lt = function () {
                    function t() {
                        this.toolbar = new ht, this.loadingLabel = "Loading...", this.closeButton = "Close", this.dataRequestFailed = "Data request failed", this.exportNotAvailable = "Your browser does not support exporting the chart."
                    }
                    return t
                }();
                r.SettingsLocalization = lt;
                var ht = function () {
                    function t() {
                        this.backButton = "Back", this.backTitle = "Move one step back in navigation", this.fullscreenButton = "Fullscreen", this.fullscreenTitle = "Toggle fullscreen mode", this.zoomoutButton = "Zoom-out", this.zoomoutTitle = "Zoom out", this.exportButton = "Export", this.exportTitle = "Export Data", this.exportJpeg = "For Office and Web (jpeg)", this.exportPNG = "For Photoshop (png)", this.exportPDF = "For Printer (pdf)", this.exportCSV = "Spreadsheet (csv)", this.exportXLS = "Spreadsheet (xls)"
                    }
                    return t
                }();
                r.SettingsLocalizationToolbar = ht;
                var ut = function () {
                    function t() {
                        this.defaultHeight = 300, this.width = null, this.height = null, this.top = null, this.left = null, this.minHeight = 50, this.maxHeight = 2e4, this.minWidth = 50, this.maxWidth = 2e4, this.style = new ct
                    }
                    return t
                }();
                r.SettingsArea = ut;
                var ct = function () {
                    function t() {
                        this.fillColor = "transparent", this.image = null, this.overlayColor = null
                    }
                    return t
                }();
                r.SettingsAreaStyle = ct;
                var dt = function () {
                    function t() {
                        this.resizing = new et
                    }
                    return t
                }();
                r.SettingsInteraction = dt;
                var pt = function () {
                    function t() {
                        this.labelCache = !0, this.labelCacheRotated = !0, this.highDPI = !0, this.pointer = new ft, this.useAnimationFrame = !0, this.showTouches = !1, this.showTouchTrail = !0, this.showFPS = !1, this.showTimestamp = !1, this.logging = !1, this.style = new gt, this.maxCanvasWidth = 4096, this.maxCanvasHeight = 4096, this.themeCSSClass = "DVSL-round", this.assets = [{
                            //加载样式css   肖若晗
							//url: "assets://zc.css",
							url: "./zc.css",
                            required: function () {
                                return !d.isStyleSheetDefined("DVSL-suppress-default-styles", "color")
                            }
                        }], this.builtinAssets = {
                            "logo-blank": c.LicenseBannerBlank,
                            "logo-supported-by": c.LicenseBannerSupportedBy,
                            "logo-development": c.LicenseBannerDevelopment,
                            "logo-license-expired": c.LicenseBannerExpired,
                            "logo-unlicensed": c.LicenseBannerUnlicensed
                        }, this.exportProxyURL = "https://echo.zoomcharts-cloud.com/download", this.exportPdfSize = [210, 297], this.crossOriginHeader = null, this.dataExportFunction = null
                    }
                    return t
                }();
                r.SettingsAdvanced = pt;
                var ft = function () {
                    function t() {
                        this.noClickOnDoubleClick = !0, this.clickSensitivity = 10, this.doubleClickSensitivity = 20, this.doubleClickTimeout = 300, this.longPressTimeout = 500, this.longPressSensitivity = 10, this.speedAveragingPeriod = 200, this.scrollIntoView = !1, this.mouseWheelRequiresFocus = !1
                    }
                    return t
                }();
                r.SettingsAdvancedPointer = ft;
                var gt = function () {
                    function t() {
                        this.messageTextStyle = {
                            fillColor: "#000",
                            font: "15px Arial"
                        }, this.messageBackgroundStyle = {
                            padding: 5
                        }, this.loadingArcStyle = {
                            r: 10,
                            lineColor: "#444",
                            lineWidth: 1,
                            location: "center"
                        }
                    }
                    return t
                }();
                r.SettingsAdvancedStyle = gt;
                var mt = function () {
                    function t(t, e, i, n) {
                        t !== 1 / 0 && t > i ? (this.x1 = t, this.x0 = i) : (this.x1 = i, this.x0 = t), e !== 1 / 0 && e > n ? (this.y1 = e, this.y0 = n) : (this.y1 = n, this.y0 = e)
                    }
                    return t.createEmpty = function () {
                        return new t(1 / 0, 1 / 0, -(1 / 0), -(1 / 0))
                    }, t.prototype.isEmpty = function () {
                        return this.x0 >= this.x1 || this.y0 >= this.y1
                    }, t.prototype.clone = function () {
                        return new t(this.x0, this.y0, this.x1, this.y1)
                    }, t.prototype.w = function () {
                        return this.x1 - this.x0
                    }, t.prototype.h = function () {
                        return this.y1 - this.y0
                    }, t.prototype.equals = function (t) {
                        return this.x0 === t.x0 && this.x1 === t.x1 && this.y0 === t.y0 && this.y1 === t.y1
                    }, t.prototype.inflate = function (t) {
                        var e = (this.x0 + this.x1) / 2,
                            i = (this.y0 + this.y1) / 2;
                        return this.x0 = (this.x0 - e) * t + e, this.x1 = (this.x1 - e) * t + e, this.y0 = (this.y0 - i) * t + i, this.y1 = (this.y1 - i) * t + i, this
                    }, t.prototype.clip = function (t) {
                        return this.x0 = Math.max(this.x0, t.x0), this.x1 = Math.min(this.x1, t.x1), this.y0 = Math.max(this.y0, t.y0), this.y1 = Math.min(this.y1, t.y1), this
                    }, t.prototype.isInside = function (t) {
                        return this.x0 >= t.x0 && this.x1 <= t.x1 && this.y0 >= t.y0 && this.y1 <= t.y1
                    }, t.prototype.isOutside = function (t) {
                        return this.x0 > t.x1 || this.x1 < t.x0 || this.y0 > t.y1 || this.y1 < t.y0
                    }, t.prototype.overlapsRect = function (t, e, i, n) {
                        return t < this.x1 && i > this.x0 && e < this.y1 && n > this.y0
                    }, t.prototype.intersectsSegment = function (t, e, i, n) {
                        return null != r.Geometry.clipSegmentToRect(t, e, i - t, n - e, this.x0, this.y0, this.x1, this.y1)
                    }, t.prototype.area = function () {
                        return (this.x1 - this.x0) * (this.y1 - this.y0);
                    }, t.prototype.toString = function () {
                        return this.x0 + "," + this.y0 + ", " + this.x1 + ", " + this.y1
                    }, t.prototype.addPoint = function (t, e) {
                        return this.x0 = Math.min(this.x0, t), this.x1 = Math.max(this.x1, t), this.y0 = Math.min(this.y0, e), this.y1 = Math.max(this.y1, e), this
                    }, t.prototype.addBounds = function (t, e, i, n) {
                        return this.x0 = Math.min(this.x0, t), this.x1 = Math.max(this.x1, i), this.y0 = Math.min(this.y0, e), this.y1 = Math.max(this.y1, n), this
                    }, t.prototype.addRect = function (t) {
                        return this.x0 = Math.min(this.x0, t.x0), this.x1 = Math.max(this.x1, t.x1), this.y0 = Math.min(this.y0, t.y0), this.y1 = Math.max(this.y1, t.y1), this
                    }, t.prototype.moveBy = function (t, e) {
                        return this.x0 += t, this.x1 += t, this.y0 += e, this.y1 += e, this
                    }, t.prototype.containsPoint = function (t, e) {
                        return t >= this.x0 && t < this.x1 && e >= this.y0 && e < this.y1
                    }, t.prototype.addLine = function (t) {
                        for (var e = 0; e <= t.length - 2; e += 2) this.addPoint(t[e], t[e + 1]);
                        return this
                    }, t.prototype.translate = function (t, e, i, n) {
                        return this.x0 = this.x0 * t + e, this.x1 = this.x1 * t + e, this.y0 = this.y0 * i + n, this.y1 = this.y1 * i + n, this
                    }, t.prototype.overlaps = function (t) {
                        return this.x0 < t.x1 && this.x1 > t.x0 && this.y0 < t.y1 && this.y1 > t.y0
                    }, t
                }();
                r.Rect = mt;
                var vt = function () {
                        function t(t, e) {
                            this.msg = t, this.pri = e
                        }
                        return t
                    }(),
                    yt = function () {
                        function t() {
                            this.settings = null, this.assetsLoader = null, this.mainData = null, this.mainDataEnabled = !0, this.chartLeft = 0, this.chartTop = 0, this.chartWidth = 1, this.chartHeight = 1, this.x0 = 0, this.y0 = 0, this.height = 0, this.width = 0, this.leftMargin = 0, this.rightMargin = 0, this.topMargin = 0, this.bottomMargin = 0, this.loading = !0, this.messages = {}, this.backStack = []
                        }
                        return t.prototype.setMessage = function (t, e, i) {
                            void 0 === i && (i = 0);
                            var n;
                            return e ? (n = !this.messages[t] || this.messages[t].msg !== e || this.messages[t].pri !== i, this.messages[t] = new vt(e, i)) : (n = this.messages.hasOwnProperty(t), delete this.messages[t]), n
                        }, t.prototype.getMessage = function () {
                            var t = null,
                                e = 0;
                            for (var i in this.messages) {
                                var n = this.messages[i];
                                n.pri > e && (t = n.msg, e = n.pri)
                            }
                            return t
                        }, t.prototype.pushBack = function (t) {
                            this.backStack.push(t), this.backStack.length > 1e3 && (this.backStack = this.backStack.slice(200))
                        }, t
                    }();
                r.Scene = yt;
                var St = 2 * Math.PI,
                    bt = function () {
                        function t() {}
                        return t.distanceToSegmentSq = function (t, e, i, n, r, s) {
                            var a = r - t,
                                o = s - e,
                                l = i - t,
                                h = n - e,
                                u = a * l + o * h,
                                c = l * l + h * h,
                                d = -1;
                            0 !== c && (d = u / c);
                            var p, f;
                            d < 0 ? (p = t, f = e) : d > 1 ? (p = i, f = n) : (p = t + d * l, f = e + d * h);
                            var g = r - p,
                                m = s - f;
                            return g * g + m * m
                        }, t.rayIntersectsSegment = function (t, e, i, n, r, s, a, o) {
                            var l = 1 / 0,
                                h = a - r,
                                u = o - s,
                                c = i * u - n * h;
                            if (0 !== c) {
                                var d = (e * h - t * u + r * u - s * h) / c,
                                    p = void 0;
                                p = Math.abs(h) > Math.abs(u) ? (t + i * d - r) / h : (e + n * d - s) / u, p >= 0 && p <= 1 && d >= 0 && (l = d)
                            }
                            return l
                        }, t.lineIntersectsSegment = function (t, e, i, n, r, s, a, o) {
                            var l = 1 / 0,
                                h = a - r,
                                u = o - s,
                                c = i * u - n * h;
                            if (0 !== c) {
                                var d = (e * h - t * u + r * u - s * h) / c,
                                    p = void 0;
                                p = Math.abs(h) > Math.abs(u) ? (t + i * d - r) / h : (e + n * d - s) / u, p >= 0 && p <= 1 && (l = d)
                            }
                            return l
                        }, t.lineIntersectsLine = function (t, e, i, n, r, s, a, o) {
                            var l = 1 / 0,
                                h = i - t,
                                u = n - e,
                                c = a - r,
                                d = o - s,
                                p = h * d - u * c;
                            if (0 !== p) {
                                var f = (e * c - t * d + r * d - s * c) / p,
                                    g = void 0;
                                g = Math.abs(c) > Math.abs(d) ? (t + h * f - r) / c : (e + u * f - s) / d, l = f
                            }
                            return l
                        }, t.rayIntersectsCircle = function (t, e, i, n, r) {
                            var s = i * i + n * n,
                                a = t * i + e * n,
                                o = t * t + e * e - r * r,
                                l = a * a - s * o,
                                h = 1 / 0;
                            if (l > 0) {
                                l = Math.sqrt(l);
                                var u = (-a - l) / s,
                                    c = (-a + l) / s;
                                u >= 0 && (h = u), c >= 0 && (h = Math.min(h, c))
                            }
                            return h
                        }, t.clipSegmentToRect = function (t, e, i, n, r, s, a, o) {
                            var l = 0,
                                h = 1;
                            if (0 !== n) {
                                var u = 1 / n,
                                    c = (s - e) * u,
                                    d = (o - e) * u;
                                if (l = Math.min(c, d), h = Math.max(c, d), l > 1 || h < 0) return null
                            } else if (e < s || e > o) return null;
                            if (0 !== i) {
                                var p = 1 / i,
                                    f = (r - t) * p,
                                    g = (a - t) * p,
                                    m = Math.min(f, g),
                                    v = Math.max(f, g);
                                if (l = Math.max(l, m), h = Math.min(h, v), l > 1 || h < 0 || l > h) return null
                            } else if (t < r || t > a) return null;
                            return [l, h]
                        }, t.rayIntersectsCircleOuter = function (t, e, i, n, r) {
                            var s = i * i + n * n,
                                a = t * i + e * n,
                                o = t * t + e * e - r * r,
                                l = a * a - s * o;
                            return l = Math.sqrt(l), Math.max((-a + l) / s, (-a - l) / s)
                        }, t.lineTouchingCircle = function (t, e, i, n, r) {
                            var s = Math.sqrt(t * t + e * e);
                            if (!(s > r)) return null;
                            var a = Math.sqrt(s * s - r * r),
                                o = r * a / s,
                                l = r * r / s,
                                h = t / s,
                                u = e / s,
                                c = t * n - e * i;
                            return c < 0 && (o = -o), {
                                x: h * l - u * o,
                                y: u * l + h * o
                            }
                        }, t.distanceToPolygonSq = function (e, i, n) {
                            if (t.isInsidePolygon(e, i, n)) return 0;
                            for (var r = 1 / 0, s = 0; s < n.length; s++)
                                for (var a = n[s], o = a.length, l = a[o - 2], h = a[o - 1], u = 0; u <= o - 2; u += 2) {
                                    var c = a[u],
                                        d = a[u + 1];
                                    r = Math.min(r, t.distanceToSegmentSq(l, h, c, d, e, i)), l = c, h = d
                                }
                            return r
                        }, t.distanceToLinesSq = function (e, i, n) {
                            for (var r = 1 / 0, s = 0; s < n.length; s++) {
                                var a = n[s],
                                    o = a.length;
                                if (2 === o) r = Math.min(r, (e - a[0]) * (e - a[0]) + (i - a[1]) * (i - a[1]));
                                else if (o > 2)
                                    for (var l = a[0], h = a[1], u = 2; u <= o - 2; u += 2) {
                                        var c = a[u],
                                            d = a[u + 1];
                                        r = Math.min(r, t.distanceToSegmentSq(l, h, c, d, e, i)), l = c, h = d
                                    }
                            }
                            return r
                        }, t.isInsidePolygon = function (t, e, i) {
                            for (var n = !1, r = 0; r < i.length; r++)
                                for (var s = i[r], a = s.length, o = s[a - 2], l = s[a - 1], h = 0; h <= a - 2; h += 2) {
                                    var u = s[h],
                                        c = s[h + 1];
                                    c > e != l > e && t < (u - o) * (e - l) / (c - l) + o && (n = !n), o = u, l = c
                                }
                            return n
                        }, t.distanceToBalloon = function (e, i, n, r) {
                            var s;
                            if (e >= i) s = e;
                            else if (0 === r) s = i;
                            else {
                                var a = d.sign(r);
                                s = e / r * a, Math.abs(n * s) > i - e && (s = t.rayIntersectsCircleOuter(-(i - e), 0, Math.abs(n), r, e))
                            }
                            return s
                        }, t.distanceToRect = function (t, e, i, n, s, a, o) {
                            void 0 === o && (o = !1);
                            var l, h;
                            i instanceof r.Rect ? (o = n, l = i.x0, h = i.y0, s = i.x1, a = i.y1) : (l = i, h = n);
                            var u, c;
                            return u = t < l ? l - t : t > s ? t - s : 0, c = e < h ? h - e : e > a ? e - a : 0, o ? u * u + c * c : Math.sqrt(u * u + c * c)
                        }, t.clipSegmentToBounds = function (e, i, n, r, s, a, o, l, h, u) {
                            var c = Math.max(s, a),
                                d = n - e,
                                p = r - i,
                                f = t.clipSegmentToRect(e, i, d, p, o - c, l - c, h + c, u + c);
                            if (null === f) return null;
                            var g = Math.max(0, f[0]),
                                m = Math.min(1, f[1]);
                            return [e + d * g, i + p * g, e + d * m, i + p * m]
                        }, t.computeBoundsSize = function (t) {
                            for (var e = 1 / 0, i = -(1 / 0), n = 1 / 0, r = -(1 / 0), s = t.length, a = 0; a < s; a += 2) {
                                var o = t[a],
                                    l = t[a + 1];
                                e = Math.min(o, e), i = Math.max(o, i), n = Math.min(l, n), r = Math.max(l, r)
                            }
                            return Math.max(i - e, r - n)
                        }, t.simplify = function (e, i) {
                            if (!i || !e.length) return e;
                            var n = i * i;
                            return e = t.reducePoints(e, n), e = t.simplifyDP(e, n)
                        }, t.simplifyDP = function (e, i) {
                            var n, r = e.length;
                            n = "undefined" != typeof Uint8Array ? new Uint8Array(r) : new Array(r), n[0] = n[r - 2] = 1, t.simplifyDPStep(e, n, i, 0, r - 2);
                            for (var s = [], a = 0; a < r; a += 2) n[a] && (s.push(e[a]), s.push(e[a + 1]));
                            return s
                        }, t.simplifyDPStep = function (e, i, n, r, s) {
                            for (var a = 0, o = 0, l = e[r], h = e[r + 1], u = e[s], c = e[s + 1], d = r + 2; d <= s - 2; d += 2) {
                                var p = t.distanceToSegmentSq(l, h, u, c, e[d], e[d + 1]);
                                p > a && (o = d, a = p)
                            }
                            a > n && (i[o] = 1, t.simplifyDPStep(e, i, n, r, o), t.simplifyDPStep(e, i, n, o, s))
                        }, t.reducePoints = function (t, e) {
                            for (var i, n, r = t[0], s = t[1], a = [r, s], o = t.length, l = 2; l < o; l += 2) i = t[l], n = t[l + 1], (r - i) * (r - i) + (s - n) * (s - n) > e && (a.push(i), a.push(n), r = i, s = n);
                            return r !== i && s !== n && a.push(i, n), a
                        }, t.transformPolyline = function (t, e, i, n, r) {
                            for (var s = [], a = 0; a < t.length; a += 2) s.push(t[a] * e + i, t[a + 1] * n + r);
                            return s
                        }, t.outlinePolylineByVectors = function (t, e, i) {
                            for (var n = [], s = [], a = t.length - 2, o = 0; o < a; o += 2) {
                                var l = e[o] * i,
                                    h = e[o + 1] * i,
                                    u = t[o] + l,
                                    c = t[o + 1] + h,
                                    d = t[o + 2] + l,
                                    p = t[o + 3] + h;
                                n.push(u, c, d, p)
                            }
                            s = n.slice(0, 2), a = n.length - 4;
                            for (var o = 0; o < a; o += 4) {
                                var f = r.Geometry.lineIntersectsLine(n[o], n[o + 1], n[o + 2], n[o + 3], n[o + 4], n[o + 5], n[o + 6], n[o + 7]);
                                f === 1 / 0 ? s.push(n[o + 2], n[o + 3]) : s.push(n[o] + (n[o + 2] - n[o]) * f, n[o + 1] + (n[o + 3] - n[o + 1]) * f)
                            }
                            return s.push.apply(s, n.slice(-2)), s
                        }, t.calculatePolyArea = function (t) {
                            for (var e = 0, i = t, n = t.length - 2, r = 0; r < n; r += 2) e += i[r] * i[r + 3] - i[r + 2] * i[r + 1];
                            return e / 2
                        }, t.calculatePolyCentroid = function (t, e) {
                            var i, n = 0,
                                r = 0,
                                s = t.length - 2;
                            e *= 6;
                            for (var a = 0; a < s; a += 2) i = t[a] * t[a + 3] - t[a + 2] * t[a + 1], n += (t[a] + t[a + 2]) * i, r += (t[a + 1] + t[a + 3]) * i;
                            return {
                                x: n / e,
                                y: r / e
                            }
                        }, t.normalizeAngle = function (t) {
                            return t < 0 ? (t %= St, t += St) : t >= St && (t %= St), t
                        }, t.sectorBetweenAngles = function (t, e) {
                            for (; e < t;) e += St;
                            return e - t
                        }, t.subtractAngle = function (t, e) {
                            var i = t - e;
                            return i > Math.PI ? i -= St : i < -Math.PI && (i += St), i
                        }, t.rotateVector = function (t, e, i, n) {
                            return {
                                x: t * n - e * i,
                                y: t * i + e * n
                            }
                        }, t.circle2 = function (t, e, i) {
                            i.x = (t[0] + e[0]) / 2, i.y = (t[1] + e[1]) / 2, i.r = ((t[0] - e[0]) * (t[0] - e[0]) + (t[1] - e[1]) * (t[1] - e[1])) / 4
                        }, t.circle3 = function (t, e, i, n) {
                            var r = t[0],
                                s = t[1],
                                a = e[0],
                                o = e[1],
                                l = i[0],
                                h = i[1],
                                u = 2 * (r * (o - h) + a * (h - s) + l * (s - o));
                            if (0 === u) {
                                var c = Math.min(r, a, l),
                                    d = Math.min(s, o, h);
                                n.x = (c + Math.max(r, a, l)) / 2, n.y = (d + Math.max(s, o, h)) / 2, n.r = (n.x - c) * (n.x - c) + (n.y - d) * (n.y - d)
                            } else n.x = ((r * r + s * s) * (o - h) + (a * a + o * o) * (h - s) + (l * l + h * h) * (s - o)) / u, n.y = ((r * r + s * s) * (l - a) + (a * a + o * o) * (r - l) + (l * l + h * h) * (a - r)) / u, n.r = (r - n.x) * (r - n.x) + (s - n.y) * (s - n.y)
                        }, t.pointDistance = function (t, e) {
                            return (e[0] - t.x) * (e[0] - t.x) + (e[1] - t.y) * (e[1] - t.y)
                        }, t.pointsInCircle = function (e, i, n) {
                            return t.pointDistance(e, i) - e.r <= 1e-5 && (!n || t.pointDistance(e, n) - e.r <= 1e-5)
                        }, t.circumscribeCircle = function (e) {
                            function i(e, i, n, l, h) {
                                if (n ? t.circle3(e, i, n, s) : t.circle2(e, i, s), (!l || t.pointsInCircle(s, l, h)) && !(o && r.r <= s.r)) {
                                    var u = r;
                                    r = s, s = u, a[0] = e, a[1] = i, a[2] = n, o = !0
                                }
                            }
                            if (null == e || e.length < 1) return null;
                            if (1 === e.length) return {
                                x: e[0].x,
                                y: e[0].y,
                                r: e[0].r
                            };
                            var n = [
                                    [e[0].x - e[0].r, e[0].y],
                                    [e[0].x + e[0].r, e[0].y], null
                                ],
                                r = {
                                    x: 0,
                                    y: 0,
                                    r: 0
                                };
                            t.circle2(n[0], n[1], r);
                            for (var s = {
                                    x: 0,
                                    y: 0,
                                    r: 0
                                }, a = [
                                    [0, 0],
                                    [0, 0],
                                    [0, 0]
                                ], o = !1, l = t.pointKoef, h = [0, 0], u = 0; u < e.length; u++)
                                for (var c = 0; c < 8; c++)
                                    if (h[0] = e[u].x + e[u].r * l[c][0], h[1] = e[u].y + e[u].r * l[c][1], !(n[0][0] === h[0] && n[0][1] === h[1] || n[1][0] === h[0] && n[1][1] === h[1] || n[2] && n[2][0] === h[0] && n[2][1] === h[1] || t.pointsInCircle(r, h))) {
                                        var d = [h[0], h[1]];
                                        o = !1, i(n[0], d, null, n[1], n[2]), i(n[1], d, null, n[0], n[2]), i(n[0], n[1], d, n[2], null), n[2] && (i(n[2], d, null, n[0], n[1]), i(n[0], n[1], d, n[2], null), i(n[1], n[2], d, n[0], null), i(n[0], n[2], d, n[1], null));
                                        var p = n;
                                        n = a, a = p, u = -1;
                                        break
                                    }
                            return r.r = Math.sqrt(r.r), r
                        }, t.findWeightedCenter = function (t) {
                            for (var e = 0, i = 0, n = 0, r = 0; r < t.length; r++) {
                                var s = t[r];
                                e += s.x * s.r, i += s.y * s.r, n += s.r
                            }
                            return {
                                x: e / n,
                                y: i / n,
                                r: n / t.length
                            }
                        }, t
                    }();
                bt.pointKoef = [
                    [-1, 0],
                    [0, -1],
                    [1, 0],
                    [0, 1],
                    [Math.SQRT1_2, Math.SQRT1_2],
                    [-Math.SQRT1_2, Math.SQRT1_2],
                    [Math.SQRT1_2, -Math.SQRT1_2],
                    [-Math.SQRT1_2, -Math.SQRT1_2]
                ], r.Geometry = bt;
                var Ct = function () {
                    function t(t) {
                        this.scene = t, this.bounds = null
                    }
                    return t.prototype.setBounds = function (t, e, i, n) {
                        this.bounds = new mt(t, e, i, n)
                    }, t.prototype.findObjectAt = function (t, e, i) {
                        return null
                    }, t.prototype.remove = function () {}, t
                }();
                r.Layer = Ct,
                    function (t) {
                        t.ToolbarItemNames.fullscreen = function (t, e) {
                            var i = t.settings.localization.toolbar;
                            return new r.Bar.ToggleButton(t, e, {
                                labelDisabled: e.label || i.fullscreenButton,
                                titleDisabled: e.title || i.fullscreenTitle,
                                cssClassEnabled: "DVSL-bar-btn-fullscreen-active",
                                cssClassDisabled: e.cssClass || "DVSL-bar-btn-fullscreen",
                                onEnable: function () {
                                    return t.setFullscreen(!0)
                                },
                                onDisable: function () {
                                    return t.setFullscreen(!1)
                                },
                                getChartState: function () {
                                    return t.isFullscreen()
                                }
                            })
                        };
                        var e = function (t) {
                            function e() {
                                return t.apply(this, arguments) || this
                            }
                            return n(e, t), e.prototype.onSceneChange = function (e) {
                                t.prototype.onSceneChange.call(this, e);
                                var i = this.chart.scene.backStack.length > 0,
                                    n = this.options;
                                n.enabled !== i && (n.enabled = i, this.updateSettings())
                            }, e
                        }(t.Button);
                        t.ToolbarItemNames.back = function (t, i) {
                            // console.log('--------back function--------');

                            // console.log(t);
                            // console.log(i);
                            var n = t.settings.localization.toolbar;
                            i.label = i.label || n.backButton, i.title = i.title || n.backTitle, i.cssClass = i.cssClass || "DVSL-bar-btn-back";
                            var r = i.onClick;
                            return i.onClick = function (e, i) {
                                t.back(!0, "user"), r && r(e, i)
                            }, new e(t, i)
                        }
                    }(o = r.Bar || (r.Bar = {}));
                var xt = function () {
                    function t(t) {
                        this.seed = t, this.A = 48271, this.M = 2147483647, this.Q = this.M / this.A, this.R = this.M % this.A, this.oneOverM = 1 / this.M
                    }
                    return t.prototype.get = function () {
                        var t = this.seed / this.Q,
                            e = this.seed % this.Q,
                            i = this.A * e - this.R * t;
                        return i > 0 ? this.seed = i : this.seed = i + this.M, this.seed * this.oneOverM
                    }, t.prototype.getArrayElement = function (t) {
                        return t[t.length * this.get() | 0]
                    }, t
                }();
                r.Random = xt;
                var wt = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.animationOrder = 500, i.paintOrder = 35, i.updateOrder = 600, i.container = null, i.backgroundContainer = null, i.background = null, i.canvas = null, i.interactionContainer = null, i.menuContainer = null, i.outerBorder = null, i.scene = null, i.curThemeClass = null, i.chart = e, i.scene = e.scene, i
                    }
                    return n(e, t), e.setContainerStyle = function (t) {
                        t.style.position = "absolute", t.style.left = "0px", t.style.right = "0px", t.style.top = "0px", t.style.bottom = "0px"
                    }, e.prototype.createDom = function (t) {
                        this.shell = t, this.container = r.Helpers.createDom("div", "DVSL-container DVSL-" + t.chart.api.typeName), this.container.style.position = "relative", this.container.style.width = "100%", this.backgroundContainer = r.Helpers.createDom("div", "DVSL-background-container", null, this.container), e.setContainerStyle(this.backgroundContainer), this.background = r.Helpers.createDom("div", "DVSL-background", null, this.backgroundContainer), e.setContainerStyle(this.background), this.backgroundImage = r.Helpers.createDom("div", "DVSL-background-image", null, this.background), this.canvas = r.Helpers.createDom("canvas", "DVSL-canvas", null, this.container), e.setContainerStyle(this.canvas), this.outerBorder = r.Helpers.createDom("div", "DVSL-border", null, this.container), e.setContainerStyle(this.outerBorder), this.interactionContainer = r.Helpers.createDom("div", "DVSL-interaction", null, this.container), e.setContainerStyle(this.interactionContainer), this.menuContainer = r.Helpers.createDom("div", "DVSL-menu-container DVSL-menu-workaround", null, this.container), e.setContainerStyle(this.menuContainer), r.Helpers.createDom("span", "DVSL-empty", " ", this.menuContainer), this.updateSettings(this.scene.settings), this.interactionContainer.tabIndex = 0
                    }, e.prototype.updateSettings = function (t) {
                        if (r.Helpers.hasProp(t, "area.style.image")) {
                            var e = t.area.style.image;
                            this.backgroundImage.style.backgroundImage = e ? "url(" + e + ")" : ""
                        }
                        var i = this.curThemeClass,
                            n = this.scene.settings.advanced.themeCSSClass;
                        n !== i && (i && r.Helpers.removeClass(this.container, i), this.curThemeClass = n, r.Helpers.addClass(this.container, n))
                    }, e.prototype.doAnimations = function (t) {
                        t.changes.bounds && (this.backgroundImage.style.bottom = this.scene.bottomMargin + "px", this.backgroundImage.style.top = this.scene.topMargin + "px")
                    }, e
                }(k);
                r.DomLayer = wt;
                var Lt = function () {
                    function t(t, e, i) {
                        void 0 === i && (i = []), this.x = i, this.y1 = e, this.y0 = t
                    }
                    return t.prototype.isEmpty = function () {
                        return 0 === this.x.length
                    }, t.prototype.makeCopy = function () {
                        return new t(this.y0, this.y1, this.x.slice(0))
                    }, t.prototype.split = function (e) {
                        var i = new t(e, this.y1);
                        return this.y1 = e, i.x = this.x.slice(0), i
                    }, t.prototype.add = function (t, e) {
                        for (var i = [], n = this.x.length, r = 0; r < n && this.x[r + 1] < t;) i.push(this.x[r], this.x[r + 1]), r += 2;
                        for (r < n && (t = Math.min(this.x[r], t)); r < n && this.x[r] <= e;) e = Math.max(e, this.x[r + 1]), r += 2;
                        for (i.push(t, e); r < n;) i.push(this.x[r], this.x[r + 1]), r += 2;
                        return this.x = i, this
                    }, t.prototype.subtract = function (t, e) {
                        for (var i = [], n = this.x.length, r = 0; r < n && this.x[r + 1] <= t;) i.push(this.x[r], this.x[r + 1]), r += 2;
                        for (r < n && this.x[r] < t && i.push(this.x[r], t); r < n && this.x[r + 1] <= e;) r += 2;
                        for (r < n && this.x[r] < e && (i.push(e, this.x[r + 1]), r += 2); r < n;) i.push(this.x[r], this.x[r + 1]), r += 2;
                        return this.x = i, this
                    }, t.prototype.subtractSlice = function (t) {
                        if (this.isEmpty() || t.isEmpty()) return this;
                        for (var e = [], i = this.x, n = t.x, r = i.length, s = n.length, a = 0, o = 0, l = i[a], h = i[a + 1]; o < s;) {
                            var u = n[o],
                                c = n[o + 1];
                            if (l >= c) o += 2;
                            else if (u >= h) {
                                if (e.push(l, h), a += 2, a === r) break;
                                l = i[a], h = i[a + 1]
                            } else if (u > l && e.push(l, u), c < h) l = c, o += 2;
                            else {
                                if (a += 2, a === r) break;
                                l = i[a], h = i[a + 1]
                            }
                        }
                        for (; a < r && (e.push(l, h), a += 2, a !== r);) l = i[a], h = i[a + 1];
                        return this.x = e, this
                    }, t.prototype.intersectsSlice = function (t) {
                        if (this.isEmpty() || t.isEmpty()) return !1;
                        for (var e = this.x, i = t.x, n = e.length, r = i.length, s = 0, a = 0; a < r && s < n;) {
                            var o = e[s],
                                l = e[s + 1],
                                h = i[a],
                                u = i[a + 1];
                            if (o >= u) a += 2;
                            else {
                                if (!(h >= l)) return !0;
                                s += 2
                            }
                        }
                        return !1
                    }, t.prototype.coversSlice = function (t) {
                        if (t.isEmpty()) return !0;
                        for (var e = this.x, i = t.x, n = e.length, r = i.length, s = 0, a = 0; a < r && s < n;) {
                            var o = e[s],
                                l = e[s + 1],
                                h = i[a],
                                u = i[a + 1];
                            if (h >= l) s += 2;
                            else {
                                if (!(h >= o && u <= l)) return !1;
                                a += 2
                            }
                        }
                        return a === r
                    }, t.prototype.clip = function (t, e) {
                        for (var i = [], n = 0; n <= this.x.length - 2; n += 2) {
                            var r = this.x[n],
                                s = this.x[n + 1];
                            s > t && r < e && (i.push(Math.max(r, t)), i.push(Math.min(s, e)))
                        }
                        return this.x = i, this
                    }, t.prototype.tryMerge = function (t) {
                        if (this.x.length !== t.x.length || this.y1 !== t.y0) return !1;
                        for (var e = 0; e <= this.x.length - 1; e++)
                            if (this.x[e] !== t.x[e]) return !1;
                        return this.y1 = t.y1, !0
                    }, t.prototype.intersects = function (t, e) {
                        for (var i = 0; i <= this.x.length - 2; i += 2) {
                            var n = this.x[i],
                                r = this.x[i + 1];
                            if (n < e && r > t) return !0
                        }
                        return !1
                    }, t.prototype.covers = function (t, e) {
                        for (var i = 0; i <= this.x.length - 2; i += 2) {
                            var n = this.x[i],
                                r = this.x[i + 1];
                            if (n <= t && r >= e) return !0
                        }
                        return !1
                    }, t.prototype.findOverlappingRect = function (t, e, i) {
                        for (var n = !1, r = 0; r <= this.x.length - 2; r += 2) {
                            var s = this.x[r],
                                a = this.x[r + 1];
                            s < e && e - i < a && (t = Math.min(t, Math.max(s, e - i)), n = !0), a > t && t + i > s && (e = Math.max(e, Math.min(a, t + i)), n = !0)
                        }
                        return {
                            x0: t,
                            x1: e,
                            overlaps: n
                        }
                    }, t.prototype.toRects = function (t) {
                        for (var e = 0; e <= this.x.length - 2; e += 2) {
                            var i = this.x[e],
                                n = this.x[e + 1];
                            t.push(new r.Rect(i, this.y0, n, this.y1))
                        }
                    }, t
                }();
                r.AreaSlice = Lt;
                var Tt = function () {
                    function t() {
                        this.slices = [new Lt(-1e30, 1e30)]
                    }
                    return t.prototype.makeCopy = function () {
                        var e = new t;
                        e.slices = [];
                        for (var i = 0; i < this.slices.length; i++) {
                            var n = this.slices[i];
                            e.slices.push(n.makeCopy())
                        }
                        return e
                    }, t.prototype.getBounds = function () {
                        var t = 1 / 0,
                            e = -(1 / 0),
                            i = 1 / 0,
                            n = -(1 / 0);
                        if (this.slices.length > 1) {
                            i = this.slices[1].y0, n = this.slices[this.slices.length - 1].y1;
                            for (var s = 0; s < this.slices.length; s++) {
                                var a = this.slices[s];
                                a.x.length > 0 && (t = Math.min(t, a.x[0]), e = Math.max(e, a.x[a.x.length - 1]))
                            }
                        }
                        return new r.Rect(t, i, e, n)
                    }, t.prototype.addRect = function (t) {
                        if (t.isEmpty()) return this;
                        for (var e = t.x0, i = t.x1, n = t.y0, r = t.y1, s = [], a = null, o = 0; o < this.slices.length; o++) {
                            var l = this.slices[o];
                            if (l.y0 >= r || l.y1 <= n) a && a.tryMerge(l) || (s.push(l), a = l);
                            else {
                                if (n > l.y0) {
                                    var h = l.split(n);
                                    a && a.tryMerge(l) || (s.push(l), a = l), l = h
                                }
                                if (r < l.y1) {
                                    var h = l.split(r);
                                    l.add(e, i), a && a.tryMerge(l) || (s.push(l), a = l), l = h
                                } else l.add(e, i);
                                a && a.tryMerge(l) || (s.push(l), a = l)
                            }
                        }
                        return this.slices = s, this
                    }, t.prototype.subtractRect = function (t) {
                        if (t.isEmpty()) return this;
                        for (var e = t.x0, i = t.x1, n = t.y0, r = t.y1, s = [], a = null, o = 0; o < this.slices.length; o++) {
                            var l = this.slices[o];
                            if (l.y0 >= r || l.y1 <= n) a && a.tryMerge(l) || (s.push(l), a = l);
                            else {
                                if (n > l.y0) {
                                    var h = l.split(n);
                                    a && a.tryMerge(l) || (s.push(l), a = l), l = h
                                }
                                if (r < l.y1) {
                                    var h = l.split(r);
                                    l.subtract(e, i), a && a.tryMerge(l) || (s.push(l), a = l), l = h
                                } else l.subtract(e, i);
                                a && a.tryMerge(l) || (s.push(l), a = l)
                            }
                        }
                        return this.slices = s, this
                    }, t.prototype.clip = function (t) {
                        return 1
                    }, t.prototype.subtractArea = function (t) {
                        if (t.isEmpty()) return this;
                        for (var e = [], i = null, n = this.slices, r = t.slices, s = n.length, a = r.length, o = 0, l = 0, h = n[o]; l < a;) {
                            var u = r[l];
                            if (h.y1 <= u.y0) {
                                if (i && i.tryMerge(h) || (e.push(h), i = h), o += 1, o === s) break;
                                h = n[o]
                            } else if (u.y1 <= h.y0 || u.isEmpty()) l += 1;
                            else {
                                if (h.y0 < u.y0) {
                                    var c = h.split(u.y0);
                                    i && i.tryMerge(h) || (e.push(h), i = h), h = c
                                }
                                if (h.y1 > u.y1) {
                                    var c = h.split(u.y1);
                                    h.subtractSlice(u), i && i.tryMerge(h) || (e.push(h), i = h), h = c, l += 1
                                } else {
                                    if (h.subtractSlice(u), i && i.tryMerge(h) || (e.push(h), i = h), o += 1, o === s) break;
                                    h = n[o]
                                }
                            }
                        }
                        for (; o < s && (i && i.tryMerge(h) || (e.push(h), i = h), o += 1, o !== s);) h = n[o];
                        return this.slices = e, this
                    }, t.prototype.intersectsArea = function (t) {
                        if (t.isEmpty() || this.isEmpty()) return !1;
                        for (var e = this.slices, i = t.slices, n = e.length, r = i.length, s = 0, a = 0; a < r && s < n;) {
                            var o = i[a],
                                l = e[s];
                            if (l.intersectsSlice(o)) return !0;
                            l.y1 < o.y1 ? s += 1 : o.y1 < l.y1 ? a += 1 : (s += 1, a += 1)
                        }
                        return !1
                    }, t.prototype.coversArea = function (t) {
                        if (t.isEmpty()) return !0;
                        for (var e = this.slices, i = t.slices, n = e.length, r = i.length, s = 0, a = 0; a < r && s < n;) {
                            var o = i[a],
                                l = e[s];
                            if (!l.coversSlice(o)) return !1;
                            l.y1 < o.y1 ? s += 1 : o.y1 < l.y1 ? a += 1 : (s += 1, a += 1)
                        }
                        return !0
                    }, t.prototype.findOverlappingRect = function (t, e) {
                        if (this.isEmpty()) return null;
                        for (var i = this.slices[1].x[0], n = Math.min(this.slices[1].x[1], i + t), s = this.slices[1].y0, a = Math.min(this.slices[1].y1, s + e), o = 0; o < this.slices.length; o++) {
                            var l = this.slices[o];
                            if (l.y0 >= s + e) break;
                            var h = l.findOverlappingRect(i, n, t);
                            i = h.x0, n = h.x1;
                            var u = h.overlaps;
                            u && (a = Math.min(l.y1, s + e))
                        }
                        return new r.Rect(i, s, n, a)
                    }, t.prototype.findTopPosition = function (t, e) {
                        for (var i = 1 / 0, n = 0; n < this.slices.length; n++) {
                            var r = this.slices[n];
                            r.covers(t, e) && (i = Math.min(i, r.y0))
                        }
                        return i === 1 / 0 ? 0 : i
                    }, t.prototype.intersects = function (t) {
                        for (var e = t.x0, i = t.x1, n = t.y0, r = t.y1, s = 0; s < this.slices.length; s++) {
                            var a = this.slices[s];
                            if (a.y0 < r && a.y1 > n && a.intersects(e, i)) return !0
                        }
                        return !1
                    }, t.prototype.isEmpty = function () {
                        return 1 === this.slices.length && this.slices[0].isEmpty()
                    }, t.prototype.coversRect = function (t) {
                        for (var e = t.x0, i = t.x1, n = t.y0, r = t.y1, s = 0; s < this.slices.length; s++) {
                            var a = this.slices[s];
                            if (n < a.y1 && r > a.y0 && !a.covers(e, i)) return !1
                        }
                        return !0
                    }, t.prototype.toRects = function () {
                        for (var t = [], e = 0; e < this.slices.length; e++) {
                            var i = this.slices[e];
                            i.toRects(t)
                        }
                        return t
                    }, t
                }();
                r.AreaCollection = Tt;
                var kt = navigator.userAgent.match(/AppleWebKit\/(\d+)/),
                    At = kt ? parseInt(kt[1], 10) : 1e6,
                    Mt = function () {
                        function e(t, i) {
                            var n = this;
                            this.chart = null, this.settings = null, this.scene = null, this.events = null, this.profiler = null, this.container = null, this.canvas = null, this.scaleX = 1, this.scaleY = 1, this.paintRequested = null, this.labelRenderer = null, this.prevTime = null, this.paintNowInProgreess = !1, this.animationInProgress = !1, this.mouseEvents = null, this.innerAreaCache = null, this.chartWidth = 0, this.chartHeight = 0, this.sizeChanged = !0, this.fullScreenMode = !1, this.fullscreenBeforeW = 0, this.fullscreenBeforeH = 0, this.lastCursor = null, this.chart = t, this.settings = t.settings, this.scene = t.scene, this.domLayer = i, this.buildDom(), this.labelRenderer = new G(this.settings, this.chart.assetsLoader, this.container), this.mouseEvents = new w(this.domLayer.interactionContainer, this.settings.advanced.pointer, [this.domLayer.menuContainer]), this.profiler = new I(this);
                            for (var r = 0; r < e.MouseEventConfig.length; r++) {
                                var s = e.MouseEventConfig[r];
                                ! function (t) {
                                    n.mouseEvents.listen(t.ev, function (e) {
                                        return n.notifyMouseEvent(e, t)
                                    })
                                }(s)
                            }
                            this.events = new D(t, this), this.events.addElement(this.domLayer), this.containerResizeFunc = function () {
                                return n.updateSize(!1)
                            }, d.listenResize(this.container, this.containerResizeFunc), d.listen(window, "resize", this.containerResizeFunc)
                        }
                        return e.prototype.forceChromeRedraw = function () {
                            var t = this.menuContainer.style,
                                e = t.transform;
                            t.transform = "translateZ(0)", window.setTimeout(function () {
                                t.transform = e
                            }, 1)
                        }, e.prototype.updateSize = function (t) {
                            var e, i, n = this.settings.area;
                            this.fullScreenMode ? (e = window.innerWidth, i = window.innerHeight) : this.fullscreenBeforeW > 0 ? (e = this.fullscreenBeforeW, i = this.fullscreenBeforeH, this.fullscreenBeforeW = 0, this.fullscreenBeforeH = 0) : (e = n.width || Math.min(n.maxWidth, this.container.clientWidth), i = n.height || Math.min(n.maxHeight, this.container.clientHeight), e > 0 && i < 2 && (i = this.settings.area.height || this.settings.area.defaultHeight), e = Math.max(n.minWidth, e), i = Math.max(n.minHeight, i)), (t || e >= 2 && e !== this.chartWidth || i >= 2 && i !== this.chartHeight) && this.setSize(e, i, t), d.updateResize(this.container)
                        }, e.prototype.setSize = function (t, e, i) {
                            this.chart.log("Update size: " + e + ", " + t);
                            var n = this.domLayer.container.style;
                            n.height = e + "px", n.width = t + "px", this.chartHeight = e, this.chartWidth = t, this.sizeChanged = !0, this.events.setNewSize(new mt(0, 0, t, e), !0, i)
                        }, e.prototype.setFullscreen = function (t) {
                            t !== this.fullScreenMode && (this.fullScreenMode = t, t ? (this.fullscreenBeforeW = this.scene.chartWidth, this.fullscreenBeforeH = this.scene.chartHeight, d.addClass(this.domLayer.container, "DVSL-fullscreen")) : d.removeClass(this.domLayer.container, "DVSL-fullscreen"), this.updateSize(!0))
                        }, e.prototype.buildDom = function () {
                            if (!this.settings.container) throw new Error("Chart container is not defined in the settings.");
                            if (!d.isDomObject(this.settings.container)) throw new Error("Chart container is not a DOM object.");
                            this.container = this.settings.container, null != this.container._DVSL_ChartInstance && this.container._DVSL_ChartInstance.remove(), this.container.innerHTML = "<!--ZoomCharts " + t.PackageInfo.Version + "-->", this.container._DVSL_ChartInstance = this.chart, this.domLayer.createDom(this), this.container.appendChild(this.domLayer.container), this.backgroundContainer = this.domLayer.backgroundContainer, this.interactiveContainer = this.domLayer.interactionContainer, this.menuContainer = this.domLayer.menuContainer, this.canvas = this.domLayer.canvas
                        }, e.prototype.remove = function () {
                            this.mouseEvents.remove(), this.domLayer.remove(), d.unlistenResize(this.container), delete this.container._DVSL_ChartInstance, d.unlisten(window, "resize", this.containerResizeFunc), this.container.innerHTML = ""
                        }, e.prototype.updateSettings = function (t) {
                            t.area && this.updateSize(!0), this.domLayer.updateSettings(t)
                        }, e.prototype.notifyMouseEvent = function (t, e) {
                            this.chart.removed || (t.consumed = !1, this.events.onMouseEvent(t, e), t.cursor || (t.cursor = "move"), this.lastCursor !== t.cursor && (this.interactiveContainer.style.cursor = t.cursor, this.menuContainer.style.cursor = t.cursor, this.lastCursor = t.cursor))
                        }, e.prototype.requestPaint = function () {
                            var t = this;
                            null === this.paintRequested && (this.settings.advanced.useAnimationFrame ? this.paintRequested = r.Helpers.requestAnimationFrame(function (e, i) {
                                return t.paintScene(i ? e : null)
                            }) : this.paintRequested = window.setTimeout(function () {
                                return t.paintScene(null)
                            }, 5))
                        }, e.prototype.paintNow = function (t) {
                            return void 0 === t && (t = !1), this.paintNowInProgreess ? void this.chart.error("paintNow called from within paintNow call") : (this.paintNowInProgreess = !0, (null !== this.paintRequested || t) && (this.settings.advanced.useAnimationFrame ? r.Helpers.cancelAnimationFrame(this.paintRequested) : window.clearTimeout(this.paintRequested), this.paintScene(null)), void(this.paintNowInProgreess = !1))
                        }, e.prototype.paintScene = function (t) {
                            if (!this.chart.removed) {
                                this.paintRequested = null;
                                var e = null !== t ? t : d.performanceNow(),
                                    i = new L;
                                i.timeStamp = e, i.isExport = !1, this.prevTime && this.animationInProgress ? (i.dtime = i.timeStamp - this.prevTime, i.dtime > 1e3 && (i.dtime = 1e3), i.dtime < 1 && (i.dtime = 1)) : i.dtime = 30, this.prevTime = e, this.chartWidth > 0 && this.chartHeight > 0 && (this.sizeChanged && (this.resizeCanvas(), this.sizeChanged = !1), this.innerAreaCache = null, this.events.animateFrame(i), i.animating ? (this.animationInProgress = !0, this.events.requestPaint()) : this.animationInProgress = !1, this.profiler.paintDone())
                            }
                        }, e.prototype.resizeCanvas = function () {
                            var t = this.chart.settings.advanced,
                                e = 1,
                                i = 1;
                            if (t.highDPI === !0) {
                                var n = d.canvasScaling();
                                e = n.x, i = n.y
                            } else t.highDPI > 0 && (e = i = t.highDPI);
                            var r, s, a = this.chartWidth,
                                o = this.chartHeight,
                                l = Math.max(100, t.maxCanvasWidth),
                                h = Math.max(100, t.maxCanvasHeight),
                                u = 0,
                                c = 0;
                            do u++, r = Math.ceil(a * e / u); while (r > l);
                            do c++, s = Math.ceil(o * i / c); while (s > h);
                            e /= u, i /= c, a = r / e, o = s / i, this.scaleX = e, this.scaleY = i, this.canvas.width = r, this.canvas.height = s, this.canvas.style.width = a + "px", this.canvas.style.height = o + "px"
                        }, e.prototype.prepareContext = function (t) {
                            var e = this.scene,
                                i = this.canvas,
                                n = i.getContext("2d");
                            n.setTransform(1, 0, 0, 1, 0, 0), n.clearRect(0, 0, i.width, i.height), 534 === At && (i.style.display = "none", i.offsetHeight, i.style.display = "inherit"), this.areaStylesBefore(n, this.canvas);
                            var r = this.scaleX,
                                s = this.scaleY;
                            n.setTransform(r, 0, 0, s, 0, 0), n.__scaleX = r, n.__scaleY = s, t.context = n, t.scaleX = r, t.scaleY = s, t.labelRenderer = this.labelRenderer, this.labelRenderer.startFrame(e.chartWidth, e.chartHeight, r, s)
                        }, e.prototype.areaStylesBefore = function (t, e) {
                            var i = this.settings.area.style.fillColor;
                            i && (t.fillStyle = i, t.fillRect(0, 0, e.width, e.height))
                        }, e.prototype.areaStylesAfter = function (t, e) {
                            var i = this.settings.area.style.overlayColor;
                            i && (t.fillStyle = i, t.setTransform(1, 0, 0, 1, 0, 0), t.fillRect(0, 0, e.width, e.height))
                        }, e.prototype.finalizeContext = function (t) {
                            this.areaStylesAfter(t.context, this.canvas), this.labelRenderer.finishFrame()
                        }, e.prototype.exportToImageGetDimensions = function () {
                            var t = new L;
                            t.isExport = !0, t.context = this.canvas.getContext("2d"), t.labelRenderer = this.labelRenderer;
                            var e = this.events.updateLayout(t);
                            return t.isExport = !1, this.events.updateLayout(t), {
                                width: e.w(),
                                height: e.h()
                            }
                        }, e.prototype.exportToContext = function (t, e, i) {
                            var n = new G(this.settings, this.chart.assetsLoader, this.container);
                            n.allowCache = !1, n.startFrame(1, 1, i, i);
                            var r = new L;
                            r.isExport = !0, r.timeStamp = this.prevTime, r.dtime = 0, r.context = t, r.scaleX = i, r.scaleY = i, r.labelRenderer = n;
                            var s = this.events.updateLayout(r);
                            this.areaStylesBefore(t, e), t.save(), t.setTransform(i, 0, 0, i, -s.x0 * i, -s.y0 * i), this.events.doPaint(r), this.areaStylesAfter(t, e), r.isExport = !1, this.events.updateLayout(r), H.restore(t)
                        }, e.prototype.getChartInnerArea = function () {
                            if (this.innerAreaCache) return this.innerAreaCache;
                            var t = new r.AreaCollection;
                            t.addRect(new r.Rect(this.scene.x0, this.scene.y0, this.scene.x0 + this.scene.width, this.scene.y0 + this.scene.height));
                            for (var e = this.menuContainer.getBoundingClientRect(), i = e.left, n = e.top, s = this.menuContainer.children, a = 0; a < s.length; a += 1) {
                                var o = s[a];
                                if (o.offsetHeight > 0 || o.offsetWidth > 0) {
                                    var l = o.getBoundingClientRect();
                                    t.subtractRect(new mt(l.left - i, l.top - n, l.right - i, l.bottom - n))
                                }
                            }
                            return this.innerAreaCache = t, t
                        }, e
                    }();
                Mt.MouseEventConfig = [{
                    ev: w.EVENT_GLOBAL_DOWN,
                    name: "GlobalPointerDown"
                }, {
                    ev: w.EVENT_DOWN,
                    name: "PointerDown",
                    captures: !0
                }, {
                    ev: w.EVENT_UP,
                    name: "PointerUp",
                    needsCapture: !0,
                    releasesCapture: !0
                }, {
                    ev: w.EVENT_DRAG,
                    name: "PointerDrag",
                    needsCapture: !0,
                    captures: !0
                }, {
                    ev: w.EVENT_MOVE,
                    name: "PointerMove",
                    captures: !0
                }, {
                    ev: w.EVENT_LEAVE,
                    name: "PointerOut"
                }, {
                    ev: w.EVENT_CANCEL,
                    name: "PointerCancel",
                    needsCapture: !0,
                    releasesCapture: !0
                }, {
                    ev: w.EVENT_CLICK,
                    name: "Click"
                }, {
                    ev: w.EVENT_INSTACLICK,
                    name: "InstantClick"
                }, {
                    ev: w.EVENT_LONGPRESS,
                    name: "LongPress"
                }, {
                    ev: w.EVENT_RCLICK,
                    name: "RightClick"
                }, {
                    ev: w.EVENT_DBLCLICK,
                    name: "DoubleClick"
                }, {
                    ev: w.EVENT_TPLCLICK,
                    name: "TripleClick"
                }, {
                    ev: w.EVENT_WHEEL,
                    name: "Wheel"
                }], r.ChartOuterShell = Mt;
                var It = function () {
                    function t(t, e) {
                        this.fullScreenMode = !1, this.chart = t, this.settings = t.settings, this.scene = t.scene, this.parentShell = e, this.buildDom(), this.events = new D(t, this), this.parentShell.events.addSubchart(this.chart), this.updateSize()
                    }
                    return t.prototype.getChartInnerArea = function () {
                        return this.parentShell.getChartInnerArea()
                    }, t.prototype.requestPaint = function () {
                        this.parentShell.requestPaint()
                    }, t.prototype.paintNow = function (t) {
                        this.parentShell.paintNow(t)
                    }, t.prototype.buildDom = function () {
                        this.container = this.parentShell.container, this.interactiveContainer = this.parentShell.interactiveContainer, this.backgroundContainer = this.parentShell.backgroundContainer, this.menuContainer = this.parentShell.menuContainer
                    }, t.prototype.remove = function () {
                        this.parentShell.events.removeSubchart(this.chart)
                    }, t.prototype.updateSettings = function (t) {
                        t.area && this.updateSize()
                    }, t.prototype.updateSize = function (t) {
                        void 0 === t && (t = !1);
                        var e = this.settings.area;
                        this.events.setNewSize(new mt(e.left, e.top, e.left + e.width, e.top + e.height), !1, t)
                    }, t.prototype.prepareContext = function (t) {
                        var e = this.settings.area.style;
                        if (e.fillColor) {
                            var i = t.context,
                                n = this.scene;
                            i.fillStyle = e.fillColor, i.fillRect(n.chartLeft, n.chartTop, n.chartWidth, n.chartHeight)
                        }
                    }, t.prototype.finalizeContext = function (t) {
                        var e = this.settings.area.style;
                        if (e.overlayColor) {
                            var i = t.context,
                                n = this.scene;
                            i.fillStyle = e.overlayColor, i.fillRect(n.chartLeft, n.chartTop, n.chartWidth, n.chartHeight)
                        }
                    }, t.prototype.forceChromeRedraw = function () {
                        this.parentShell.forceChromeRedraw()
                    }, t.prototype.setFullscreen = function (t) {}, t
                }();
                r.ChartInnerShell = It;
                var Pt = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.animationOrder = 2e3, i.paintOrder = 70, i.updateOrder = 200, i.scene = null, i.loadingTime = null, i.chart = e, i.scene = e.scene, i
                    }
                    return n(e, t), e.prototype.doAnimations = function (t) {
                        this.scene.loading && (t.animating = !0)
                    }, e.prototype.paintScene = function (t) {
                        var e = this.scene,
                            i = e.getMessage(),
                            n = e.settings.advanced.style,
                            r = n.loadingArcStyle,
                            s = e.loading && "hidden" !== r.location;
                        if (s || (this.loadingTime = null), i || s) {
                            null === this.loadingTime && (this.loadingTime = t.timeStamp);
                            var a, o, l = t.context,
                                h = "corner" === r.location,
                                u = r.r,
                                c = r.lineWidth;
                            if (h) {
                                a = e.x0 + e.width - 1.2 * (u + c), o = e.y0 + 1.2 * (u + c);
                                var d = this.chart.shell.getChartInnerArea();
                                o += d.findTopPosition(a, a)
                            } else a = e.x0 + e.width / 2, o = e.y0 + e.height / 2 + u;
                            if (i) {
                                var p = n.messageTextStyle;
                                l.textBaseline = "top", l.textAlign = "left";
                                var f = H.getTextHeight(l, p.font),
                                    g = H.getTextWidth(l, p, i),
                                    m = void 0,
                                    v = void 0,
                                    y = void 0,
                                    S = n.messageBackgroundStyle,
                                    b = S.padding || 0;
                                s && (h ? (a -= b, m = a - 1.2 * u - g, v = f > 2 * u ? 4 : o - f / 2, y = g + 2.2 * u) : (o -= f / 2, m = a - g / 2, v = o + 1.3 * f, y = g));
                                var C = H.beginStrokeAndFill(l, S);
                                C.rect(m - b, o - u - b, y + 2 * b, v - o + u + 2 * b + f), H.endStrokeAndFill(l, C, S), H.drawText(l, p, i, m, v), H.resetTextStyle(l)
                            }
                            if (s) {
                                l.save(), l.lineCap = "round", l.lineWidth = c;
                                var x = (t.timeStamp - this.loadingTime) / 700 * Math.PI,
                                    w = l.createLinearGradient(a + u * Math.cos(x + Math.PI), o + u * Math.sin(x + Math.PI), a + u * Math.cos(x), o + u * Math.sin(x));
                                w.addColorStop(0, r.lineColor), w.addColorStop(1, "transparent"), l.strokeStyle = w, l.beginPath(), l.arc(a, o, u, x, x + Math.PI), l.stroke(), H.restore(l)
                            }
                        }
                    }, e
                }(k);
                r.MessagesOverlay = Pt;
                var Dt = "undefined" != typeof document ? document.currentScript : null,
                    Nt = null,
                    Ft = function () {
                        if (Nt) return Nt;
                        if ("undefined" == typeof document) return "";
                        var e = t.PackageInfo.LibraryName;
                        "<?" === e.substr(0, 2) && (e = "everything");
                        var i = e.indexOf("-");
                        i > -1 && (e = e.substr(0, i));
                        for (var n = new RegExp("^(.*?/" + e + "(-dev|.min|).js)"), s = document.getElementsByTagName("script"), a = 0; a < s.length; a++) {
                            var o = s[a].src;
                            if (o) {
                                var l = o.match(n);
                                if (l) return Nt = l[1] + "/../assets/"
                            }
                        }
                        return Dt && Dt.src ? (r.Helpers.warn("Cannot locate the ZoomCharts script path based on file name '" + e + ".js'. The script path was detected using `document.currentScript` which is not supported on all browsers. Please specify 'assetsUrlBase' in settings when creating the chart for full browser compatibility."),
                            Nt = Dt.src.match(/^([^?#]*)/)[1] + "/../assets/") : Nt = ""
                    },
                    Ot = function () {
                        function t() {}
                        return t.hasPendingRequests = function () {
                            return d.hasProperties(this._imageLoading) || d.hasProperties(this.pendingHTMLAssets)
                        }, t.getAssetImage = function (t, e, i) {
                            var n = this;
                            if (this._imageCache.hasOwnProperty(t)) return this._imageCache[t];
                            if (this._imageLoading.hasOwnProperty(t)) return null;
                            if (!t) return null;
                            var r = function (e) {
                                    if (delete n._imageLoading[t], n._imageCache[t] = e, i) return i(e)
                                },
                                s = function () {
                                    var t = c.ErrorImage,
                                        i = n._imageCache[t];
                                    if (i) r(i);
                                    else if (n._imagesPendingForErrors.push(r), !n._imageLoading.hasOwnProperty(t)) {
                                        var s = function (e) {
                                            delete n._imageLoading[t], n._imageCache[t] = e;
                                            for (var i = 0; i < n._imagesPendingForErrors.length; i++) {
                                                var r = n._imagesPendingForErrors[i];
                                                r(e)
                                            }
                                            n._imagesPendingForErrors = null
                                        };
                                        d.buildImage(t, e, s, function () {
                                            d.error("Could not load '" + t + "'")
                                        }), n._imageCache.hasOwnProperty(t) || (n._imageLoading[t] = !0)
                                    }
                                };
                            return this._imageLoading[t] = !0, d.buildImage(t, e, r, s), this._imageCache.hasOwnProperty(t) ? this._imageCache[t] : null
                        }, t.loadHtmlAssets = function (t, e) {
                            for (var i = this, n = !1, r = 0; r < t.length; r++) {
                                var s = t[r];
                                this.loadedHTMLAssets[s.url] || (this.pendingHTMLAssets[s.url] ? n = !0 : this.loadHTMLAsset(s, function (t) {
                                    return i.htmlAssetLoaded(t)
                                }) && (this.pendingHTMLAssets[s.url] = !0, n = !0))
                            }
                            return !!n && (this.callbacks.push(e), !0)
                        }, t.htmlAssetLoaded = function (t) {
                            if (delete this.pendingHTMLAssets[t], this.loadedHTMLAssets[t] = !0, !d.hasProperties(this.pendingHTMLAssets)) {
                                for (var e = 0; e < this.callbacks.length; e += 1) this.callbacks[e](this.errors);
                                this.callbacks = [], this.errors = []
                            }
                        }, t.loadHTMLAsset = function (t, e) {
                            var i, n = this,
                                s = t.url,
                                a = s.toUpperCase(),
                                o = a.indexOf(".CSS"),
                                l = a.indexOf(".JS"),
                                h = !1,
                                u = null,
                                c = !1,
                                p = function () {
                                    u && window.clearInterval(u), c || (c = !0, !h && t.required && t.required() && n.errors.push("The `required` delegate did not return `false` after loading " + s), e(s))
                                },
                                f = function () {
                                    u && window.clearInterval(u), c || (c = !0, n.errors.push("Failed to load asset: " + s), e(s))
                                };
                            if (o > l) {
                                var g = document.createElement("link");
                                if (g.rel = "stylesheet", g.href = s, g.type = "text/css", !t.required) {
                                    r.Helpers.warn("Asset url " + s + " does not define the `required` delegate which prevents the detection of asset load in older browsers.");
                                    var m = 5;
                                    t.required = function () {
                                        return m-- > 0
                                    }, h = !0
                                }
                                var v = 100;
                                u = window.setInterval(function () {
                                    v-- < 0 ? f() : t.required() || p()
                                }, 100), i = g
                            } else {
                                if (!(l > -1)) return this.errors.push("Assets: Do not know how to load " + s + '. The URL should contain either ".css" or ".js" - it can be either in the path, the file name or the query string.'), !1;
                                var y = document.createElement("script");
                                y.src = s, y.type = "text/javascript", y.async = !1, i = y
                            }
                            return d.listen(i, "load", p), d.listen(i, "error", f), document.getElementsByTagName("head")[0].appendChild(i), !0
                        }, t
                    }();
                Ot._imageCache = {}, Ot._imageLoading = {}, Ot._imagesPendingForErrors = [], Ot.loadedHTMLAssets = {}, Ot.pendingHTMLAssets = {}, Ot.callbacks = [], Ot.errors = [];
                var Et = function () {
                    function e(t) {
                        this.chart = t, this.settings = t.settings;
                        var e = this.settings.assetsUrlBase || Ft();
                        e.length > 0 && "/" !== e[e.length - 1] && (e += "/"), this.assetsUrlBase = e
                    }
                    return e.prototype.getAssetUrl = function (e) {
                        return 0 === e.indexOf("builtin://") ? this.settings.advanced.builtinAssets[e.slice(10)] : 0 === e.indexOf("assets://") ? (this.assetsUrlBase || this.chart.error("Cannot locate the ZoomCharts script path based on file name '" + t.PackageInfo.LibraryName + ".js'. Please specify 'assetsUrlBase' in settings when creating the chart."), this.assetsUrlBase + e.slice(9)) : e
                    }, e.prototype.hasPendingRequests = function () {
                        return Ot.hasPendingRequests()
                    }, e.prototype.getAssetImage = function (t, e) {
                        var i = this;
                        return Ot.getAssetImage(this.getAssetUrl(t), this.settings.advanced.crossOriginHeader, function (t) {
                            i.chart.events.requestPaint(), e && e(t)
                        })
                    }, e.prototype.ensureAssetsList = function (t, e) {
                        for (var i = [], n = 0; n < t.length; n++) {
                            var r = t[n];
                            d.isString(r) ? i.push({
                                url: r,
                                required: null
                            }) : r.required && !r.required() || i.push(r)
                        }
                        var s = this.loadAssetsList(i, function () {
                            e(!0)
                        });
                        s || e(!1)
                    }, e.prototype.loadAssetsList = function (t, e) {
                        for (var i = this, n = 0; n < t.length; n++) {
                            var r = t[n];
                            r.url = this.getAssetUrl(r.url)
                        }
                        var s = function (t) {
                                for (var n = 0; n < t.length; n += 1) i.chart.error(t[n]);
                                i.chart.log("Assets loaded"), e()
                            },
                            a = Ot.loadHtmlAssets(t, s);
                        return a && this.chart.log("Loading assets"), a
                    }, e
                }();
                r.AssetsLoader = Et;
                var Rt = function () {
                    function t(e, i, n, r, s) {
                        if (void 0 === r && (r = "<>"), void 0 === s && (s = null), this.t = 0, this.startSpeed = 0, this.duration = n, this.from = e, this.to = i, null == this.from && (this.from = this.to), this.startTime = s, this.x = this.from, this.t = this.startTime, this.formula = t.easingFormulas[r], !this.formula) throw new Error("Easing formula not defined: " + r)
                    }
                    return t.prototype.jump = function (t) {
                        this.to = t, this.from = t, this.x = t, this.t = this.startTime = null
                    }, t.prototype.reset = function (t, e, i) {
                        void 0 === i && (i = null), this.from = t, this.to = e, this.startTime = i, this.x = this.from, this.t = this.startTime
                    }, t.prototype.retarget = function (t, e) {
                        return this.finished(this.t) ? this.startSpeed = 0 : (this.startSpeed = this._getSpeed(), e || (e = this.t)), e ? (this.from = this.get(e), this.startTime = e) : (this.startTime = null, this.from = this.x), this.to = t, this
                    }, t.prototype.switchCoordinates = function (t, e) {
                        this.from = this.from * e + t, this.x = this.x * e + t, this.to = this.to * e + t, this.startSpeed = this.startSpeed * e
                    }, t.prototype.updateAndGet = function (t, e) {
                        var i = this.x !== t;
                        return t !== this.to && this.retarget(t, e), {
                            value: this.get(e),
                            changes: i
                        }
                    }, t.prototype.updateAndGetFixed = function (t, e) {
                        var i = this.x !== t;
                        return t !== this.to && (this.startSpeed = 0, this.startTime = e, this.from = this.x, this.to = t), {
                            value: this.get(e),
                            changes: i
                        }
                    }, t.prototype.getClean = function (t) {
                        return this.duration <= 0 ? this.to : this.startTime ? this._calculate(t) : this.from
                    }, t.prototype._calculate = function (t) {
                        var e = Math.min(1, Math.max(t - this.startTime, 0) / this.duration);
                        if (e >= 1) return this.to;
                        var i = this.formula(e),
                            n = i * (this.to - this.from);
                        if (this.startSpeed && e < 1) {
                            var r = this.startSpeed * e * this.duration;
                            n = n * i + r * (1 - i)
                        }
                        return n = this.from + n
                    }, t.prototype.get = function (t) {
                        if (this.duration <= 0) return this.t = t, this.x = this.to, this.to;
                        this.startTime || (this.startTime = t);
                        var e = this._calculate(t);
                        return this.t = t, this.x = e, e
                    }, t.prototype.finished = function (t) {
                        return this.startTime || (this.startTime = t), t >= this.startTime + this.duration
                    }, t.prototype._getSpeed = function () {
                        var t = this.t,
                            e = this.duration / 1e3,
                            i = this.getClean(t - e / 2),
                            n = this.getClean(t + e / 2);
                        return this.t = t, (n - i) / e
                    }, t
                }();
                Rt.easingFormulas = {
                    "=": function (t) {
                        return t
                    },
                    "<>": function (t) {
                        return t < .5 ? 2 * t * t : -.5 * ((2 * t - 1) * (2 * t - 3) - 1)
                    },
                    scroll: function (t) {
                        return 1 - (1 - t) * (1 - t)
                    }
                }, r.Animator = Rt;
                var Ht = function () {
                    function t(t, e, i, n, r) {
                        void 0 === n && (n = "<>"), void 0 === r && (r = null), this._animator = new Rt(0, 1, i, n, r), this.reset(t, e, r)
                    }
                    return t.prototype.reset = function (t, e, i) {
                        return d.isString(t) || null == t ? this._fromColor = O.parse(t) : this._fromColor = t, d.isString(e) || null == e ? this._toColor = O.parse(e) : this._toColor = e, this._animator.reset(0, 1, i), this
                    }, t.prototype.getColor = function (t) {
                        var e = Math.min(1, this._animator.get(t));
                        return this._lastValue = O.blend(this._fromColor, this._toColor, e)
                    }, t.prototype.get = function (t) {
                        return O.format(this.getColor(t))
                    }, t.prototype.updateAndGet = function (t, e) {
                        (d.isString(t) || null == t) && (t = O.parse(t));
                        var i = !O.areEqual(this._lastValue, t);
                        return O.areEqual(this._toColor, t) || this.reset(this._lastValue, t, e), {
                            value: this.get(e),
                            changes: i
                        }
                    }, t.prototype.finished = function (t) {
                        return this._animator.finished(t)
                    }, t
                }();
                r.ColorAnimator = Ht;
                var Bt = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.animationOrder = 0, i.paintOrder = 1e4, i.touches = {}, i.fps = 0, i.prevFrame = null, i.frameCount = 0, i.chart = e, i.settings = e.settings.advanced, i.captureTouches = i.settings.showTouches, i
                    }
                    return n(e, t), e.prototype.onSceneChange = function (t) {
                        this.captureTouches = this.settings.showTouches
                    }, e.prototype.paintScene = function (t) {
                        var e = "";
                        if (this.settings.showTimestamp && (e += Math.round(t.timeStamp)), this.settings.showFPS) {
                            if (this.frameCount += 1, this.prevFrame) {
                                var i = Math.max(t.timeStamp - this.prevFrame, 1) / 1e3,
                                    n = 1 / i,
                                    r = Math.min(1, 3 * i);
                                this.fps = this.fps * (1 - r) + n * r
                            }
                            this.prevFrame = t.timeStamp, e += "FPS:" + Math.round(this.fps)
                        }
                        var s = t.context;
                        if (this.captureTouches) {
                            var a = this.settings.showTouchTrail,
                                o = 0;
                            for (var l in this.touches) {
                                var h = this.touches[l];
                                if (this.touches.hasOwnProperty(l)) {
                                    s.beginPath(), s.moveTo(h.dx, h.dy);
                                    for (var u = 0; u < h.trace.length; u++) {
                                        var c = h.trace[u];
                                        s.lineTo(c.x, c.y)
                                    }
                                    a && h.cancelled ? (s.strokeStyle = "red", s.fillStyle = "red", s.lineWidth = 1) : a && h.up ? (s.strokeStyle = "gray", s.fillStyle = "gray", s.lineWidth = 3) : (s.strokeStyle = "rgba(180,180,180,0.4)", s.fillStyle = "rgba(180,180,180,0.3)", s.lineWidth = 3), s.moveTo(h.x + 30, h.y), s.stroke(), s.lineWidth = 1.5, s.beginPath(), s.arc(h.x, h.y, h.animator.get(t.timeStamp), 0, 2 * Math.PI), s.stroke(), s.fill(), h.up || (o += 1), h.animator.finished(t.timeStamp) || (t.animating = !0)
                                }
                            }
                            s.beginPath(), s.fillStyle = "black";
                            for (var l in this.touches)
                                if (this.touches.hasOwnProperty(l))
                                    for (var h = this.touches[l], u = 0; u < h.trace.length; u++) {
                                        var c = h.trace[u];
                                        s.rect(c.x - 1, c.y - 1, 2, 2)
                                    }
                            s.fill(), a && (e += "\ntouches:" + o)
                        }
                        if (e.length > 0) {
                            var d = this.chart.shell.getChartInnerArea(),
                                p = Math.max(30, d.findTopPosition(50, 200));
                            H.resetTextStyle(s), s.fillStyle = "#000", s.textAlign = "start", s.textBaseline = "middle", s.font = "bold 11px Arial", s.fillText(e, 50, p)
                        }
                    }, e.prototype.previewPointerDown = function (t) {
                        if (this.captureTouches) {
                            for (var e in this.touches) {
                                var i = this.touches[e];
                                this.touches.hasOwnProperty(e) && i.up && delete this.touches[e]
                            }
                            this.touches[t.identifier] = {
                                dx: t.x,
                                dy: t.y,
                                x: t.x,
                                y: t.y,
                                up: !1,
                                cancelled: !1,
                                trace: [],
                                animator: new r.Animator(10, 40, 200)
                            }, t.changes.requestPaint = !0
                        }
                    }, e.prototype.previewPointerDrag = function (t) {
                        if (this.captureTouches) {
                            var e = this.touches[t.identifier];
                            e.x = t.x, e.y = t.y, this.settings.showTouchTrail && e.trace.push({
                                x: e.x,
                                y: e.y
                            }), t.changes.requestPaint = !0
                        }
                    }, e.prototype.previewPointerUp = function (t) {
                        if (this.captureTouches) {
                            var e = this.touches[t.identifier];
                            e.up = !0, e.animator.retarget(0), this.previewPointerDrag(t), t.changes.requestPaint = !0
                        }
                    }, e.prototype.previewPointerCancel = function (t) {
                        if (this.captureTouches) {
                            var e = this.touches[t.identifier];
                            e.up = !0, e.cancelled = !0, e.animator.retarget(0), this.previewPointerDrag(t), t.changes.requestPaint = !0
                        }
                    }, e
                }(k);
                r.TouchMarkers = Bt;
                var zt = "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet",
                    Ut = function () {
                        function t() {}
                        return t.createImage = function (e, i, n, s) {
                            var a = t.getSizes(e, n),
                                o = document.createElement("canvas");
                            o.width = a.width, o.height = a.height;
                            var l = o.getContext("2d");
                            s || (l.fillStyle = "#fff", l.fillRect(0, 0, a.width, a.height)), e.exportToContext(l, o, a.scale);
                            try {
                                return o.toDataURL(i)
                            } catch (t) {
                                throw r.Helpers.error(t), new Error("Browser security prevents exporting this chart. The canvas might be tainted. See `advanced.crossOriginHeader` setting in the documentation.")
                            }
                        }, t.createPdf = function (e, i) {
                            var n, r = e.exportToImageGetDimensions(),
                                s = [10, 10, 10, 10],
                                a = e.settings.advanced.exportPdfSize,
                                o = 0,
                                l = 0,
                                h = 0,
                                u = 0,
                                c = 72,
                                d = 1,
                                p = 0,
                                f = 0;
                            r.width >= r.height ? (a = [a[1], a[0]], n = "l") : n = "p", o = a[0] / 25.4 * c, l = a[1] / 25.4 * c, d = Math.min(l / r.height, o / r.width), "l" === n ? (p = r.width * d / o * a[0] - s[1] - s[3], h = (a[0] - p - s[1] - s[3]) / 2, f = r.height / r.width * p, u = (a[1] - s[0] - s[2] - f) / 2) : (f = r.height * d / l * a[1] - s[0] - s[2], u = (a[1] - f - s[0] - s[2]) / 2, p = r.width / r.height * f, h = (a[0] - s[1] - s[3] - p) / 2);
                            var g = t.createImage(e, "image/jpeg", {
                                    scaling: 3 * d
                                }, !1),
                                m = new jsPDF(n, "mm", a);
                            return m.addImage(g, "JPEG", s[3] + h, s[0] + u, p, f), m.output("datauristring")
                        }, t.createCsv = function (e) {
                            for (var i = /[^a-zA-Z0-9\.]/, n = "data:text/csv;charset=utf-8,", r = encodeURIComponent("\r\n"), s = 0; s < e.length; s++) {
                                for (var a = e[s], o = 0; o < a.length; o++) {
                                    o > 0 && (n += t._csvSeparator);
                                    var l = a[o];
                                    if (null != l) {
                                        var h = void 0;
                                        h = l instanceof Date ? l.toISOString() : "" + l, n += i.test(h) ? '"' + encodeURIComponent(h.replace('"', '""')) + '"' : h
                                    }
                                }
                                n += r
                            }
                            return n
                        }, t.retrieveData = function (t, e) {
                            var i = t.exportVisibleData,
                                n = t.settings.advanced.dataExportFunction;
                            if (!i && !n) throw new Error("This chart type does not support data export. Provide `advanced.dataExportFunction` delegate to enable it.");
                            var r = i ? t.exportVisibleData() : null;
                            n ? n(r, e) : e(r)
                        }, t.createExcel = function (t) {
                            function e(t) {
                                return (t.getTime() + 22091616e5) / 864e5
                            }
                            for (var i = Object.create(null), n = {
                                    s: {
                                        c: 1 / 0,
                                        r: 1 / 0
                                    },
                                    e: {
                                        c: 0,
                                        r: 0
                                    }
                                }, r = 0; r < t.length; r++) {
                                n.s.r > r && (n.s.r = r), n.e.r < r && (n.e.r = r);
                                for (var s = t[r], a = 0; a < s.length; a++) {
                                    n.s.c > a && (n.s.c = a), n.e.c < a && (n.e.c = a);
                                    var o = s[a];
                                    if (null != o) {
                                        var l = {
                                            t: "s",
                                            v: o
                                        };
                                        "number" == typeof o ? (l.t = "n", Math.round(o) === o && (l.z = "0")) : "boolean" == typeof o ? l.t = "b" : o instanceof Date && (l.t = "n", l.z = XLSX.SSF._table[14], l.v = e(l.v)), i[XLSX.utils.encode_cell({
                                            c: a,
                                            r: r
                                        })] = l
                                    }
                                }
                            }
                            n.s.c < 1 / 0 && (i["!ref"] = XLSX.utils.encode_range(n));
                            var h = {
                                    SheetNames: ["export"],
                                    Sheets: {
                                        export: i
                                    }
                                },
                                u = XLSX.write(h, {
                                    bookType: "xlsx",
                                    bookSST: !0,
                                    type: "binary"
                                });
                            return "data:" + zt + ";base64," + d.base64Encode(u)
                        }, t.export = function (e, i, n, s, a) {
                            void 0 === i && (i = "png"), void 0 === n && (n = {}), void 0 === s && (s = null);
                            var o = e.shell;
                            if (!(o instanceof Mt)) throw new Error("Export functionality is only available on the top level chart, not within nested charts.");
                            var l = t._mimeMap[i];
                            if ("xls" === i) r.Helpers.warn("XLS format is not supported. XLSX will be used instead.");
                            else if (null == i) i = "png", l = t._mimeMap.png;
                            else if (void 0 === l) throw new Error("Export image type `" + i + "` is not supported. Supported types: " + Object.keys(t._mimeMap).join(", "));
                            if (l.transparent ? null == s && (s = !0) : s && (r.Helpers.warn("Only PNG images can be exported as transparent."), s = !1), l.csv) return void t.retrieveData(e, function (e) {
                                a(t.createCsv(e), l.mime, l.extension)
                            });
                            if (l.excel) return void e.assetsLoader.ensureAssetsList([{
                                url: "./src/dist/assets/js/xlsx.core.min.js",
                                required: function () {
                                    return "undefined" == typeof XLSX
                                }
                            }], function () {
                                t.retrieveData(e, function (e) {
                                    a(t.createExcel(e), l.mime, l.extension)
                                })
                            });
                            if (l.image) {
                                var h = t.createImage(o, l.mime, t.getDimensions(e, n), s);
                                return a(h, l.mime, l.extension), h
                            }
                            if (l.pdf) return void e.assetsLoader.ensureAssetsList([{
                                url: "./src/dist/assets/js/jspdf.js",
                                required: function () {
                                    return "undefined" == typeof jsPDF
                                }
                            }], function () {
                                a(t.createPdf(o, n), l.mime, l.extension)
                            });
                            throw new Error("not implemented")
                        }, t.download = function (t, e, i, n) {
                            var r = this;
                            void 0 === i && (i = {}), this.export(t, e, i, n, function (e, i, n) {
                                r.launchDownload(t, i, n, e)
                            })
                        }, t.getSizes = function (t, e) {
                            var i = t.exportToImageGetDimensions(),
                                n = i.width,
                                r = i.height,
                                s = d.tryParseFloat(e.width),
                                a = d.tryParseFloat(e.height),
                                o = 1;
                            if ("mm" === e.unit) {
                                var l = d.tryParseFloat(e.dpi, 300) / 25.4;
                                s > 0 && (s *= l), a > 0 && (a *= l)
                            }
                            s > 0 && a > 0 ? o = Math.min(s / n, a / r) : s > 0 ? (o = s / n, a = r * o) : a > 0 ? (o = a / r, s = n * o) : (s = n, a = r);
                            var h = d.tryParseFloat(e.scaling, 1);
                            return 1 !== h && (o *= h, s *= h, a *= h), {
                                width: s,
                                height: a,
                                scale: o,
                                chartWidth: n,
                                chartHeight: r
                            }
                        }, t.getDimensions = function (t, e) {
                            var i = t.shell;
                            if (!(i instanceof Mt)) throw new Error("Export functionality is only available on the top level chart, not within nested charts.");
                            return this.getSizes(i, e || {})
                        }, t.dataUriToBlob = function (t, e) {
                            var i = e.indexOf(","),
                                n = i > 13 && ";base64" === e.substr(i - 7, 7);
                            e = e.substr(i + 1), e = n ? window.atob(e) : decodeURIComponent(e);
                            for (var r = new ArrayBuffer(e.length), s = new Uint8Array(r), a = 0; a < e.length; a++) s[a] = e.charCodeAt(a);
                            return new Blob([r], {
                                type: t
                            })
                        }, t.launchDownload = function (e, i, n, r, s) {
                            var a = document.body;
                            n.indexOf(".") === -1 && (n = "export." + n);
                            var o = d.createDom("a", null, null, null);
                            if (navigator.msSaveOrOpenBlob && window.atob) {
                                if (navigator.msSaveOrOpenBlob(t.dataUriToBlob(i, r), n)) return
                            } else if (b.detect().isChrome && r.length > 2097152);
                            else if (void 0 !== o.download) return o.download = n, o.type = i, o.href = r, a.appendChild(o), o.click(), void a.removeChild(o);
                            var l = e.settings.advanced.exportProxyURL;
                            if (!l) return void alert(e.settings.localization.exportNotAvailable);
                            var h = function () {
                                var t = document.createElement("form");
                                t.action = l, t.target = "_top", t.method = "POST", t.style.display = "none";
                                var e = document.createElement("input");
                                e.name = "name", e.value = n, t.appendChild(e);
                                var i = document.createElement("textarea");
                                i.name = "data", i.value = r, t.appendChild(i), a.appendChild(t), t.submit(), a.removeChild(t)
                            };
                            s ? s(h, function () {}) : h()
                        }, t
                    }();
                Ut._csvSeparator = ";", Ut._mimeMap = {
                        png: {
                            mime: "image/png",
                            extension: "png",
                            image: !0,
                            transparent: !0
                        },
                        jpg: {
                            mime: "image/jpeg",
                            extension: "jpg",
                            image: !0
                        },
                        jpeg: {
                            mime: "image/jpeg",
                            extension: "jpg",
                            image: !0
                        },
                        csv: {
                            mime: "text/csv",
                            extension: "csv",
                            csv: !0
                        },
                        txt: {
                            mime: "text/csv",
                            extension: "csv",
                            csv: !0
                        },
                        xlsx: {
                            mime: zt,
                            extension: "xlsx",
                            excel: !0
                        },
                        xls: {
                            mime: zt,
                            extension: "xlsx",
                            excel: !0
                        },
                        pdf: {
                            mime: "application/pdf",
                            extension: "pdf",
                            pdf: !0
                        }
                    }, r.Export = Ut,
                    function (t) {
                        var e = function (t) {
                            function e(e, i) {
                                var n, r = e.settings.localization.toolbar;
                                if (!i.dropDownItems) {
                                    var s = e.settings.toolbar.exportOptions,
                                        a = [];
                                    (!s || s.indexOf("jpg") > -1) && a.push({
                                        label: r.exportJpeg,
                                        onClick: function () {
                                            return Ut.download(e, "jpg", {
                                                scaling: 2
                                            })
                                        }
                                    }), (!s || s.indexOf("png") > -1) && a.push({
                                        label: r.exportPNG,
                                        onClick: function () {
                                            return Ut.download(e, "png", {
                                                scaling: 3
                                            })
                                        }
                                    }), (!s || s.indexOf("pdf") > -1) && a.push({
                                        label: r.exportPDF,
                                        onClick: function () {
                                            return Ut.download(e, "pdf")
                                        }
                                    }), (e.exportVisibleData || e.settings.advanced.dataExportFunction) && ((!s || s.indexOf("csv") > -1) && a.push({
                                        label: r.exportCSV,
                                        onClick: function () {
                                            return Ut.download(e, "csv")
                                        }
                                    }), (!s || s.indexOf("xlsx") > -1) && a.push({
                                        label: r.exportXLS,
                                        onClick: function () {
                                            return Ut.download(e, "xlsx")
                                        }
                                    })), i.dropDownItems = a
                                }
                                return i.title = i.title || r.exportTitle, i.label = i.label || r.exportButton, i.cssClass = i.cssClass || "DVSL-bar-btn-export", n = t.call(this, e, i) || this
                            }
                            return n(e, t), e
                        }(t.Dropdown);
                        t.ExportDropdown = e, r.Bar.ToolbarItemNames.export = function (t, e) {
                            return new r.Bar.ExportDropdown(t, e)
                        }
                    }(o = r.Bar || (r.Bar = {}));
                var Gt = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.animationOrder = 2e3, i.paintOrder = 65, i.updateOrder = 0, i.chart = e, i
                    }
                    return n(e, t), e.prototype.onKeyDown = function (t) {
                        this.chart.isFullscreen() && 27 === t.keyCode ? (this.chart.setFullscreen(!1), t.consumed = !0) : 8 === t.keyCode && this.chart.back(!0, "user") && (t.consumed = !0)
                    }, e
                }(k);
                r.KeyShortcuts = Gt;
                var jt = "C314F39F62CBF2AEFA1D5BA41E38EFFD080E88849EE210BA17971BF63A55C44E159C9F9ED004F8D50856EC8ECE673690F60C29AAC124B7C46D549D20EB22CC2A387B2FB643700546312114F831133F242CFFD023A1788167025FF398F5F09D1003C47C9B3208860A547577F540D07FF66403097FE27E7BB6B8D76036AD31B62B04EAD1BB8B2C314F6DA7489346978286491D0DF7504E9EE85A4459805F4FFCEE664122FC27B80DAD6751A7A6C0D38E9C2ECD7C0AD1F2B774D6FF81C5A2CE14D608F08E13BEE45663450519774ADF87D34CE6150FC819558EBD336511D51405A42E7A38EBB786ED5050345CBC532ED7C0EECB05C5D6D4D00534249ED4585DFABD",
                    Wt = function () {
                        function t() {}
                        return t.verifySignature = function (t, e, i) {
                            var n = new Vt;
                            return n.setPublic(i || jt, "10001"), n.verify(t, e)
                        }, t.hash = function (t) {
                            return Vt.hash(t)
                        }, t
                    }();
                r.RsaCrypto = Wt, Object.freeze(Wt);
                var Vt = function () {
                        function t(t, e) {
                            null != t && (null == e && "string" != typeof t ? this.fromString(t, 256) : this.fromString(t, e))
                        }

                        function e() {
                            return new t(null)
                        }

                        function i(t, e, i, n, r, s) {
                            for (; --s >= 0;) {
                                var a = e * this[t++] + i[n] + r;
                                r = Math.floor(a / 67108864), i[n++] = 67108863 & a
                            }
                            return r
                        }

                        function n(t, e, i, n, r, s) {
                            for (var a = 32767 & e, o = e >> 15; --s >= 0;) {
                                var l = 32767 & this[t],
                                    h = this[t++] >> 15,
                                    u = o * l + h * a;
                                l = a * l + ((32767 & u) << 15) + i[n] + (1073741823 & r), r = (l >>> 30) + (u >>> 15) + o * h + (r >>> 30), i[n++] = 1073741823 & l
                            }
                            return r
                        }

                        function r(t, e, i, n, r, s) {
                            for (var a = 16383 & e, o = e >> 14; --s >= 0;) {
                                var l = 16383 & this[t],
                                    h = this[t++] >> 14,
                                    u = o * l + h * a;
                                l = a * l + ((16383 & u) << 14) + i[n] + r, r = (l >> 28) + (u >> 14) + o * h, i[n++] = 268435455 & l
                            }
                            return r
                        }

                        function s(t) {
                            return et.charAt(t)
                        }

                        function a(t, e) {
                            var i = it[t.charCodeAt(e)];
                            return null == i ? -1 : i
                        }

                        function o(t) {
                            for (var e = this.t - 1; e >= 0; --e) t[e] = this[e];
                            t.t = this.t, t.s = this.s
                        }

                        function l(t) {
                            this.t = 1, this.s = t < 0 ? -1 : 0, t > 0 ? this[0] = t : t < -1 ? this[0] = t + this.DV : this.t = 0
                        }

                        function h(t) {
                            var i = e();
                            return i.fromInt(t), i
                        }

                        function u(e, i) {
                            var n;
                            if (16 == i) n = 4;
                            else if (8 == i) n = 3;
                            else if (256 == i) n = 8;
                            else if (2 == i) n = 1;
                            else if (32 == i) n = 5;
                            else {
                                if (4 != i) return void this.fromRadix(e, i);
                                n = 2
                            }
                            this.t = 0, this.s = 0;
                            for (var r = e.length, s = !1, o = 0; --r >= 0;) {
                                var l = 8 == n ? 255 & e[r] : a(e, r);
                                l < 0 ? "-" == e.charAt(r) && (s = !0) : (s = !1, 0 == o ? this[this.t++] = l : o + n > this.DB ? (this[this.t - 1] |= (l & (1 << this.DB - o) - 1) << o, this[this.t++] = l >> this.DB - o) : this[this.t - 1] |= l << o, o += n, o >= this.DB && (o -= this.DB))
                            }
                            8 == n && 0 != (128 & e[0]) && (this.s = -1, o > 0 && (this[this.t - 1] |= (1 << this.DB - o) - 1 << o)), this.clamp(), s && t.ZERO.subTo(this, this)
                        }

                        function c() {
                            for (var t = this.s & this.DM; this.t > 0 && this[this.t - 1] == t;) --this.t
                        }

                        function d(t) {
                            if (this.s < 0) return "-" + this.negate().toString(t);
                            var e;
                            if (16 == t) e = 4;
                            else if (8 == t) e = 3;
                            else if (2 == t) e = 1;
                            else if (32 == t) e = 5;
                            else {
                                if (4 != t) return this.toRadix(t);
                                e = 2
                            }
                            var i, n = (1 << e) - 1,
                                r = !1,
                                a = "",
                                o = this.t,
                                l = this.DB - o * this.DB % e;
                            if (o-- > 0)
                                for (l < this.DB && (i = this[o] >> l) > 0 && (r = !0, a = s(i)); o >= 0;) l < e ? (i = (this[o] & (1 << l) - 1) << e - l, i |= this[--o] >> (l += this.DB - e)) : (i = this[o] >> (l -= e) & n, l <= 0 && (l += this.DB, --o)), i > 0 && (r = !0), r && (a += s(i));
                            return r ? a : "0"
                        }

                        function p() {
                            var i = e();
                            return t.ZERO.subTo(this, i), i
                        }

                        function f() {
                            return this.s < 0 ? this.negate() : this
                        }

                        function g(t) {
                            var e = this.s - t.s;
                            if (0 != e) return e;
                            var i = this.t;
                            if (e = i - t.t, 0 != e) return this.s < 0 ? -e : e;
                            for (; --i >= 0;)
                                if (0 != (e = this[i] - t[i])) return e;
                            return 0
                        }

                        function m(t) {
                            var e, i = 1;
                            return 0 != (e = t >>> 16) && (t = e, i += 16), 0 != (e = t >> 8) && (t = e, i += 8), 0 != (e = t >> 4) && (t = e, i += 4), 0 != (e = t >> 2) && (t = e, i += 2), 0 != (e = t >> 1) && (t = e, i += 1), i
                        }

                        function v() {
                            return this.t <= 0 ? 0 : this.DB * (this.t - 1) + m(this[this.t - 1] ^ this.s & this.DM)
                        }

                        function y(t, e) {
                            var i;
                            for (i = this.t - 1; i >= 0; --i) e[i + t] = this[i];
                            for (i = t - 1; i >= 0; --i) e[i] = 0;
                            e.t = this.t + t, e.s = this.s
                        }

                        function S(t, e) {
                            for (var i = t; i < this.t; ++i) e[i - t] = this[i];
                            e.t = Math.max(this.t - t, 0), e.s = this.s
                        }

                        function b(t, e) {
                            var i, n = t % this.DB,
                                r = this.DB - n,
                                s = (1 << r) - 1,
                                a = Math.floor(t / this.DB),
                                o = this.s << n & this.DM;
                            for (i = this.t - 1; i >= 0; --i) e[i + a + 1] = this[i] >> r | o, o = (this[i] & s) << n;
                            for (i = a - 1; i >= 0; --i) e[i] = 0;
                            e[a] = o, e.t = this.t + a + 1, e.s = this.s, e.clamp()
                        }

                        function C(t, e) {
                            e.s = this.s;
                            var i = Math.floor(t / this.DB);
                            if (i >= this.t) return void(e.t = 0);
                            var n = t % this.DB,
                                r = this.DB - n,
                                s = (1 << n) - 1;
                            e[0] = this[i] >> n;
                            for (var a = i + 1; a < this.t; ++a) e[a - i - 1] |= (this[a] & s) << r, e[a - i] = this[a] >> n;
                            n > 0 && (e[this.t - i - 1] |= (this.s & s) << r), e.t = this.t - i, e.clamp()
                        }

                        function x(t, e) {
                            for (var i = 0, n = 0, r = Math.min(t.t, this.t); i < r;) n += this[i] - t[i], e[i++] = n & this.DM, n >>= this.DB;
                            if (t.t < this.t) {
                                for (n -= t.s; i < this.t;) n += this[i], e[i++] = n & this.DM, n >>= this.DB;
                                n += this.s
                            } else {
                                for (n += this.s; i < t.t;) n -= t[i], e[i++] = n & this.DM, n >>= this.DB;
                                n -= t.s
                            }
                            e.s = n < 0 ? -1 : 0, n < -1 ? e[i++] = this.DV + n : n > 0 && (e[i++] = n), e.t = i, e.clamp()
                        }

                        function w(e, i) {
                            var n = this.abs(),
                                r = e.abs(),
                                s = n.t;
                            for (i.t = s + r.t; --s >= 0;) i[s] = 0;
                            for (s = 0; s < r.t; ++s) i[s + n.t] = n.am(0, r[s], i, s, 0, n.t);
                            i.s = 0, i.clamp(), this.s != e.s && t.ZERO.subTo(i, i)
                        }

                        function L(t) {
                            for (var e = this.abs(), i = t.t = 2 * e.t; --i >= 0;) t[i] = 0;
                            for (i = 0; i < e.t - 1; ++i) {
                                var n = e.am(i, e[i], t, 2 * i, 0, 1);
                                (t[i + e.t] += e.am(i + 1, 2 * e[i], t, 2 * i + 1, n, e.t - i - 1)) >= e.DV && (t[i + e.t] -= e.DV, t[i + e.t + 1] = 1)
                            }
                            t.t > 0 && (t[t.t - 1] += e.am(i, e[i], t, 2 * i, 0, 1)), t.s = 0, t.clamp()
                        }

                        function T(i, n, r) {
                            var s = i.abs();
                            if (!(s.t <= 0)) {
                                var a = this.abs();
                                if (a.t < s.t) return null != n && n.fromInt(0), void(null != r && this.copyTo(r));
                                null == r && (r = e());
                                var o = e(),
                                    l = this.s,
                                    h = i.s,
                                    u = this.DB - m(s[s.t - 1]);
                                u > 0 ? (s.lShiftTo(u, o), a.lShiftTo(u, r)) : (s.copyTo(o), a.copyTo(r));
                                var c = o.t,
                                    d = o[c - 1];
                                if (0 != d) {
                                    var p = d * (1 << this.F1) + (c > 1 ? o[c - 2] >> this.F2 : 0),
                                        f = this.FV / p,
                                        g = (1 << this.F1) / p,
                                        v = 1 << this.F2,
                                        y = r.t,
                                        S = y - c,
                                        b = null == n ? e() : n;
                                    for (o.dlShiftTo(S, b), r.compareTo(b) >= 0 && (r[r.t++] = 1, r.subTo(b, r)), t.ONE.dlShiftTo(c, b), b.subTo(o, o); o.t < c;) o[o.t++] = 0;
                                    for (; --S >= 0;) {
                                        var C = r[--y] == d ? this.DM : Math.floor(r[y] * f + (r[y - 1] + v) * g);
                                        if ((r[y] += o.am(0, C, r, S, 0, c)) < C)
                                            for (o.dlShiftTo(S, b), r.subTo(b, r); r[y] < --C;) r.subTo(b, r)
                                    }
                                    null != n && (r.drShiftTo(c, n), l != h && t.ZERO.subTo(n, n)), r.t = c, r.clamp(), u > 0 && r.rShiftTo(u, r), l < 0 && t.ZERO.subTo(r, r)
                                }
                            }
                        }

                        function k(i) {
                            var n = e();
                            return this.abs().divRemTo(i, null, n), this.s < 0 && n.compareTo(t.ZERO) > 0 && i.subTo(n, n), n
                        }

                        function A(t) {
                            this.m = t
                        }

                        function M(t) {
                            return t.s < 0 || t.compareTo(this.m) >= 0 ? t.mod(this.m) : t
                        }

                        function I(t) {
                            return t
                        }

                        function P(t) {
                            t.divRemTo(this.m, null, t)
                        }

                        function D(t, e, i) {
                            t.multiplyTo(e, i), this.reduce(i)
                        }

                        function N(t, e) {
                            t.squareTo(e), this.reduce(e)
                        }

                        function F() {
                            if (this.t < 1) return 0;
                            var t = this[0];
                            if (0 == (1 & t)) return 0;
                            var e = 3 & t;
                            return e = e * (2 - (15 & t) * e) & 15, e = e * (2 - (255 & t) * e) & 255, e = e * (2 - ((65535 & t) * e & 65535)) & 65535, e = e * (2 - t * e % this.DV) % this.DV, e > 0 ? this.DV - e : -e
                        }

                        function O(t) {
                            this.m = t, this.mp = t.invDigit(), this.mpl = 32767 & this.mp, this.mph = this.mp >> 15, this.um = (1 << t.DB - 15) - 1, this.mt2 = 2 * t.t
                        }

                        function E(i) {
                            var n = e();
                            return i.abs().dlShiftTo(this.m.t, n), n.divRemTo(this.m, null, n), i.s < 0 && n.compareTo(t.ZERO) > 0 && this.m.subTo(n, n), n
                        }

                        function R(t) {
                            var i = e();
                            return t.copyTo(i), this.reduce(i), i
                        }

                        function H(t) {
                            for (; t.t <= this.mt2;) t[t.t++] = 0;
                            for (var e = 0; e < this.m.t; ++e) {
                                var i = 32767 & t[e],
                                    n = i * this.mpl + ((i * this.mph + (t[e] >> 15) * this.mpl & this.um) << 15) & t.DM;
                                for (i = e + this.m.t, t[i] += this.m.am(0, n, t, e, 0, this.m.t); t[i] >= t.DV;) t[i] -= t.DV, t[++i]++
                            }
                            t.clamp(), t.drShiftTo(this.m.t, t), t.compareTo(this.m) >= 0 && t.subTo(this.m, t)
                        }

                        function B(t, e) {
                            t.squareTo(e), this.reduce(e)
                        }

                        function z(t, e, i) {
                            t.multiplyTo(e, i), this.reduce(i)
                        }

                        function U() {
                            return 0 == (this.t > 0 ? 1 & this[0] : this.s)
                        }

                        function G(i, n) {
                            if (i > 4294967295 || i < 1) return t.ONE;
                            var r = e(),
                                s = e(),
                                a = n.convert(this),
                                o = m(i) - 1;
                            for (a.copyTo(r); --o >= 0;)
                                if (n.sqrTo(r, s), (i & 1 << o) > 0) n.mulTo(s, a, r);
                                else {
                                    var l = r;
                                    r = s, s = l
                                }
                            return n.revert(r)
                        }

                        function j(t, e) {
                            var i;
                            return i = t < 256 || e.isEven() ? new A(e) : new O(e), this.exp(t, i)
                        }

                        function W(e, i) {
                            return new t(e, i)
                        }

                        function V() {
                            this.n = null, this.e = 0, this.d = null, this.p = null, this.q = null, this.dmp1 = null, this.dmq1 = null, this.coeff = null
                        }

                        function Z(t, e) {
                            null != t && null != e && t.length > 0 && e.length > 0 ? (this.n = W(t, 16), this.e = parseInt(e, 16)) : alert("Invalid RSA public key")
                        }

                        function Y(t) {
                            return t.modPowInt(this.e, this.n)
                        }

                        function q(t) {
                            for (var e in rt.crypto.Util.DIGESTINFOHEAD) {
                                var i = rt.crypto.Util.DIGESTINFOHEAD[e],
                                    n = i.length;
                                if (t.substring(0, n) == i) return [e, t.substring(n)]
                            }
                            return []
                        }

                        function _(t, e) {
                            e = e.replace(st, ""), e = e.replace(/[ \n]+/g, "");
                            var i = W(e, 16);
                            if (i.bitLength() > this.n.bitLength()) return !1;
                            var n = this.doPublic(i),
                                r = n.toString(16).replace(/^1f+00/, ""),
                                s = q(r);
                            if (0 === s.length) return !1;
                            var a = s[1],
                                o = nt.hash(t);
                            return a === o
                        }
                        var X, Q = 0xdeadbeefcafe,
                            J = 15715070 == (16777215 & Q);
                        "undefined" == typeof window ? null : window.crypto || window.msCrypto;
                        J && "undefined" != typeof navigator && "Microsoft Internet Explorer" === navigator.appName ? (t.prototype.am = n, X = 30) : J && "undefined" != typeof navigator && "Netscape" !== navigator.appName ? (t.prototype.am = i, X = 26) : (t.prototype.am = r, X = 28), t.prototype.DB = X, t.prototype.DM = (1 << X) - 1, t.prototype.DV = 1 << X;
                        var K = 52;
                        t.prototype.FV = Math.pow(2, K), t.prototype.F1 = K - X, t.prototype.F2 = 2 * X - K;
                        var $, tt, et = "0123456789abcdefghijklmnopqrstuvwxyz",
                            it = new Array;
                        for ($ = "0".charCodeAt(0), tt = 0; tt <= 9; ++tt) it[$++] = tt;
                        for ($ = "a".charCodeAt(0), tt = 10; tt < 36; ++tt) it[$++] = tt;
                        for ($ = "A".charCodeAt(0), tt = 10; tt < 36; ++tt) it[$++] = tt;
                        A.prototype.convert = M, A.prototype.revert = I, A.prototype.reduce = P, A.prototype.mulTo = D, A.prototype.sqrTo = N, O.prototype.convert = E, O.prototype.revert = R, O.prototype.reduce = H, O.prototype.mulTo = z, O.prototype.sqrTo = B, t.prototype.copyTo = o, t.prototype.fromInt = l, t.prototype.fromString = u, t.prototype.clamp = c, t.prototype.dlShiftTo = y, t.prototype.drShiftTo = S, t.prototype.lShiftTo = b, t.prototype.rShiftTo = C, t.prototype.subTo = x, t.prototype.multiplyTo = w, t.prototype.squareTo = L, t.prototype.divRemTo = T, t.prototype.invDigit = F, t.prototype.isEven = U, t.prototype.exp = G, t.prototype.toString = d, t.prototype.negate = p, t.prototype.abs = f, t.prototype.compareTo = g, t.prototype.bitLength = v, t.prototype.mod = k, t.prototype.modPowInt = j, t.ZERO = h(0), t.ONE = h(1), V.prototype.doPublic = Y, V.prototype.setPublic = Z;
                        var nt = {};
                        nt.utf8Encode = function (t) {
                            return window.unescape(encodeURIComponent(t))
                        }, nt.hash = function (t) {
                            t = nt.utf8Encode(t);
                            var e = [1116352408, 1899447441, 3049323471, 3921009573, 961987163, 1508970993, 2453635748, 2870763221, 3624381080, 310598401, 607225278, 1426881987, 1925078388, 2162078206, 2614888103, 3248222580, 3835390401, 4022224774, 264347078, 604807628, 770255983, 1249150122, 1555081692, 1996064986, 2554220882, 2821834349, 2952996808, 3210313671, 3336571891, 3584528711, 113926993, 338241895, 666307205, 773529912, 1294757372, 1396182291, 1695183700, 1986661051, 2177026350, 2456956037, 2730485921, 2820302411, 3259730800, 3345764771, 3516065817, 3600352804, 4094571909, 275423344, 430227734, 506948616, 659060556, 883997877, 958139571, 1322822218, 1537002063, 1747873779, 1955562222, 2024104815, 2227730452, 2361852424, 2428436474, 2756734187, 3204031479, 3329325298],
                                i = [1779033703, 3144134277, 1013904242, 2773480762, 1359893119, 2600822924, 528734635, 1541459225];
                            t += String.fromCharCode(128);
                            for (var n = t.length / 4 + 2, r = Math.ceil(n / 16), s = new Array(r), a = 0; a < r; a++) {
                                s[a] = new Array(16);
                                for (var o = 0; o < 16; o++) s[a][o] = t.charCodeAt(64 * a + 4 * o) << 24 | t.charCodeAt(64 * a + 4 * o + 1) << 16 | t.charCodeAt(64 * a + 4 * o + 2) << 8 | t.charCodeAt(64 * a + 4 * o + 3)
                            }
                            s[r - 1][14] = 8 * (t.length - 1) / Math.pow(2, 32), s[r - 1][14] = Math.floor(s[r - 1][14]), s[r - 1][15] = 8 * (t.length - 1) & 4294967295;
                            for (var l, h, u, c, d, p, f, g, m = new Array(64), a = 0; a < r; a++) {
                                for (var v = 0; v < 16; v++) m[v] = s[a][v];
                                for (var v = 16; v < 64; v++) m[v] = nt.s1(m[v - 2]) + m[v - 7] + nt.s0(m[v - 15]) + m[v - 16] & 4294967295;
                                l = i[0], h = i[1], u = i[2], c = i[3], d = i[4], p = i[5], f = i[6], g = i[7];
                                for (var v = 0; v < 64; v++) {
                                    var y = g + nt.S1(d) + nt.Ch(d, p, f) + e[v] + m[v],
                                        S = nt.S0(l) + nt.Maj(l, h, u);
                                    g = f, f = p, p = d, d = c + y & 4294967295, c = u, u = h, h = l, l = y + S & 4294967295
                                }
                                i[0] = i[0] + l & 4294967295, i[1] = i[1] + h & 4294967295, i[2] = i[2] + u & 4294967295, i[3] = i[3] + c & 4294967295, i[4] = i[4] + d & 4294967295, i[5] = i[5] + p & 4294967295, i[6] = i[6] + f & 4294967295, i[7] = i[7] + g & 4294967295
                            }
                            return nt.toHexStr(i[0]) + nt.toHexStr(i[1]) + nt.toHexStr(i[2]) + nt.toHexStr(i[3]) + nt.toHexStr(i[4]) + nt.toHexStr(i[5]) + nt.toHexStr(i[6]) + nt.toHexStr(i[7])
                        }, nt.ROTR = function (t, e) {
                            return e >>> t | e << 32 - t
                        }, nt.S0 = function (t) {
                            return nt.ROTR(2, t) ^ nt.ROTR(13, t) ^ nt.ROTR(22, t)
                        }, nt.S1 = function (t) {
                            return nt.ROTR(6, t) ^ nt.ROTR(11, t) ^ nt.ROTR(25, t)
                        }, nt.s0 = function (t) {
                            return nt.ROTR(7, t) ^ nt.ROTR(18, t) ^ t >>> 3
                        }, nt.s1 = function (t) {
                            return nt.ROTR(17, t) ^ nt.ROTR(19, t) ^ t >>> 10
                        }, nt.Ch = function (t, e, i) {
                            return t & e ^ ~t & i
                        }, nt.Maj = function (t, e, i) {
                            return t & e ^ t & i ^ e & i
                        }, nt.toHexStr = function (t) {
                            for (var e, i = "", n = 7; n >= 0; n--) e = t >>> 4 * n & 15, i += e.toString(16);
                            return i
                        };
                        var rt = {
                                crypto: {
                                    Util: {
                                        DIGESTINFOHEAD: {
                                            sha256: "3031300d060960864801650304020105000420"
                                        }
                                    }
                                }
                            },
                            st = new RegExp("[^0-9a-f]", "gi");
                        return V.prototype.verify = _, V.hash = nt.hash, V
                    }(),
                    Zt = function () {
                        function t(t, e, i) {
                            var n = this;
                            this.api = null, this.scene = null, this.settings = null, this.shell = null, this.events = null, this.removed = !0, this.assetsLoaded = !1, this.toolbar = null, this.data = {}, this.navigator = null, this.curState = null, this.goingBack = !1, this.chartUpdateOrigin = null, this.chartUpdateTimeout = null, this.scene = e, this.settings = t, this.api = i, i._impl = this, this.scene.settings = t, this.scene.assetsLoader = this.assetsLoader = new Et(this), this.data = {}, this.settings.parentChart ? (this.shell = new It(this, this.settings.parentChart._impl.shell), this.events = this.shell.events) : (this.shell = new Mt(this, this.createDomLayer()), this.events = this.shell.events, this.events.addElement(new Bt(this)), this.events.addElement(new it(this)), this.events.addElement(new F(this, this.settings.credits))), window.setTimeout(function () {
                                return Qt.execute(n, !n.settings.parentChart)
                            }, 500), this.removed = !1, this.EVENT_NAMES = {};
                            var r;
                            for (r in t.events)
                                if (0 === r.indexOf("on")) {
                                    var s = r.charAt(2).toLowerCase() + r.slice(3);
                                    this.EVENT_NAMES[r] = s, this.EVENT_NAMES[s] = s
                                }
                            this.eventListeners = {}, this.assetsLoaded = !1, this.assetsLoader.ensureAssetsList(this.settings.advanced.assets, function () {
                                return n.notifyAssetsLoaded()
                            }), this.clearData(), this.events.addElement(new Gt(this)), this.title = this.events.addElement(new z(this)), this.events.addElement(new Pt(this))
                        }
                        return t.prototype.createDomLayer = function () {
                            return new r.DomLayer(this)
                        }, t.prototype.updateFilters = function (t) {
                            this.events.notifySceneChanges({
                                filters: !0
                            })
                        }, t.prototype.updateStyle = function (t) {
                            this.events.notifySceneChanges({
                                style: !0
                            })
                        }, t.prototype.defaultDoubleClick = function (t, e) {}, t.prototype.defaultTripleClick = function (t, e) {}, t.prototype.defaultClick = function (t, e) {}, t.prototype.defaultRightClick = function (t, e) {}, t.prototype.finalInitialize = function () {
                            var t = {
                                settings: !0,
                                settingsChanges: this.scene.settings,
                                data: {}
                            };
                            this.processChangedSettings(t), this.events.notifySceneChanges(t), this.updateSize(), this.updateEvents(null, this.settings.events)
                        }, t.prototype.getRootChart = function () {
                            var t = this.settings.parentChart;
                            return t ? t._impl.getRootChart() : this
                        }, t.prototype.processChangedSettings = function (t) {}, t.prototype.updateSettings = function (t, e) {
                            var i = this;
                            if (void 0 === e && (e = null), !this.removed) {
                                var n = d.clone(this.settings.events),
                                    r = this.settings.apply(t),
                                    s = {
                                        settings: !0,
                                        settingsChanges: r
                                    };
                                this.processChangedSettings(s), r.events && this.updateEvents(n, this.settings.events), r.advanced && r.advanced.assets && (this.assetsLoaded = !1, this.assetsLoader.ensureAssetsList(this.settings.advanced.assets, function () {
                                    return i.notifyAssetsLoaded()
                                })), r.data && this.dataSettingsChanged(r.data), this.shell.updateSettings(r), this.onSettingsChanged(r), r.toolbar && this.assetsLoaded && this.createToolbar(), this.events.notifySceneChanges(s);
                                var a = r.area;
                                if (a && (a.width || a.height || a.maxWidth || a.minWidth || a.minHeight || a.maxHeight) && this.updateSize(!0), e) {
                                    var o = this.createEventArguments(null, e);
                                    o.changes = r, this.notifySettingsChanged(o)
                                }
                            }
                        }, t.prototype.getData = function (t) {
                            if (this.data[t]) return this.data[t];
                            var e = this.settings._computedDataMap[t];
                            if (e) {
                                var i = this.createDataObj(e);
                                return i.applyPreloadedData(), this.data[t] = i, i
                            }
                            throw new Error("No data configured for source ID " + t)
                        }, t.prototype.addData = function (t, e) {
                            this.removed || this.getData(e).addData(t)
                        }, t.prototype.reloadData = function (t, e) {
                            if (void 0 === t && (t = null), void 0 === e && (e = !1), !this.removed) {
                                this.log("Reload data"), t ? this.data[t] && (this.data[t].remove(), delete this.data[t]) : this.clearData(), this.scene.mainDataEnabled && (this.scene.mainData = this.getData(this.settings.data[0].id));
                                var i = {};
                                for (var n in this.settings._computedDataMap) i[n] = !0;
                                this.events.notifySceneChanges({
                                    data: i,
                                    dataDeep: e
                                }), this.navigator && this.navigator.onNewDataObject()
                            }
                        }, t.prototype.replaceData = function (t, e) {
                            if (void 0 === e && (e = "default"), null == e && (e = "default"), !this.removed) {
                                this.events.clearSceneChanges({
                                    dataArrived: null
                                }), this.data[e] && this.data[e].remove();
                                var i = this.data[e] = this.createDataObj(this.settings._computedDataMap[e]);
                                i.addData(t), this.scene.mainDataEnabled && (this.scene.mainData = this.getData(this.settings.data[0].id));
                                var n = {};
                                n[e] = !0, this.events.notifySceneChanges({
                                    data: n
                                }), this.navigator && this.navigator.onNewDataObject()
                            }
                        }, t.prototype.clearData = function (t) {
                            void 0 === t && (t = !1);
                            for (var e in this.data) {
                                var i = this.data[e];
                                i.remove()
                            }
                            this.events.clearSceneChanges({
                                dataArrived: null
                            }), this.data = {}, this.scene.mainData = null, !t && this.scene.mainDataEnabled && (this.scene.mainData = this.getData(this.settings.data[0].id))
                        }, t.prototype.dataSettingsChanged = function (t) {
                            for (var e in this.data) !t[e] && this.settings._computedDataMap[e] || (this.data[e].remove(), delete this.data[e]);
                            this.events.clearSceneChanges({
                                dataArrived: null
                            }), this.events.notifySceneChanges({
                                data: t,
                                dataDeep: !0
                            }), this.scene.mainDataEnabled && (this.scene.mainData = this.getData(this.settings.data[0].id)), this.navigator && this.navigator.onNewDataObject()
                        }, t.prototype.hasPendingRequests = function () {
                            if (!this.assetsLoaded) return !0;
                            if (this.assetsLoader.hasPendingRequests()) return !0;
                            for (var t in this.data)
                                if (this.data[t].hasPendingRequests()) return !0;
                            return !1
                        }, t.prototype.remove = function () {
                            return this.removed ? void r.Helpers.warn("Removing already removed chart") : (this.cancelChartUpdateNotify(), this.removed = !0, this.toolbar && this.toolbar.remove(), this.shell.remove(), this.clearData(!0), this.shell = null, this.scene = null, void(this.events = null))
                        }, t.prototype.setFullscreen = function (t) {
                            this.shell.setFullscreen(t)
                        }, t.prototype.isFullscreen = function () {
                            return this.shell.fullScreenMode
                        }, t.prototype.updateSize = function (t) {
                            void 0 === t && (t = !1), this.removed || this.shell.updateSize(t)
                        }, t.prototype.on = function (t, e) {
                            var i = this.EVENT_NAMES[t];
                            return i ? (this.eventListeners[i] || (this.eventListeners[i] = []), void this.eventListeners[i].push(e)) : void this.error("Unrecognized event name: " + t)
                        }, t.prototype.off = function (t, e) {
                            var i = this.EVENT_NAMES[t];
                            return i ? this.eventListeners[i] ? d.removeFromArray(this.eventListeners[i], e) : void 0 : void this.error("Unrecognized event name: " + t)
                        }, t.prototype.updateEvents = function (t, e) {
                            var i = t,
                                n = e;
                            for (var r in this.EVENT_NAMES) {
                                var s = this.EVENT_NAMES[r];
                                t && i[r] && this.off(s, i[r]), n[r] && this.on(s, n[r])
                            }
                        }, t.prototype.notifyHoverChanged = function (t, e) {
                            this.dispatchEvent("hoverChange", t, e, null)
                        }, t.prototype.notifyDoubleClick = function (t, e) {
                            var i = this;
                            this.dispatchEvent("doubleClick", t, e, function (t, e) {
                                return i.defaultDoubleClick(t, e)
                            })
                        }, t.prototype.notifyTripleClick = function (t, e) {
                            var i = this;
                            this.dispatchEvent("tripleClick", t, e, function (t, e) {
                                return i.defaultTripleClick(t, e)
                            })
                        }, t.prototype.notifyRightClick = function (t, e) {
                            var i = this;
                            this.dispatchEvent("rightClick", t, e, function (t, e) {
                                return i.defaultRightClick(t, e)
                            })
                        }, t.prototype.notifyClick = function (t, e) {
                            var i = this;
                            this.dispatchEvent("click", t, e, function (t, e) {
                                return i.defaultClick(t, e)
                            })
                        }, t.prototype.notifySelectionChanged = function (t) {
                            return this.dispatchEventParams("selectionChange", t, null)
                        }, t.prototype.notifySettingsChanged = function (t) {
                            return this.dispatchEventParams("settingsChange", t, null)
                        }, t.prototype.notifyPositionChange = function (t) {
                            return this.dispatchEventParams("positionChange", t, null)
                        }, t.prototype.notifyPointerDown = function (t, e) {
                            this.dispatchEvent("pointerDown", t, e, null)
                        }, t.prototype.notifyPointerUp = function (t, e) {
                            this.dispatchEvent("pointerUp", t, e, null)
                        }, t.prototype.notifyPointerDrag = function (t, e) {
                            this.dispatchEvent("pointerDrag", t, e, null)
                        }, t.prototype.notifyPointerMove = function (t, e) {
                            this.dispatchEvent("pointerMove", t, e, null)
                        }, t.prototype.notifyDataUpdated = function (t) {
                            return this.dispatchEventParams("dataUpdated", t, null)
                        }, t.prototype.notifyChartUpdate = function (t, e) {
                            var i = this;
                            void 0 === e && (e = !1);
                            var n = d.performanceNow();
                            e && (this.chartUpdateForce = !0), t && (this.chartUpdateWasBack = this.goingBack, this.chartUpdateOrigin = t, this.chartUpdateTime = n), this.chartUpdateState = this.saveNavigation(), null === this.chartUpdateTimeout && (this.chartUpdateTimeout = setTimeout(function () {
                                return i.chartUpdateNotify()
                            }, this.chartUpdateTime + this.scene.settings.events.chartUpdateDelay - n))
                        }, t.prototype.cancelChartUpdateNotify = function () {
                            this.chartUpdateOrigin = null, this.chartUpdateTimeout && (clearTimeout(this.chartUpdateTimeout), this.chartUpdateTimeout = null)
                        }, t.prototype.chartUpdateNotify = function () {
                            this.chartUpdateTimeout = null;
                            var t = this.chartUpdateOrigin;
                            if (t) {
                                var e = this.chartUpdateState;
                                !e || this.curState && JSON.stringify(e) === JSON.stringify(this.curState) ? this.chartUpdateForce && (this.chartUpdateForce = !1, this.chartUpdateOrigin = null, this.chartUpdateState = null, this.doChartUpdateNotify(t)) : (this.chartUpdateForce = !1, !this.chartUpdateWasBack && this.curState && (this.scene.pushBack(this.curState), this.events.notifySceneChanges({
                                    requestPaint: !0
                                })), this.curState = e, this.chartUpdateOrigin = null, this.chartUpdateState = null, this.doChartUpdateNotify(t))
                            }
                        }, t.prototype.doChartUpdateNotify = function (t) {
                            var e = this.createEventArguments(null, t);
                            this.dispatchEventParams("chartUpdate", e, null)
                        }, t.prototype.back = function (t, e) {
                            if (void 0 === t && (t = !0), void 0 === e && (e = "api"), 0 === this.scene.backStack.length) return !1;
                            var i = this.scene.backStack.pop();
                            return this.goingBack = !0, this.restoreNavigation(i, t, e), this.goingBack = !1, !0
                        }, t.prototype.goHome = function (t, e) {
                            if (void 0 === t && (t = !0), void 0 === e && (e = "api"), 0 === this.scene.backStack.length) return !1;
                            var i = this.scene.backStack[0];
                            return this.restoreNavigation(i, t, e), !0
                        }, t.prototype.clearHistory = function () {
                            return this.scene.backStack = [], !0
                        }, t.prototype.dispatchEventParams = function (t, e, i) {
                            var n = new C(0, 0, d.performanceNow(), "api");
                            return i || this.eventListeners[t] && this.eventListeners[t].length ? (this.dispatchEvent(t, n, e, i), n) : n
                        }, t.prototype.dispatchEvent = function (t, e, i, n) {
                            if (n || this.eventListeners[t] && this.eventListeners[t].length > 0) {
                                for (var r = Object.keys(i), s = 0; s < r.length; s++) e[r[s]] = i[r[s]];
                                if (this.eventListeners[t])
                                    for (var a = 0; a < this.eventListeners[t].length; a++) {
                                        var o = this.eventListeners[t][a];
                                        this.log("Call user event handler, " + t, e, i), o.call(this.api, e, i)
                                    }!e.defaultPrevented && n && (this.log("Call default event handler, " + t), n.call(this.api, e, i))
                            }
                        }, t.prototype.error = function (t, e) {
                            var i = this;
                            void 0 === e && (e = null);
                            var n = this.createEventArguments(null, "api");
                            n.message = t, n.arg = e, this.dispatchEventParams("error", n, function (t, e) {
                                return i.defaultError(t, e)
                            })
                        }, t.prototype.log = function (t) {
                            for (var e = [], i = 1; i < arguments.length; i++) e[i - 1] = arguments[i];
                            this.settings.advanced.logging && d.log(t, e)
                        }, t.prototype.deprecated = function (t, e) {
                            var i = "Deprecated: " + t + ".";
                            e && (i += " Use " + e + " instead"), r.Helpers.warn(i)
                        }, t.prototype.defaultError = function (t, e) {
                            e.arg ? d.error(e.message, e.arg) : d.error(e.message)
                        }, t.prototype.createToolbar = function () {
                            this.toolbar && this.toolbar.remove(), this.assetsLoaded && (this.toolbar = new $(this, this.settings.toolbar))
                        }, t.prototype.notifyAssetsLoaded = function () {
                            this.removed || (this.assetsLoaded = !0, this.createToolbar(), this.updateSize(!0), this.events.notifySceneChanges({
                                assets: !0,
                                style: !0
                            }))
                        }, t
                    }();
                r.Impl = Zt;
                var Yt;
                ! function (t) {
                    t[t.FacetChart = 1] = "FacetChart", t[t.GeoChart = 2] = "GeoChart", t[t.NetChart = 4] = "NetChart", t[t.PieChart = 8] = "PieChart", t[t.TimeChart = 16] = "TimeChart"
                }(Yt || (Yt = {}));
                var qt, _t = !1,
                    Xt = {},
                    Qt = function () {
                        function e() {}
                        return e.checkChartType = function (t, e) {
                            var i = e.lastIndexOf("-", e.indexOf(":"));
                            if (i === -1 || i === e.indexOf("-")) return !0;
                            var n, r = 0;
                            for (i++;
                                (n = e.charCodeAt(i)) > 47 && n < 58;) r = 10 * r + n - 48, i++;
                            var s = Yt[t];
                            return s > 0 && (r & s) === s
                        }, e.execute = function (e, i) {
                            var n = this,
                                s = window.ZoomChartsLicense,
                                a = window.ZoomChartsLicenseKey,
                                o = e.api.typeName,
                                l = s + d.SeparatorChar + o,
                                h = Xt[l];
                            if (h) return void(h.result ? this.handleServerResponse([e], h.result) : h.charts.push(e));
                            Xt[l] = h = {
                                charts: [e],
                                result: null
                            };
                            var u = "ZoomCharts " + t.PackageInfo.Version;
                            s && a ? Wt.verifySignature(s, a) ? _t || (d.log(u + " license verified: " + s), _t = !0) : d.error(u + (" license key for license '" + s + "' is invalid. Please configure the correct key in order to use the charts.")) : (d.error(u + " license key was not found on the page. Please make sure ZoomChartsLicense and ZoomChartsLicenseKey variables are correctly set before initializing the chart."), s = a = "---:");
                            var c = ". Please upgrade your license on https://zoomcharts.com",
                                p = s.charAt(2);
                            if (!this.checkChartType(o, s) && (d.error("ZoomCharts license used on this page does not allow use of " + o + c), p = "-", !i)) return void this.displayBanner(e, "builtin://logo-license-expired");
                            var f = /(\d\d\d\d-\d\d-\d\d)$/,
                                g = "builtin://logo-license-expired",
                                m = g;
                            switch (p) {
                                case "F":
                                case "O":
                                    var v = s.match(f),
                                        y = t.PackageInfo.Built,
                                        S = s.substring(0, s.indexOf(":")),
                                        b = ["ZCF-f7zr14ipl-25", "ZCF-6sag05711-16", "ZCF-981cwt0sy-8", "ZCF-x33yuxzf8-1", "ZCF-8r2n87ra8-8", "ZCF-1flw35m2i-16"];
                                    return b.indexOf(S) >= 0 ? void(g = null) : void(v && v[1] < y ? (h.result = {
                                        status: 2,
                                        bannerImage: g,
                                        consoleMessages: [{
                                            level: "error",
                                            text: "ZoomCharts license is not valid for this library version which was released on " + y + c
                                        }]
                                    }, this.handleServerResponse(h.charts, h.result)) : (h.result = {
                                        status: 1
                                    }, h.charts = []));
                                case "B":
                                    var C = s.match(f),
                                        x = "https://zoomcharts.com/en/renew-licence/";
                                    return void(C && C[1] < (new Date).toISOString() ? (h.result = {
                                        status: 2,
                                        bannerImage: "builtin://logo-license-expired",
                                        consoleMessages: [{
                                            level: "error",
                                            text: "ZoomCharts license has expired on " + C[1] + ". Please renew the license at " + x
                                        }],
                                        bannerTarget: x
                                    }, this.handleServerResponse(h.charts, h.result)) : (h.result = {
                                        status: 1
                                    }, h.charts = []));
                                case "-":
                                case "S":
                                    g = "builtin://logo-development";
                                    break;
                                case "X":
                                    g = "builtin://logo-supported-by";
                                    break;
                                default:
                                case "P":
                                    g = null
                            }
                            var w = JSON.stringify({
                                protocol: 1,
                                version: t.PackageInfo.Version,
                                revision: t.PackageInfo.Revision,
                                libraryName: t.PackageInfo.LibraryName,
                                assetsDomain: this.parseUriDomain(e.assetsLoader.getAssetUrl("assets://")),
                                pageDomain: location.hostname,
                                chartType: o,
                                license: s.substring(0, s.indexOf(":")),
                                licenseKeyHash: Wt.hash(a)
                            }, null, " ");
                            r.Helpers.doPostRequest(e.assetsLoader.getAssetUrl("https://api.zoomcharts-cloud.com/lc/v1/"), 3e4, w, function (t) {
                                try {
                                    var i = JSON.parse(t);
                                    if (1 !== i.protocol) throw "Server response contains invalid protocol.";
                                    var r = Xt[l];
                                    r.result = i, n.handleServerResponse(r.charts, r.result)
                                } catch (t) {
                                    n.handleServerError(e, "Unable to parse licensing server response: " + t), g && n.displayBanner(e, g), delete Xt[l]
                                }
                            }, function (t) {
                                t = t || "", delete Xt[l], n.handleServerError(e, "Unable to contact licensing server: " + t), (2153644038 === t.result || t instanceof DOMException && t.code === DOMException.SECURITY_ERR || "SecurityError" === t.name) && (g = m), g && n.displayBanner(e, g)
                            })
                        }, e.displayBanner = function (t, e, i) {
                            if (!t.removed) {
                                var n = new N;
                                i && (n.url = i), n.imageScaling = .5, n.image = e, n.enabled = !0, n.enabledOnExport = !0, n.location = "inside", t.events.addElement(new F(t, n)), t.events.notifySceneChanges({
                                    settings: !0,
                                    settingsChanges: {
                                        credits: {
                                            enabled: n.enabled
                                        }
                                    }
                                })
                            }
                        }, e.handleServerError = function (t, e) {
                            t.error(e)
                        }, e.handleServerResponse = function (t, e) {
                            if (null !== e) {
                                if (e.consoleMessages)
                                    for (var i = 0; i < e.consoleMessages.length; i++) {
                                        var n = e.consoleMessages[i];
                                        switch (n.level) {
                                            case "error":
                                                d.error(n.text);
                                                break;
                                            case "warn":
                                                d.warn(n.text);
                                                break;
                                            default:
                                            case "info":
                                                d.log(n.text)
                                        }
                                    }
                                for (var i = 0; i < t.length; i++) {
                                    var r = t[i];
                                    if (!r.removed)
                                        { 
                                            // console.log()
                                            // if (1 === e.status);
                                            // else if (2 === e.status) this.displayBanner(r, e.bannerImage, e.bannerTarget);
                                          }
                                    else {
                                        if (3 !== e.status) {
                                            d.warn("Licensing server returned unknown status code " + e.status);
                                            break
                                        }
                                        this.blockChart(r, '<a href="' + e.bannerTarget + '"><img src="" title="Problem with the license"/></a>')
                                    }
                                }
                                t.length = 0
                            }
                        }, e.parseUriDomain = function (t) {
                            var e = document.createElement("a");
                            return e.href = t, e.hostname || (e.href = e.href), e.hostname
                        }, e.blockChart = function (t, e) {
                            var i = t.settings.container;
                            t.remove(), i.innerHTML = "<strong>Unable to use ZoomCharts library because of a licensing issue:</strong><br/>" + e
                        }, e
                    }();
                ! function (t) {
                    t[t.inside = 0] = "inside", t[t.outside = 1] = "outside"
                }(qt = r.InfoPopupPosition || (r.InfoPopupPosition = {}));
                var Jt = function () {
                    function t(t) {
                        this.chart = t, this.container = t.shell.interactiveContainer, this.events = t.events, this.popup = null, this.visible = !1, this.x0 = null, this.x1 = null, this.y = null, this.contentsChanged = !1
                    }
                    return t.prototype.hide = function () {
                        return !(!this.visible || !this.popup) && (this.visible = !1, this.popup.style.display = "none", !0)
                    }, t.prototype.remove = function () {
                        this.popup && this.popup.parentNode && (this.popup.parentNode.removeChild(this.popup), this.popup = null)
                    }, t.prototype.ensurePopup = function () {
                        this.popup || (this.popup = d.createDom("div", "DVSL-info-center", null, this.container), d.createDom("em", null, null, this.popup), this.popup.style.position = "absolute", this.popup.style.display = "none")
                    }, t.prototype.show = function (t, e, i, n, r) {
                        void 0 === r && (r = qt.inside), this.ensurePopup();
                        var s = this.popup;
                        n ? (n.indexOf("<") === -1 && n.indexOf(">") === -1 && (n = "<b>" + n + "</b>"), this.visible = !0, s.style.display = "block", n !== s.innerHTML && (s.innerHTML = n, this.postProcessHtml(s), this.contentsChanged = !0), this.updateXY(t, e, i, r)) : s.style.display = "none"
                    }, t.prototype.postProcessHtml = function (t) {
                        if (t instanceof HTMLElement) {
                            var e = t.getAttribute("data-color");
                            e && (t.style.color = e, null != t.getAttribute("data-selected") && (t.style.borderColor = e))
                        }
                        for (var i = t.firstElementChild; i;) this.postProcessHtml(i), i = i.nextElementSibling
                    }, t.prototype.updateContents = function (t) {
                        null === t ? this.hide() : this.show(this.x0, this.x1, this.y, t, this.position)
                    }, t.prototype.updateXY = function (t, e, i, n) {
                        if (void 0 === n && (n = qt.inside), this.visible && (this.contentsChanged || this.x0 !== t || this.x1 !== e || this.y !== i || this.position !== n)) {
                            this.ensurePopup(), this.contentsChanged && (this.contentsChanged = !1, this.popup.style.right = null, this.width = this.popup.offsetWidth, this.height = this.popup.offsetHeight), this.x0 = t, this.x1 = e, this.y = i, this.position = n;
                            var r, s = 12,
                                a = 10,
                                o = this.width,
                                l = this.height,
                                h = null,
                                u = this.popup.style,
                                c = this.chart.scene;
                            if (t > c.x0 + c.width || e < c.x0) return void(u.top = "-10000px");
                            var d = this.chart.getRootChart().scene;
                            switch (n) {
                                default:
                                    case qt.inside:
                                    d.x0 <= t - o - a ? (h = t - o - a, r = "DVSL-info-left") : d.x0 + d.width >= e + o + a ? (h = e + a, r = "DVSL-info-right") : (h = (Math.max(t, d.x0) + Math.min(e, d.x0 + d.width) - o) / 2, r = "DVSL-info-center"),
                                i = Math.min(Math.max(d.y0 + s, i - l / 2), d.y0 + d.height - l),
                                i = Math.max(this.chart.shell.getChartInnerArea().findTopPosition(h, h + o), i);
                                break;
                                case qt.outside:
                                        r = "DVSL-info-center",
                                    h = Math.min(d.x0 + d.width - o, Math.max(0, (t + e - o) / 2));
                                    var p = this.chart.shell.container.offsetTop;i = p > l ? d.y0 - l : d.y0 + d.height
                            }
                            var f = null;
                            o >= d.chartWidth ? (f = 0, h = 0) : h + o > d.chartWidth - 20 && (h + o > d.chartWidth ? (f = 0, h = null) : (f = d.chartWidth - h - o, h = null)), u.right = null !== f ? f + "px" : null, u.left = null !== h ? h + "px" : null, u.top = i + "px", this.popupClass !== r && (this.popupClass = r, this.popup.className = r)
                        }
                    }, t
                }();
                r.InfoPopup = Jt;
                var Kt = function () {
                    function t(t, e, i) {
                        void 0 === i && (i = !1), this._direction = 1, this._endTime = 0, this._midTime = 0, this._startTime = 0, this._preventOvershoot = !1, this._setTargetPending = !1, this._settableTargetValue = 0, this._settableAcceleration = 0, this._acceleration = t, this._initialValue = this._targetValue = e, this._preventOvershoot = i
                    }
                    return t.prototype.setTarget = function (t, e, i, n) {
                        if (null == e) return this._settableTargetValue = t, this._settableAcceleration = i, void(this._setTargetPending = !0);
                        this._settableAcceleration = null, this._setTargetPending = !1, null != i && this.setAcceleration(i, e);
                        var r = this._getDeltaT(e),
                            s = this._getDistanceToV0(r),
                            a = this._composeValue(e, s),
                            o = Math.abs(t - a),
                            l = t > a ? 1 : -1;
                        if (e < this._startTime && (this._direction *= -1), this._targetValue = t, e < this._endTime)
                            if (s > o || this._direction !== l)
                                if (this._preventOvershoot)
                                    if (this._direction === l) {
                                        var h = this._getCurrentVelocity(r);
                                        this._acceleration = h * h / (2 * o), this._startTime = e - h / this._acceleration, this._initialValue = a - o * this._direction
                                    } else this._startTime = e, this._initialValue = a;
                        else this._startTime = e + r, this._initialValue = a + s * this._direction;
                        else(e >= this._midTime || e <= this._startTime) && (this._startTime = e - r, this._initialValue = a - s * this._direction);
                        else this._startTime = e, this._initialValue = a;
                        this._direction = this._targetValue > this._initialValue ? 1 : -1;
                        var u = Math.abs(this._targetValue - this._initialValue),
                            c = Math.sqrt(u / this._acceleration);
                        this._midTime = this._startTime + c, this._endTime = this._startTime + 2 * c, null != n && this._endTime - this._startTime > n && (this._endTime = this._startTime + n, this._midTime = (this._startTime + this._endTime) / 2, c = this._endTime - this._midTime, this._acceleration = u / (c * c))
                    }, t.prototype.getValue = function (t) {
                        return this._setTargetPending && this.setTarget(this._settableTargetValue, t, this._settableAcceleration), this.finished(t) ? this._targetValue : this._composeValue(t, this._getDistanceToV0(this._getDeltaT(t)))
                    }, t.prototype.getTargetValue = function () {
                        return this._targetValue
                    }, t.prototype.finished = function (t) {
                        return !this._setTargetPending && t >= this._endTime
                    }, t.prototype.jump = function (t, e, i) {
                        if (this._initialValue = this._targetValue = t, this._startTime = this._midTime = this._endTime = 0, null != e && null != i && 0 !== e) {
                            var n = e > 0 ? 1 : -1,
                                r = Math.abs(e / this._acceleration);
                            this._direction = n, this._midTime = i, this._endTime = i + r, this._targetValue = t + this._getDistanceToV0(r) * n
                        }
                        return this._targetValue
                    }, t.prototype.setAcceleration = function (t, e) {
                        if (t !== this._acceleration) {
                            var i = e < this._endTime;
                            if (i) {
                                var n = this._getDeltaT(e),
                                    r = this._getCurrentVelocity(n),
                                    s = this._composeValue(e, this._getDistanceToV0(n));
                                e < this._startTime && (r = -r), this._acceleration = t, this.jump(s, r * this._direction, e)
                            } else this._acceleration = t
                        }
                    }, t.prototype._composeValue = function (t, e) {
                        return t < this._startTime ? this._initialValue + e * this._direction : t < this._midTime ? this._initialValue + e * this._direction : t < this._endTime ? this._targetValue - e * this._direction : this._targetValue
                    }, t.prototype._getDistanceToV0 = function (t) {
                        return this._acceleration * t * t / 2
                    }, t.prototype._getDeltaT = function (t) {
                        return t < this._startTime ? this._startTime - t : t < this._midTime ? t - this._startTime : t < this._endTime ? this._endTime - t : 0
                    }, t.prototype._getCurrentVelocity = function (t) {
                        return t * this._acceleration
                    }, t
                }();
                r.Inertia = Kt;
                var $t = function (t) {
                    function e() {
                        return t.apply(this, arguments) || this
                    }
                    return n(e, t), e
                }(r.ChartElement);
                r.Navigator = $t;
                var te = function () {
                    function t() {}
                    return t.prototype.customize = function (t) {
                        var e = this.constructor.themes;
                        if (!e.hasOwnProperty(t)) throw new Error("The chart does not contain a predefined theme named `" + t + "`.");
                        return this.updateSettings(e[t])
                    }, t.prototype.saveState = function () {
                        return this._impl.save()
                    }, t.prototype.restoreState = function (t, e) {
                        void 0 === e && (e = !1), null == e && (e = !1), this._impl.restore(t, e)
                    }, t.prototype.fullscreen = function (t) {
                        return t === !0 ? this._impl.setFullscreen(!0) : t === !1 && this._impl.setFullscreen(!1), this._impl.isFullscreen()
                    }, t.prototype.updateSettings = function (t) {
                        return t && this._impl.updateSettings(t, "api"), this
                    }, t.prototype.replaceSettings = function (t) {
                        if (t) {
                            var e = i.Base.SettingsHelper;
                            try {
                                e.replacingSettings = !0, this._impl.updateSettings(t, "api")
                            } finally {
                                e.replacingSettings = !1
                            }
                        }
                        return this
                    }, t.prototype.updateFilters = function () {
                        this._impl.updateFilters(null)
                    }, t.prototype.updateStyle = function () {
                        this._impl.updateStyle(null)
                    }, t.prototype.on = function (t, e) {
                        this._impl.on(t, e)
                    }, t.prototype.off = function (t, e) {
                        return this._impl.off(t, e)
                    }, t.prototype.updateSize = function () {
                        return this._impl.updateSize(!0), this
                    }, t.prototype.reloadData = function (t) {
                        return void 0 === t && (t = null), this._impl.reloadData(t)
                    }, t.prototype.remove = function () {
                        return this._impl.remove()
                    }, t.prototype.saveAsImage = function (t, e, i) {
                        return this._impl.deprecated("saveAsImage", "exportAsString"), this.exportImageAsString(t, e, i)
                    }, t.prototype.exportGetDimensions = function (t) {
                        return this._impl.deprecated("exportGetDimensions", "exportImageGetDimensions"), this.exportImageGetDimensions(t)
                    }, t.prototype.exportImageAsString = function (t, e, i) {
                        return this._impl.deprecated("exportImageAsString", "exportAsString"), Ut.export(this._impl, t, e, i, function () {})
                    }, t.prototype.exportImageGetDimensions = function (t) {
                        return Ut.getDimensions(this._impl, t)
                    }, t.prototype.exportAsString = function (t, e, i, n) {
                        if (void 0 === n && (n = !1), !e) throw new Error("`callback` argument is mandatory.");
                        Ut.export(this._impl, t, i, n, e)
                    }, t.prototype.export = function (t, e, i) {
                        void 0 === i && (i = !1), Ut.download(this._impl, t, e, i)
                    }, t.prototype.addSubchartContainer = function (t) {
                        this._impl.shell.interactiveContainer.appendChild(t)
                    }, t.prototype.suspendPaint = function () {
                        this._impl.events.suspendPaint()
                    }, t.prototype.resumePaint = function () {
                        this._impl.events.resumePaint()
                    }, t.prototype.paintNow = function (t) {
                        return void 0 === t && (t = !1), this._impl.events.paintNow(t), this
                    }, t.prototype.back = function () {
                        return this._impl.back(), this
                    }, t.prototype.home = function () {
                        return this._impl.goHome()
                    }, t.prototype.clearHistory = function () {
                        return this._impl.clearHistory(), this
                    }, t.prototype.profiler = function () {
                        return this._impl.shell.profiler
                    }, t.prototype.measureFps = function (t, e) {
                        this._impl.deprecated("measureFps"), this.profiler().measureFps(t, e)
                    }, t
                }();
                te.themes = {}, r.Api = te;
                var ee = function () {
                    function t(t, e, i, n) {
                        void 0 === i && (i = 0), void 0 === n && (n = t.length), null == n && (n = t.length), null == i && (i = 0), this.n0 = i;
                        var r = [];
                        r.length = n - i;
                        var s = 0;
                        r[n - i - 1] = (e[n - 1] - e[n - 2]) / (t[n - 1] - t[n - 2]);
                        var a, o = (e[i + 1] - e[i]) / (t[i + 1] - t[i]);
                        for (a = i + 1; a < n - 1; a++) {
                            var l = (e[a + 1] - e[a]) / (t[a + 1] - t[a]),
                                h = void 0;
                            if (0 === o) h = s = 0;
                            else {
                                h = (o + l) / 2;
                                var u = (s * s + h * h) / (o * o);
                                if (u > 9) {
                                    var c = 3 / Math.sqrt(u);
                                    s = c * s, h = c * h
                                }
                            }
                            r[a - i - 1] = s, s = h, o = l
                        }
                        r[a - i - 1] = s, this.x = t, this.y = e, this.m = r
                    }
                    return t.prototype.interpolate = function (t, e) {
                        var i = this.x[t + 1] - this.x[t],
                            n = (e - this.x[t]) / i,
                            r = n * n,
                            s = r * n,
                            a = 2 * s - 3 * r + 1,
                            o = s - 2 * r + n,
                            l = -2 * s + 3 * r,
                            h = s - r,
                            u = a * this.y[t] + o * i * this.m[t - this.n0] + l * this.y[t + 1] + h * i * this.m[t - this.n0 + 1];
                        return u
                    }, t.prototype.interpolateArray = function (t, e, i, n, r) {
                        for (var s = this.x[t], a = this.y[t], o = this.m[t - this.n0], l = this.y[t + 1], h = this.m[t - this.n0 + 1], u = this.x[t + 1] - s, c = 1 / u, d = i; d < n; d++) {
                            var p = (e[d] - s) * c,
                                f = p * p,
                                g = f * p,
                                m = 2 * g - 3 * f + 1,
                                v = g - 2 * f + p,
                                y = -2 * g + 3 * f,
                                S = g - f,
                                b = m * a + v * u * o + y * l + S * u * h;
                            r.push(b)
                        }
                    }, t.prototype.clear = function () {
                        this.m.length = 0
                    }, t
                }();
                r.MonotoneCurve = ee,
                    function (t) {
                        var e = function (t) {
                            function e() {
                                return t.apply(this, arguments) || this
                            }
                            return n(e, t), e.prototype.onSceneChange = function (e) {
                                t.prototype.onSceneChange.call(this, e);
                                var i = this.chart.zoomOutPossible(),
                                    n = this.options;
                                n.enabled !== i && (n.enabled = i, this.updateSettings())
                            }, e
                        }(t.Button);
                        t.ToolbarItemNames.zoomOut = function (t, i) {
                            var n = t.settings.localization.toolbar;
                            i.label = i.label || n.zoomoutButton, i.title = i.title || n.zoomoutTitle, i.cssClass = i.cssClass || "DVSL-bar-btn-zoomout";
                            var r = i.onClick;
                            return i.onClick = function (e, i) {
                                t.zoomOut(!0, "user"), r && r(e, i)
                            }, new e(t, i)
                        }
                    }(o = r.Bar || (r.Bar = {}))
            }(d = i.Base || (i.Base = {})),
            function (t) {
                t.LicenseBannerBlank = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQQAAABICAYAAAAQ5YupAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABAxpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ1dWlkOjU4MDZiZGQ4LWNkOWEtNDY3MS05ZTg1LTcwOWFlZDg0MDY4YyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxQkU1RjhGREExRjQxMUU3QjM5Mzg1MjMwMzI0MjYyRiIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxQkU1RjhGQ0ExRjQxMUU3QjM5Mzg1MjMwMzI0MjYyRiIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBJbGx1c3RyYXRvciBDQyAyMDE3IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ1dWlkOjAzYTBmMDNkLTNiNTktNDRkNi05ZjhlLWZkMGI3MTQ3ZDk1YiIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo3YzdiOTZjNi0yYzYyLWM3NGEtOTEzYi00YTgzZTg1YmViODAiLz4gPGRjOnRpdGxlPiA8cmRmOkFsdD4gPHJkZjpsaSB4bWw6bGFuZz0ieC1kZWZhdWx0Ij5mb3ItY2hhcnRzLXpvb21jaGFydHMtYmxhbms8L3JkZjpsaT4gPC9yZGY6QWx0PiA8L2RjOnRpdGxlPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PtHwutkAABHoSURBVHja7J0J2ExlG8dvS1p9VCpF2SoqUlEptJK0UJKQ9oVEKNKVtIhLtIu0Ry6ilZK0XVEpok1RqGhBSUmS3fP59Xzne888c2bmnHlnmDH3/7qO18yc9Vnu577/93JKGJFFIlJOFApFoWNliS0CYcOW/5TWtlAoCh4bS275529tB4VCgSwoqW2gUCg8qEBQKBQqEBQKhQoEhUKhAkGhUKhAUCgUKhAUCoUKBIVCoQJBoVCoQFAoFCoQFApF9qBJTYr0sMMOIrvtJmKM/VyihMhff4ls2qRtoxqCouBw2mki33xTtH39tcjhh2u7qIawHWPXXUX23FOkbFm7+q1YIfK3Jof+C7SDvfeO/W6nnQpsOS1pNSO0JP5u3lykMalA2E7AKnfyySLNm4scdpjIf/5j1eMNG0T++Udk9myRN94Qeftt+/9CBe3hopDMhbp1RYYP3zKDtkyhjRtFypQRueMOkVdfVYGw3XRw794ibdtaae9i552tcKhY0arLrATPPy8ycKDI559r+xUa0ByPOy72u/33Vw5hu0DHjiIffCDSrl2wMAgC+7VpIzJtmkjnztqGqiGJrFunAiHvcf/9Io88Ym3iRB2/apXImjXBv++yi8iwYSJDh+okUeQ9CttkGDBApHv34N8wB95/X+STT0T++MMSZtWrizRsKHLGGSK1asXuf+21IqtXW7NDochXbLGEVxhrERfW1qqVCcTo0cbUrp382F13NaZ7d2NWr44//pJLCrf9jjmmcMZP48bxz3/FFfn+XCsK02QoV07k4Yfjv7/1VpELLxT56qvkx6MJPPCAyIkniixaFG+C7L578uPxWoTlKoKw44652a6JzKp8R1Bf/fln/HeYlmoypECDBiLnniuydm3658BOf/NNkbfeysw9odbvs0/sd7fdJnLnndHOM2uW9ThMny6yxx72O4TB9deL9O1rPRK4LhEchxxiWWieBRcVLjoEyy+/iEyZYt1VCxYUnbtUKZFq1USOPVakfn2RmjVF9trLejs8NyixEQQETZggMnWqyMqV0e5/v/3svZ1yisjBB1sehXtbv966WH/6SeTLL63pRPDR8uVJVE1jBVXlyiJNmth+P/BAK3z5nuflfjnf669bt21YEo625fkbNRI59FDbLsSIcF6uy70uXizy0Uci77yTntcHr0GVKtbbVLu2SNWqtv9obwjnsWNFzj7btg0bz+aiQweRgw6ybegBU/PHHy1PFeSWrVfPmqD0M3EdXM9zcc+bZ6/N+Fi4MPa4ffe17Yzbk/ZkHOWFydC7t8kIhgxJfa3SpY1p2tSYm24yZvhwY15+2ZhJk4x55RVjnnzSmBtvNOaCC4xZvDj23FOmFO8Z27WLPd+yZcY8/bQxS5eGf7716+0znniiMddea8x770Vrn3nzjGnbNtz97r67MYMHG7N8efjzL1pkTJcuiU2GzZuNmTXLmBUrwp1vxgxjmjdPfa+YYN99F60t6Pcw5kvFisZcfbUxTzxhny8RJk82pk+f9MfuTz8ZU6ZM7LUrVTJmzJhwx69bZ8yoUcbUrWuPPfpoO6YZL/37GzNunDFHHpkRkyH7AgFbOxMYNCjxNapVs78zKdJBgwbFf86pU01OIJXgZODMmZPeuT//PDUHExXduiW/3wkT0jsvAtYvwPxbhQp2Mi5ZEu5cY8ca07Nn+s84d26sQNhnH2O++Sb6efr1M6ZECWPuvtv284gRxvTta0zHjsbce2+80MlJDgEVORMIsptRGwcNshGDN95o1d6oQNVG5S8ucD3mArp2tVxIEFBzUS9Ru9NBptRSP+BiiP9IhKhmkJ+neeghkYsuiv8N84NronaHAWq83wyICsapB8KdR4+29xAVv/9uw+gxjz77TKR9e5EWLURGjLAh9TVq5AGHMGeOtYPCEC7YTdiHRx0V/xv2px9HH23tsqB9o+DddzPznDNmWFKNweM+0/z51o6EI6BTsUHZDzv1iCOsHZkM2JJsCD4GA53PAGVQNW4cHzHnhdAyaPwDcdy4eO4EfPGFFRTY99yfZ1MzwI45xtrV8B/Y1GHw/ff2eXnu336zNjF8BefBVnZBDAf8UBBHgQ1O3/PstDGE7w8/2LwScgeYIIyZk04SadlSpEKF2OMfe8wGj3FPHhKFWNN/kMS0MX3188/22nAS8D1cD94DPgyh2qVL7PG073vvxS5e9NPSpTa8GbRuLXLqqfHXnjjRhsTDFTA+ECIIcPqWMe5xGoynSpXseR980ArMCy6w7UBbb3duxyDVe+FCa+95+5x2mjGrViVXrxYsMObFF4159FHLJ6D2zZ4dv19YuzvVtuOOxnz5Zey5N2ywqnUYDmLt2vh7g/do1syYUqWSHz9gQPyxcBj+fTp3jt/nr7+MueiicJxDjx5WZfXU0iCTgWuefbZ1yyY611lnBZt2qORB+8MF1KoVrg+qVAkeP3AE/v0wEV0MHVpko4fZ6tSJP0ebNqmPg9Ny+YEOHZIfU7asNa1atrSfGbPwXqeeasz551sTsEWLPOEQomx0nAvIquOOK9qnSRNjNm0KFgKQedhW9erZQeyef7fdjDnkEEvE/PCDPYYGzdT9T5sWez9r1hhTvXq4Y7knFwi+sNeePj2eBGQg8dsOO8TzBhs3Rju/t3nCKUggVK0a7hzEeTAR/Jg5MzN9sMce8dwA46J8+eQCIWpbpBOHQNu5wnDixPSek3nAQsDWqFHG4hByRyB06hQ8ySFMvH0YcCtXBu+HMKlcOfz1GCDDhmVOQ6CzP/009p5Y9Y84Itzx++4bH+j0wAPhrx+kARx+uP2tYcP433j2TAcm1a8f/ng0Nj/++Se8QEm1DRwYf2+spskEQvv22RcILEjeQuQB7VUDkxxgIw0ZEv/9c8+JPPpo0ecnn7QZh67/m+SkK6+0Nl9YEFhCuPH48Zl5BmIEsPPSBXYmtqsfbr2BZHD91KB8efuXWAMXL7yQ+X4sGWE4ETPgEnfEamQCxGW4IOw8FwK34Af8gBQkZqNgApNSgQnO4IQV9gOC6+KLiz5fcYUNoHEBSfPSS+lfvzgBU35QRyFVhGLUSL8ozLZHWgVNUJe0XLJE5NNPt22/IwBdhCUtITyZ4BCVkGkE5zDRaD8IR353EUSmbm1AZhLg5Q9q4hkI/Bo1yi54EKdBfVkwAgFPASyx23BEfXmRbHT4LbfEH9uvX/GEQSZxySXFX13dFTbKihu0L6w4cPP0mYzpuvMyBdjyIFdhIpBMdtZZdkWF4UcQBAlMxkzQhCqO2zDT453niJmFW8b3ZZfZBZDIU6IiP/wwcx6wvBEIN90U7IOmcfzViBgErjqOK4lw41wArjR8wplGcctxeRPDTe3e1sIgkevPE2CuBnnXXSKXXx4uh4N9gvbLldJmr70mMniwjZtxQbg6YdP9+9vPM2dadyzuxWXLtsrtbTsOAf821YZcPPWUVZ/8oBCJi9tvz40OZvA9/rjkJLwJ5q68rh27LRAmuYu8CFbJa67J3YSudEAuDRpvqpJzxNrcfLPIxx/bfKDtVkOALAsitbBrIQj9YHVzuQMCRUiO2dYgcefFF0Xq1BFFhoFmQKJSUPQpATiMFdRqyFSC3jAJICYxJeBMMOGKk1GabVCLA/KTkn0EFsGJJDIRSbrCND7vvKybyNtGIIwcGW/XYlOidrv2H9FtbvQZmY/ZAvcVprry8cdbVY5MxFwFKmiQRpAPqy1agSsM6BfU6aeftv9PBAhETNFcf06iLtEU4MIYT5jGjCeiT4PwzDO2YA/E6XZjMvTpI3L66fHfI9EJzw0ik1xJDxObLRAOTKNjznjCiHwMVh5CRs8/32oFcBiuMIAQygV1/P/i/n/y3g379lK1cxX096WXxn6HFtC0qch99yUXBsANH891MGZIcSZt/oQTrHAg38EF4cxB3EPeagjUDvAIEz9YaRP5xV0XEnHxWZSQ/0ptViYITzYSeiB0WG28egZBoNAqWgXaT66B9vL7urHNMdu2ElGVlpaGO84PJgiCOqxmlM/vRyBGg42kOxK0/CBng/yOTLnLt5lAILOM5A8X2IGJ6hoC9+UfSNMolWmYyFRBwiZFmEDkuI2J7QYB9+yz1j4lwIlJA/CNJ/OPE+CEZEeNxTuSi3YrbDV2ql/IQuqSUJOL4P5cNyFJcmGBMChdOr6PM63FZBskfSHIGb8e8LYxl4IC0fJKIDBhvMg5v01IvEEqdcqV/lF8yggU3DxBwSoumCBk3IUZPPi78YbcfbfN6gOJKjdvS9UbBPmz8XnnqkDALYrw9i8GUSIN6QdXIGS6RHqQizQb5iLEql8gYA5lkRvZOhzCPfeINGsWr/rjSkkl6dyahQwSV51MtVqEef3at9/a6soQUngPPBD9RiAPGxwHfmQIL/zFV11VJAwSDZJcAIw8WoIfcCHpBFN5RGU2QZ+7kYznnJM8cMmPoBoIQfxUcYCW6gqZMKHmaKr++gip4BKMaKQuJ5RXAqFVK5Ebboj/nqIOFCehERNtTEy8D66/NupLRcNMVCYM+6FK+zuM2gJHHmnzLbxoOaLNECD5BIq/BvVBz56pSThyDAgOophJya2whtAPbj4C0ayTJqV28V53nUiPHvEaByttJkF9BZfc7NQpuOgKmpq3qlP/AjO5WzfrTkwGTFFXaGM6ZaNQzVYzGRK91QiCEe0gmfqDFoF54NprxCWgdWQSY8bYv64mQ7zDr79K3gN+BI4Dpt4PTB4GMiz33Ll28jDpMbGIuUf44nlhZYPUC3pjUTZABSomtl/1p6goZBtFSPA0eYVHEOAQwSRxBQkMAsfQ/jKtIXAPFGXxQHsRRARBTtEZxi0rPF4dLxQfjZM2RbjicqTNaVcKynBO2p5CrRwXlPQEaZ1FTTT7AiFRokYq6ZgMvIwVm9JfBac4oLIQ9jQrpT8qEtU1CpmV62BQopW5L5mhMlKY8lvJqi5nGnhGWEXd0nRMfl7EyxYGTLio1bTDgvJ9foEAIKNdkhzB5fELfrMHlzZuRrYwYHEikjeLyL7+lw33DzxCJv2xpEF72gxpzB4QElHcO646zeoWhY127fMo9nrQddzvcDOiIaQb5ennbsJcL+r9uu3HuzMI8013RSRjFhPPtbmLe+8e0FbCvKnLnztCKbZ0Fy0C97LMU2VfIIQlgqKCEGdX/U0H1FGgY1HTiBjz27G87rs4hBufoww013yK0nZBtn3Qd7hUaTeEYJTX2WP3+nNPgoRVlGcNuregc+Ih4vV5TzwRnCEZBALEevWy9QiDSOuw1w4D7o8UfN7RkUz4eQsjcS4QutRPDGuaYNYRf5CJmomp5PS/ZZNEymftCqj3+E6LY3syEChM6fIRFBQhbj2ZjY/tS+6Dm2LNOalQjArGSo5Q8EcekpuOsIgCbG0GIcKEQcAzU7w0VWSdN2jOPNNqKJ7LjUKfqPhhAJnFCz9QTb2XpqDhJGsb1G/IUlRWiEN4A45DK4LNxq5llWWwY575+/CAA6xgwS72Urcp7OoVaU0Foj7hgjwhwvEU401G1nJNMktpY1Rz6k8wkbHLMWeoNUBtAez3ZLEqqOqYHFwTwhrBG/QylKhaK/dFH9CWBLAxxhh7EKS0oast8xIfSGyIRp4HEp17QqNgbBMNS5vwwpytgz/z692Obs1CMH++rZOYrFQaxU79tQRHjjSmZs2i3ylY6QcvMPHX4NNNt8LYVuSXQDj00NjJ7eHnn4sq0ga9mJUXWvCmm65djalRo+g3ire6dRBB69Y6OHRTgZAXG+WmE2H8eFtMk1e6pSqhTYnzIPTqpQNDt4IVCNnnELIBSBnyIhKRWF69BEgz7DEelXBWSm/BaVB4Iij8GVIxV6owKRRbH3/mp0AApIgSMZiJ4iQIDQhLLzhJoShQgVAyb28dNxiuGHzVxYl1eOUVy7KrMFAoJH81BD9INCIsN+wLPHFRTZ5s3/mAW0ehUOS5yRAE/LjEszdqZItskCBFODK+coQA/lwy/6hkuz3kJygUKhAUCoVyCAqFIutQgaBQKFQgKBQKFQgKhUIFgkKhUIGgUChUICgUChUICoVCBYJCoVCBoFAoVCAoFIrsgVwGKmeW1qZQKAoeGxEEi7ds5bQtFIqCx8r/CjAAVYxYofEJKfkAAAAASUVORK5CYII=", 
				t.LicenseBannerExpired = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQQAAABICAYAAAAQ5YupAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABARpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ1dWlkOjU4MDZiZGQ4LWNkOWEtNDY3MS05ZTg1LTcwOWFlZDg0MDY4YyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxRTNGMzgyRkExRjQxMUU3QTlDQ0U0RjY4QUEzQkFCNCIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxRTNGMzgyRUExRjQxMUU3QTlDQ0U0RjY4QUEzQkFCNCIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBJbGx1c3RyYXRvciBDQyAyMDE3IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ1dWlkOjNhMzUwODIzLTljMDYtNGFhOS1iOGEzLTNkOTE4ZGY3MzQ5NyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpiZjFjMDMxMi02MTMwLWE4NDgtYWM1Zi1iMTljOTliOGVjMDIiLz4gPGRjOnRpdGxlPiA8cmRmOkFsdD4gPHJkZjpsaSB4bWw6bGFuZz0ieC1kZWZhdWx0Ij56b29tY2hhcnRzLWxvZ28tcmVkPC9yZGY6bGk+IDwvcmRmOkFsdD4gPC9kYzp0aXRsZT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz4BTPUAAAAjtklEQVR42uxdB5wURb7+JmxO7LLAElUUAyoSRJBwBkBQQRQRhTOhGJ4YTj15BvBUDlH0DlEBlVMQFT3E9O4ZT1Gf+QyYs+SFBZbNeXemXn1d3Ts9PT2zM7uzsCv9/X7NLD3d1VXVVf/w/f9V4xLARgBZcODAwb6OUpcUCPXyD6/TFw4c7PNocMt/Kpx+cODAAWWB2+kDBw4cGHAEggMHDhyB4MCBA0cgOHDgwBEIDhw4cASCAwcOHIHgwIEDRyA4cOCghXAyFB00D0lJQOfOQG0t4HJJ1SJ1S2EhUF/v9I0jEBzsczjxROCJJ4DqaiUQPB7g5JOBL790+sYRCL9T5OQAHTsCCQlAQwNQVKS0oAMgM1P1jRkpKfuYw+1WwlAI9TfHiCMQfmc48khg6lRg4EDg0EOBLl2AxERlCu/cCXz/vdKCTz0FfPPNvttPdq6Bz7fvtH/AAGDZsmCBcPvtwEsvOQLhd4FDDgFuugk46ywgNdXeZ+7ZUx1jxwJXXQW8+CJwxx3ATz85/bevITsbGDQo+BzHRns3epw3KzFzJvD118AFF9gLAzvwumnTgK++Aq6+2ulDx0JSfIojENo5Fi4EHnxQuQXhwBcdzhym5bBokSrDgQOHQ2jHuO8+4JprQs8zlPbss8D//i+wcSNQUqIERrduwODBimPo2zfUyqirA667zhlVDtovBFAsFC2ybx1nnils8fzzQhx1VOR7ExOFuPpqIUpLQ+8/77x9o/8mTQpt+zHH7DvjZ/jw0PZfdFF7b1fxvukydOoELF0aen72bGDSJMULRAItgfvvB4YMAX7+Ofg7ltu1q/19jNWTe8jKAtLTI7spduD1vK9DB/XpjvPro/vD+vGzObBzq1hnlhnvkKRRLg/2a2uAEQTjGVbYhZ9pScajTcnJ6tm/S5eBTOyYMYDf3wKmQw78jz4C3n03PnWim0ChYAZDRvPmxVbOjz8CEyequnGSEmlpwOWXA3/5i2Ki//AH4LDD1LHffiq3gS+dQqW0FFi/HvjsM+C114Affggun24J+48REN5Pl4Xxf04u8ho7digy9IMPgH/9C6ipia3+zDQ85RQVaj3iCFU3CgO6TMXFwObNKszK4513mi6fderRAzjpJODww4GDDlJhW7aXMfpdu4B164BPPgFeeCG2icJ+ZJnsiwMOUP3NcqnXOBHp2jEc/P77qj9jBSfh0UerOh94INC7N5CXB+TmqnH35JOqDhyLFRWqv6ygK0llwDFgHrsMVz/+uL3APOYY4Pjj1Xvu1UvdS8KS/f/ddyq0vXatGidm8F2NGydnsJzCL78M7N7dTlyGW28VccEjjzT9rOxsIUaOFGLOHCFWrRLirbeEePttIdauFWLNGlWXs84SYuvW4LJ5TUvaeMYZweUVFgqxerUQmzZF377KSiGWLhViwAAhZs0S4tNP1blo8fPPQlxySXT1TU8X4r77hMjPj638m24K7zL4/UJ8/bUQu3ZFV95XXwkxZUrTdb3iCiF+/DH6erIer70mxLBhTZfdo4cQ06cL8eKLqn3hwO9vv735Y7e4WIikpOBn5+WpMRrt/azDEUeoe489VohXXhHi0UeFWLBAiGeeEWLQoLi4DK0vEK65Jj4C4a67wj/j4IOFmDdPiPXrYy+XAygevu8774g2gYcfjlzP/v2F+Oab5pX92WeROYTm4LrrItf3hReaV25dnRImdmVyMq5YIUR5eXRlUZlcf33z2/jdd4p3Mp7ftasQ338fezmzZ6v777xTiOXLhXj5ZSHmzhXi8suVYEhNbQccAn3dePmMVtBkvOce4D//AW6+WZmSseL//k/d31K0lbDjpZcCt95q/x1dELoXduZuNIiXWWrG3/6mTO1woOkcjsehaxPOFWW6+eLFwHnnhX7HDFTmnEQ7NmmWm92AWEHXzMwJPPOMcgFjRWUlkJGh3sO//62yJUeOBP7xD6Cqqnnjf49zCPRxX3ml6TxvyicSNf37h2aAEfS3zSCh9/DDwFFHtax+b70Vn3ZSqNCHtpJnbDf9ZmYzbtum/F36iLyOawHYjqFDI5f9yy/Ahx8qP5n+KH1Y+vrduyv/87jjQvkQhky/+CJYoK5caU+Qffqp8kNZvkGWkf/gAKPPPnq04gKsaxfCYcsW1eZNm9R7o+/MgUx/ecSI0Os5cTlGrO+YIAHLsfHqq4ojYB15lJcrYcB+pM/PcUDBYuWGHnlE9d1vvwXOReJC6LOzv8mfsC84CclJ8B6Sl+x71ofPJFdkxpo1ih8xT34KEpZljP+zz1ZchBW8l/wH20ZBR2HFZxx8sOIKyB+xL1gP8gfkNshL8FqGuvmc7dt/h2HH994LNZV++02I3NzANaedpkzCcGhoEOKHH4R49VUhHntMiGXLlA9GU7miIvjac86JT71pEtKHNqO2VoiJE4PNRevh9ao61NeHtoNm7dChihuJ9Oy//jX03pUrQ31xK2pqVKgsUv14dOsmxMUXK1PVuNbOZXj8cSFGjBCic2f7ctxuIcaPt3ftbrjB/npyKn37RvcOundXvJEV9LXN17FPrbj3XvUc8ivRPOvAA0PL4Lhs6j76/tax2lSomi4OuQ5yVfz/tGlCvPuu4mB4L10S47s2zyHEcpA4tPMF+QKNa8aNCy8MduwQYv58FSMO94x+/RQ5tmFDfAUCj/ffD65PdbUQPXtGd+9ttzVvgBnHBx8E37t5c2BwcxJTQFqF1ahRsbfR5QovEA45JLoyeF1ZWfC9X3wRn3fQsaMaB2aQ6MzKiiwQTjkltueQvLaCQjPSPQkJQvzyS/A9L73UvHYef7wS0OTOIo33disQZsywn+SXXhq4Zv/9wxNBDz6oNFm0z6PFsXBh/ASCx6MGtVUDk8SLVrtZ27ZoUfTPt7MAjAQruyQaRjTinZg0eHD095MZN4OWG99vPN4FlYIVo0dHFgjUuq0tEDIzQyNPS5Y4iUm2sdglS0LPcwMO+oAGli8PJYLom114IXDllcpHjxb0D6+9FnjuufglO7WE1MnPD/UBrf5wJJh9ZLP/TZxwQuh3q1a1TiJPtKC/bAZ9YOYZxANPPx16jv743gb5CPr8ZjARbvjwNpOzt/fXMpAc48QnK2wGk3T+678C/58+XRFodskgJGSai3ht+UXm3khOau5kspJdsWQyUr7bJXQRVuKVgodk794Ek5Ts2PhowGXGTBqiwGOiFscOow6ccCRtWQ77wyygYhGurQWSq8xs7dMncI5k7dtvK8KXyo9k7F7chm7vCwRmgJFJNYMhlDPOUC+YIJPMzD8r/vu/WyYM4onLLmu5drVq2FhSk+20syEk9t8/1BqxY/T3tLa0CxWGgxEqZDYhN68h0x4OtBqtAqG56djxBlPeTz01tN0XX6wOCgRmJr7xhjr2MPauy3D99cDkyaHnufmIedMRpsIy7deMjz8GFixoGy+ZKyApwOINO60fC4xQlzXUyJBdW9CWVtjlFNAKYI4Hw7o33qhCoJGEgZE3YBWmLUmdjyc4ySONW+YWcF68/roKgbLNtIZ+9wKBsfd777WPST/2WPC5888PvY4d1RZAk5VWTmstsInHpLO6HrGueWgNRMM30Cr4/HO1tJx5DL8X0LJlIl1TG6rQDZ0/X1kNkZK32r3LwAQXZmtZwUQa6/4EJJuspAslZ7wWOrUErNvq1aEuT1uD1dLYSyvpYuaW/vlPezKwoECtSDWSiMrKAisFaT1wIjEByN2GF/NyonNBGl1NZhtGSrCjhUASmNxCK7vIe0cgUBhYXQD6tHQfrKYksxZJvJjBrLrWAlfrkaBiRmAk0I154IFQYWD1XfcmDKvFSlK1h92RqUX79Qs+x5Td225Tk4JCIZKgpgvHFYxtGd9+q9xjgtvaM9rGepMnsRNm3NiXgpBC8HfjMsyapfxAK5gGumFD6HkuR7WCZmRrgam6772nXJJhw5TG4cTi4GJdTj9daS76eFZhQN6jrfiqZoHAdFszWhIN2SOOrByW55wTfI4kJJdqk0+IJAwILkFuD1aQGSQS77pLjTmmNnPHLitoBbXy/p171kIgu3r33aHnec7OhSCsoShqO+va8HiCa9DJytOkI5iXT+uFTDDzycP5sjT9aLraxcD3tp/+669K+xhg2I6TJh65760BWo+01MxgDkq0i9CMNJv2CFrIXIDGg9yJddEc9xaha8RIXLsWCNS0VrKQ4GIQbn8eDlZCjOa8VeM15YtOmaI+I8V3OXkolZmwRHfBGJDG1uvhwB9v4eISLjRhWKwtgouCuEO0+V2QzW6rAoEWjDUEyc1oogWtNK/X3lqKt7CNxNW0FCTYjz0W+OMfg11autB21nS7EgjMCLRqe+74Q94gUkdaGXG+6FhiyvSXqV2iGRBccUfTNJpruSyXPh2XX3M1G8GIQ1uCMWi5VNaKSy5R7W2LYN9S8Js5AO5gFItAsQqEeG+Rbhc2bY1fbmLSklkgcDzHuvVem+MQ6BtZswyp5bn92Natke+luWvV+OH2LAynLYwJGwnMIKN1wIw2s1tAq4JWADPr6E4wqkB+gcu0SQiZy25L/IEZZOOtvAu5EPNAi1qF7AEdwjFBZWEGFUe0JKGVfzDebzzB8UuhFcm9tQPzKmKZ0LQQzGAOSSwWcpsTCMzVJmNsBScW05NpAkU67CYazd14g/4pn8MQp3m9BDde5eTnM+mHM5xFziMaIdOW/FIKZSuYP0HhFmmfAw5eptqSU7HbmLY1QE37/PPB57jfIKNLkd49Bfmf/gTccEPweUYn4rXvhQGa7NYNY7g5DetpBaMehhDg/pUU0Ew+skbazKDw4zUXXRTq/rWiq9f64p7EiB1IMFJLRTLPjRCe1V+jtWFHTrYEBqvLcKIZ3PyUxGJ7B0N13GSEv9BsBic6CVHjNygMl4mDmAOWacIUhGT+mSeyp37QlP4zJ7fZPWRojpu58PcTmaxD14IWHOtKwpdts1sgRe6KVl48QQKZSoRWrgEKTkaoKGhp5XDccmckclDkl2hRsP8YnWJS3ty5apEX20KLiH1PC4yWBjdFMRPBZiHempZoqy9/tm4IEQ9wU4nevaN7PpecNrXX4rp16tq0NCG2bw+c533WzTEjHTNnNn/5MzcDse51+Nxz0T977NjQdnHNvHWvAG6m0Vy88Ub8fpeB+w9YwSXw5mu4aWxLwT7NyGh6g5RYlz/zGDIkujpwyTM3wgn37Gjx5puB/Sja7fLn1sgWowZj6me8YCxMojVjzhun1rQuV42lrWTKY4mHt4QZt3uO9RxNXMbySVQ1B2Zuxe69xtJWu2utZfLXlWk2N5e9p+alBreu3Yjm2dGAETKre2IHWgbGu2yuhcW2MFLUyuHU1hcILdmcMhK4MowmZEtBtp2mH1NkyReYCUKarbHAGv3gIItlUlujFLFsUGu3UtCOAOQ+h+w3Cj+SpNGAeRjcV9DMIUT7vFjqa0e2/f3vavEYl8g3lZBkgNzUn/+s+CC7nBW7ejaXuafpT3LWvH+lHSdimPnkD0iQMvWebkdT4B4fXAzFtjSVPRsHuLRtk4DWS10bNUr5TC0J+5AU42akVj6C5ApZWA7ySJOMRIx18xK+DJJAzDrkxGMiiDlVloP/iitiqycX43DDU/q1FAa0LkiEReu/UpsxgsJQK7UxU1uj1eb0oZn2yoQVahEKYoZ6m5pETHQhacpkLPqunKjGD4XQDyZ5RoFp/cl78gunnaa0ryH4+OMrdr9oZAcSxnw272V9OUnZ1khpuewbYzxxg1luBGv0MycLiV5GU5j1FwmMJI0fr+rMyUoCj6sQW5rwNnasmrhULnx/7BtGNxj25UavVnAXbF7Pscn2cByyTryPbWFfkPexRlxaDyXt67cdP/nE3keMxCdwLz3zxqr8mxuQ9ukT4A3oG5uxe7cQXbrse7936Rz7+lHcvgRCuD0Vt21TJJfdPZzw3G+RG7heeWWw8CDpZkeyxWcHW+dwjnYnEFrfZYg3GKoM97uADK0tWqTM/0jkC1dQ0l2YMSOUTKLvyR8PadIVkgf3RKmGAwd7BtkMj8vj9dZzGdqfQCAmTFCTPxwRRAKMB/1e+pbkL/jDFkwK4bpzux/KIBi5MBY1NQXSGXNJuJGAdMaqg9aO1pF3kccseSxsPYHgbZedw40lmNjETSntdjrmenIe0YIkDpNg7BZfhQOXWDBRjUSx1RhJ0l8gI5ZMebeLxvFcov5ZqwsVl+X7BFMciOU0hHlWuPLr9HugP8ur/99Y48WyPPp3RpvsymmqHi69HuFQr99jV0+h1yvRpm0uvV9q9e+MNvj0thn3J+iHXz8vIvSN0Otjfi/mOvj057ksZQubNtksZ9DKCBe7M/e90RZzuT7T93bvIbn1LVJvu5WYb76p2HH+bBmjD5E26IwELlfmbyFa10w0K2Yj368clNWlLvj8LqQm+1XU0cZ74XVVpW7tMzXFrzwXoQ9qDpZMjfNFaZlbC5tnZvmVHVemDxp90FXJZ/nls6yhdb8sKzlRyG5RD6+tdKG23oXMNL9663oZfjlIqyrd2nhjPRqL8esDMF3+KQVfubyGdczoIL/I0uvhU2VobSl2a9V3WeYewXp4vcK2H3h/Q50L1eUuuC1toNfndgvZj0K7bnehR7umQ4YPrkR98uv9W77bjZpaF3Lkdx59Alv7hpG/JFmXxFyh7q3U+9GoQ5lLq2dKsl5Xeb6+xoWaskDd2K/8O62TXzW2LLjRbIfPF/w+hP5PkuV91De4Gu9l3bR3LA1ZFEVQJHAEQngwdMjfVlixQm3ZzjBWNKviGMZhHPihh5qfpGMHOYGqitw4e3YePvshGS//PR+DhtWqF2y5buc2L86R123b5cHaJfnofoCcmeW6VkuRbuIrqbj3qWx8/E0KEuQgHTW4CpeeUYoxo6saB7KQg3rq7K74cVOCNriqqt2NgmJnsQeP3bITF06XPo28Zd7DOVj6bAecObocD926U715OZl++i4RZ9+Sh6w0gTce2IqUDKE0ZIr6fs2adPxtVTa+/SUJaVJgjBlahavOKsExw2rUZJBtKS7w4PRZXVFc7kZZpQe1cmJqwobCscaNp+cVYPypFZqAC0Fn4OVnU3HZXV3QJbsBO4q9MCTL7hIPBh5ag3eW5iOlpx+PP5WJeY/mYPTQSjw1dwe8nLgZwD33Z2vnxx5bhRV3FCAlSU34c2/Lw7e/JWlR68oqN+pkF/fM8+Ey2Y+XTyuBO1W3imQZb/07BefKvjx1ZAVWLNih9RmF4T9XZ2CO7Lv0FIFdRR7Zz3Liyj6adlIZ/iTL6NTDp/pB9ledFAaXzOuCz35MlsJXtr3KrfVhgxQQZRUu3H/9Llx+eamm5Rcsy8bK1zNBMVpSJvtMvr/jBlbjxvOLcOxIWakKXWi7HIEQO7itFHdcYuyXO84wn4AxXsatyTMwrs4sPSbifP+92rG5NRaI6JNg2y4vduxM0DQyPPbXcZBu3enFlh1eOWB0TcVr5SB97IlMXHxHVww+shor7y5AZYkbc5Z2xJq30vHMnQU4+8xyNWAlNsv7f9mSiJunF2HggFolLDjOpcYbekRNo/DYXepBoRQST76agQkjKnHq6ZVaGazjpoIEZGf4Ne3X6MpILfvX+3MwZ0lnnDy8HCv/XoCCjR7MeSQXL76ThhcWbMfok6q0ieeTbf51awKqa9246cIiHHRQvTboWRy15YCDaxrrGwL+fqoUZDt2JqJ393osmbFTPb9O1S0n06cJRN5/wfgyLPufTKx+PQsTRlbi3KvKkf+hFw+u7iAtKS9mjC9FSiehJqjEVvbNpkTceOFuDB5cC5fs58efy8TM+XnyfAIW3rJL9bnsnyopuAqLE1Cw2xMw+eVnmZzUG7ck4/jBFbj9mt3ajPnog2Tc+Wgu3v8qBS/ctx05Wb7Ge7bKd//T+kTcetluHDWoVuOY2K8NcsIPOkwXolLo75ZC4NcNiZh6Shkmn14Bnzx/8wO5GDZ9P6yatw1Tp5QrBeF3BELzQS6AW5u9/vreeb6+Foua1JMoD7e9u2Bcly6vy0j1K3NUKC2z6acEzFnWET3y6vDc/G3oOaJBm6QpsrzJN/TEgieyMeWUcrjcAXOcrsnEP1Ri8KQaRREbJFSJrgFT1HXpctLTrF74dAecemKlpgH5bNYh3ewuSKG07j9JmLu8I/ofWo1/ysmfcZi/0fydOb8nFj6TjdHjqrS6sS2ae+L1Y+pJFbLO9Y2TUiuUdaoK41vLArUJL/84UAqESVMrlHVSrV9PLclcJ/lqOx7kw7xLd+PMWd2x/F9ZOPf8crzwdho25yfjojOKMObkKqVZRaBvkpL8GC8F4PCza7SyRh5WjS9/ScQTr2dgxsQyHH5UrXa918OX4lfuiQjULdGr/nPIfnWYdEGFNkEnDa/Az5sT8T/vpOPN91IxZVq5ei6fmaTacsZxFeg/RZZdYHofpbqLkajcB1437MgaTJpWoQnAfvvXYsRlvTBrcS6G9qvBARSslXueu3TQViA1xyffJmkWxrhhVejZRwqDjfJ8PjSX4frzC/HHseUQVaGmpOazGodXn1AVwW+4Vg66gYfW4cOvU7B8TabGSdBHtwO1X121CxP+UIGM7nIWrFcTk4Lniik7cZo0ra3+c2M93KZ6VJp89Sg4mKAD+iQy/Gn596SJFTh9VBnWfpaChX/rgMdfyUS3LrXS1C4OELmmuvCgdQT+yt8m6aJLl2Fk/xrp2rjx8xZvgFBtQtLT4jLKoMDq27tWa1RBkddWrQa9D48uEC3vg9+xHny/2CyFTv96TBlTjq3bEvDWf1IiE7WOhbBvhJYKOXhJNEqt38ikywnVIcuPe2/apSZHTYDhJmnplccqqfE+35CkfVchzdx+fWoxZmRVkMlZX+vB5FHl2K9LMuatyMF5E8uRlea3TdnQJpEUFknSMtGep0/I7l0bsPj2ner51YEIRYIcSQ1yjjzyQia6f9qgTcxyWY8RR1Vj6OAaVUaE1BCX1NCbt3vx8JIszV0hP0L3a9IJFcjr5lMTvUb59bOlW/LFT9Jsf6ojyitdmD+zEH3616mojw0xSYtNI0JJksqqr89PkJof6Jztt48U2AUPSAbq20YUfunBm5+mIiurHkMOrw7S4h5aSylCc80+3pCsfVctrbIjD6zDqKFV4ftAqChEr84qzFAkXQqHVHSAujq3NolJRDUOHiP8ZhMW9MhJS3OXfr14Wy0k27ozAZecXoIx9PGrg1Vw99wGTL6iEL3POACLn+qA808tC13851LWBIRL832DNLgRlrOESWn2V0qLghPBEDCbdyTgjssKMfS4mkDoMJwslG0gp3LX49kqAifbT27lmMNrkNfbFwgFSqE0aEgtThxUhaffyECPzg3440nlgUnlCtbSjIxsLkjA5p/r4ZYT7qEns/DhujRMOrEMxwzQuY3UyO8kNa1Bs5hGnNRTE9r5BR6UlHuwfM4ODDlelrErUIYRFXnu7XSItYZw9eLC8aUYNaIqsgCS9a/3qQa499Km0Y5AaGPwelU4ixM9JE6eobQITKt5GV0g+bZ41i6cPK5SmdgGSvT7TG+ZmueA4+oxWZqmc5fnoHfPOuRm+ZQACqqHYYGYZrFfj4KkK9IPpp28qAVprayeX4CjaRGYVxzvbrrdPikIBx1Wi9XztitNbhZ+paZ+kH3w47pEfP5DsjbZd0iTffXaDFx5cEmIRmXdGXG4eUkuau9zycmmLjl/Qgnu/FMhElJFUBvCwS/7hjzLEQfXagIhJ9WLd79MwUffJmPsCZVITQj0EfuxqNSNZ2Q7xpxapYRFo8/WtMuUoPc3w9aOQNjXISdcTqYfbq9ivRsTieQEKdrlwZOrMqSZ68OUE8vhtviXGilmJNEYk9dGG1VVu7Rr/jKjCG99lop7nsiW1oAbycn+IE2lMeecl7XuQGKONEDyN3ux6rUM9OlVj9NPrAjhBkLq4YueKXcZSVAJprqbk6CSVVm3PpKDb35LxFWTSvDvL9K0NowdUoU+/eqCQry0Muj73zJ9N4YfW4OGUuYw+HF43zrl6pREx23U1Hgx8JAyLH1Ud5W2AGdf1xX3rMhF/4NqMe288hDBEu37sLqMjFJQMGSm+fbKEHRIxdaa20INPs3vpBXMzywEMuDsIN3H/n3qNL/+g69TUFIgXw/3k+0OfP1LIq5ZkIcFT2YHMhxNijNN+q1aMlO6fnTQtbllMmoJUFJjH3FMLa6QE+q9dSla/kCCVwRpqoGaNhR4X2rChlJ5ohu0urz/VTJmLeqGh1/MUhaLyVcnMlJt6pEY2V0ImkTpuiXEz0z9MNoq/37t1TQ8+2YGBh5aiwVzCqW7UIbN+Um4e2V2wIIx1Ynh3aOl5TFkdA2Gy+Pwo+vUdSWxjH6hWUDgfsDrFak44BDlw2zZlRBK/gnL+8jQ+yHZ8j4EVFSjo+rb4i1uvPZRGtLSfTj2yOoAh+RYCO1cGPiVD7jupyQ0pKvBR22VJM3XPj3qGtdTMX4ftJu3tDD79q/FzRcU4YZFXTD5pm54YPZO1FVJLfdQrnbJhaeUwZ2BRiKLgoeZgt/8moisj32Nmoqma88uDcjp5GusEwewX6AxI/LKqSV4dm06NuQnonuX+qB6HDe8GteeU4KFT+Xiglu6YPa1RSjc6sHt/+ioqe3zx5WpCWUa4PT5P/8xCTV6dEF7jDR99+9aj8zM8ASeIUyKpTvz3eeJjXkIbANN/gN71MOTLlCV78LcFTmyUDcukj558v4CF5xWhuUvZ+LRlzIx+bhyjJtUpcKUev+y3cVlbmW6l4ZXhVodhCtku0JVN9N5PSWcZGajEBPBioDXfC3fR9pHfi3kKoRLq0v3zg3I7egLum7Tdi++ky6Qv8yFK+/shF83JmPBNTvQf2Bd+NwNRyC0N7i0vIGr7u2kCQK+eA7Kw3vX4uNHtyI9RzH7JOxIIjWy/A1qsP15RrEWz176fBYGTO6l5TP06VWHRTcU4OpzS4KIQpduas95uCMaFgdSYYuLPXj01h246GKVGWf4pJygRspt3iE+XDWlBFct6CLNYnewryvdg7uvLUQn6aIseykL/U/rpfm3fXvXYeXc7Zg6sVxNsCQ1acgfMB135oJAmzmJ6PqsuWs7TpsQJlPRpU8OOau+/DkRIy8L/ChOcYkH/Q+rwUf/2ApPmsC992fjwy9SccLQSpw3oVzT2D37NmD6hDLMWdwJtyzLRb8jtqFbjwZtMlGgkGPxC0Rm7BvrgGAuxaX3l9mnF6rN+3dVvszH3ySjdpsU9h1E47oWWgc3Lc6F737VDyyzvMKFB2ftxMyZ6n2Ql0iS1zE6tEIKNGZ3HiTdsOW3bcOFZ5dFXv/RmiO3Xa52bAu4WB43Inhxk742gJl/tXWuIPfAp+fR9+5WD3eCyp3fKLUDhQI1YAITVfwm4k6am2Wb3di4LUFjrqnts3r6lWVAwk3P4d+wTT2LQsEcPqS27t7Zh2w5oVlmgfRNC+UEy+uoaymfXob8ZJKNy6U0cdCailR1FK73IF/eT7eC2j61mwisqZBl+Opdsh5ebdIYefvGB+vEumdkhLEQpEoqLXFrEQaGLs0aukH+rVkI3eu1vv3+t0TUybYeIP+f1VEPhyao9Qa/5qt+OCBPficFLuvGvqGpH/H5UG0ol27Tpu0Jmu/eq1uDar9HCaV8WTeun+iRp5+Xz6yRwo/ZmQz5HiTfqVe6SgyVMnOUQtBteh9Ct9C65vqQk6Pex45dHhSVq7UZWiajPN1bPjetl7IqQtKW+Tfdttvl8VCrjeoSRyDEUyDoC2I0n9G6qMkI2RnpqB79OiODzbr6zqN8VU04CJ3Vr0boopdMm2cZJnGlfo9LaXytvCoEEoWMFYQZep2MpdzWeqQhQCzW6mX6TXyIx+Tr261YrNDr77InUjXfOsOGdHPrWrJMvy5T74+agMukPS9Zr6Nf719j8VembgNXIBC2tKcIVLkZej3LTG3RF3hp95cjEAI26lyvn/eZ3n2ChSswEpSs78PMKRirUysREj7dkwLBcRmai3T9BaVGR5g1wi7mHcUP/jQO2FiQqBOaZmTphx2So6xHrL9YF23GXUKYNqTaXJcRQxtyYqhrgj5Z7c6nhzmf2oL3Ee07pkDIC1MHh0NoA/hYHvPQZAaeAwdxoqWUIP7Q4RAcOHCwZ1Di5CE4cOAgyEKod1wHBw4cSDRQEHDxZZbTFw4c7PMo/X8BBgB5OBYtILpQMAAAAABJRU5ErkJggg==",
                    //脚标 logo
                t.LicenseBannerDevelopment = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAJwAAAB+CAYAAADRNHjEAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAABYZSURBVHhe7Z0N1B1FecdJgkACgUQloAhIjUJFPqQYAoGjhiYKpILIh3y00UPLh6AFJBDRUiCxDYgSSCSnKIqIEYgIKh6+CkpLKG2toJZQhBYkkCiCEBGUfNHff/a569333Zu7s/fu3rnvO79znrO7MzvzPPPM3Lu7szOzG0UikUgkEolEIpFIJBKJRCKRSC959dVXt1q/fv3eyLHsz163bt1C5Ka1a9cuXbNmzTJkBbKKuDxekBD/BOf/hHS3IV8jbB75fQJ5P/tvRkaaushwggawI3KUGoQaBw1lJfuVg56XaZAPsns1+k9Cdmd/lJkVGSqogVGxJ9K4FlPpy1X5oYA9L2LX7dh4BvI2MznST1CPI6m8A6jIS6jQh5Oq7Q+w9zHsno/9+1pxIqFCJU2ishZQaSus/voayvEoZToP2cmKGOk1VMYE6mY2lfM/STUNTfgh3UpZp7M7wooeqROcvy+VcC0N7ZWkSoYHPHT8N2X/a3Y3MVdEqgInj8DZM3D6vc77wxh+aI/ji5nsxq6WboNTRyCHqY9Lzo78ERreQzS8D5irIp2CM6fR0P7T/BtpAbcX32fzZnNbxBca2s7mxL6Af5pV/DB+is13IIuRSwk+n3Kci5yO/K1tJX9H/FxkEbKEdP+iSySyNsmtHKR/mbw/xe5rzI2RduCwzakE9Z+tSdwYFpj1Eg1kKTZezuFHsHcKsrWZ3xHk9xrymojMQD6Djm+j7xdOsR8/In3sRG4HTjq4pIMrA3tWUfG3YNuZHO6J1P4qCp16D/sR5Grs+RXbtnDe77D5o5ZFpBn8M45KvSZxVe+hsp7CngVU2IEcbmxmBgH2jET2xz5dBdq+puO8xWzGWPIIlToVxz2ZuKd3YIP+ya7Env047IvOVezUK7zp2H0d9q92BcmBW4AHOW9HSzY8wQ+jcNSFOGp94pbeQGXcT2Uch4w20/oSirIt/pyLP59LSpaFcI2I+TM7fXhB5W6Dc+5KXFE/OF9Pgzdgx5B7QU65xlCusynjs66wTRCm+7qpdurwgALvRcF7cglF73oa+jewYaKZEzSYrKfWPdgeyfYMbP8H5DLkSmQ+cjHhZyEaNLo/2y0tqfy8JfG6gvxeZW/A8SvEDY+OYgp6BAV+2cpeKzj/RvS/3UwJEswchbwHmadLPb7y7hoiyeOU9euU9a843JbtThx/N4lN4JzVhP+FqR2aUMDTrby1QsXpddh7zIwg0Q+BRjGfhvBMYnV3ID/9o99J/scjR3Gcdqmwr07iA8yEoQNlG0GhP5cUsz5wqO5XTmM32CHc2Lcfvrk1sTgBu1fzI/kPwr9E/JlqKGoYRO3JVpdXbSchhyAncN6FyBLSbXCgKfHPcN4c5BYLUtgq8gj6X98LyqTGtigpXn2g8w42O5gZwUElT8TGmxJrXcU/yfGlhE/jcDM7zRvSvxaZQV5XkGfuIFTC9TBxA1t3uWbzBGkmWBb9C2WpvbHhPF0m/sZMCA5MHIV9Z8lOZC3+WcLxVMK7PsSIPDWU693o0DyOQWMGCXsYcU+ynPMDNkF1cHtDIb6owtQFlyENTNzV1AcHJqqf7C4qWf2OmrVV25Myut6Abt0jDnxiVcP/pfaJv8hO7z8wfq4rUU2g7xqcGmzHLSbuScUu50dxL3bubsG1gx074KubndOawDY3TRLbptup/QNGn+pKUQM4ah36zjbVQYJ9enX3DFs9wATxygxbDsem3yReTOD4OeRJ4tK+vODBWI32WGdlqBT06H7tEFMdJNj3bnXLsH2HBQUDLtxBT8OJNxPw6bP8Ay6wU8IGp+6Kwb812ysFPc+jb7KpDhL5g8r7DuaOt6DgwLYx2Jh2kxgvYPt+dkqYYOBYGsEjZnCloGcF+nYz1UGCmeOpyPlsS3dx1AU2ahDFEvm2AT5exibcyTkDDa4KHPFrNruY2mDhB3EKdvbNND7ZSh2q79KBn/9AGT5p0WGBYSeZnZWCE34T+j+bwEa9DdjCDvsGbB6Hjx9zzgb2H6Esm1p0GGDQWzHsd2ZjZaBDDwhB37M1wNy+7UDVjwVfp53EHIfTA4A9I3nK+bfEtGqh4B8ytZGKwdfnmdv1Q9cwsjBuDTDM9bdhlJ5M3YJ8VQh6zjGVkRrA35tSp+k6LRyfblG9AyPeqIbGP9yPsSkuNTDEoH4/nDQ394fyf2x6W8c80Xw9MefV2YgGDJaV/S3LSEBQLyNpaOoacdAAe/fKC+V7mx0dQ8NdZNk6yFtPvLmX1laCYzTi4U8siwzktw86bg5ZsPFjZm4GyrQZZXuouaxVCrr+l2366k12cezAzm9acP2g/4eJGR2j+7N0xjrHW1Fo7xGvOOOLlkUGokZwyV+anBUmlFdDvXNnyBP+aTutNtC5h6mX/i2x7yWLUqOsf/kIlOoyqKFAWlzm6k6EAn3YsnXQcC4i3AscohGrucssEH6EnRYslHm+mZsB27ejbJV3Nw0EvZnOXuz7lkUp7r0WXB/o/SGOQHd3x3KR307k+4ekaMUhXW4/EVGbkN+jyVlhgn2aP5r7npWK7tUqBDeYCQ6OtbyEA1+fZ8H1gELNSNe/m0YYDLz595VM3w4Ovp4wL6iwx9nkvqvE1o8nZ4ULNp5q5mYgfLKdUjv4dJmZ4cCWN1qU/o2/a8H1UKZR5EE+d1uWjkZD9oV0mUtyA6J0LzhoEnBIYJ8eBga9kSBM9533u5N6AHZpgnjmz4Cwpy1uuQVVD5X7JjOmI8hDAybTEa8ElXIwafSGI3cwIw36H5OzwgUfvM/MzUC45pL2FGzY2cxx6J/NohRXz7tVFH1GClGu5RlyHwKKCPmcYVk6OD6GcG9IN8WyyED49jTqzLj90MCH3zdzMxC1RePfpJfgw2lmkgN7m+em5HY/dRWUjMARjyJ6WujKwnuCvEaT5RNJObzI3Ng2g3P0fatgMR9m/kEaYPtn7bSegn2ZNeWa7SIu94feVVDSuIn9EaIF+UoJ+WxuWTo41tKgXlBfGsnQqpNXIx16uhJTO6i8Vt0gpZ7Sq0D1YmY5OJ5lUYrLvRXoKjip41nzOFO92OnNKIZvQ5j3cHRsucSyGARxd9ppQUJ5N9QNkvZ39RrVt5nlIOjEJMZxmAVXB47quD+LBna4ZeegUP9kUYXBDj15jrMsMuiXl5zlBw8f/8pmnIeMR/RP7w025naDEKVuomCgbq4y0xzYrdlmDaptcCjbWVqobK1LkfsusIAstOwc5Lkb+Xk/8ZLu45ZFBqI0Lu+nyVl+kKfXPQnn65OX3lDe3G4QQZ6jictr3LuQrtRKU6TTn8Trkbx820lmeVbsSxchYv8gC64GFJwsRTSa3PeVZSCvdOx8UXCgJui0qrCPJmf5gR3fsSwKQRK9TFdnszdlKgr7vmrJvUFf15biIq/mBvcuC64GCn2dKTqDjVbS9hLSDXxQOJhwb0iXu4Ae4XrS9e5KII36A72WheD8A/FH3j94O/mCZVEYdL0LG0s9AKHvdsvGQV5aHy7PrkLC1eNnlrXqYXvLthrKVGYD0v4WA7exrPQPsTFh6RirolDoH1gWgyB/1z/oC3l+1bIIDsxTZ/h9iaV+4N+1+ORPLSsHwTcksV2hummPGL61KSkF6TNDwzlOx1cVRb9yeKdlkYHwCWrUdmphSKPuh5CX8jousdQffkiZbheC9k9iOge/rbRsq4GC69ucUvQ8G42BKywU/Hts018D+3q/qTmlvlxtWQwCHQvtHC9I93nLIjjw+eb4qdRVxfyb6XYhv+0Iy+0XLSrkqwcePdHfZ9lWA8bqvk0VtNiCSkMeFysvHyiopgZuZ1lkIPxtxJd5t6uBhK+3bIIDP5V+24BPTrZsugp+dsvwY9s1FlQNKFhgivSRsrzH51aSuc7jCPWie39EF70XWBaDIO7bdpoX2PJpyyI4zE+l3jbw76N1jNOlZclL3yv7MmG577SLCnmk4/LI8yzLvhpQNnCRk7bgMOxav5dl4SDY+6aVfLRcaO7sdcJL3ZeQ50pVhGUTHPj7RjO1DJlFs8nrQgvvGvjuQMu+GvjVPGC6CkNBv2LJHRg5xaK8IN0JlkUGovQEV2ryNXmeYtkEB7a918z0Bp8vsWwc5KWhZF39NIH+SNhUuwoUSp4yZY9RyQ+2E07VJxPfYMkbjePflYcPpNHlIXceJPmXmqdAGdTzHuQSDLKLMpd6U0K5NBQr81FeNTjCBo6wLiXY5daPU/1a9tVBYRq/klLfOKDg+jpKGf7csshAuOYppIut+IAtR1k2wYFtWmmpFPy7zbFsug7Zj8LfbpVM9OSOcukqUiRwyAw2eQ8HzTLw/ZveAHh/95SC5Q5OFOT5CTvNF71sD2Kp04Fg13j8lPsxtnaQ7il8kt6TEqRV4y9Q4+iSpK/W0FP9p5JMVyEw6GhL5uD4XIsqDA5UL3nuRyqI1lJSZecp5P5jtgIbSl2SWtm+IahUfVW6FOg71rJxcJwuz9BN8Lu6p6pfsNv0tYXr+71smmdsa6zbi0lscXD+FZbFIIjznrMqSHenZVEIknTyUHKoZVMIztcStaXmiWCjXn01+7zs6Om24MObTU21mD618CcpYO6DgoTCZkYQYOCVlrQw6NCE5tyvoRC9A/Fl5yl4fR8UGw63dF7gh3sti8LgJ+9RMwJfYOb6vS0bB8fbE6U5pF0RbEu7Vcj7OFNTLRTMdUKisHAPNudqrFuZVcxnWxaDoPCNhXO8IN31lkUhSKLBBekyVT5Qbq9FmDn/UEvqDeXKDJCsAnTMkS78oXfV9Xy+HGWNbzWdb0FtwdAyY910KWg1ofmdxJcapkM6PWVnFmzZkJhzvaHMN5q5haBMWn+t1NO2bCR9OgJHcHw0cno3BT3ue7Z1NO4ULhPpOKg8MCwz9Z/jsmPdjrEsBkGB/9lOCxIqRg86uYvRtILzz7Hk3pB2lmXj4FgfO65s4hD5Vzvgshkq+zbTOwj9AjAmfXIhqNRYNxq1OoZzuyzI/6DkrHDBR5nlxtpBkm3xk/cDlSDdz9lkZsXjv3uS2O5D3tWODhkIOvUC10Fhn2gWGkOmI5Vj77FugnS5cwqI0jyFDf7D9hr8oNWNtjWTC8H5qU99wVczLBsHx/pUZe4lsazwA7rC1ElfvZ3lKG+eANtyaDHRpca6kX/mHWAz6DvBTguZwve2gjJNwk9lh43fZtlUCnrclALsrP/DIDhoppQbR1rwIDCyzFi31WxyJzQTPob4ni95sCGwT5/yLvwtBs4t3b+HLvWDZIaNc6wvROd2aZQV8jxNqtjXH0zuQkGVokJKucAQ9YO9QOPKdM5yTtmxbi0nNJNnqXkKdYKNuXNMW8H5x1tSb/BV5j0meWlo/SqL7jrk3ZvPHqFUa4q4j7cK9vWK400W7SC4zFg3vTtsNaFZzix1U10X2Keb98IjTyhTp8PGM76iAXpPIvcBew82VfVD4dIRn+xfbMEODCs71i13QrNAR3rTGirY7/WREsrUybDxkywbB0GbEKYrwPndEuybQ8N2Vyn27zBVvYHC6V7BwT1I5vUNQZsheSNH2knu3zXhG3fbmd0W7NPCLl4jT0gzljR5figilV/asM+NwlGjYz93Zadaae6ewKD4CaKaweda2yMz16CbQkNzb1jQ8/emsrdgSPNXSX7J8essKlIx+LrUMha+UK8PoSuMLwdij75Kkr7U5jqvj/QHOaCxKNhf/zcHPKEBTMPv6j6qFOlAV+5k856BQadiWNppyfG5FtV3YPtoJDOzLDSwbx/8XVnXxwBajtTpKdzLaXJLCk6ZaVF9A2aPwm4tqR/sP3SdjY2rld6X19/nVgQcMRVHpMO82dcKRPUMzusCmKzPbGtSt9f7zzrBn/vW1djQ8wv0hX0/ToVpsq7Gjzms0fX+e5ptwMYtZTvbzEjZkMC2g/BnV+eTtkJ6QvZFCkZug72DBitSmVcRV/1EixJg3i6I5sweYkHBgW0z8WnlDwgN0HeEqQ4fjHXLSeEgraqUwvEy4oK5GcekEdhzMnb9iu1UCw4KbBzFj7XjRbt9wBeZVcr7Apy0WMZTmZm5pxyvJe4L7Oa+K60LnLo7Dzn3YI/mbgb5RIqPxuOrW53jagJ9l5r6/oJKHEtlunH5A59eBXHPcs5Z7BYewtMN0DkRneo9x7fr7uA4dyZYr8GuKdjoPVG8E/CHJjb3b/8pTnsHTnMfcKXRLWV/ufabIex5Cnox53qN+/cBNSPJfzp6bkLfeuRFjk8lPDjnYpO6Zc7Dxo6/W+YDvvkGm3Q5r74F5x2uSlah2P6cgl3BNvfDsjRKfcRtNml2Y9tRYyD9GPLRIs+Xo6+x6I4u51exG2S3B/bqMq8PG9eN3pn2f2NrgCM/mZTLVfpLHJ/N7jz23UIoeRD3HI3jFuSznH88MgXR5XAcW/e0y3YsMgF5OzINOZnzF1Jp95E+faJj/xXCv0J8Vz8a3C2wazT2zcXONWZybaD3MjZ9/RoyFwp2SVLEBI51/6SPimgW9134uszk6A1Cw3sAHbOQrn1wrptgop6Sj6bslSzB0A50Zxb1HlJQPq3csygpagKO1r/dp5BNkQkEaey8bugfQ7wnk5DmaXR8i7xOQ95iqoME+ybzg9CaK7WDn36P/r55A1QayqpGN2jErhoYDtCaHelfO/tbEDYJ0azxM0k3F9ESUZfZ9nOEn4PMRA5AgnzaHAh2Tsb2lvN5qwZfr8CGSWbO8ACHz7XyZ9AlkM1hyJC6p6A8eko+lHLfrXL2Cvx7D3akK5AOKyj4Kfzacu/bCNcbiZPYrWeRlIqgDFsjZ1IefZqzp9DY9dn1ofMkWgYq431URub1VzPE6Un1cs4L/yWyga2bYvph2H0z9tf+1DkQTNCblMwnw4c1OGMif/WD3kQMBMc9RCVewPl7cRjUJRd7tsKuY7DveuwstcJSFWCPOnN7+goxSPSvgHM0Dq0QVOpyzv8y6f6Sw8wK3XWAXvX/6bNP8/ix3I89tb4VaAf2aCGhrn2ecsiCk3SJTSdWF4U0T9EAv4fMIY8PIXsgYy3b0pCHumt2RQ5FZpH/deh6BCm1/kfVYJdeEH+e3VrfT/c1VOxrcdqXEhd2Bv7/Nf9AD5Dfncg3kYXIfKIyc0kVZnItchtpfkzap0NtWHlgt0aV7GJujPhCw9uPii/1MYzhBD76L3w13dwW6QT8qZn26j5Zmbg30oCG9jN880F2h9570F6DYzVt72waXtnvMAwZaGhL8YU+xBIbWtXgZI0UmUXDq3VgYq+hvKt1f0nZJ5srInVCHehSezS/9lIL+PULNDStZqDxgX3xnnhYQGXsyq//IirHDbLsdyjHCsqzgHLtY0WMhAh1pRfkGuG7iEpz3xDoF7D3Yey+BPu19FmYs9wjG4bK2w05h4q8mwp18ypCAXv0pkSz2k7Exh3N5MhQgYrVPd9eyMeo6Gu59/sJlV7q2/G+oGclOjX+bR5yZGxgwxQqX5fgnZCDEX1/4CLka8jt1iA17Lvx2aNBEL8KWYEsU1cF6W5CFhKlm/xjkb3Z38rURSKRSCQSiUQikUgkEolEIpFIJDIc2Gij/wcHf8CdnqEs2QAAAABJRU5ErkJggg==", 
                t.LicenseBannerSupportedBy = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQQAAABICAYAAAAQ5YupAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAABARpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuNi1jMTM4IDc5LjE1OTgyNCwgMjAxNi8wOS8xNC0wMTowOTowMSAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wTU09Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9tbS8iIHhtbG5zOnN0UmVmPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvc1R5cGUvUmVzb3VyY2VSZWYjIiB4bWxuczp4bXA9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC8iIHhtbG5zOmRjPSJodHRwOi8vcHVybC5vcmcvZGMvZWxlbWVudHMvMS4xLyIgeG1wTU06T3JpZ2luYWxEb2N1bWVudElEPSJ1dWlkOjU4MDZiZGQ4LWNkOWEtNDY3MS05ZTg1LTcwOWFlZDg0MDY4YyIgeG1wTU06RG9jdW1lbnRJRD0ieG1wLmRpZDoxM0JENjYxQkExRjQxMUU3ODAzQkI2OTI4Q0EyMzZFQSIgeG1wTU06SW5zdGFuY2VJRD0ieG1wLmlpZDoxM0JENjYxQUExRjQxMUU3ODAzQkI2OTI4Q0EyMzZFQSIgeG1wOkNyZWF0b3JUb29sPSJBZG9iZSBJbGx1c3RyYXRvciBDQyAyMDE3IChXaW5kb3dzKSI+IDx4bXBNTTpEZXJpdmVkRnJvbSBzdFJlZjppbnN0YW5jZUlEPSJ1dWlkOjgxYjI4YzQzLTQzNzctNGNlNC1hODk1LTZlNjE5ZjdkOWMxNyIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDpjOGZmM2ZlNC0yZmRjLTgyNDAtYjlkZS02MDg1MjIwOGI0YTkiLz4gPGRjOnRpdGxlPiA8cmRmOkFsdD4gPHJkZjpsaSB4bWw6bGFuZz0ieC1kZWZhdWx0Ij56b29tY2hhcnRzLWxvZ28tcmVkPC9yZGY6bGk+IDwvcmRmOkFsdD4gPC9kYzp0aXRsZT4gPC9yZGY6RGVzY3JpcHRpb24+IDwvcmRmOlJERj4gPC94OnhtcG1ldGE+IDw/eHBhY2tldCBlbmQ9InIiPz5j1ZUXAAAYZklEQVR42uydB5gURROGixOzCCoYMGEWc845R8SAipgVzDlgxqyoPOYcwZxzwJww55wzZgUUFQXt/17b+rent3d3dnf2bveuv+cZ8WZnenp6uqurvqrq7mBEPhORzhIREdHeMaZDs0AY3/w/HWNbRES0e0xoav7P2NgOERERyIKm2AYRERGKKBAiIiKiQIiIiIgCISIiIgqEiIiIKBAiIiKiQIiIiIgCISIiIgqEiIiIKBAiIiKiQIiIiKgdYlJTRGWYay6RrbYSGTtWpEOH5p7U3JWuuUbku+9i20SBENHusPTSIiedlDz37LNRIESB0AYx2WQiiy0mssQSIjPPbP/+80+Rb74RefFFkddfF/njj/bdRhMm5J/7++/28/7TTSeyyirNRnez1f3PPyITTWT7xuefR4HQZjDvvCLbbivSt69Ijx5WDQ4NhC+/tOrx9deLvPtu+2wrBoEPY9rP+y+4oMhttyXPDRggcumlDf1akVT8txWam+Hkk0VefVXk6KNF5p47LAz+FaHN5+eYw1732mv2voknjm3Y3gBvkuZcFAgNhu7dRR55ROTww0WmmKK8eyeZxN738MMis84aB0l715DagMnUvk0GTIQnnhCZccbw79iD77wj8uOPIpNOaq+HXe/UKXkdtuRLL9l/338/DpaIKBAaDlNOaW3AkDC46y5rCzLzjxuXVAnnmUdkm22svTjTTLnfpp9e5JZbRFZYQeTXX2PPiogmQ0PhvPMsMeTi++9FNtpIZJNNRO65JykMAKTZBx+IHHusyOKLiwwblvx9oYVErrgi9qr2gL/+yj83fnzUEEqLnCZLxIVsrrTApQO7n5WNtvLKIjvumDz3xRciG24o8tZb6crA377DDiJjxojss0/u/BZbWNPhySdz5yAd0SxwYXbuLDL55LbzoEngsXjjjeLPmmYaa6rMMIPIVFNZNyjC6ocfrIkycmR17YGmgznUpYutK52d98LNigBMi59/zv0/mhfkK+456su34/e337YmWKWgzFlmEZl6alsuQpp2/Oqr7Dw+tAOcULduItNOayeKESNypCF9kW/og/r8O6o6Jvs/fT/kpnX79yKLWD6LcrmW9v/wQ/teLQiWYR9FE9TsCdtvL3LkkdUJBBr1kktEhgxJdz02fteudvBg+zP4iKjjw9J57r9fZL31kpJ9ueVEXnmlsvr55d13n8jee9tzCBm8FggD6uODeIaPPhK5916rtTC46RTUZ911rfDiXjpLyJuBYEKIXXmlyLXXpq8znR3TBxfr7LOHTSc6JR0SoXP77daE+vZb+9tmm4ncemvy+t13twNo003toKVMn3mnvDffFLngAquFpannOuuI9Ool0rOnbQeEjA++62efiTz1lNXSXn45fVsgrGnv1Ve3WiOCl+cqyTx8uMiNN4oceqj9m5gUhPRssyXLoW3oY5DNbt+l/TbfPF+DmH9+kf33txPInHPavuprrEwYd98tcvPNls9SgcPEw3djgqH8oUOzGK2jBYFgrJytzXH44SYTnHde8edMPbUxO+1kzMUXG/PWW8b8+Wfy/r//tufvuMOYceOSv51wQnXvOPPMxowdmyzTf34afPutMWedZczLL1fWRg89ZMx885Wu79ZbG/Pll+WXf889uTI226z6b3rbbcZMM03xul56aWVln3OOMVNMUbjcnj2NOfhgYx5+2Jh//ile1o03GnPUUZW/59dfGzPppMnn77KLMb/+mr4M+u9WW9l7+/c35plnjLngAmMOOsiYm26y5VU/XkfVXiDsv382AmHw4HD5001nzLHHGvPpp5WV+/33pTtlmuPMM01dAKHSo0fhep56auVlP/ZYtgIBjBhhzFRTFa7vsGGVl/344/kDkWPhhY0ZMyZ9OXfdZczAgZXX48MPjZlkktzzGdiV4Jhj7Pscd5wVZj/9ZOvGJDBkiDEzzVS1QKg9h1Bu0A62JjZVyCvgAzXsjDNsVGGlQL0fNar690SlRP0rhV9+saoj6mjIDi3VNl9/LfL771YtRWX12wp1F9MBNdTnXOA6Bg4Ml43diumiPAB2NGqs2sVKqpYL6sDhqtEu8Mqcf77lY0LwzaxPP7XuYEwEyqUdqSdmmY9VVxW5+mqRLbfM52TgIErht9+sqYlKzvMwFWh7zF/ex3c/8xsmYJPD1VM/VH9tO8y/QtGMXMf7weHQ33knt56UzXiiXvBHmHTUgT7Fb1wL71PXpCK2J4RdMVJFgf181FHW7vZBvIAL+IQDD6y+fsQPZAEIIOx5BqQ7gLC7ETrYzXwsPiYdmQ/LB4Qj2HNPax/7oDPCa0BQPvqotb/pBHQYBAH2+mqriZx2mh3A7iBjgLkeD0hDhKcPBtfZZ1s7lU5G/bQjw8NAZuJ12Xhj20mxXwt9S4hOojefflrkuedEPvnEvgMDCOFHveAZ8ND4PNM55+Tb/fAPDMY777Rh4pQNIYnQcoUT7YBwpOzddkuW0aePnThcviPkIaBtKf/55y3Jy8BUITB6tH1vuATu5X3gHHAzu8D7dN11SYGA4KBNlT/gW/uCBKL1iCNsX+T9VIDCY8ATUP/evW0b0p6875JLWl4F4Ya3i3p//HH1/bjmJkM5xzzzWJXXxyWXJK+75prittbdd1sVr08fY1Zf3ZhVVjGmVy9rvlx7rTG//Za7nvNZ1f+FF5J1gauYY47S96Eyv/lm/ruktQuXWCKfw3jyyeQ1V1yRX/599xnTuXO6Z3TpYttx4okLmwx9+5Yup6nJ2vc+hg7Nv7ZDh/K/wd5755f97LPJa5ZbLv8aeJVynrPIIvllqI1fTh/56itr9pa6D45srrly/AfcyvHHG3PyycZceaUxc87ZIBxC2qNTJ2M++SS/kV99NWkHQqQUwkUXGbPggqWfNfvsxpx+uh2wEDRZvQNEjy8QFl003b0bbphPbg0YkP7Zl12WvBcbuXt3+9sMM+TbzO+/b8xkk1X+riGBkIbQ1OO995L3fvFF2N6v5HjqqWTZf/2VG0yFBMKWW5b3jJVXLl+AQ3L6XBf9uZJ3pK169zZm441zQjoDgVA/gUmohPiYfXsbVQm1DRA7sMce+feiji+/vFUZUb9KATX5kEOsul4qBiAtUKdRsfMcuykTXjAt/LUEeKe0eOCB5N+YI+oWW2ONfJv5zDPzA6+qBS6wtMAMcIE7EV98FvBdcJhnqNhFjecWCtr1+0OlOTCMiTvusKZehgFR9SEQSBAK8QYMfs0vh4yhE/tgUY6117Y2a7kgfx3bKwvQoSG3KgUf+KefkufKSbaCWygUKIO96z/L52RaGu+9lx+cUw057IKYjtD3aW1AOsJHuCAy9qyzqus7GaL1cxmYvUgh9nH66ZagUXBNly75nYrgnXrIHSB4JuQdKSf4yg/eKsdDU0wT8UO0CeBp7SQsf2CoZ6MYINWWWkpkpZXsAIJcQzOj3SHiYNpVqNKWLrkH+VYPeOghkUUXTZ7bbz+RnXe2wUcEuXEouduuBAIhs7iFfDDba1QYgGll/b4EG9ps8Wy3Xf0kEsEeZ61OluPmCwkE9Qb4pgwsfTWRo1mgHHOFqMeddhLZZRf7/2kEr9929bJWAd4UBj/CzAWeB85z4G1DcODFwLvUgqtzta7JcMMN+aocbhdcRS4IsfXDOnGhZeUyrBaDBokssIDUHTQOwY93qAchGhqgIQEIb8TCNccfbyeGtFpYNcK1liAUGa222NqTmMe8N6HduJ3RINq8QDjmGBs84wMJ6Sd0QCz6swu+83oAHxf/cz1CB0FTU1hQ1DvQusjRCJG1gJgA4gUgkjGB4JvcBKt6BRMZprIfxxAC+Q5wDMRRtADx2TomA4kZxx2Xf55zsKYuIJp89hkbq9oMvyyAyXLZZfXb8XSW9AVAxwZYBgOvABGMPphZMTNJYiKyUiM3eSdIVCIbWRz3ppvqe2k7EpXQhFnMl4mRaEr6uR+0pCCZDE7Nj7pseIFAJB+Ziz4efzw800LAuOGzwE0tzhrLLGNJOMJ/QxFtWieyGXfdNaymV0MuZvp1//u86rZVhMLA6w2HHZZ/DtKN8HCEQEhbQDCgIUBYajRovYPoSA64BYhSokLxuK25Zv61CBAySYn+bRMCgYHCy/iML7N9Icnnp5iCrGIHCqnZhPxCaj7zjA2nhdcglNRNk/U7GynIXB8SEq0FFUzEyLsgJJb3KSTwWhvMksSIuIBHSDs7snpVIy54Sqg3rnWOtdYSuegiGzrugpW62oxA4EVDwTbE3RNHH4If7AJ/UMvNQFhkgwGE7cYBp1EK5DEQV47KxwerNw4B+5oOpiAYho5Wr0vIMwn4qjMmQFqEPCiNJiAIVCO+BtMIktHVTlkPwo9ZaTiBgLrjriykIKmDVY9L2cGuSp4mUUqBTUkmIqYK9xXqGER7oa7R0GlnTsqDQyCDkKjKDTaoTw6BTrXXXrnzmGAIiHoVCCGTq5xvzv1+dmVLCISsXbkQpvAobpwO2l3DCwRm2ssvzz9P6OUppxS/13eR4X4sRLwU6hxkBKaJ+kMowMj7Lk4fmBCQnzDgDLZ6n4XgXPBlu+7Hffe1abhZhy9nAUxI6ut+s3LCuEkb9r9F1gOIvoIG5j6nFt6bkIu4hi7U2rsd6YSoe/4ghkSEICkFUmndBoAoC+W+F1Ob05gY2P/M8sQTuBFzBEmx3BfLm0F0EZFI+i6mhCsMavyhqgJp18R8+IOG/JG0azJoym1LEHUMXvJTXKC9pdHAqB8p9D4Icc8SmJWkIrvweY8QSEPfeut8ojwEyF/fZEVY+pxQQ2kIBJQsvHD4o5OrEFpn0B1g2Lu6d54CT4DfwasFAgqwqIbb6VHXfFdoI4L3YJs6992I70DgIuyIjPPjP2h73GJs7NqvnxWsK67YMvW9+GKr2bmaHmQa8SdMMBDLrmmHKg0zj1nKugsuICRfeCHb+hHzgLdjvvmSXBj1IrmKyQUQWUn/Z/JAgGC6IoiJRWAbAHJp2CvU1WAQBJh0mKL+2hHkoITyVhpGIDB4Q2DRB45KwExx8MHZ2WyUg/qvM5ECdbqWHo2WBD57It7Qdlzgs8erwqyDKYSLEjUYzQGtgIGmYAGOltKC4H0OOsjmLijgBchSxdxBeDHodPUi7OpCCUy4s7OuN+YBgokt/VztBPchfVMHOIQg7lCdFNUFzHvpu+nCN9r2eOEKJXrVOCCv9gKhFmGySGV8tVnN3MyQDBjiD4ggU+BybPDdfBO48EI765Nd6gNXHUcxlLvVXTVgALMiNLH8foowHI/vjiuEwYPtxju1AKt2UUffhMVL4rrLWcpeuZqQyYUWwVEKBxxQ+crgdcMh1KoTnXhiNuWgAWgiFQSna5qEEq+KwWe26bjlBCn55lM5bReKPgydw6vDMmOh4J5ScF3DoY5dzruG6ua3H0IaEy6UzpzGxkfwhQKcQvWshBthVkejLLUGh2ZkApZqT7v3h6up8i6EMNcYtdcQUDOZ0avJ2MLlxCzhDhB8/kho1MpKgW1J/ACqGnHzrBuoIEX4qqvKHzAkr1BfvBWksKIupp0RcQMyUKgPJCyBKmmB+gx5SDtTFm1VSDsjUhQPD5wCmtayy4ajFymHGAsIV0g51oZUEA2o+1yg5lLvtO+qg4n3o514DveHNnDB9caaAdjUfB9IXbxWIdDe1BMfPmG+fItC1/Fs3QAIwV3pQruEIGMWk41JSL7Le2gbws+o25TxgJmGZsE7IfBCwXcqEElwgpMgmrEFUPuNWuhouhtNNTY+9lYoXqF//+L5BKwUhAT3VTJCkwkiohOvv36yswNINHc9hjSgYzHLU18GCXYmRFJadxRCgDK0k3Jv2rx4BhS2J/fSCZnx6OSl2p16YudykI7OfbjUGJxoEdjCIRKL63gexB5lMLA1ZDhtfXlf7qW+3I9wKRUDwvdkAxjqC8fBoGYGRRhypNnpiHsoh2fzragLArXayE3egWhWVv7CU0V7IFARaoX4LrgPiEb4D+pEXbgPYcb7hNaNqB1G19ciq6WOo48Or6V42GGF72ER0ZEj7XWsY89inmuskfu9X7/8TVVY675R2iQe8cjuGNVYAoHj0UfDQuGGGwovsMrKy8ssk9zJZ9ZZwwu2fv55FhtexCMeDSkQam8yZA3UKrwLobUUUFdxV5Fnjr8WdctX1QgewRxgBSZ/yS72j8Cmgz+IKAzMBQ2sCfEUqM7KSWDyuN8A8xG1GPXczcLken/dBv8a1zQLbfySxqOlAXJ+vdy6w7/4kY6h66lDsahW+qPyKm6bhbgaylfTyedzeG7LLKk2uvE0BF2jnj35iuGHH4x57jm7l+Ptt9ulub/5pvh2W2mXTG+vB/sk7LFHcl/IBx80Zuml8/e6pP3Z03DeeZO/XXWV/e2QQ3Ln2OaMb8V5F999FzYHjzjCXvv77/l7O8w9d7juCyxg92h0l6FnL1D/OjRH+oJfl9dft0ueu9dSN3c/EO5x9/x48cXctdtsY3//5ZfwdoLTTmuvo73Ym8R9Psvzn3RS7ppoMhQ42NNxwoTq9xdkExOETBz0xQ/dIIe9MnbYIbffIR127bWT+14ofDPugQfseTYYcfcYQHjopr6UzfHKK+FNXNhTA7zxRu7a006z59iwZv75k9cvu6zdmwGwWQ/Xv/22/fvEE5PXsrGOgj0UuXbffXPCZ7vtctfybvp8Nq5VQaPn1lsvd+1uu+UGv/6ux+ab5/Z+pEwF7cvvl19u//74Y2NmmSUKhKLHiitaLaASsLvRppvGgZ7mmG0222bjxxvTrVv+LPnuu8lZVjdIYZchtxwdOIMGJQXCBx/Y8662Qef/4w97np2S9DyDGLA5jVu2agAIB/c8OzeBXXfNnWODX90lbLXVksJMN8xx35N7wUsv2d2n/PZB29CdokPtt/POuc1ti7Uz7aUah7sBiwqFUrugt5mNWirFiBE2Jh+3JCGq+GsLuWqwMXEDsS4DEYnwEDVcbKJNQe157H8WiFGwXD6h5G56dTXApajAhaih4/juSwVyaQCTG+5MvAqL2hCf4bqRcclquLofQq9cgeuq1ghBojmbmsLuw6wD8dz4hHPPtf+SGFVOtm/dBSa1FAgz5iCZijhwshb5eBA/+OLxpxNEQkBKNTER7RVE2DHoSTqCuKVjkgNB4AxrXGYFTQrSGAkdFBC+PnzCkUxC4Iaba04Afn0/1VuDkfwBpoSiG5lJIBEglbya/sPK0f4O3CQ7hd7PBUvD8VwED/EfNVo5u2Ob67goPgSCcERkC9a0QCMjuYil4khfR8ASRq6zbbVgUGuEIYlDaAxESobW0WRw6I5HCy0kcuSRuXoqdPCiIfieA/VU+FuhMdhYqYsJBs0I7wArP5MTwfLo1YCAqlNPTZ4jE7OUQNBQb7SXGu6p0TH28oiywG5ZhHmTZsxemiSGoSkw2Nzt510BHfrbzyfQ8/4CvLiYSZMPzcqEXbtbAGIOsrw/Kd3+QGLw+3VRQeDnVWjd0CiJ0sREILW6Z0+bCl7N2goIGdekSQt9f+rS1BQFQkQrA1scWxuOBt4FHzvLezFgSAI78ECb++GuXYGQ8Aey/u3Pcjp7M8ujEahKz1oBhfDYY9ZE1PLYq9PPmSH8V/kAhIJrNujiML4poXEAvK/u84BmgBZExih8RqWzdKVp2BqmTZu4ZlUUCBGtAmL0mX1ZscclYtU0Q8XWQQ1fw4FKj6pNko5COQF/RSR3kKedgQkg04VtCoEENp5PijKJUW4qtO4QRjKUCxVq2PsqEHRTYHgpgpEqTdYrh39wV0ZCONG+vG8N8xuaYk+PSAW2m8fWxQYm+45Zkk1XMRkAyWKa2IQNrvY8hBm7W3E96bsw/ngO/O3rVatwF2Qp2Gv/67bFVttyByB7OQAyPFH9qQuCAeIZzwMrF4Xq4nIOuvo35kVoltc6FVLntSxmep7vHvAf/jMpB08Yv6N9sSwc7VrrXcIaPg4hHi13dO1qzNlnGzNuXC6Wg8g8YhFcn7keAwYkoxo1dqB79+R1xCGQQwJ69y5dj8GD7bXENKSte69eNtpQQYzEkCE2+tK9rkeP3DVLLpmMw9D3dpPj/HiM4cPDz+/fv3A8zOjRuShEIipDINZm8cVjLkNEHYI0aVRnuhCuObXTQ8ClRzowMx/p3KwHEJo9UelRxXEZlnKpkS6MJgF/UWjNg6CB3NFqBTwPdTxUb3IO8HRwDaaGyy+wShO8A6nhuGFdYBrhEaHuoVW2cBXq/go+oYong1WV0LBoA101Gi2BfyE/IThrj9FRIERERPxfIEQOISIiIpKKERERUSBEREREgRAREZEGkIrEb8YApYiIiAkIgpHNR+fYFhER7R5j/ifAAAu+3z0PC2TkAAAAAElFTkSuQmCC", 
                t.LicenseBannerUnlicensed = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADAAAAAwCAYAAABXAvmHAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAALPSURBVGhD7VjtcRNBDHUH8I8h3DEpgQ6gA+gAOggd4A5CB6YDZ/CdzeRP/A+YW++5A9IB6SDoaaXzkoQQ9svY4zejYawjkp5W0upudMA+4NFk+vj43L5UeTL9eiyP/k8gwHphT0imJNe/S7+R1vRVuzo9avoX8qfbBQKngCabIF3QVWsu68Vq6aRX2RCBzO3Fs0X/SkyVRzW3HzSYat5fEZFPTz9/eyOP7wQyXzXdR0dwQ6RoiaG+4XQIngKHTh4/GHVj3oE421jYn0XKikumMT9c4OYy1imIIwGaDJCSR+nBmacmFGfLkKz/CWRvrCSynQQ1J00YctKadcrgFUoC5ZS8J3C0bJxqNkfwiqGcqMdEFQ+uU8oKDOcee+xLGjuZLzKm9bkUVVboaSc7BZ06JW9PvSeOmu9xPhE0DMGgqIoAlx37pX9FFYZkhv4RmjiMbVGFQXaZ7M17F5gA7VXyMwxKoGT9K8gv+bbXUXeCy0Ifl4VAKIGo0995AjrO5GdRpDoB7oGtNDEWx3lkD9AJnIHA315UcgB+QUB+hqGemfcwhCVLVEWAhLHfmTkTVRhwfGyIljlRFcGwlVICRRUO7P9sLOfbkgd/+03yXjAcJy11osoKzX7SsiWDPI2SHOk9GHagVNlXYIyq4VwjlUtHVneSsajTYZhImT6BeJ9q8r04DfVJJFKdBDLvfe1A7U/kUR4MI47Fnog6CEiCThxfspPQcmJnqNtZ91YePQjcrP7XPXmRf/4Fsi5DQhrbTSc4pEzCad10r/FJXf4bAwFDR89PvUZ1gdP9ImXk7htPspMA+J645fzmJ3aIHxhvuWMELma0F7ZDAuC1g0oL+0vdrpZVa6+wjLE03Ro6kvF9zb91Eilwk0SxnkiJvTwJJ5ZW7O5Aoij2jIQ3lmm67S4JHc87S8In0Jii7+vRYBK4GHcxeIU7iVX6l54DojEa/QJwh1a9wdC2PAAAAABJRU5ErkJggg==",
                t.ErrorImage = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAQAAAC1HAwCAAAAC0lEQVQIHWP4zwAAAgEBAMVfG14AAAAASUVORK5CYII=", 
                t.PiechartBack = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC8AAAA1CAMAAADmtEJjAAAAYFBMVEVMaXEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAADIAgUIAAAAH3RSTlMACbeu3XUBgH/vy+gqMRghOfqXYUpWwkDGihCfgmebkGEUkgAAAQVJREFUeNqV0ttugzAURNEx2BADBMItTXqZ///Lyi0qrXOkZvajtcbyg2F1gtSJIqfIKXKKnCKnyClyipwip8gpcmo8FaNvitewdtV/PB8WYRD4V83sBJ5q50rgqW2QOBlHiZOXUeJkewZQ8/kKiIOrOCigDS5ncbBCG9ygDUqYgxhpt8EcALh3Syjb3L/AHAB7/a3N7jcHOHIhZu83BvjduTj8BHOAP1XTjw8wB8gG5fGBzAGynN//g4M5QN7y7Rs8VJu+8ky9wR7gocBUD2tg+TFxD7Pa8C75GnbWeSQ54Pk8WULzV8VHNgp35Kr4nk2l+JkLlD42SPle4t0Eqfe75jvsfQLbYGzTrP2yIAAAAABJRU5ErkJggg=="
            }(c = i.Resources || (i.Resources = {})),
            function (t) {
                var e = function () {
                        function t() {
                            this._dict = new Object(null), this._count = 0
                        }
                        return t.prototype.add = function (t) {
                            var e = this._dict[t.id];
                            e ? e.push(t) : this._dict[t.id] = [t], this._count++
                        }, t.prototype.remove = function (t) {
                            var e = this._dict[t.id];
                            e && d.Helpers.removeFromArrayHasty(e, t), this._count--
                        }, t.prototype.contains = function (t) {
                            var e = this._dict[t.id];
                            return e && e.indexOf(t) >= 0
                        }, t.prototype.clone = function () {
                            var e = new t;
                            for (var i in this._dict) e._dict[i] = this._dict[i].slice();
                            return e._count = this._count, e
                        }, t.prototype.count = function () {
                            return this._count
                        }, t
                    }(),
                    i = function (t) {
                        function i() {
                            var i = t.apply(this, arguments) || this;
                            return i.centerX = 0, i.centerY = 0, i.zoom = 1, i.hoverNode = null, i.hoverLink = null, i.hoverItem = null, i.lastClickedNode = null, i.selection = [], i.selectionSet = new e, i.notifyChanges = !0, i.lastNotifiedSelectionSet = new e, i.autoZoomMode = !1, i.layoutActive = !1, i
                        }
                        return n(i, t), i.prototype.xyInChart = function (t, e) {
                            return t >= this.x0 && t < this.x0 + this.width && e >= this.y0 && e < this.y0 + this.height
                        }, i.prototype.toDisplay = function (t, e) {
                            return {
                                x: (t - this.centerX) * this.zoom + this.x0 + .5 * this.width,
                                y: (e - this.centerY) * this.zoom + this.y0 + .5 * this.height
                            }
                        }, i.prototype.fromDisplay = function (t, e) {
                            return {
                                x: (t - this.x0 - .5 * this.width) / this.zoom + this.centerX,
                                y: (e - this.y0 - .5 * this.height) / this.zoom + this.centerY
                            }
                        }, i.prototype.toDisplayTransform = function () {
                            return {
                                xm: this.zoom,
                                xa: this.x0 + .5 * this.width - this.centerX * this.zoom,
                                ym: this.zoom,
                                ya: this.y0 + .5 * this.height - this.centerY * this.zoom
                            }
                        }, i.prototype.objectRemoved = function (t) {
                            d.Helpers.removeFromArray(this.selection, t) && (t.selected = !1), this.hoverNode !== t && this.hoverLink !== t || this.setActiveObject(null, null)
                        }, i.prototype.addToSelection = function (t) {
                            return !this.selectionSet.contains(t) && (this.selectionSet.add(t), this.selection.push(t), t.layer.touchNodeOrLink(t), t.selected = !0, !0)
                        }, i.prototype.removeFromSelection = function (t) {
                            return !!this.selectionSet.contains(t) && (this.selectionSet.remove(t), d.Helpers.removeFromArray(this.selection, t), t.selected = !1, t.layer.touchNodeOrLink(t), !0)
                        }, i.prototype.setSelection = function (t) {
                            for (var i = this.selectionSet, n = this.selection, r = new e, s = [], a = !1, o = 0; o < t.length; o++) {
                                var l = t[o];
                                r.contains(l) || (r.add(l), s.push(l)), i.contains(l) || (i.add(l), l.selected = !0, a = !0, l.layer.touchNodeOrLink(l))
                            }
                            for (var o = 0; o < n.length; o++) {
                                var l = n[o];
                                r.contains(l) || (l.selected = !1, l.layer.touchNodeOrLink(l), a = !0)
                            }
                            return this.selectionSet = r, this.selection = s, a
                        }, i.prototype.setActiveObject = function (t, e) {
                            if (this.hoverNode) {
                                this.hoverNode.layer.touchNode(this.hoverNode);
                                for (var i = 0; i < this.hoverNode.links.length; i++) {
                                    var n = this.hoverNode.links[i];
                                    n.layer.touchLink(n)
                                }
                                this.hoverNode.hovered = !1, this.hoverNode.locks--
                            }
                            if (this.hoverLink && (this.hoverLink.layer.touchLink(this.hoverLink), this.hoverLink.from.layer.touchNode(this.hoverLink.from), this.hoverLink.to.layer.touchNode(this.hoverLink.to), this.hoverLink.hovered = !1), this.hoverNode = null, this.hoverLink = null, this.hoverItem = e, t instanceof h) {
                                this.hoverNode = t, t.hovered = !0, t.locks++, this.hoverNode.layer.touchNode(this.hoverNode);
                                for (var i = 0; i < this.hoverNode.links.length; i++) {
                                    var n = this.hoverNode.links[i];
                                    n.layer.touchLink(n)
                                }
                            } else if (t instanceof u) this.hoverLink = t, t.hovered = !0, this.hoverLink.layer.touchLink(this.hoverLink), this.hoverLink.from.layer.touchNode(this.hoverLink.from), this.hoverLink.to.layer.touchNode(this.hoverLink.to);
                            else if (null !== t) throw "scene.setActiveObject invalid active object type " + t
                        }, i.prototype.getVisibleBounds = function () {
                            var t = this.fromDisplay(this.x0, this.y0),
                                e = t.x,
                                i = t.y;
                            t = this.fromDisplay(this.x0 + this.width, this.y0 + this.height);
                            var n = t.x,
                                r = t.y;
                            return new d.Rect(e, i, n, r)
                        }, i.prototype.disableSelectionChangeNotification = function () {
                            this.notifyChanges = !1
                        }, i.prototype.enableSelectionChangeNotification = function () {
                            this.notifyChanges = !0
                        }, i.prototype.notifySelectionChangesIfNeeded = function (t, e) {
                            if (this.notifyChanges) {
                                for (var i = !1, n = 0; n < this.selection.length; n++)
                                    if (!this.lastNotifiedSelectionSet.contains(this.selection[n])) {
                                        i = !0;
                                        break
                                    }(i || this.selection.length !== this.lastNotifiedSelectionSet.count()) && (t.events.notifySceneChanges({
                                        selection: !0
                                    }), t.notifySelectionChanged(t.createEventArguments(null, e)), this.lastNotifiedSelectionSet = this.selectionSet.clone())
                            }
                        }, i
                    }(d.Scene);
                t.Scene = i;
                var r = 2 * Math.PI,
                    s = function () {
                        function t(t, e) {
                            this.node = t, this.nodesLayer = e
                        }
                        return t.prototype.postProcess = function (t, e, i) {
                            var n = this.node;
                            n.targetHWidth = n.targetHHeight, n.bounds = new d.Rect(-n.targetHHeight, -n.targetHHeight, n.targetHHeight, n.targetHHeight), this.sizeScale = n.targetHHeight / t.nodeLabelScaleBase, this.postProcessLabel(e, i)
                        }, t.prototype.postProcessLabel = function (t, e) {
                            var i, n, r, s = this.node;
                            if (null != s.label && this.nodesLayer.chart.assetsLoaded) {
                                var a = s.label.toString();
                                if (0 === a.length) this.currentLabel = null;
                                else {
                                    var o = this.currentLabel;
                                    null == o ? o = this.currentLabel = new d.Label(s.labelStyle, !0) : o.style = s.labelStyle, o.text = a, e.measure(t, o), r = o.style.scaleWithSize ? this.sizeScale : (o.style.scaleWithZoom, 1), i = 0, n = s.targetHHeight + o.hheight * r * .8, s.outerBounds.addBounds(i - o.hwidth * r, n - o.hheight * r, i + o.hwidth * r, n + o.hheight * r)
                                }
                            }
                        }, t.prototype.getAnchor = function () {
                            return {
                                x: 0,
                                y: 0
                            }
                        }, t.prototype.adaptToViewport = function (t, e, i, n, r) {
                            var s = this.node;
                            this.x = s.x * t + e, this.y = s.y * i + n, this.hWidth = s.hHeight * r, this.hHeight = s.hWidth * r, this.zoom = r
                        }, t.prototype.isInViewport = function (t, e, i, n, r) {
                            var s = this.node.outerBounds;
                            return this.x + s.x0 * r < e && this.x + s.x1 * r > t && this.y + s.y0 * r < n && this.y + s.y1 * r > i
                        }, t.prototype.paintSelection = function (t, e, i) {
                            var n = this.hWidth * (1 + e) + i;
                            t.moveTo(this.x, this.y), t.arc(this.x, this.y, n, 0, 2 * Math.PI), t.closePath()
                        }, t.prototype.paint = function (t, e, i) {
                            this.paintBasicShape(t), i && (this.image = this.nodesLayer.getNodeImage(this.node, !0), this.paintDetails(t, e))
                        }, t.prototype.paintBasicShape = function (t) {
                            var e = d.Graphics.beginStrokeAndFill(t, this.node);
                            if (this.hWidth !== this.hHeight) {
                                var i = this.x + this.hHeight - this.hWidth;
                                e.moveTo(i, this.y - this.hWidth), e.arc(i, this.y, this.hWidth, -Math.PI / 2, Math.PI / 2, !1), i = this.x - this.hHeight + this.hWidth, e.lineTo(i, this.y + this.hWidth), e.arc(i, this.y, this.hWidth, .5 * Math.PI, 1.5 * Math.PI, !1), e.closePath()
                            } else e.moveTo(this.x + this.hWidth, this.y), e.arc(this.x, this.y, this.hWidth, 0, r, !1);
                            d.Graphics.endStrokeAndFill(t, e, this.node)
                        }, t.prototype.paintDetails = function (t, e) {
                            this.image && this.basicPaintImage(t), this.paintLabel(t, e)
                        }, t.prototype.basicPaintImage = function (t, e) {
                            if (void 0 === e && (e = 1), this.image) {
                                var i, n, r = 0,
                                    s = 0;
                                if (this.node.imageSlicing) {
                                    var a = this.node.imageSlicing;
                                    r = a[0], s = a[1], i = a[2], n = a[3]
                                } else i = this.image.width, n = this.image.height;
                                d.Graphics.drawImageInSquare(t, this.image, r, s, i, n, this.x - this.hHeight + this.hWidth, this.y, this.hWidth * e)
                            }
                        }, t.prototype.paintLabel = function (t, e) {
                            var i = this.nodesLayer.style.nodeLabelScaleBase;
                            if (this.node.hovered && (i = d.Helpers.toleranceMin(i, this.hWidth, .9)), this.currentLabel) {
                                var n = this.hWidth / i,
                                    r = this.currentLabel,
                                    s = 1;
                                if (this.node.labelStyle.scaleWithSize ? s = n : this.node.labelStyle.scaleWithZoom && (s = this.zoom), e.measure(t, r), r.hheight > 1.5) {
                                    var a = this.getLabelPosition(r, s);
                                    e.paint(t, a.x, a.y, s, r)
                                }
                            }
                        }, t.prototype.getLabelPosition = function (t, e) {
                            return {
                                x: this.x,
                                y: this.y + this.hWidth + t.hheight * e * .8 + (t.style.margin || 0) * this.zoom
                            }
                        }, t.prototype.distanceToEdge = function (t, e, i, n) {
                            return t
                        }, t.prototype.hitTest = function (t, e, i, n) {
                            var r, s = this.node,
                                a = s.renderHheight * i,
                                o = s.renderHwidth * i,
                                l = s.x,
                                h = s.y;
                            if (a < o) {
                                var u = o - a;
                                r = d.Geometry.distanceToSegmentSq(l - u, h, l + u, h, t, e)
                            } else r = (t - l) * (t - l) + (e - h) * (e - h);
                            var c = (a + n) * (a + n);
                            if (r < c) {
                                var p = a * a;
                                return r < p ? 0 : Math.sqrt(r) - a
                            }
                            return n
                        }, t
                    }();
                t.Shape = s;
                var a = function (t) {
                    function e(e, i) {
                        var n = t.call(this, e, i) || this;
                        return n.validate(), n
                    }
                    return n(e, t), e.prototype.postProcess = function (t, e) {
                        var i = this.node.customShape.onUpdate.call(this.node, e, this.node.radius),
                            n = new d.Rect(i.bounds[0], i.bounds[1], i.bounds[2], i.bounds[3]);
                        this.node.targetHWidth = i.HWidth, this.node.targetHHeight = i.HHeight, this.node.bounds = n, this.node.outerBounds = n.clone(), i.anchor && (this.node.shapeAnchorX = i.anchor[0], this.node.shapeAnchorY = i.anchor[1])
                    }, e.prototype.paint = function (t, e, i) {
                        var n = this.nodesLayer.getNodeImage(this.node, !0);
                        this.node.customShape.paint.call(this.node, t, this.x, this.y, this.hWidth, this.hHeight, n, i)
                    }, e.prototype.paintSelection = function (e, i, n) {
                        this.node.customShape.paintSelection ? this.node.customShape.paintSelection.call(this.node, e, this.x, this.y, this.hWidth, this.hHeight) : t.prototype.paintSelection.call(this, e, i, n)
                    }, e.prototype.distanceToEdge = function (e, i, n, r) {
                        return "function" == typeof this.node.customShape.distanceToEdge ? this.node.customShape.distanceToEdge.call(this.node, e, i, n, r) : t.prototype.distanceToEdge.call(this, e, i, n, r)
                    }, e.prototype.hitTest = function (e, i, n, r) {
                        return "function" == typeof this.node.customShape.hitTest ? this.node.customShape.hitTest.call(this.node, e, i, n, r) : t.prototype.hitTest.call(this, e, i, n, r)
                    }, e.prototype.validate = function () {
                        var t = this.node;
                        "object" != typeof t.customShape ? d.Helpers.error('If the display of an object is "customShape", it\'s mandatory to supply the rendering methods for the custom shape') : ("function" != typeof t.customShape.onUpdate && d.Helpers.error("onUpdate function was not supplied for the custom shape"), "function" != typeof t.customShape.paint && d.Helpers.error("paint function was not supplied for the custom shape"))
                    }, e
                }(t.Shape);
                t.CustomShape = a;
                var o;
                ! function (t) {
                    t[t.Floating = 0] = "Floating", t[t.Scene = 1] = "Scene", t[t.Fixed = 2] = "Fixed"
                }(o = t.NodeAnchorMode || (t.NodeAnchorMode = {}));
                var l = function () {
                    function t() {
                        this.id = null, this.data = null, this.added = !1, this.removed = !1, this.visibility = 1, this.selected = !1, this.hovered = !1, this.dragging = !1, this.selectionLock = !1, this.cursor = null, this.invisible = !1, this.items = [], this.currentItems = null, this.label = null, this._labelStyle = null
                    }
                    return Object.defineProperty(t.prototype, "labelStyle", {
                        get: function () {
                            return this._labelStyle
                        },
                        set: function (t) {
                            null !== this._labelStyle ? (d.Helpers.warn("For performance reasons it is not recommended to set `labelStyle` to a custom object. Instead modify properties on the existing object."), d.SettingsHelper.updateRecursive(this._labelStyle, t, d.SettingsMapping.ItemsChartSettingsItemsLayerLabelStyle, {})) : this._labelStyle = t
                        },
                        enumerable: !0,
                        configurable: !0
                    }), t
                }();
                t.ItemsLayerObject = l;
                var h = function (t) {
                    function e(e, i, n) {
                        void 0 === n && (n = !1);
                        var r = t.call(this) || this;
                        return r.parentNode = null, r.data = null, r.links = [], r.dataLinks = [], r.isNode = !0, r.isLink = !1, r.aura = null, r.x = null, r.y = null, r.anchorX = null, r.anchorY = null, r.shapeAnchorX = 0, r.shapeAnchorY = 0, r.targetHHeight = null, r.targetHWidth = null, r.hHeight = 0, r.hWidth = 0, r.renderHheight = 0, r.renderHwidth = 0, r.anchorMode = o.Floating, r.coordinates = null, r.coordinatesCache = null, r.coordinatesCachePrecision = 1 / 0, r.expanded = !1, r.focused = !1, r.background = !1, r.loading = !1, r.userLock = !1, r.relevance = 1, r.display = "image", r.image = null, r.imageCropping = null, r.imageSlicing = null, r.tintImage = !1, r._anchorStyle = null, r.zindex = 0, r.opacity = 1, r.aspectRatio = 1, r.locks = 0, r.locked = null, r.fillColor = null, r.lineColor = null, r.lineWidth = 1, r.draggable = !0, r.layer = i, r.id = e, r
                    }
                    return n(e, t), Object.defineProperty(e.prototype, "anchorStyle", {
                        get: function () {
                            return this._anchorStyle
                        },
                        set: function (t) {
                            null !== this._anchorStyle ? (d.Helpers.warn("For performance reasons it is not recommended to set `anchorStyle` to a custom object. Instead modify properties on the existing object."), d.SettingsHelper.updateRecursive(this._anchorStyle, t, d.SettingsMapping.ItemsChartSettingsNodeAnchorStyle, {})) : this._anchorStyle = t
                        },
                        enumerable: !0,
                        configurable: !0
                    }), e
                }(l);
                t.Node = h;
                var u = function (t) {
                    function e(e, i) {
                        var n = t.call(this) || this;
                        return n.data = null, n.from = null, n.to = null, n.isNode = !1, n.isLink = !0, n.multiId = null, n.radius = 1, n.fillColor = null, n.lineColor = null, n.length = 1, n.strength = 1, n.dashed = !1, n.currentRadius = 0, n.background = null, n._angle = null, n.targetRadius = null, n.targetStrength = null, n.targetLength = null, n.direction = null, n.fromDecoration = null, n.toDecoration = null, n.relevance = 1, n.toPieValue = 0, n.toPieColor = null, n.toPie0 = null, n.toPie1 = null, n.currentCenterOffset = 0, n.layer = i, n.id = e, n
                    }
                    return n(e, t), e.prototype.otherEnd = function (t) {
                        return t === this.from ? this.to : t === this.to ? this.from : null
                    }, e.prototype.commonNode = function (t) {
                        return this.from === t.from || this.from === t.to ? this.from : this.to === t.from || this.to === t.to ? this.to : null
                    }, e
                }(l);
                t.Link = u;
                var c = function (t) {
                    function e(e, i) {
                        var n = t.call(this, e) || this;
                        return n.parentId = null, n.scaleNodesWithZoom = !0, n.scaleLinksWithZoom = !0, n._nodes = [], n._links = [], n._nodesDel = null, n._linksDel = null, n.idToNode = {}, n.idToLink = {}, n.lastClickedNode = null, n.newNodes = {}, n.newLinks = {}, n.modifiedNodes = {}, n.modifiedLinks = {}, n.deletedNodes = {}, n.deletedLinks = {}, n.drilldownId = null, n.layerSettings = i, n.scene = e, n.clearModified(), n.styleUpdater = n.createStyleUpdater(n.layerSettings.style), n
                    }
                    return n(e, t), e.prototype.onSettingsChanged = function (t) {
                        if (t.style) {
                            this.styleUpdater = this.createStyleUpdater(this.layerSettings.style);
                            for (var e = 0, i = this.nodes(); e < i.length; e++) {
                                var n = i[e];
                                this.touchNode(n)
                            }
                            for (var r = 0, s = this.links(); r < s.length; r++) {
                                var a = s[r];
                                this.touchLink(a)
                            }
                        }
                    }, e.prototype.updateStyle = function (t) {
                        this.styleUpdater.updateLayer(t, !0)
                    }, e.prototype.postprocessStyle = function (t) {
                        this.styleUpdater.postprocessLayer(t)
                    }, e.prototype.createStyleUpdater = function (t) {
                        return null
                    }, e.prototype.paintPrepare = function (t) {}, e.prototype.paintBackground = function (t) {}, e.prototype.findObjectById = function (t) {
                        return this.idToNode.hasOwnProperty(t) ? this.idToNode[t] : this.idToLink.hasOwnProperty(t) ? this.idToLink[t] : null
                    }, e.prototype.paint = function (t) {
                        this.paintPrepare(t), this.clearModified(), this.paintBackground(t);
                        var e = this.scene.selection;
                        if (e.length > 0) {
                            for (var i = [], n = [], r = 0; r < e.length; r++) {
                                var s = e[r];
                                s.layer === this && s instanceof h && i.push(s), s.layer === this && s instanceof u && n.push(s)
                            }(i.length > 0 || n.length > 0) && this.paintSelection(t, i, n)
                        }
                        var a = this.links(),
                            o = this._makeHoveredLast(a, this.scene.hoverLink);
                        this.paintLinks(t, a), this._restoreHovered(a, o);
                        var l = this.nodes(),
                            c = this._makeHoveredLast(l, this.scene.hoverNode);
                        this.paintNodes(t, l), this._restoreHovered(l, c)
                    }, e.prototype.clearObjects = function () {
                        for (var t = 0, e = this.nodes(); t < e.length; t++) {
                            var i = e[t];
                            this.removeNode(i)
                        }
                        for (var n = 0, r = this.links(); n < r.length; n++) {
                            var s = r[n];
                            this.removeLink(s)
                        }
                    }, e.prototype.nodes = function () {
                        if (null === this._nodesDel) return this._nodes;
                        for (var t = [], e = 0; e < this._nodes.length; e++) {
                            var i = this._nodes[e];
                            this._nodesDel[i.id] || t.push(i)
                        }
                        return this._nodes = t, this._nodesDel = null, t
                    }, e.prototype.links = function () {
                        if (null === this._linksDel) return this._links;
                        for (var t = [], e = 0; e < this._links.length; e++) {
                            var i = this._links[e];
                            this._linksDel[i.id] || t.push(i)
                        }
                        return this._links = t, this._linksDel = null, t
                    }, e.prototype.addNode = function (t) {
                        this.nodes();
                        var e;
                        return this.idToNode.hasOwnProperty(t) ? (e = this.idToNode[t], e.removed = !1, e.added || (e.added = !0)) : this.deletedNodes.hasOwnProperty(t) ? (e = this.deletedNodes[t], e.removed = !1, e.added || (e.added = !0), this.idToNode[t] = e, this._nodes.push(e), delete this.deletedNodes[t]) : (e = new h(t, this), e.added = !0, this.idToNode[t] = e, this._nodes.push(e), this.newNodes[t] = e), this.modifiedNodes[t] = e, e
                    }, e.prototype.touchNodeOrLink = function (t) {
                        t instanceof h ? this.modifiedNodes[t.id] = t : t instanceof u && (this.modifiedLinks[t.id] = t)
                    }, e.prototype.touchNode = function (t) {
                        this.modifiedNodes[t.id] = t
                    }, e.prototype.removeNode = function (t) {
                        var e = t.id;
                        this.idToNode.hasOwnProperty(e) && (t === this.lastClickedNode && (this.lastClickedNode = null), this.scene.objectRemoved(t), this.newNodes.hasOwnProperty(t.id) ? this.deleteNode(t) : (t.removed || (t.removed = !0), t.added = !1, this.modifiedNodes[e] = t))
                    }, e.prototype.deleteNode = function (t) {
                        null === this._nodesDel && (this._nodesDel = {}), this._nodesDel[t.id] = !0, this.scene.objectRemoved(t), delete this.newNodes[t.id], delete this.modifiedNodes[t.id], delete this.idToNode[t.id], this.deletedNodes[t.id] = t
                    }, e.prototype.addLink = function (t, e, i) {
                        var n = this.idToNode[e],
                            r = this.idToNode[i];
                        if (!n || !r) throw new Error("Cannot add link - missing nodes");
                        var s = null;
                        return this.links(), this.idToLink.hasOwnProperty(t) ? (s = this.idToLink[t], s.removed = !1, s.added || (s.added = !0)) : this.deletedLinks.hasOwnProperty(t) ? (s = this.deletedLinks[t], delete this.deletedLinks[t], this.idToLink[t] = s, this._links.push(s), s.removed = !1, s.added || (s.added = !0)) : (s = new u(t, this), s.added = !0, this._links.push(s), this.idToLink[t] = s, this.newLinks[t] = s), s.from && s.from !== n && (d.Helpers.removeFromArrayHasty(s.from.links, s), s.from = null), s.from || (s.from = n, s.from.links.push(s), this.touchNode(s.from)), s.to && s.to !== r && (d.Helpers.removeFromArrayHasty(s.to.links, s), s.to = null), s.to || (s.to = r, s.to !== s.from && (s.to.links.push(s), this.touchNode(s.to))), s.multiId = e < i ? e + d.Helpers.SeparatorChar + i : i + d.Helpers.SeparatorChar + e, this.modifiedLinks[t] = s, s
                    }, e.prototype.removeLink = function (t) {
                        var e = t.id;
                        this.idToLink.hasOwnProperty(e) && (this.scene.objectRemoved(t), this.newLinks.hasOwnProperty(e) ? this.deleteLink(t) : (t.added = !1, t.removed || (t.removed = !0), this.modifiedLinks[e] = t))
                    }, e.prototype.deleteLink = function (t) {
                        null === this._linksDel && (this._linksDel = {}), this._linksDel[t.id] = !0, this.scene.objectRemoved(t), this.newLinks.hasOwnProperty(t.id) ? delete this.newLinks[t.id] : this.deletedLinks[t.id] = t, delete this.modifiedLinks[t.id], delete this.idToLink[t.id], d.Helpers.removeFromArrayHasty(t.from.links, t), d.Helpers.removeFromArrayHasty(t.to.links, t)
                    }, e.prototype.touchLink = function (t) {
                        this.modifiedLinks[t.id] = t
                    }, e.prototype.getModified = function () {
                        return {
                            this_newNodes: this.newNodes,
                            this_newLinks: this.newLinks,
                            this_modifiedNodes: this.modifiedNodes,
                            this_modifiedLinks: this.modifiedLinks,
                            this_deletedNodes: this.deletedNodes,
                            this_deletedLinks: this.deletedLinks
                        }
                    }, e.prototype.hasTopologyChanges = function () {
                        return d.Helpers.hasProperties(this.newNodes) || d.Helpers.hasProperties(this.newLinks) || d.Helpers.hasProperties(this.deletedNodes) || d.Helpers.hasProperties(this.deletedLinks)
                    }, e.prototype.hasStyleChanges = function () {
                        return this.hasTopologyChanges() || d.Helpers.hasProperties(this.modifiedLinks) || d.Helpers.hasProperties(this.modifiedNodes)
                    }, e.prototype.clearModified = function () {
                        this.newNodes = {}, this.newLinks = {}, this.modifiedNodes = {}, this.modifiedLinks = {}, this.deletedNodes = {}, this.deletedLinks = {}
                    }, e.prototype.paintNodeDetails = function (t, e, i, n, r, s, a, o, l) {
                        var h, u, c, p = o.labelRenderer,
                            f = o.context;
                        if (t.hovered ? (u = d.Helpers.toleranceMax(s, 1, .9), c = d.Helpers.toleranceMin(a, r, .9)) : (u = s, c = a), t.currentItems)
                            for (var g = 0; g < t.currentItems.length; g++) {
                                var m = t.currentItems[g];
                                if (l) {
                                    if (m.style.zIndex >= 0) break
                                } else if (m.style.zIndex < 0) continue;
                                var v = m.style.x || 0,
                                    y = m.style.y || 0,
                                    S = m.style.px || 0,
                                    b = m.style.py || 0,
                                    C = e + n * S + v,
                                    x = i + r * b + y;
                                h = m.style.scaleWithSize ? r / (m.style.hoverEffect ? c : a) : m.style.scaleWithZoom ? m.style.hoverEffect ? u : s : 1, p.measure(f, m), m.hheight > 1.5 && p.paint(f, C, x, h, m)
                            }
                    }, e.prototype.getNodesSceneZoom = function () {
                        return this.scaleNodesWithZoom ? 1 : 1 / this.scene.zoom
                    }, e.prototype.getGeometry = function () {
                        var t = this.scene.toDisplayTransform(),
                            e = t.xm,
                            i = t.xa,
                            n = t.ym,
                            r = t.ya,
                            s = this.bounds.x0,
                            a = this.bounds.x1,
                            o = this.bounds.y0,
                            l = this.bounds.y1,
                            h = (s - i) / e,
                            u = (a - i) / e,
                            c = (o - r) / n,
                            d = (l - r) / n,
                            p = this.scaleNodesWithZoom ? this.scene.zoom : 1,
                            f = this.scaleLinksWithZoom ? this.scene.zoom : 1;
                        return {
                            txm: e,
                            txa: i,
                            tym: n,
                            tya: r,
                            zoom: p,
                            linkZoom: f,
                            x0s: s,
                            x1s: a,
                            y0s: o,
                            y1s: l,
                            x0w: h,
                            y0w: c,
                            x1w: u,
                            y1w: d
                        }
                    }, e.prototype._makeHoveredLast = function (t, e) {
                        var i = t.length;
                        if (i < 2 || !e || e === t[i - 1]) return i - 1;
                        for (var n = 0; n < t.length; n++) {
                            var r = t[n];
                            if (r === e) {
                                var s = t[i - 1];
                                return t[i - 1] = e, t[n] = s, n
                            }
                        }
                        return i - 1
                    }, e.prototype._restoreHovered = function (t, e) {
                        var i = t.length;
                        if (e !== i - 1) {
                            var n = t[e];
                            t[e] = t[i - 1], t[i - 1] = n
                        }
                    }, e
                }(d.Layer);
                t.ItemsLayer = c;
                var p = function () {
                    function t() {
                        this.nameLegend = null, this.showInLegend = !0, this.legendGroupId = null
                    }
                    return t
                }();
                t.SettingsItemClass = p;
                var f = function (t) {
                    function e() {
                        return t.apply(this, arguments) || this
                    }
                    return n(e, t), e
                }(p);
                t.SettingsNodeClass = f;
                var g = function (t) {
                    function e() {
                        return t.apply(this, arguments) || this
                    }
                    return n(e, t), e
                }(p);
                t.SettingsLinkClass = g;
                var m = function () {
                    function t() {
                        this.allObjectsStyleFunction = null, this.linkStyleFunction = null, this.nodeStyleFunction = null, this.nodeRules = {}, this.linkRules = {}, this.nodeClasses = [], this.linkClasses = [], this.node = {
                            fillColor: "#c7dae0",
                            lineColor: null,
                            lineWidth: null,
                            radius: 30,
                            aspectRatio: 1,
                            shadowColor: null,
                            lineDash: null
                        }, this.nodeAnchor = {
                            lineColor: "blue",
                            lineWidth: 1
                        }, this.link = {
                            fillColor: "#333",
                            shadowColor: null,
                            fromDecoration: null,
                            toDecoration: null,
                            label: null,
                            radius: 1,
                            length: 1,
                            strength: 1,
                            lineDash: null,
                            toPieValue: 0,
                            toPieColor: null
                        }, this.item = {
                            align: "center",
                            aspectRatio: 4,
                            borderRadius: 1e3,
                            textStyle: {
                                fillColor: "black",
                                font: "12px Arial"
                            },
                            backgroundStyle: {
                                fillColor: "rgba(255,255,255,0.7)"
                            },
                            hoverEffect: !0,
                            zIndex: 0
                        }, this.linkLabel = {
                            padding: .6,
                            margin: 0,
                            align: "center",
                            aspectRatio: 4,
                            borderRadius: 1e3,
                            lineSpacing: .2,
                            textStyle: {
                                fillColor: "black",
                                font: "12px Arial"
                            },
                            backgroundStyle: {
                                fillColor: "#FFF",
                                lineColor: "gray"
                            },
                            scaleWithZoom: !0,
                            scaleWithSize: !1,
                            rotateWithLink: !1
                        }, this.nodeLabel = {
                            padding: 0,
                            margin: 0,
                            align: "center",
                            aspectRatio: 4,
                            borderRadius: 1e3,
                            lineSpacing: .2,
                            textStyle: {
                                fillColor: "black",
                                font: "12px Arial"
                            },
                            backgroundStyle: {
                                fillColor: "rgba(255,255,255,0.7)"
                            },
                            scaleWithZoom: !1,
                            scaleWithSize: !0
                        }, this.nodeLocked = {}, this.nodeExpanded = {}, this.nodeFocused = {
                            fillColor: "#09c"
                        }, this.nodeNotLoaded = {
                            fillColor: "#fff"
                        }, this.nodeHovered = {
                            shadowOffsetX: 0,
                            shadowOffsetY: 2,
                            shadowBlur: 6,
                            shadowColor: "rgba(0,0,0,.6)"
                        }, this.linkHovered = {
                            shadowOffsetX: 0,
                            shadowOffsetY: 0,
                            shadowBlur: 2,
                            shadowColor: "blue"
                        }, this.nodeSelected = {}, this.linkSelected = {}, this.selection = {
                            enabled: !0,
                            fillColor: null,
                            lineColor: "rgba(0,0,0,0)",
                            lineWidth: 1,
                            sizeConstant: .5,
                            sizeProportional: 0,
                            shadowBlur: 8,
                            shadowOffsetX: 1,
                            shadowOffsetY: 3,
                            shadowColor: "rgba(0,0,0,0.8)"
                        }, this.removedColor = "#EEE", this.nodeBackground = {}, this.nodeDetailMinZoom = .2, this.nodeDetailMinSize = 5, this.linkDetailMinZoom = .5, this.linkDetailMinSize = 12, this.linkDecorationScale = 4, this.linkDecorationMinSize = 4, this.nodeLabelScaleBase = 30, this.linkLabelScaleBase = 1, this.scaleObjectsWithZoom = !0, this.scaleLinksWithZoom = null
                    }
                    return t
                }();
                t.SettingsItemsLayerStyle = m;
                var v = function () {
                    function t(t, e) {
                        this.layer = e, this.styleSettings = t, this.nodeClasses = d.Helpers.arrayToMap(this.styleSettings.nodeClasses, "className"), this.linkClasses = d.Helpers.arrayToMap(this.styleSettings.linkClasses, "className"), this.nodeRules = this.sortRules(this.styleSettings.nodeRules), this.styleSettings.nodeStyleFunction && this.nodeRules.unshift(this.styleSettings.nodeStyleFunction), this.linkRules = this.sortRules(this.styleSettings.linkRules), this.styleSettings.linkStyleFunction && this.linkRules.unshift(this.styleSettings.linkStyleFunction)
                    }
                    return t.getClasses = function (t) {
                        return t ? t.trim().split(/\s+/g) : []
                    }, t.prototype.updateLayer = function (t, e) {
                        void 0 === e && (e = !1), null == e && (e = !1), this.isIncremental = e;
                        var i = this.styleSettings,
                            n = t.changes.style || t.changes.zoom && !(!this.nodeRules.length && !this.linkRules.length);
                        if (n) {
                            this.isIncremental = !1;
                            for (var r = 0, s = this.layer.nodes(); r < s.length; r++) this.layer.touchNode(s[r]);
                            for (var a = 0, o = this.layer.links(); a < o.length; a++) this.layer.touchLink(o[a])
                        }
                        var l = this.layer.modifiedNodes;
                        for (var h in l) {
                            var u = l[h];
                            if (this.updateNode(u), e)
                                for (var a = 0; a < u.links.length; a++) this.layer.touchLink(u.links[a])
                        }
                        var c = this.layer.modifiedLinks;
                        for (var h in c) {
                            var d = c[h];
                            this.updateLink(d)
                        }
                        if (i.allObjectsStyleFunction && (t.changes.zoom || this.layer.hasStyleChanges())) {
                            var p = this.layer.nodes(),
                                f = this.layer.links(),
                                g = i.allObjectsStyleFunction(p, f),
                                m = f,
                                v = p;
                            g && (m = g.modifiedLinks, v = g.modifiedNodes);
                            for (var y = 0; y < v.length; y += 1) this.layer.touchNode(v[y]);
                            for (var y = 0; y < m.length; y += 1) this.layer.touchLink(m[y])
                        }
                        if (this.nodeRules.length > 0) {
                            l = this.layer.modifiedNodes;
                            for (var h in l) {
                                var u = l[h];
                                this.applyStyleRules(u, this.nodeRules)
                            }
                        }
                        if (this.linkRules.length > 0) {
                            c = this.layer.modifiedLinks;
                            for (var h in c) {
                                var d = c[h];
                                this.applyStyleRules(d, this.linkRules)
                            }
                        }
                    }, t.prototype.postprocessLayer = function (t) {
                        var e = this.layer.modifiedNodes;
                        for (var i in e) {
                            var n = e[i];
                            this.postprocessNode(n)
                        }
                        var r = this.layer.modifiedLinks;
                        for (var i in r) {
                            var s = r[i];
                            this.postprocessLink(s)
                        }
                    }, t.prototype.postprocessItems = function (t) {
                        for (var e = t.currentItems, i = t instanceof h ? d.SettingsMapping.ItemsChartSettingsNodeItem : d.SettingsMapping.ItemsChartSettingsLinkItem, n = this.styleSettings.item, r = 0; r < t.items.length; r++) {
                            var s = t.items[r],
                                a = new d.Label(n);
                            d.SettingsHelper.updateRecursive(a.style, s, i, {}, "items[" + r + "]"), e.push(a)
                        }
                    }, t.prototype.sortRules = function (t) {
                        var e = [];
                        for (var i in t) e.push(i);
                        e.sort();
                        for (var n = [], r = 0; r < e.length; r++) {
                            var i = e[r];
                            n.push(t[i])
                        }
                        return n
                    }, t.prototype.updateNode = function (t) {
                        var e = this.styleSettings,
                            i = t.hovered;
                        if (t.radius || (t.radius = 10), t.label = null, d.Helpers.extendStyleTo(e.node, t), t._labelStyle = d.Helpers.realClone(e.nodeLabel), t._anchorStyle = d.Helpers.realClone(e.nodeAnchor), t.userLock && d.Helpers.extendStyleTo(e.nodeLocked, t), t.expanded && d.Helpers.extendStyleTo(e.nodeExpanded, t), t.focused && d.Helpers.extendStyleTo(e.nodeFocused, t), t.background && d.Helpers.extendStyleTo(e.nodeBackground, t), t.data.loaded || d.Helpers.extendStyleTo(e.nodeNotLoaded, t), t.data && (t.data.error && (t.label = t.data.error, t.fillColor = "red"), t.data.style && d.Helpers.extendStyleTo(t.data.style, t), t.data.className))
                            for (var n = this.getClassSequence(t.data.className, this.nodeClasses), r = 0; r < n.length; r++) {
                                var s = n[r];
                                d.Helpers.extendStyleTo(this.styleSettings.nodeClasses[s].style, t)
                            }
                        t.removed && (t.fillColor = e.removedColor), t.selected && d.Helpers.extendStyleTo(e.nodeSelected, t), i && d.Helpers.extendStyleTo(e.nodeHovered, t)
                    }, t.prototype.updateLink = function (t) {
                        var e = this.styleSettings;
                        t.label = null, t._labelStyle = d.Helpers.realClone(e.linkLabel), t.radius = 1, d.Helpers.extendStyleTo(e.link, t);
                        var i = t.hovered || t.from.hovered || t.to.hovered;
                        if (t.data.style && d.Helpers.extendStyleTo(t.data.style, t), t.data.className)
                            for (var n = this.getClassSequence(t.data.className, this.linkClasses), r = 0; r < n.length; r++) {
                                var s = n[r];
                                d.Helpers.extendStyleTo(e.linkClasses[s].style, t)
                            }
                        t.selected && d.Helpers.extendStyleTo(e.linkSelected, t), i && (d.Helpers.extendStyleTo(e.linkHovered, t), t.from.hovered && (t.toPieColor = t.fillColor)), t.removed && (t.fillColor = e.removedColor)
                    }, t.prototype.applyStyleRules = function (t, e) {
                        for (var i = 0; i < e.length; i++) {
                            var n = e[i];
                            n(t)
                        }
                    }, t.prototype.getClassSequence = function (e, i) {
                        for (var n = t.getClasses(e), r = [], s = 0; s < n.length; s++) {
                            var a = n[s],
                                o = i[a];
                            o ? r.push(o.index) : d.Helpers.error("Unable to apply item style: class `" + a + "` undefined")
                        }
                        return r.sort(function (t, e) {
                            return t - e
                        })
                    }, t
                }();
                t.ItemsStyle = v;
                var y = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.data = [], e.info = {
                            enabled: !1,
                            nodeContentsFunction: null,
                            linkContentsFunction: null
                        }, e.interaction = new b, e.nodeMenu = new B, e.linkMenu = new z, e.advanced = new w, e.style = {}, e
                    }
                    return n(e, t), e.prototype.apply = function (e) {
                        return this.applyCompatibility(e, [{
                            from: "style.makeImagesCircular",
                            to: "style.node.imageCropping"
                        }, {
                            from: "style.nodeDecorationMinSize",
                            alternative: "style.nodeDetailMinSize"
                        }, {
                            from: "style.nodeLabelMinSize",
                            to: "style.nodeDetailMinSize"
                        }, {
                            from: "style.nodeRules",
                            alternative: "style.nodeStyleFunction",
                            alternativeAsWarning: !0
                        }, {
                            from: "style.linkRules",
                            alternative: "style.linkStyleFunction",
                            alternativeAsWarning: !0
                        }]), t.prototype.apply.call(this, e)
                    }, e
                }(d.Settings);
                t.Settings = y;
                var S = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.cacheSize = 1e4, e.random = null, e.randomGridLinkProbability = .6, e.randomNodes = 0, e.randomLinks = 0, e.randomTreeDensity = 3, e.requestMaxUnits = 2, e
                    }
                    return n(e, t), e
                }(d.SettingsData);
                t.SettingsData = S;
                var b = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.nodesMovable = !0, e.zooming = new x, e.panning = {
                            enabled: !0
                        }, e.selection = new C, e
                    }
                    return n(e, t), e
                }(d.SettingsInteraction);
                t.SettingsInteraction = b;
                var C = function () {
                    function t() {
                        this.enabled = !0, this.nodesSelectable = !0, this.linksSelectable = !0, this.lockNodesOnMove = !0, this.allowMoveNodesOffscreen = !0, this.tolerance = 10
                    }
                    return t
                }();
                t.SettingsInteractionSelection = C;
                var x = function () {
                    function t() {
                        this.zoomInOnDoubleClick = !0, this.autoZoomAfterClick = !1, this.doubleClickZoom = 1.5, this.sensitivity = 1, this.wheel = !0, this.fingers = !0
                    }
                    return t
                }();
                t.SettingsInteractionZooming = x;
                var w = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.perNodeLoadingIndicator = !0, e
                    }
                    return n(e, t), e
                }(d.SettingsAdvanced);
                t.SettingsAdvanced = w;
                var L = function (t) {
                    function e() {
                        return t.apply(this, arguments) || this
                    }
                    return n(e, t), e
                }(s);
                t.ImageShape = L;
                var T = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.leftOffset = 0, e
                    }
                    return n(e, t), e.prototype.postProcessLabel = function (t, e) {
                        if (this.nodesLayer.chart.assetsLoaded) {
                            var i = this.node.targetHHeight,
                                n = this.currentLabel;
                            null == n ? n = this.currentLabel = new d.Label(this.node.labelStyle, !0) : n.style = this.node.labelStyle, n.text = this.node.label.toString(), n.style.backgroundStyle = null, n.style.image = null, e.measure(t, n);
                            var r = n.hwidth,
                                s = n.hheight,
                                a = r / s * i;
                            this.node.image && (a += i), this.node.targetHWidth = Math.max(a, i), this.node.bounds.x0 = -this.node.targetHWidth, this.node.bounds.x1 = this.node.targetHWidth
                        }
                    }, e.prototype.distanceToEdge = function (t, e, i, n) {
                        return d.Geometry.distanceToBalloon(t, e, i, n)
                    }, e.prototype.paintSelection = function (t, e, i) {
                        var n = this.node.renderHheight * (1 + e) + i,
                            r = this.node.renderHwidth - this.node.renderHheight + n,
                            s = this.x,
                            a = this.y,
                            o = s + r - n;
                        t.moveTo(o, a - n), t.arc(o, a, n, -Math.PI / 2, Math.PI / 2, !1), o = s - r + n, t.lineTo(o, a + n), t.arc(o, a, n, Math.PI / 2, -Math.PI / 2, !1), t.closePath()
                    }, e.prototype.paintDetails = function (t, e) {
                        var i = this.currentLabel;
                        if (i) {
                            if (this.hWidth > 2) {
                                if (e.measure(t, i), this._computeScale(), this.image) {
                                    var n = this.image,
                                        r = this.x - this.hHeight,
                                        s = this.y - this.imSize / 2;
                                    if (this.node.imageSlicing) {
                                        var a = this.node.imageSlicing;
                                        d.Graphics.drawImageHighQuality(t, n, a[0], a[1], a[2], a[3], r, s, this.imSize, this.imSize)
                                    } else d.Graphics.drawImageHighQuality(t, n, 0, 0, n.width, n.height, r, s, this.imSize, this.imSize)
                                }
                                e.paint(t, this.x + this.leftOffset, this.y, this.scale, i), d.Graphics.clearShadow(t)
                            }
                        } else this.basicPaintImage(t)
                    }, e.prototype._computeScale = function () {
                        this.scale = this.hWidth / this.currentLabel.hheight, this.image && (this.leftOffset = this.hWidth, this.imSize = 2 * this.hWidth)
                    }, e
                }(s);
                t.TextShape = T;
                var k = function (t) {
                    function e() {
                        return t.apply(this, arguments) || this
                    }
                    return n(e, t), e.prototype.postProcessLabel = function (t, e) {
                        if (this.nodesLayer.chart.assetsLoaded) {
                            var i = this.node.labelStyle;
                            i.backgroundStyle.fillColor = "transparent";
                            var n = this.currentLabel;
                            null == n ? n = this.currentLabel = new d.Label(i, !0) : n.style = this.node.labelStyle, n.text = this.node.label.toString(), n.style.aspectRatio = 1, n.style.image = null
                        }
                    }, e.prototype.distanceToEdge = function (t, e, i, n) {
                        return s.prototype.distanceToEdge.call(this, t, e, i, n)
                    }, e.prototype._computeScale = function () {
                        var t = Math.sqrt(this.currentLabel.hwidth * this.currentLabel.hwidth + this.currentLabel.hheight * this.currentLabel.hheight);
                        if (this.image) {
                            var e = this.currentLabel.lineHeight + 2 * this.currentLabel.hwidth,
                                i = (e * e + this.currentLabel.hheight * this.currentLabel.hheight) / 2 / e;
                            i > t && (this.leftOffset = i - t, t = i)
                        }
                        this.scale = this.hWidth / t, this.image && (this.imSize = this.currentLabel.lineHeight * this.scale)
                    }, e
                }(T);
                t.RoundTextShape = k;
                var A = {
                        a0x: 0,
                        a0y: -1,
                        a1x: .556548642145067,
                        a1y: -1,
                        a2x: 1,
                        a2y: -.5534547954623581,
                        b0x: 1,
                        b0y: 0,
                        b1x: 1,
                        b1y: .808869027157099,
                        b2x: 0,
                        b2y: 1.2870402200068753,
                        apexX: 0,
                        apexY: 1.878652526641458,
                        imageRadius: .6170212765957447
                    },
                    M = [A.a0x, A.a0y, A.a1x, A.a1y, A.a2x, A.a2y, A.b0x, A.b0y, A.b1x, A.b1y, A.b2x, A.b2y, A.apexX, A.apexY],
                    I = d.Helpers.reversePolyline(d.Geometry.transformPolyline(M, -1, 0, 1, 0)),
                    P = [0, -1, .7095605708093294, -.7046444467621514, 1, 0, 1, 0, .4313896533498214, .9021657092700437, 1, 0],
                    D = d.Helpers.reversePolyline(d.Geometry.transformPolyline(P, -1, 0, 1, 0)),
                    N = function (t) {
                        function e() {
                            return t.apply(this, arguments) || this
                        }
                        return n(e, t), e.prototype.postProcess = function (e, i, n) {
                            t.prototype.postProcess.call(this, e, i, n), this.node.bounds.addBounds(0, 0, 0, this.node.targetHHeight * A.apexY), this.node.shapeAnchorX = 0, this.node.shapeAnchorY = this.node.radius * A.apexY
                        }, e.prototype.getAnchor = function () {
                            return {
                                x: 0,
                                y: this.hWidth * A.apexY
                            }
                        }, e.prototype.adaptToViewport = function (e, i, n, r, s) {
                            t.prototype.adaptToViewport.call(this, e, i, n, r, s), this.controlPoints = d.Geometry.transformPolyline(M, this.hWidth, this.x, this.hHeight, this.y), this.reverseControlPoints = d.Geometry.transformPolyline(I, this.hWidth, this.x, this.hHeight, this.y)
                        }, e.prototype.paintSelection = function (t, e, i) {
                            var n = this.hWidth * e + i,
                                r = d.Geometry.outlinePolylineByVectors(this.controlPoints, P, n),
                                s = d.Geometry.outlinePolylineByVectors(this.reverseControlPoints, D, n);
                            t.moveTo.apply(t, r.slice(0, 2)), t.bezierCurveTo.apply(t, r.slice(2, 8)), t.bezierCurveTo.apply(t, r.slice(8, 14)), t.arc(this.controlPoints[12], this.controlPoints[13], n, 0, Math.PI, !1), t.bezierCurveTo.apply(t, s.slice(2, 8)), t.bezierCurveTo.apply(t, s.slice(8, 14)), t.closePath()
                        }, e.prototype.paintBasicShape = function (t) {
                            var e = d.Graphics.beginStrokeAndFill(t, this.node);
                            e.beginPath(), e.moveTo.apply(e, this.controlPoints.slice(0, 2)), e.bezierCurveTo.apply(e, this.controlPoints.slice(2, 8)), e.bezierCurveTo.apply(e, this.controlPoints.slice(8, 14)), e.bezierCurveTo.apply(e, this.reverseControlPoints.slice(2, 8)), e.bezierCurveTo.apply(e, this.reverseControlPoints.slice(8, 14)), e.closePath(), d.Graphics.endStrokeAndFill(t, e, this.node)
                        }, e.prototype.paintDetails = function (t, e) {
                            this.image && this.basicPaintImage(t, A.imageRadius), this.paintLabel(t, e)
                        }, e.prototype.getLabelPosition = function (t, e) {
                            return {
                                x: this.x,
                                y: this.y - this.hWidth - t.hheight * e * 1.1
                            }
                        }, e.prototype.distanceToEdge = function (t, e, i, n) {
                            var r = e,
                                s = t * A.apexY,
                                a = d.Geometry.rayIntersectsSegment(0, 0, i, n, 0, s, r, 0),
                                o = d.Geometry.rayIntersectsSegment(0, 0, i, n, -r, 0, 0, s),
                                l = Math.min(a, o);
                            return l < 1 / 0 ? l : t
                        }, e
                    }(s);
                t.DropletShape = N;
                var F = function (t) {
                    function e() {
                        return t.apply(this, arguments) || this
                    }
                    return n(e, t), e.prototype.calcHalf = function (t, e) {
                        return this.node.aspectRatio > 1 ? {
                            hWidth: t,
                            hHeight: t / this.node.aspectRatio
                        } : {
                            hWidth: e * this.node.aspectRatio,
                            hHeight: e
                        }
                    }, e.prototype.render = function (t, e, i) {
                        var n = this.calcHalf(this.hWidth, this.hHeight),
                            r = n.hHeight,
                            s = n.hWidth;
                        r = r * (1 + e) + i, s = s * (1 + e) + i, t.moveTo(this.x, this.y), t.moveTo(this.x - s, this.y - r), t.lineTo(this.x + s, this.y - r), t.lineTo(this.x + s, this.y + r), t.lineTo(this.x - s, this.y + r), t.lineTo(this.x - s, this.y - r)
                    }, e.prototype.paint = function (t, e, i) {
                        this.paintBasicShape(t), i && (this.image = this.nodesLayer.getNodeImage(this.node, !1), this.paintDetails(t, e))
                    }, e.prototype.paintBasicShape = function (t) {
                        var e = d.Graphics.beginStrokeAndFill(t, this.node);
                        this.render(e, 0, 0), d.Graphics.endStrokeAndFill(t, e, this.node)
                    }, e.prototype.basicPaintImage = function (t, e) {
                        if (void 0 === e && (e = 1), this.image) {
                            var i, n, r, s, a, o, l, h;
                            if (this.node.imageSlicing) {
                                var u = this.node.imageSlicing;
                                i = u[0], n = u[1], r = u[2], s = u[3]
                            } else i = 0, n = 0, r = this.image.width, s = this.image.height;
                            var c = this.calcHalf(this.hWidth, this.hHeight),
                                p = c.hHeight,
                                f = c.hWidth;
                            switch (this.node.imageCropping) {
                                case !0:
                                    a = this.x - f, o = this.y - p, l = 2 * f, h = 2 * p;
                                    break;
                                case "crop":
                                    if (a = this.x - f, o = this.y - p, l = 2 * f, h = 2 * p, s * this.node.aspectRatio <= r) {
                                        var g = s * this.node.aspectRatio;
                                        i += (r - g) / 2, r = g
                                    } else {
                                        var m = r / this.node.aspectRatio;
                                        n += (s - m) / 2, s = m
                                    }
                                    break;
                                case "letterbox":
                                case "fit":
                                    var v = Math.min(2 * p / s, 2 * f / r);
                                    h = s * v, l = r * v, a = this.x - l / 2, o = this.y - h / 2;
                                    break;
                                default:
                                    var y = 2 * Math.max(f, p),
                                        S = Math.min(y / s, y / r);
                                    h = s * S, l = r * S, a = this.x - l / 2, o = this.y - h / 2
                            }
                            d.Graphics.drawImageHighQuality(t, this.image, i, n, r, s, a, o, l, h)
                        }
                    }, e.prototype.paintSelection = function (t, e, i) {
                        this.render(t, e, i), t.closePath()
                    }, e.prototype.distanceToEdge = function (t, e, i, n) {
                        var r = this.calcHalf(t, e);
                        return Math.min(r.hHeight / Math.abs(n), r.hWidth / Math.abs(i))
                    }, e.prototype.hitTest = function (t, e, i, n) {
                        var r = this.node,
                            s = this.calcHalf(r.renderHwidth * i, r.renderHheight * i),
                            a = Math.max(Math.abs(t - r.x) - s.hWidth, Math.abs(e - r.y) - s.hHeight);
                        return a < 0 ? 0 : Math.min(a, n)
                    }, e
                }(s);
                t.RectangleShape = F;
                var O = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.multilinkSpacing = 10, e.nodeRadiusExtent = [10, 150], e.linkRadiusExtent = [.6, 30], e.linkStrengthExtent = [.1, 1], e.linkLengthExtent = [.3, 150], e.nodeAutoScaling = null, e.linkAutoScaling = null, e.linkStrengthAutoScaling = null, e.linkLengthAutoScaling = null, e.hiddenLinks = {
                            lineColor: "rgba(100,100,100,0.3)",
                            lineWidth: 1,
                            size: 7
                        }, e.fadeTime = 600, e.selfLinkHeightFactor = 1, e.selfLinkWidthFactor = 1, e.selfLinkShape = "quadratic", e.selfLinkAngle = 60, e
                    }
                    return n(e, t), e
                }(m);
                t.SettingsNodesLayerStyle = O;
                var E = function (t) {
                    function e(e, i, n) {
                        var r = t.call(this, e, i) || this;
                        return r.g = null, r.fadeout = n, r.styleSettings = e, r
                    }
                    return n(e, t), e.prototype.updateLayer = function (e, i) {
                        void 0 === i && (i = !1), this.nodeRadiusChanged = d.Helpers.hasProperties(this.layer.newNodes) || d.Helpers.hasProperties(this.layer.deletedNodes) || this.styleSettings.allObjectsStyleFunction && this.layer.hasStyleChanges() || this.nodeRules.length > 0, this.linkRadiusChanged = d.Helpers.hasProperties(this.layer.newLinks) || d.Helpers.hasProperties(this.layer.deletedLinks) || this.styleSettings.allObjectsStyleFunction && this.layer.hasStyleChanges() || this.linkRules.length > 0, t.prototype.updateLayer.call(this, e, i)
                    }, e.prototype.postprocessLayer = function (t) {
                        this.g = t.context;
                        var e = this.layer,
                            i = this.styleSettings.removedColor;
                        this.itemRenderer = t.labelRenderer;
                        for (var n in e.modifiedLinks) {
                            var r = e.modifiedLinks[n];
                            this.fadeout && r.relevance < 1 && (r.fillColor && (r.fillColor = d.Colors.blend(i, r.fillColor, r.relevance)), r.lineColor && (r.lineColor = d.Colors.blend(i, r.lineColor, r.relevance)), r.length = .2 + (r.length - .2) * r.relevance), this.postprocessLink(r)
                        }
                        for (var s in e.modifiedNodes) {
                            var a = e.modifiedNodes[s];
                            this.fadeout && a.relevance < 1 && (a.fillColor && (a.fillColor = d.Colors.blend(i, a.fillColor, a.relevance)), a.lineColor && (a.lineColor = d.Colors.blend(i, a.lineColor, a.relevance)))
                        }
                        var o = this.layer.nodes();
                        if (this.nodeRadiusChanged || this.fadeout && t.changes.navigation) {
                            this.computeNodeSize(o, this.styleSettings.nodeAutoScaling, this.styleSettings.nodeRadiusExtent);
                            for (var l = 0; l < o.length; l++) {
                                var h = o[l];
                                this.postprocessNode(h)
                            }
                        } else
                            for (var u in e.modifiedNodes) {
                                var c = e.modifiedNodes[u];
                                this.postprocessNode(c)
                            }
                        if (this.linkRadiusChanged || t.changes.navigation) {
                            var p = e.links();
                            this.computeRadii(p, this.styleSettings.linkAutoScaling, this.styleSettings.linkRadiusExtent), this.computeStrengths(p, this.styleSettings.linkStrengthAutoScaling, this.styleSettings.linkStrengthExtent), this.computeLengths(p, this.styleSettings.linkLengthAutoScaling, this.styleSettings.linkLengthExtent), d.Helpers.sort(p, function (t, e) {
                                return t.targetRadius === e.targetRadius ? 0 : t.targetRadius > e.targetRadius ? 1 : -1
                            })
                        }
                        d.Helpers.sort(o, function (t, e) {
                            return t.zindex - e.zindex
                        })
                    }, e.prototype.updateLink = function (e) {
                        var i = e.radius;
                        t.prototype.updateLink.call(this, e), i !== e.radius && (this.linkRadiusChanged = !0)
                    }, e.prototype.updateNode = function (e) {
                        var i = e.radius;
                        t.prototype.updateNode.call(this, e), i !== e.radius && (this.nodeRadiusChanged = !0), null == e.label && e.data && (e.label = e.data.id)
                    }, e.prototype.computeNodeSize = function (t, e, i) {
                        var n = i[0],
                            r = i[1];
                        if ("linear" === e || "logarithmic" === e || "square" === e) {
                            for (var s = 1 / 0, a = -(1 / 0), o = 0; o < t.length; o++) {
                                var l = t[o];
                                if (!l.removed && !l.invisible) {
                                    var h = l.radius;
                                    d.Helpers.isNumber(h) ? (s = Math.min(s, h), a = Math.max(a, h)) : l.targetHHeight = n
                                }
                            }
                            if (s >= a)
                                for (var o = 0; o < t.length; o++) {
                                    var l = t[o];
                                    l.removed || (l.targetHHeight = r)
                                } else if ("linear" === e)
                                    for (var u = r / a, o = 0; o < t.length; o++) {
                                        var l = t[o];
                                        if (!l.removed) {
                                            var h = l.radius;
                                            d.Helpers.isNumber(h) && (l.targetHHeight = Math.max(n, h * u))
                                        }
                                    } else if ("square" === e)
                                        for (var u = r / Math.sqrt(a), o = 0; o < t.length; o++) {
                                            var l = t[o];
                                            if (!l.removed) {
                                                var h = l.radius;
                                                d.Helpers.isNumber(h) && (l.targetHHeight = Math.max(n, Math.sqrt(h) * u))
                                            }
                                        } else {
                                            s = Math.max(1e-4, s), a = Math.max(s + 1e-4, a);
                                            for (var u = r / Math.log(a), o = 0; o < t.length; o++) {
                                                var l = t[o];
                                                !l.removed && d.Helpers.isNumber(l.radius) && (l.targetHHeight = Math.max(n, Math.log(Math.max(1e-4, l.radius)) * u))
                                            }
                                        }
                        } else
                            for (var o = 0; o < t.length; o++) {
                                var l = t[o];
                                l.removed || (d.Helpers.isNumber(l.radius) ? l.targetHHeight = Math.min(Math.max(1e-6, l.radius), 1e30) : l.targetHHeight = n)
                            }
                        if (this.fadeout)
                            for (var o = 0; o < t.length; o++) {
                                var l = t[o];
                                l.relevance < 1 && (l.targetHHeight = l.targetHHeight * l.relevance)
                            }
                    }, e.prototype.computeRadii = function (t, e, i) {
                        var n = i[0],
                            r = i[1];
                        if ("linear" === e || "logarithmic" === e || "square" === e) {
                            for (var s = 1 / 0, a = -(1 / 0), o = 0; o < t.length; o++) {
                                var l = t[o];
                                if (!l.removed) {
                                    var h = l.radius;
                                    d.Helpers.isNumber(h) ? (s = Math.min(s, h), a = Math.max(a, h)) : l.targetRadius = n
                                }
                            }
                            if (s >= a)
                                for (var o = 0; o < t.length; o++) {
                                    var l = t[o];
                                    l.removed || (l.targetRadius = n)
                                } else if ("linear" === e)
                                    for (var u = r / a, o = 0; o < t.length; o++) {
                                        var l = t[o];
                                        if (!l.removed) {
                                            var h = l.radius;
                                            d.Helpers.isNumber(h) && (l.targetRadius = Math.max(n, h * u))
                                        }
                                    } else if ("square" === e)
                                        for (var u = r / Math.sqrt(a), o = 0; o < t.length; o++) {
                                            var l = t[o];
                                            if (!l.removed) {
                                                var h = l.radius;
                                                d.Helpers.isNumber(h) && (l.targetRadius = Math.max(n, Math.sqrt(h) * u))
                                            }
                                        } else {
                                            s = Math.max(1e-4, s), a = Math.max(s + 1e-4, a);
                                            for (var u = r / Math.log(a), o = 0; o < t.length; o++) {
                                                var l = t[o];
                                                !l.removed && d.Helpers.isNumber(l.radius) && (l.targetRadius = Math.max(n, Math.log(Math.max(1e-4, l.radius)) * u))
                                            }
                                        }
                        } else
                            for (var o = 0; o < t.length; o++) {
                                var l = t[o];
                                l.removed || (d.Helpers.isNumber(l.radius) ? l.targetRadius = Math.min(Math.max(1e-6, l.radius), 1e30) : l.targetRadius = n)
                            }
                        if (this.fadeout)
                            for (var o = 0; o < t.length; o++) {
                                var l = t[o];
                                l.relevance < 1 && (l.targetRadius = l.targetRadius * l.relevance)
                            }
                    }, e.prototype.computeStrengths = function (t, e, i) {
                        var n = i[0],
                            r = i[1];
                        if ("linear" === e || "logarithmic" === e || "square" === e) {
                            for (var s = 1 / 0, a = -(1 / 0), o = 0; o < t.length; o++) {
                                var l = t[o];
                                l.removed || (s = Math.min(s, l.strength), a = Math.max(a, l.strength))
                            }
                            if (s >= a)
                                for (var o = 0; o < t.length; o++) {
                                    var l = t[o];
                                    l.removed || (l.targetStrength = n)
                                } else if ("linear" === e)
                                    for (var h = r / a, o = 0; o < t.length; o++) {
                                        var l = t[o];
                                        l.removed || (l.targetStrength = Math.min(n, l.strength * h))
                                    } else if ("square" === e)
                                        for (var h = r / Math.sqrt(a), o = 0; o < t.length; o++) {
                                            var l = t[o];
                                            if (!l.removed) {
                                                var u = l.strength;
                                                d.Helpers.isNumber(u) && (l.targetStrength = Math.max(n, Math.sqrt(u) * h))
                                            }
                                        } else {
                                            s = Math.max(1e-4, s), a = Math.max(s + 1e-4, a);
                                            for (var h = r / Math.log(a), o = 0; o < t.length; o++) {
                                                var l = t[o];
                                                l.removed || (l.targetStrength = Math.max(n, Math.log(Math.max(1e-4, l.strength)) * h))
                                            }
                                        }
                        } else
                            for (var o = 0; o < t.length; o++) {
                                var l = t[o];
                                l.removed || (l.targetStrength = Math.min(Math.max(n, l.strength), r))
                            }
                    }, e.prototype.computeLengths = function (t, e, i) {
                        var n = i[0],
                            r = i[1];
                        if ("linear" === e || "logarithmic" === e || "square" === e) {
                            for (var s = 1 / 0, a = -(1 / 0), o = 0; o < t.length; o++) {
                                var l = t[o];
                                l.removed || (s = Math.min(s, l.length), a = Math.max(a, l.length))
                            }
                            if (s >= a)
                                for (var o = 0; o < t.length; o++) {
                                    var l = t[o];
                                    l.removed || (l.targetLength = n)
                                } else if ("linear" === e)
                                    for (var h = (r - n) / (a - s), u = r - a * h, o = 0; o < t.length; o++) {
                                        var l = t[o];
                                        l.removed || (l.targetLength = l.length * h + u)
                                    } else if ("square" === e)
                                        for (var h = r / Math.sqrt(a), o = 0; o < t.length; o++) {
                                            var l = t[o];
                                            if (!l.removed) {
                                                var c = l.length;
                                                d.Helpers.isNumber(c) && (l.targetLength = Math.max(n, Math.sqrt(c) * h))
                                            }
                                        } else {
                                            s = Math.max(1e-4, s), a = Math.max(s + 1e-4, a);
                                            for (var h = (r - n) / Math.log(a / s), u = r - h * Math.log(a), o = 0; o < t.length; o++) {
                                                var l = t[o];
                                                l.removed || (l.targetLength = Math.log(Math.max(1e-4, l.length)) * h + u)
                                            }
                                        }
                        } else
                            for (var o = 0; o < t.length; o++) {
                                var l = t[o];
                                l.removed || (l.targetLength = Math.min(Math.max(n, l.length), r))
                            }
                    }, e.prototype.postprocessNode = function (t) {
                        var e;
                        switch (t.display) {
                            case "customShape":
                                e = a;
                                break;
                            case "roundtext":
                                e = k;
                                break;
                            case "text":
                                e = T;
                                break;
                            case "droplet":
                                e = N;
                                break;
                            case "rectangle":
                                e = F;
                                break;
                            default:
                                e = L
                        }
                        t.shape && t.shape.constructor === e || (t.shape && (t.shape.node = null), t.shape = new e(t, this.layer));
                        var i = t.outerBounds = d.Rect.createEmpty();
                        t.shape.postProcess(this.styleSettings, this.g, this.itemRenderer), i.addRect(t.bounds), t.currentItems = [], this.postprocessItems(t);
                        for (var n = t.targetHWidth, r = t.targetHHeight, s = 0; s < t.currentItems.length; s++) {
                            var o = t.currentItems[s];
                            this.measureCustomItem(n, r, t.shape.sizeScale, o, i)
                        }
                    }, e.prototype.measureCustomItem = function (t, e, i, n, r) {
                        this.itemRenderer.measure(this.g, n);
                        var s = 1;
                        n.style.scaleWithSize && (s = i);
                        var a = n.style.x || 0,
                            o = n.style.y || 0,
                            l = n.style.px || 0,
                            h = n.style.py || 0,
                            u = t * l + a,
                            c = e * h + o;
                        r.addBounds(u - n.hwidth * s, c - n.hheight * s, u + n.hwidth * s, c + n.hheight * s)
                    }, e.prototype.postprocessLink = function (t) {
                        var e = [];
                        if (t.label) {
                            var i = void 0;
                            t.currentItems && t.currentItems.length ? (i = t.currentItems[0], i.style = t.labelStyle) : i = new d.Label(t.labelStyle), i.text = t.label.toString(), i.style.px = 0, i.style.py = 0, e.push(i)
                        }
                        t.currentItems = e, this.postprocessItems(t)
                    }, e
                }(v);
                t.NodesStyle = E;
                var R = function () {
                    function t() {
                        this.className = null, this.text = null, this.title = null, this.onInit = null, this.onRefresh = null, this.onClick = null
                    }
                    return t
                }();
                t.SettingsMenuButton = R;
                var H = function () {
                    function t() {
                        this.enabled = !0, this.showData = !1, this.contentsFunction = null, this.buttons = []
                    }
                    return t
                }();
                t.SettingsMenu = H;
                var B = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.contentsFunction = null, e.buttons = [], e
                    }
                    return n(e, t), e
                }(H);
                t.SettingsNodeMenu = B;
                var z = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.contentsFunction = null, e
                    }
                    return n(e, t), e
                }(H);
                t.SettingsLinkMenu = z;
                var U = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.animationOrder = 600, i.paintOrder = 40, i.updateOrder = 2e3, i.node = null, i.link = null, i.contents = null, i.x = 0, i.y = 0, i.chart = e, i.container = e.shell.menuContainer, i.scene = e.scene, i.events = e.events, i.buttons = [], i.popup = d.Helpers.createDom("div", "DVSL-Menu", null, i.container), i.closeButton = d.Helpers.createDom("a", "DVSL-Menu-close", null, i.popup), i.popupValue = d.Helpers.createDom("div", "DVSL-Menu-title", null, i.popup), i.detailsDiv = d.Helpers.createDom("div", "DVSL-Menu-details", null, i.popup), i.popupActions = d.Helpers.createDom("nav", null, null, i.popup), i.buildDetailsPanel(i.detailsDiv), i.buildCloseButton(i.closeButton), i.popup.style.position = "absolute", i.popup.style.display = "none", i
                    }
                    return n(e, t), e.prototype.remove = function () {
                        this.popup.parentNode && this.popup.parentNode.removeChild(this.popup)
                    }, e.prototype.doAnimations = function (t) {
                        this.node && (this.node.removed || this.link && this.link.removed ? this.hideMenu() : this.node.layer.modifiedNodes.hasOwnProperty(this.node.id) && this.updateMenu())
                    }, e.prototype.previewPointerDown = function (t) {
                        this.hideMenu()
                    }, e.prototype.previewWheel = function (t) {
                        this.hideMenu()
                    }, e.prototype.toggleNodeMenu = function (t) {
                        this.node === t ? this.hideMenu() : this.showNodeMenu(t)
                    }, e.prototype.toggleLinkMenu = function (t, e, i) {
                        this.link === i ? this.hideMenu() : this.showLinkMenu(t, e, i)
                    }, e.prototype.showNodeMenu = function (t) {
                        this.scene.settings.nodeMenu.enabled && (this.node === t ? this.updateMenu() : (this.hideMenu(), this.showPopup(t, null)))
                    }, e.prototype.showLinkMenu = function (t, e, i) {
                        this.scene.settings.linkMenu.enabled && (this.x = t, this.y = e, this.link === i ? this.updateMenu() : (this.hideMenu(), this.showPopup(null, i)))
                    }, e.prototype.showPopup = function (t, e) {
                        this.node = t, this.link = e, this.node && (this.node.locks += 1), this.buildButtons(), this.contents = null, this.popupValue.innerHTML = "", this.popup.style.display = "block", this.updateMenu(), this.updateXY()
                    }, e.prototype.hideMenu = function () {
                        (this.node || this.link) && (this.node && (this.node.locks -= 1), this.node = null, this.link = null, this.popup.style.display = "none")
                    }, e.prototype.updateMenu = function () {
                        var t = this;
                        this.closeButton.title = this.scene.settings.localization.closeButton;
                        var e, i;
                        this.node ? (e = this.scene.settings.nodeMenu, i = this.node) : (e = this.scene.settings.linkMenu, i = this.link);
                        var n = null,
                            r = this.node,
                            s = this.link,
                            a = function (e) {
                                if (t.node === r && t.link === s && e !== t.contents) {
                                    if (null == e) t.popupValue.innerHTML = "";
                                    else if (d.Helpers.isString(e)) t.popupValue.innerHTML = e;
                                    else {
                                        if (!d.Helpers.isDomObject(e)) return void d.Helpers.error("Invalid value for menu text. Must be either a string or a DOM element.");
                                        t.popupValue.innerHTML = "", t.popupValue.appendChild(e)
                                    }
                                    t.contents = e
                                }
                            };
                        if (e.contentsFunction) {
                            var o = e.contentsFunction.call(this.chart.api, i.data, i, a);
                            n = d.Helpers.isString(o) || d.Helpers.isDomObject(o) ? o : null == this.contents ? "<small>" + this.scene.settings.localization.loadingLabel + "</small>" : this.contents
                        } else n = i.label;
                        a(n), this.updateButtons(), e.showData ? (this.details.innerHTML = JSON.stringify(i.data, null, "  "), this.detailsDiv.style.display = "block") : (this.detailsDiv.style.display = "none", null == n && 0 === this.buttons.length && this.hideMenu())
                    }, e.prototype.updateXY = function () {
                        var t, e, i, n, r, s, a = 12;
                        if (this.node) {
                            var o = this.scene.toDisplay(this.node.x, this.node.y);
                            r = o.x, s = o.y, t = s - this.node.renderHheight - a, n = s + this.node.renderHheight + a, e = r - this.node.renderHheight - a, i = r + this.node.renderHheight + a
                        } else t = n = s = this.y, e = this.x - a, i = this.x + a;
                        var l = this.chart.getRootChart().scene,
                            h = l.x0,
                            u = l.x0 + l.width,
                            c = this.popup.offsetWidth,
                            d = this.popup.offsetHeight;
                        s = Math.max(Math.min(s, l.y0 + l.height - d), l.y0), i + c <= u ? r = i : e - c >= h ? r = e - c : (r = Math.max(e - c / 2, h), s = n), this.popup.style.left = r + "px", this.popup.style.top = s + "px"
                    }, e.prototype.buildDefaultButton = function (t, e) {
                        this.chart.error("The menu does not support any named buttons.")
                    }, e.prototype.buildButton = function (t, e, i, n, r, s, a) {
                        var o = this,
                            l = d.Helpers.createDom("a", e, i, this.popupActions);
                        l.title = n, l.onclick = function (e) {
                            s && s.call(o.chart.api, t, l), o.hideMenu(), e.preventDefault()
                        }, l.href = "#", r && r.call(this.chart.api, t, l), this.buttons.push({
                            e: l,
                            t: t,
                            a: a
                        })
                    }, e.prototype.buildButtons = function () {
                        this.popupActions.innerHTML = "", this.buttons = [];
                        var t, e;
                        this.node ? (t = this.scene.settings.nodeMenu, e = this.node) : (t = this.scene.settings.linkMenu, e = this.link);
                        var i = t.buttons;
                        if (i)
                            for (var n = 0; n < i.length; n++) {
                                var r = i[n];
                                d.Helpers.isString(r) ? this.buildDefaultButton(e, r) : this.buildButton(e, r.className, r.text, null == r.title ? r.text : r.title, r.onInit, r.onClick, r.onRefresh)
                            }
                    }, e.prototype.updateButtons = function () {
                        for (var t = 0; t < this.buttons.length; t++) {
                            var e = this.buttons[t];
                            e.a && e.a.call(this.chart.api, e.t, e.e)
                        }
                    }, e.prototype.buildCloseButton = function (t) {
                        var e = this;
                        t.onclick = function (t) {
                            e.hideMenu(), t.preventDefault()
                        }
                    }, e.prototype.buildDetailsPanel = function (t) {
                        var e = d.Helpers.createDom("small", null, "Technical data", t),
                            i = this.details = d.Helpers.createDom("pre", null, "", t);
                        i.style.display = "none", e.onclick = function () {
                            "none" === i.style.display ? i.style.display = "block" : i.style.display = "none"
                        }
                    }, e
                }(d.ChartElement);
                t.Menu = U;
                var G = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.animationOrder = 800, i.paintOrder = 45, i.updateOrder = 2e3, i.chart = e, i.scene = e.scene, i.options = i.scene.settings, i.item = null, i.x = null, i.y = null, i.popup = new d.InfoPopup(e), i
                    }
                    return n(e, t), e.prototype.previewPointerMove = function (t) {
                        this.onMove(t.x, t.y)
                    }, e.prototype.doAnimations = function (t) {
                        null !== this.x && null !== this.y && this.onMove(this.x, this.y)
                    }, e.prototype.previewPointerDown = function (t) {
                        this.x = this.y = null, this.setCurrentObject(0, 0, null)
                    }, e.prototype.previewPointerDrag = function (t) {
                        this.x = this.y = null, this.setCurrentObject(0, 0, null)
                    }, e.prototype.onPointerOut = function (t) {
                        this.x = this.y = null, this.setCurrentObject(0, 0, null)
                    }, e.prototype.onMove = function (t, e) {
                        if (this.y = e, this.x = t, this.options.info.enabled) {
                            var i = this.scene.hoverNode ? this.scene.hoverNode : this.scene.hoverLink;
                            this.setCurrentObject(t, e, i)
                        }
                    }, e.prototype.setCurrentObject = function (t, e, i) {
                        if (i) {
                            if (i !== this.item) {
                                var n = this.buildContents(i);
                                this.popup.show(t, t, e, n)
                            } else this.popup.updateXY(t, t, e);
                            this.item = i
                        } else this.item = null, this.popup.hide()
                    }, e.prototype.buildContents = function (t) {
                        var e = this,
                            i = null;
                        if (t instanceof h ? i = this.options.info.nodeContentsFunction : t instanceof u && (i = this.options.info.linkContentsFunction), i) {
                            var n = function (i) {
                                t === e.item && e.popup.updateContents(i)
                            };
                            return i.call(this.chart.api, t.data, t, n)
                        }
                        return t.label
                    }, e.prototype.remove = function () {
                        this.popup.remove()
                    }, e
                }(d.ChartElement);
                t.InfoPopup = G;
                var j = "undefined" != typeof Float32Array,
                    W = function () {
                        function t() {
                            this._calculatedStyles = {}, this._defaultStyles = {}, this.enabled = !0, this.drawLimit = .8, this.cellSize = 3, this.intensity = 6, this.style = {}, this.defaultStyle = null, this.defaultColors = ["rgba(47,195,47,0.3)", "rgba(176,220,11,0.3)", "rgba(234,180,4,0.3)", "rgba(222,103,44,0.3)", "rgba(236,46,46,0.3)", "rgba(213,66,155,0.3)", "rgba(111,82,184,0.3)", "rgba(28,124,213,0.3)", "rgba(86,185,247,0.3)", "rgba(10,232,235,0.3)"], this.overlap = !1
                        }
                        return t
                    }();
                t.SettingsNodesLayerAuras = W;
                var V = function () {
                    function t(t, e, i) {
                        this._marginCells = 1, this._polygons = [], this._autoAuraCounter = 0, this._overlapWarning = !0, this._auraCounter = 0, this._settings = i, this._scene = t, this._events = e
                    }
                    return t.prototype.recalculateStyles = function (t) {
                        var e = this._settings,
                            i = Object.keys(e.style);
                        e._calculatedStyles = {};
                        for (var n = 0; n < i.length; n++) {
                            var r = i[n],
                                s = d.Helpers.realClone(this._settings._defaultStyles[r]);
                            e.defaultStyle && d.Helpers.extendStyleTo(e.defaultStyle, s), e.style[r] && d.Helpers.extendStyleTo(e.style[r], s), e._calculatedStyles[r] = s, s.__auraCounter = this._auraCounter++
                        }
                        i = Object.keys(t).filter(function (t) {
                            return e._calculatedStyles[t].enabled
                        }), i.sort(function (t, i) {
                            var n = e._calculatedStyles[t].zIndex - e._calculatedStyles[i].zIndex;
                            return 0 === n ? t.localeCompare(i) : n
                        }), this._auras = new Array(i.length + 1), this._aurasMap = Object.create(null), this._aurasMap[""] = 0;
                        for (var n = 0; n < i.length; n++) {
                            var a = i[n];
                            this._aurasMap[a] = n + 1, this._auras[n + 1] = e._calculatedStyles[a]
                        }
                        this._events.notifySceneChanges({
                            auras: !0
                        })
                    }, t.prototype.recalculateGrid = function () {
                        var t = this._scene,
                            e = this._settings;
                        this._overlapWarning = e.overlap;
                        for (var i = t.width, n = t.height, r = this._marginCells, s = e.cellSize, a = this._widthCells = Math.ceil(i / s) + 2 * r, o = this._heightCells = Math.ceil(n / s) + 2 * r, l = this._cellLength = this._auras.length, h = a * o * l, u = this._cells = j ? new Float32Array(h) : new Array(h), c = this._cellEdges = j ? new Int8Array(h) : new Array(h), d = a * l, p = 0; p < h; p++) c[p] = -1;
                        if (!j)
                            for (var f = 0; f < u.length; f++) u[f] = 0;
                        var g = [-d, -d + l, +l, +d + l, +d, +d - l, -l, -d - l, -d, -d + l, +l, +d + l, +d, +d - l, -l, -d - l];
                        this._edgeFinderDeltas = j ? new Int16Array(g) : g
                    }, t.prototype.doAnimations = function (t, e) {
                        if (this._settings.enabled && t) {
                            for (var i = !1, n = {}, r = 0; r < t.length; r++) {
                                var s = t[r].aura;
                                if (s) {
                                    Array.isArray(s) ? !this._overlapWarning && s.length > 1 && (d.Helpers.warn("One or more nodes defined more than one aura. It is recommended to set `overlap: true` in the chart configuration to better handle this scenario."), this._overlapWarning = !0) : s = [s];
                                    for (var a = 0; a < s.length; a++) {
                                        var o = "" + (s[a] || "");
                                        "" !== o && (i = !0, n[o] = !0, this.ensureAura(o))
                                    }
                                }
                            }
                            for (var r in this._settings.style) d.Helpers.hasProperty(this._settings.style, r) && this.ensureAura(r);
                            var l, h = e.changes,
                                u = h.settingsChanges,
                                c = !1;
                            if (!this._auras || u && u.auras) l = !0;
                            else if (i) {
                                for (var p = Object.keys(n), f = 0, g = this._settings._calculatedStyles, r = 0; r < p.length; r++) {
                                    var m = p[r];
                                    if (null == g[m]) {
                                        l = !0;
                                        break
                                    }
                                    g[m].enabled && f++
                                }
                                l = l || this._auras.length - 1 !== f
                            }
                            if (l ? (this.recalculateStyles(n), c = !0) : h.bounds && (c = !0), !i || this._auras.length < 2) return void(this._polygons.length > 0 && (this._polygons = []));
                            c && this.recalculateGrid(), this.reset(), this.stage1(t), this.stage2(), this.stage3()
                        }
                    }, t.prototype.ensureAura = function (t) {
                        if (this._settings.style[t] || (this._settings.style[t] = {}), !this._settings._defaultStyles[t]) {
                            var e = this._settings.defaultColors;
                            e && e.length || (e = ["rgba(47,195,47,0.3)"]), this._autoAuraCounter = (this._autoAuraCounter + 1) % e.length, this._settings._defaultStyles[t] = {
                                lineWidth: 1,
                                showInLegend: !0,
                                enabled: !0,
                                zIndex: 0,
                                fillColor: e[this._autoAuraCounter]
                            }
                        }
                    }, t.prototype.reset = function () {
                        for (var t = this._cellEdges, e = 0; e < t.length; e++) t[e] = -1;
                        for (var i = this._cells, e = 0; e < i.length; e++) i[e] = 0;
                        this._polygons = new Array(this._auras.length);
                        for (var e = 0; e < this._polygons.length; e++) this._polygons[e] = []
                    }, t.prototype.stage1 = function (t) {
                        for (var e = this._scene, i = e.zoom, n = this._settings, r = n.cellSize, s = this._marginCells, a = this._widthCells, o = this._heightCells, l = this._cells, h = this._cellLength, u = this._aurasMap, c = n.intensity, d = e.centerX * e.zoom % r, p = e.centerY * e.zoom % r, f = 0; f < t.length; f++) {
                            var g = t[f],
                                m = e.toDisplay(g.x, g.y),
                                v = (m.x + d) / r + s,
                                y = (m.y + p) / r + s,
                                S = 0 | v,
                                b = 0 | y,
                                C = v - S,
                                x = y - b,
                                w = t[f].aura;
                            if (w) {
                                Array.isArray(w) || (w = [w]);
                                for (var L = 0; L < w.length; L++) {
                                    var T = "" + (w[L] || ""),
                                        k = u[T];
                                    if (void 0 !== k && this._auras[k].enabled) {
                                        var A = Math.min((g.hHeight * i + 5) / r, a, o),
                                            M = A * c + 1,
                                            I = 2 * M;
                                        if (v > -I && v < a + I && y > -I && y < o + I) {
                                            var P = A / 2,
                                                D = Math.ceil(M);
                                            M -= P;
                                            for (var N = -D; N < D; N++)
                                                if (!(v + N < s || v + N >= a - s))
                                                    for (var F = C - N, O = -D; O < D; O++)
                                                        if (!(y + O < s || y + O >= o - s)) {
                                                            var E = x - O,
                                                                R = Math.sqrt(F * F + E * E) - P;
                                                            if (R < M) {
                                                                R = R <= 0 ? 1 : 1 - R / M;
                                                                var H = k + (b + O) * a * h + (S + N) * h;
                                                                l[H] = l[H] + R - l[H] * R
                                                            }
                                                        }
                                        }
                                    }
                                }
                            }
                        }
                    }, t.prototype.stage2 = function () {
                        var t = this._cellLength;
                        if (1 !== t && !this._settings.overlap)
                            for (var e = this._cells, i = 0; i < e.length; i += t)
                                for (var n = i, r = e[i], s = 1; s < t; s++) {
                                    var a = e[i + s];
                                    a > r ? (r = a, e[n] = 0, n = i + s) : a > 0 && (e[i + s] = 0)
                                }
                    }, t.prototype.stage3FindEdge = function (t, e) {
                        var i = this._cells,
                            n = this._cellEdges,
                            r = this._settings,
                            s = r.drawLimit,
                            a = this._edgeFinderDeltas,
                            o = [e],
                            l = e,
                            h = 2,
                            u = 0,
                            c = 0,
                            p = r.overlap,
                            f = 0,
                            g = 0;
                        do {
                            for (var m = n[l], v = void 0, y = (h + 5) % 8, S = y, b = !1; S < y + 8; S++)
                                if (m !== S && (v = l + a[S], i[v] >= s)) {
                                    b = !0;
                                    break
                                }
                            if (!b) {
                                l !== e && d.Helpers.error("Edge finder stuck");
                                break
                            }
                            if (S %= 8, (h !== S || ++f > 5) && (0 === u && (u = 7 === S ? 7 : 1, c = 7 === S ? 6 : 2), (!p || h !== (S + u) % 8 && h !== (S + c) % 8) && o.push(l), f = 0), m === -1 && (n[l] = S), h = S, l = v, ++g > 1e4) {
                                d.Helpers.error("Edge finder run into a loop");
                                break
                            }
                        } while (l !== e);
                        o[o.length - 1] !== e && o.push(e), t.push(o)
                    }, t.prototype.stage3 = function () {
                        for (var t = this._cellLength, e = this._widthCells * t, i = this._cells, n = this._cellEdges, r = this._settings, s = r.drawLimit, a = e - t, o = this._polygons, l = 0, h = i.length - t, u = 0; u < h; u++) {
                            var c = i[u];
                            if (u % e >= a || c < s) {
                                var p = u + t;
                                if (i[p] >= s && n[p] < 0 && (this.stage3FindEdge(o[p % t], p), ++l > 1e4)) {
                                    d.Helpers.error("Edge finder found too many polygons");
                                    break
                                }
                            }
                        }
                    }, t.prototype.paintPolygons = function (t) {
                        if (this._settings.enabled) {
                            var e = t.context;
                            e.save();
                            for (var i = this._settings, n = i.cellSize, r = this._marginCells, s = r * n - n / 2, a = this._cellLength, o = this._widthCells, l = this._auras, h = this._polygons, u = this._scene, c = -u.centerX * u.zoom % n, p = -u.centerY * u.zoom % n, f = 1; f < h.length; f++) {
                                for (var g = h[f], m = l[f], v = d.Graphics.beginStrokeAndFill(e, m), y = 0; y < g.length; y++) {
                                    var S = g[y],
                                        b = S[0] / a | 0,
                                        C = b % o * n - s + c,
                                        x = (b / o | 0) * n - s + p,
                                        w = S[1] / a | 0,
                                        L = w % o * n - s + c,
                                        T = (w / o | 0) * n - s + p;
                                    v.moveTo((C + L) / 2, (T + x) / 2);
                                    for (var k = 2; k < S.length; k++) {
                                        w = S[k] / a | 0;
                                        var A = w % o * n - s + c,
                                            M = (w / o | 0) * n - s + p;
                                        v.quadraticCurveTo(L, T, (A + L) / 2, (M + T) / 2), L = A, T = M
                                    }
                                    w = S[1] / a | 0;
                                    var I = w % o * n - s + c,
                                        P = (w / o | 0) * n - s + p;
                                    v.quadraticCurveTo(L, T, (I + L) / 2, (P + T) / 2), v.closePath()
                                }
                                d.Graphics.endStrokeAndFill(e, v, m)
                            }
                            d.Graphics.restore(e)
                        }
                    }, t
                }();
                t.NodesLayerAuras = V;
                var Z = function (e) {
                    function i(t, i, n) {
                        var r = e.call(this, t.scene, i) || this;
                        r.chart = t, r.imageCache = {}, r.imageLoading = {}, r.multilinks = {}, r.useFadeout = n, r.styleUpdater = r.createStyleUpdater(i.style), r.events = t.events, r.layerSettings = i;
                        var s = i.style;
                        return r.style = s, r.scaleNodesWithZoom = s.scaleObjectsWithZoom, r.scaleLinksWithZoom = null == s.scaleLinksWithZoom ? s.scaleObjectsWithZoom : s.scaleLinksWithZoom, r._auras = new V(t.scene, t.events, i.auras), r
                    }
                    return n(i, e), i.prototype.createStyleUpdater = function (t) {
                        return null == this.useFadeout ? null : new E(t, this, this.useFadeout)
                    }, i.prototype.updateStyle = function (t) {
                        var e = !t.changes.newGraph;
                        this.styleUpdater.updateLayer(t, e)
                    }, i.prototype.postprocessStyle = function (t) {
                        e.prototype.postprocessStyle.call(this, t), this.animateSize(t)
                    }, i.prototype.animateSize = function (t) {
                        var e = t.timeStamp,
                            i = t.changes.newGraph,
                            n = t.dtime,
                            r = !1,
                            s = !1,
                            a = this.style.fadeTime;
                        i = i || !(a > 0) || n > a;
                        var o = [],
                            l = [];
                        if (i) {
                            for (var h = 0, u = this.nodes(); h < u.length; h++) {
                                var c = u[h];
                                c.removed ? (c.visibility = 0, o.push(c)) : c.targetHWidth !== c.hWidth && (c.added = !1, c.visibility = 1, c.hHeight = c.targetHHeight, c.hWidth = c.targetHWidth)
                            }
                            for (var d = 0, p = this.links(); d < p.length; d++) {
                                var f = p[d];
                                f.removed ? (f.visibility = 0, l.push(f)) : f.targetRadius !== f.currentRadius && (f.added = !1, f.visibility = 1, f.currentRadius = f.targetRadius)
                            }
                        } else {
                            for (var g = a > 0 ? Math.max(0, Math.pow(.2, n / a)) : 0, m = .01, h = 0, u = this.nodes(); h < u.length; h++) {
                                var c = u[h];
                                if (c.added === !0 && (c.added = e), c.added + a < e && (c.added = !1), c.removed === !0 && (c.removed = e), c.removed) r = !0, c.visibility = g, c.hHeight = c.hHeight * g, c.hWidth = c.hWidth * g, e - c.removed < a ? c.visibility = 1 - (e - c.removed) / a : o.push(c);
                                else {
                                    e - c.added < a ? (c.visibility = (e - c.added) / a, r = !0) : c.visibility = 1;
                                    var v = c.targetHHeight,
                                        y = c.hHeight,
                                        S = c.targetHWidth,
                                        b = c.hWidth;
                                    v === y && S === b || (s || (Math.abs(v - y) / Math.max(v, y) >= .5 || Math.abs(S - b) / Math.max(S, b) >= .5) && (s = !0), r = !0, c.hHeight = y * g + v * (1 - g), c.hWidth = b * g + S * (1 - g), Math.abs(c.hHeight - v) < m * v && (c.hHeight = v, c.hWidth = S))
                                }
                            }
                            for (var d = 0, p = this.links(); d < p.length; d++) {
                                var f = p[d];
                                f.added === !0 && (f.added = e), f.added + a < e && (f.added = !1), f.removed === !0 && (f.removed = e), f.removed ? (r = !0, f.currentRadius = f.currentRadius * g, e - f.removed < a ? f.visibility = 1 - (e - f.removed) / a : l.push(f)) : (e - f.added < a && !f.invisible ? (f.visibility = (e - f.added) / a, r = !0) : f.visibility = 1, f.targetRadius !== f.currentRadius && (r = !0, f.currentRadius = f.currentRadius * g + f.targetRadius * (1 - g), Math.abs(f.currentRadius - f.targetRadius) < m * f.targetRadius && (f.currentRadius = f.targetRadius)))
                            }
                        }
                        for (var C = 0; C < l.length; C++) {
                            var x = l[C];
                            this.deleteLink(x)
                        }
                        for (var w = 0; w < o.length; w++) {
                            var L = o[w];
                            this.deleteNode(L)
                        }
                        if (r) {
                            var T = {
                                position: !0
                            };
                            s && (T.dynamicLayout = !0), this.events.notifySceneChanges(T), t.animating = !0
                        }
                    }, i.prototype.paintPrepare = function (t) {
                        this.computeNodeRenderRadii(), this.multilinks = this.updateMultilinks(), (t.changes.position || this.hasTopologyChanges()) && this.placePies()
                    }, i.prototype.paintBackground = function (t) {
                        this._auras.doAnimations(this.nodes(), t), this._auras.paintPolygons(t)
                    }, i.prototype.paintSelection = function (t, e, i) {
                        var n = this.style.selection;
                        if (n.enabled) {
                            null === n.fillColor && (n = d.Helpers.clone(n), n.fillColor = this.chart.settings.area.style.fillColor, n.fillColor && "transparent" !== n.fillColor || (n.fillColor = "white"));
                            var r = this.getGeometry(),
                                s = r.txm,
                                a = r.txa,
                                o = r.tym,
                                l = r.tya,
                                h = r.zoom,
                                u = t.context,
                                c = n.sizeProportional,
                                p = n.sizeConstant;
                            u.beginPath();
                            for (var f = 0; f < e.length; f++) {
                                var g = e[f];
                                g.invisible || (g.shape.adaptToViewport(s, a, o, l, h), g.shape.paintSelection(u, c, p * h))
                            }
                            for (var f = 0; f < i.length; f++) {
                                var m = i[f];
                                if (!m.invisible) {
                                    var v = (m.currentRadius / 2 * (1 + c) + .9 * p) * h,
                                        y = m.from,
                                        S = m.to,
                                        b = y.x * s + a,
                                        C = y.y * o + l,
                                        x = S.x * s + a,
                                        w = S.y * o + l,
                                        L = b - x,
                                        T = C - w,
                                        k = 1 / Math.sqrt(L * L + T * T),
                                        A = L * k,
                                        M = T * k;
                                    if (0 !== m.currentCenterOffset) {
                                        var I = M * m.currentCenterOffset * h,
                                            P = -A * m.currentCenterOffset * h;
                                        b += I, C += P, x += I, w += P
                                    }
                                    A *= v, M *= v, u.moveTo(b + M, C - A), u.lineTo(b - M, C + A), u.lineTo(x - M, w + A), u.lineTo(x + M, w - A), u.closePath()
                                }
                            }
                            return d.Graphics.paint(u, n)
                        }
                    }, i.prototype.paintLinks = function (t, e) {
                        var i = this.getGeometry();
                        this.paintLinksImpl(t, e, this.multilinks, {
                            geometry: i,
                            paintDetails: i.zoom > this.style.linkDetailMinZoom
                        })
                    }, i.prototype.paintNodes = function (t, e) {
                        var i = this.getGeometry();
                        t.animating = this.paintNodesImpl(t, e, {
                            geometry: i,
                            paintDetails: i.zoom > this.style.nodeDetailMinZoom
                        }, t.timeStamp) || t.animating
                    }, i.prototype.updateMultilinks = function () {
                        if (!this.hasTopologyChanges()) return this.multilinks;
                        for (var t = this.links(), e = {}, i = [], n = 0; n < t.length; n++) {
                            var r = t[n],
                                s = r.multiId;
                            if (e.hasOwnProperty(s)) {
                                var a = e[s];
                                if (a instanceof Array) a.push(r);
                                else {
                                    var o = [a, r];
                                    i.push(o), e[s] = o
                                }
                            } else e[s] = r
                        }
                        for (var l = 0; l < i.length; l++) i[l].sort(function (t, e) {
                            return ("" + (t.id || "")).localeCompare("" + (e.id || ""))
                        });
                        return e
                    }, i.prototype.getNodeImage = function (t, e, i) {
                        if (void 0 === i && (i = !1), !t.image) return null;
                        var n = t.tintImage && t.fillColor,
                            r = !!e && t.imageCropping,
                            s = t.image,
                            a = s;
                        if (n && (s += "##" + t.fillColor), s += "##" + r, this.imageCache.hasOwnProperty(s)) return this.imageCache[s];
                        if (this.imageLoading[s]) return null;
                        var o = this.scene.assetsLoader.getAssetImage(a);
                        return i ? o : o ? (r && (o = d.Graphics.cropImageToCircle(o, r)), n && (o = d.Graphics.applyColorToImage(o, t.fillColor, !1)), this.imageCache[s] = o, delete this.imageLoading[s], this.events.notifySceneChanges({
                            layout: !0
                        }), o) : null
                    }, i.prototype.computeNodeRenderRadii = function () {
                        for (var t = this.getGeometry().zoom, e = 0, i = this.nodes(); e < i.length; e++) {
                            var n = i[e],
                                r = n.hHeight * t,
                                s = n.hWidth * t;
                            n.lineWidth && (r += n.lineWidth / 2, s += n.lineWidth / 2), n.renderHheight = r, n.renderHwidth = s
                        }
                    }, i.prototype.paintLinksImpl = function (t, e, i, n) {
                        var r = t.context,
                            s = n.geometry.txm,
                            a = n.geometry.txa,
                            o = n.geometry.tym,
                            l = n.geometry.tya,
                            h = n.geometry.linkZoom,
                            u = n.geometry.x0w,
                            c = n.geometry.y0w,
                            p = n.geometry.x1w,
                            f = n.geometry.y1w,
                            g = 1 / h,
                            m = this.scaleNodesWithZoom ? 1 : 1 / this.scene.zoom;
                        r.textAlign = "center", r.textBaseline = "middle";
                        for (var v = this.style, y = v.linkDetailMinSize * v.linkDetailMinSize, S = n.paintDetails && this.chart.assetsLoaded, b = v.multilinkSpacing * h, C = v.linkDecorationScale, x = v.linkDecorationMinSize, w = v.linkLabelScaleBase, L = 2, T = 5, k = .1, A = 0; A < e.length; A++) {
                            var M = e[A];
                            if (!M.invisible && M.from !== M.to) {
                                var I = M.from.x,
                                    P = M.from.y,
                                    D = M.to.x,
                                    N = M.to.y,
                                    F = M.currentItems,
                                    O = F && F.length && F[0].style.rotateWithLink,
                                    E = void 0,
                                    R = M.from.renderHheight,
                                    H = M.to.renderHheight,
                                    B = M.from.renderHwidth,
                                    z = M.to.renderHwidth,
                                    U = d.Geometry.clipSegmentToBounds(I, P, D, N, (R + B) * m, (H + z) * m, u, c, p, f);
                                if (U) {
                                    I = U[0], P = U[1], D = U[2], N = U[3], I = I * s + a, P = P * o + l, D = D * s + a, N = N * o + l;
                                    var G = D - I,
                                        j = N - P,
                                        W = G * G + j * j,
                                        V = Math.max(.25, M.currentRadius * h * .5),
                                        Z = M.hovered || M.from.hovered || M.to.hovered,
                                        Y = Z || S && W > y;
                                    if (W > 25) {
                                        var q = Math.sqrt(W);
                                        if (O && (E = Math.atan2(j, G) * (180 / Math.PI), I >= D && (E -= 180), M.currentItems[0].style.angle = E), M.toPieValue > 0) {
                                            var _ = H + L,
                                                X = _ + T + k * H;
                                            this.paintLinkPie(r, D, N, _, X, M.toPie0, M.toPie1, M.toPieColor), H = X
                                        }
                                        if (q < R + H) continue;
                                        var Q = 1 / q,
                                            J = G * Q,
                                            K = j * Q,
                                            $ = void 0,
                                            tt = void 0;
                                        if ($ = M.from.shape.distanceToEdge(R, B, J, K), tt = M.to.shape.distanceToEdge(H, z, -J, -K), q <= $ + tt) continue;
                                        var et = Math.min((q - $ - tt) / 4, Math.max(x, V * C));
                                        M.fromDecoration && ($ += et), M.toDecoration && (tt += et), I += J * $, P += K * $, D -= J * tt, N -= K * tt, G = D - I, j = N - P, q = q - $ - tt, Q = 1 / q;
                                        var it = M.multiId,
                                            nt = i[it];
                                        if (nt instanceof Array) {
                                            var rt = nt.length,
                                                st = Math.min(b * (rt - 1), 1.5 * R, 1.5 * H),
                                                at = st * (nt.indexOf(M) - (rt - 1) / 2) / (rt - 1);
                                            M.from.id > M.to.id && (at = -at), M.currentCenterOffset = at * g, I -= K * at, D -= K * at, P += J * at, N += J * at
                                        } else M.currentCenterOffset = 0;
                                        if (M.renderPointsX ? (M.renderPointsX[0] = I, M.renderPointsX[1] = D) : M.renderPointsX = [I, D], M.renderPointsY ? (M.renderPointsY[0] = P, M.renderPointsY[1] = N) : M.renderPointsY = [P, N], M.renderBounds ? (M.renderBounds.x0 = Math.min(I, D), M.renderBounds.x1 = Math.max(I, D), M.renderBounds.y0 = Math.min(P, N), M.renderBounds.y1 = Math.max(P, N)) : M.renderBounds = new d.Rect(I, P, D, N), Y && M.currentItems && !M.removed && (M.currentItems.sort(function (t, e) {
                                                return t.style.zIndex - e.style.zIndex
                                            }), this.paintLinkItems(r, t.labelRenderer, h, V / w, I, P, J, K, q, V, M.currentItems, M.renderBounds, Z, !0)), r.beginPath(), M.fromDecoration && this.paintLinkDecoration(r, I, P, J, K, et, M.fromDecoration, M.fillColor), M.toDecoration && this.paintLinkDecoration(r, D, N, -J, -K, et, M.toDecoration, M.fillColor), M.lineDash) {
                                            M.lineDashBackgroundFillColor && (r.moveTo(I + K * V, P - J * V), r.lineTo(I - K * V, P + J * V), r.lineTo(D - K * V, N + J * V), r.lineTo(D + K * V, N - J * V), r.closePath(), d.Graphics.fill(r, {
                                                fillColor: M.lineDashBackgroundFillColor
                                            })), r.beginPath();
                                            var ot = I + K * V,
                                                lt = P - J * V,
                                                ht = I - K * V,
                                                ut = P + J * V;
                                            if (M.lineDash.length > 0)
                                                for (var ct = M.lineDash, dt = ct.length, pt = ct.reduce(function (t, e) {
                                                        return t + e
                                                    }) * h, ft = 0, gt = 0; gt <= q / pt; gt++) {
                                                    for (var mt = 0; mt <= dt - 1; mt += 2) {
                                                        var vt = gt * pt + ft;
                                                        if (vt > q - V) break;
                                                        var yt = vt + ct[mt] * h,
                                                            St = yt >= q - V ? q - V : yt,
                                                            bt = [ot + vt * J, lt + vt * K],
                                                            Ct = [ht + vt * J, ut + vt * K],
                                                            xt = [ht + St * J, ut + St * K],
                                                            wt = [ot + St * J, lt + St * K];
                                                        if (M.lineDashShape && "rectangle" != M.lineDashShape) {
                                                            if ("triangle" == M.lineDashShape) {
                                                                var Lt = [(bt[0] + Ct[0]) / 2, (bt[1] + Ct[1]) / 2];
                                                                r.moveTo(Lt[0], Lt[1]), r.lineTo(xt[0], xt[1]), r.lineTo(wt[0], wt[1])
                                                            } else if ("diamond" == M.lineDashShape) {
                                                                var Lt = [(bt[0] + Ct[0]) / 2, (bt[1] + Ct[1]) / 2],
                                                                    Tt = [(Ct[0] + xt[0]) / 2, (Ct[1] + xt[1]) / 2],
                                                                    kt = [(xt[0] + wt[0]) / 2, (xt[1] + wt[1]) / 2],
                                                                    At = [(wt[0] + bt[0]) / 2, (wt[1] + bt[1]) / 2];
                                                                r.moveTo(Lt[0], Lt[1]), r.lineTo(Tt[0], Tt[1]), r.lineTo(kt[0], kt[1]), r.lineTo(At[0], At[1])
                                                            } else if ("hexagon" == M.lineDashShape) {
                                                                var Lt = [(bt[0] + Ct[0]) / 2, (bt[1] + Ct[1]) / 2],
                                                                    Tt = [(Ct[0] + xt[0]) / 2, (Ct[1] + xt[1]) / 2],
                                                                    At = [(bt[0] + wt[0]) / 2, (bt[1] + wt[1]) / 2],
                                                                    Mt = [(Tt[0] + At[0]) / 2, (Tt[1] + At[1]) / 2];
                                                                r.moveTo(Lt[0], Lt[1]), r.lineTo(Tt[0], Tt[1]), r.lineTo(xt[0], xt[1]), r.lineTo(Mt[0], Mt[1]), r.lineTo(wt[0], wt[1]), r.lineTo(At[0], At[1])
                                                            }
                                                        } else r.moveTo(bt[0], bt[1]), r.lineTo(Ct[0], Ct[1]), r.lineTo(xt[0], xt[1]), r.lineTo(wt[0], wt[1]);
                                                        r.closePath(), ft += h * (ct[mt] + ct[mt + 1])
                                                    }
                                                    ft = 0
                                                } else
                                                    for (var It = Math.max(5, 3 * V), gt = 0; gt <= q / It; gt += 2) {
                                                        var vt = gt * It,
                                                            St = Math.min((gt + 1) * It, q);
                                                        r.moveTo(ot + vt * J, lt + vt * K), r.lineTo(ht + vt * J, ut + vt * K), r.lineTo(ht + St * J, ut + St * K), r.lineTo(ot + St * J, lt + St * K), r.closePath()
                                                    }
                                        } else r.moveTo(I + K * V, P - J * V), r.lineTo(I - K * V, P + J * V), r.lineTo(D - K * V, N + J * V), r.lineTo(D + K * V, N - J * V), r.closePath();
                                        d.Graphics.fill(r, M), Y && M.currentItems && !M.removed && this.paintLinkItems(r, t.labelRenderer, h, V / w, I, P, J, K, q, V, M.currentItems, M.renderBounds, Z, !1)
                                    } else if (M.fillColor) {
                                        if (r.beginPath(), r.lineWidth = Math.max(.1, 2 * V), r.strokeStyle = M.fillColor, M.dashed)
                                            for (var q = Math.sqrt(W), Q = 1 / q, J = G * Q, K = j * Q, It = Math.max(5, 3 * V), gt = 0; gt <= q / It; gt += 2) {
                                                var vt = gt * It,
                                                    St = Math.min((gt + 1) * It, q);
                                                r.moveTo(I + vt * J, P + vt * K), r.lineTo(I + St * J, P + St * K)
                                            } else r.moveTo(I, P), r.lineTo(D, N);
                                        r.stroke(), M.renderPointsX ? (M.renderPointsX[0] = I, M.renderPointsX[1] = D) : M.renderPointsX = [I, D], M.renderPointsY ? (M.renderPointsY[0] = P, M.renderPointsY[1] = N) : M.renderPointsY = [P, N], M.renderBounds ? (M.renderBounds.x0 = Math.min(I, D), M.renderBounds.x1 = Math.max(I, D), M.renderBounds.y0 = Math.min(P, N), M.renderBounds.y1 = Math.max(P, N)) : M.renderBounds = new d.Rect(I, P, D, N)
                                    }
                                }
                            }
                        }
                    }, i.prototype.paintNodesImpl = function (e, i, n, r) {
                        var s = !1,
                            a = e.context,
                            o = n.geometry.txm,
                            l = n.geometry.txa,
                            h = n.geometry.tym,
                            u = n.geometry.tya,
                            c = n.geometry.zoom,
                            p = n.geometry.x0s,
                            f = n.geometry.x1s,
                            g = n.geometry.y0s,
                            m = n.geometry.y1s,
                            v = 1 / o,
                            y = n.paintDetails,
                            S = this.style.nodeDetailMinSize * this.style.nodeDetailMinSize * v * v,
                            b = this.style.hiddenLinks,
                            C = this.style.nodeLabelScaleBase;
                        a.textAlign = "center", a.textBaseline = "middle";
                        for (var x = this.style.removedColor, w = 0; w < i.length; w++) {
                            var L = i[w];
                            L.data && !L.invisible && this.paintSelfLinks(e, L, n)
                        }
                        for (var w = 0; w < i.length; w++) {
                            var L = i[w];
                            if (L.data && !L.invisible) {
                                var T = L.shape;
                                if (T.adaptToViewport(o, l, h, u, c), null != L.anchorX && null != L.anchorY && L.anchorMode === t.NodeAnchorMode.Floating) {
                                    var k = L.anchorX * o + l,
                                        A = L.anchorY * h + u,
                                        M = T.getAnchor(),
                                        I = T.x + M.x,
                                        P = T.y + M.y,
                                        D = I - k,
                                        N = P - A,
                                        F = P;
                                    N < 0 && (F = Math.max(F, A - N * Math.min(.3, Math.abs(D) / N))), a.beginPath(), a.moveTo(I, P), a.lineTo(I, F), a.lineTo(k, A), d.Graphics.stroke(a, L.anchorStyle)
                                }
                            }
                        }
                        for (var w = 0; w < i.length; w++) {
                            var L = i[w],
                                T = L.shape;
                            if (L.data && !L.invisible && T.isInViewport(p, f, g, m, c)) {
                                var O = L.opacity,
                                    E = L.outerBounds.w(),
                                    R = L.outerBounds.h(),
                                    H = y && E * R > S || L.hovered;
                                if (O < 1 && (a.globalAlpha = O), H && !L.removed) {
                                    var B = L.dataLinks.length - L.links.length;
                                    if (B > 0)
                                        if (this.useFadeout && L.relevance < 1) {
                                            var z = b.lineColor;
                                            b.lineColor = d.Colors.blend(x, z, L.relevance), this.paintHiddenLinks(a, L, T.x, T.y, T.hWidth, T.hHeight, B, b, b.size * c), b.lineColor = z
                                        } else this.paintHiddenLinks(a, L, T.x, T.y, T.hWidth, T.hHeight, B, b, b.size * c);
                                    L.items.sort(function (t, e) {
                                        return t.zIndex - e.zIndex
                                    }), this.paintNodeDetails(L, T.x, T.y, T.hHeight, T.hWidth, c, C, e, !0)
                                }
                                T.paint(a, e.labelRenderer, H), H && !L.removed && this.paintNodeDetails(L, T.x, T.y, T.hHeight, T.hWidth, c, C, e, !1), O < 1 && (a.globalAlpha = 1)
                            }
                        }
                        if (this.scene.settings.advanced.perNodeLoadingIndicator) {
                            var U = this.scene.settings.advanced.style.loadingArcStyle;
                            a.save(), a.lineCap = "round", a.lineWidth = U.lineWidth, a.strokeStyle = U.lineColor;
                            var G = r / 1400;
                            G = (G - Math.floor(G)) * (2 * Math.PI);
                            for (var j = G + Math.PI / 2, w = 0; w < i.length; w++) {
                                var L = i[w];
                                if (!L.invisible) {
                                    var T = L.shape;
                                    if (L.loading || L.image && null === this.getNodeImage(L, !1, !0)) {
                                        if (!T.isInViewport(p, f, g, m, c)) continue;
                                        s = !0, a.beginPath(), a.arc(T.x, T.y, T.hWidth, G, j), a.stroke()
                                    }
                                }
                            }
                            d.Graphics.restore(a)
                        }
                        return s
                    }, i.prototype.paintLinkDecoration = function (t, e, i, n, r, s, a, o) {
                        t.fillStyle = o, "circle" === a ? (t.moveTo(e + s, i), t.arc(e, i, s, 0, 2 * Math.PI, !0)) : "arrow" === a ? (t.moveTo(e - n * s, i - r * s), t.lineTo(e + n * s - r * s, i + r * s + n * s), t.lineTo(e + n * s + r * s, i + r * s - n * s)) : d.Helpers.error("Unrecognized link decoration value. Valid values are 'circle' and 'arrow'.")
                    }, i.prototype.paintLinkPie = function (t, e, i, n, r, s, a, o) {
                        var l = (n + r) / 2,
                            h = r - n;
                        t.beginPath(), t.arc(e, i, l, s, a), d.Graphics.paint(t, {
                            lineColor: o,
                            lineWidth: h
                        })
                    }, i.prototype.paintLinkItems = function (t, e, i, n, r, s, a, o, l, h, u, c, p, f) {
                        var g, m;
                        p ? (g = d.Helpers.toleranceMax(i, 1, .9), m = d.Helpers.toleranceMax(n, 1, .9)) : (g = i, m = n);
                        for (var v = 0; v < u.length; v++) {
                            var y = u[v];
                            if (f) {
                                if (y.style.zIndex >= 0) break
                            } else if (y.style.zIndex < 0) continue;
                            var S = y.x || 0,
                                b = y.y || 0,
                                C = y.style.px || 0,
                                x = y.style.py || 0,
                                w = y.style.lx || 0,
                                L = y.style.ly || 0;
                            C = l * (C + 1) * .5 + w, x = x * h + L;
                            var T = r + a * C - o * x + S,
                                k = s + o * C + a * x + b,
                                A = 0;
                            A = y.style.scaleWithSize ? y.style.hoverEffect ? m : n : y.style.scaleWithZoom ? y.style.hoverEffect ? g : i : 1, e.paint(t, T, k, A, y)
                        }
                    }, i.prototype.paintBezierLinkItems = function (t, e, i, n, r, s, a, o, l, h, u) {
                        var c, p;
                        h ? (c = d.Helpers.toleranceMax(i, 1, .9), p = d.Helpers.toleranceMax(n, 1, .9)) : (c = i, p = n);
                        for (var f = 0; f < o.length; f++) {
                            var g = o[f];
                            if (u) {
                                if (g.style.zIndex >= 0) break
                            } else if (g.style.zIndex < 0) continue;
                            var m = g.x || 0,
                                v = g.y || 0,
                                y = g.style.px || 0,
                                S = g.style.py || 0,
                                b = g.style.lx || 0,
                                C = g.style.ly || 0,
                                x = 0;
                            y <= 0 ? y = 1 + y : x = 2;
                            var w = 1 - y,
                                L = r[x] * w + r[x + 1] * y,
                                T = s[x] * w + s[x + 1] * y,
                                k = r[x + 1] * w + r[x + 2] * y,
                                A = s[x + 1] * w + s[x + 2] * y,
                                M = k - L,
                                I = A - T,
                                P = Math.sqrt(M * M + I * I),
                                D = M / P,
                                N = I / P,
                                F = L * w + k * y + D * b - N * (S * a + C) + m,
                                O = T * w + A * y + N * b + D * (S * a + C) + v,
                                E = 0;
                            E = g.style.scaleWithSize ? g.style.hoverEffect ? p : n : g.style.scaleWithZoom ? g.style.hoverEffect ? c : i : 1, g.style.rotateWithLink && (g.style.angle = 180 * Math.atan2(N, D) / Math.PI), e.paint(t, F, O, E, g), l.addRect(g.currentBounds)
                        }
                    }, i.prototype.paintSelfLinks = function (t, e, i) {
                        var n = this.multilinks[e.id + d.Helpers.SeparatorChar + e.id];
                        if (null != n) {
                            n instanceof u && (n = [n]), n = n.filter(function (t) {
                                return !t.invisible
                            });
                            var r = n.length;
                            if (!(r < 1)) {
                                for (var s, a, o, l = e.dataLinks.length > e.links.length, h = 0, c = 0, p = 0, f = 0; f < e.links.length; f++) {
                                    var g = e.links[f];
                                    if (g.from !== g.to) {
                                        var m = g.otherEnd(e);
                                        h += m.x, c += m.y, p++
                                    }
                                }
                                if (0 === p) s = -1, a = 0, o = l ? 4 * Math.PI / 3 : 2 * Math.PI;
                                else {
                                    h = e.x - h / p, c = e.y - c / p;
                                    var v = 1 / Math.sqrt(h * h + c * c);
                                    if (s = h * v, a = c * v, l) {
                                        o = Math.PI / 2;
                                        var y = Math.SQRT2 / 2,
                                            S = y * (s - a);
                                        a = y * (a + s), s = S
                                    } else o = Math.PI
                                }
                                var b, C, x, w, L = this.style.selfLinkAngle;
                                L <= 0 ? L = 60 : L > 90 && (L = 90);
                                var T = Math.PI * L / 180,
                                    k = Math.cos(T),
                                    A = Math.sin(T),
                                    M = Math.cos(T / 2),
                                    I = Math.sin(T / 2);
                                if (o >= T * r) {
                                    o /= r;
                                    var P = -(o * (r - 1) + T) / 2;
                                    x = Math.cos(P), w = Math.sin(P), b = s * x - a * w, C = s * w + a * x, x = Math.cos(o), w = Math.sin(o)
                                } else {
                                    var P = -o / 2;
                                    x = Math.cos(P), w = Math.sin(P), b = s * x - a * w, C = s * w + a * x;
                                    var D = (o - T) / (r - 1);
                                    x = Math.cos(D), w = Math.sin(D)
                                }
                                var N = t.context,
                                    F = i.geometry.txm,
                                    O = i.geometry.txa,
                                    E = i.geometry.tym,
                                    R = i.geometry.tya,
                                    H = i.geometry.linkZoom;
                                N.textAlign = "center", N.textBaseline = "middle";
                                for (var B = this.style, z = B.linkDetailMinSize * B.linkDetailMinSize, U = i.paintDetails && this.chart.assetsLoaded, G = B.linkDecorationScale, j = B.linkDecorationMinSize, W = B.linkLabelScaleBase, V = 2, Z = 5, Y = .1, q = 5, _ = e.x * F + O, X = e.y * E + R, Q = 1 + (this.style.selfLinkHeightFactor <= 0 ? 1 : this.style.selfLinkHeightFactor), J = Math.max(this.style.selfLinkWidthFactor, 0), K = [0, 0, 0, 0, 0], $ = [0, 0, 0, 0, 0], tt = [0, 0, 0, 0, 0], et = [0, 0, 0, 0, 0], it = [0, 0, 0, 0, 0], nt = [0, 0, 0, 0, 0], rt = 0; rt < r; rt++) {
                                    var g = n[rt];
                                    if (!g.invisible) {
                                        var st = Math.max(e.renderHheight, e.renderHwidth);
                                        st *= st;
                                        var at = e.renderHheight;
                                        if (st > 25 && g.toPieValue > 0) {
                                            var ot = at + V,
                                                lt = ot + Z + Y * at;
                                            this.paintLinkPie(N, _, X, ot, lt, g.toPie0, g.toPie1, g.toPieColor), at = lt
                                        }
                                        var ht = b * k - C * A,
                                            ut = b * A + C * k,
                                            ct = b * M - C * I,
                                            dt = b * I + C * M,
                                            pt = e.shape.distanceToEdge(at, e.renderHwidth, b, C),
                                            ft = e.shape.distanceToEdge(at, e.renderHwidth, ht, ut),
                                            gt = Math.max(pt, ft) * Q,
                                            mt = Math.max(.25, g.currentRadius * H * .5),
                                            vt = Math.min((gt - Math.max(pt, ft) - mt) / 2, Math.max(j, mt * G));
                                        g.fromDecoration && (pt += vt), g.toDecoration && (ft += vt), tt[0] = _ + b * pt, et[0] = X + C * pt, tt[2] = _ + ct * gt, et[2] = X + dt * gt, tt[4] = _ + ht * ft, et[4] = X + ut * ft, K[2] = _ + ct * (gt - mt), $[2] = X + dt * (gt - mt), it[2] = _ + ct * (gt + mt), nt[2] = X + dt * (gt + mt);
                                        var yt = void 0,
                                            St = void 0,
                                            bt = void 0,
                                            Ct = void 0;
                                        if ("parabolic" === this.style.selfLinkShape) {
                                            yt = b, St = C, bt = ht, Ct = ut, K[0] = tt[0] - C * mt, $[0] = et[0] + b * mt, K[4] = tt[4] + ut * mt, $[4] = et[4] - ht * mt;
                                            var xt = ((gt - mt) * I - mt) / M * J;
                                            K[1] = K[2] + dt * xt, $[1] = $[2] - ct * xt, K[3] = K[2] - dt * xt, $[3] = $[2] + ct * xt, it[0] = tt[0] + C * mt, nt[0] = et[0] - b * mt, it[4] = tt[4] - ut * mt, nt[4] = et[4] + ht * mt, xt = ((gt + mt) * I + mt) / M * J, it[1] = it[2] + dt * xt, nt[1] = nt[2] - ct * xt, it[3] = it[2] - dt * xt, nt[3] = nt[2] + ct * xt, xt = gt * I / M * J, tt[1] = tt[2] + dt * xt, et[1] = et[2] - ct * xt, tt[3] = tt[2] - dt * xt, et[3] = et[2] + ct * xt
                                        } else {
                                            yt = ct, St = dt, bt = ct, Ct = dt, K[0] = tt[0] - dt * mt, $[0] = et[0] + ct * mt, K[4] = tt[4] + dt * mt, $[4] = et[4] - ct * mt;
                                            var wt = (K[4] - K[0]) * J / 2,
                                                Lt = ($[4] - $[0]) * J / 2;
                                            K[1] = K[2] - wt, $[1] = $[2] - Lt, K[3] = K[2] + wt, $[3] = $[2] + Lt, it[0] = tt[0] + dt * mt, nt[0] = et[0] - ct * mt, it[4] = tt[4] - dt * mt, nt[4] = et[4] + ct * mt, wt = (it[4] - it[0]) * J / 2, Lt = (nt[4] - nt[0]) * J / 2, it[1] = it[2] - wt, nt[1] = nt[2] - Lt, it[3] = it[2] + wt, nt[3] = nt[2] + Lt, wt = (tt[4] - tt[0]) * J / 2, Lt = (et[4] - et[0]) * J / 2, tt[1] = tt[2] - wt, et[1] = et[2] - Lt, tt[3] = tt[2] + wt, et[3] = et[2] + Lt
                                        }
                                        g.renderBounds || (g.renderBounds = new d.Rect(0, 0, 0, 0)), g.renderBounds.x0 = Math.min.apply(Math, it), g.renderBounds.y0 = Math.min.apply(Math, nt), g.renderBounds.x1 = Math.max.apply(Math, it), g.renderBounds.y1 = Math.max.apply(Math, nt), g.renderPointsX || (g.renderPointsX = new Array(2 * q), g.renderPointsY = new Array(2 * q));
                                        for (var Tt = 0; Tt < q; Tt++) {
                                            var kt = Tt / (q - 1),
                                                At = 1 - kt;
                                            g.renderPointsX[Tt] = At * At * tt[0] + 2 * At * kt * tt[1] + kt * kt * tt[2], g.renderPointsY[Tt] = At * At * et[0] + 2 * At * kt * et[1] + kt * kt * et[2], g.renderPointsX[Tt + q] = At * At * tt[2] + 2 * At * kt * tt[3] + kt * kt * tt[4], g.renderPointsY[Tt + q] = At * At * et[2] + 2 * At * kt * et[3] + kt * kt * et[4]
                                        }
                                        if (st > 25) {
                                            var Mt = g.hovered || g.from.hovered || g.to.hovered,
                                                It = Mt || U && st > z;
                                            It && g.currentItems && !g.removed && (g.currentItems.sort(function (t, e) {
                                                return t.style.zIndex - e.style.zIndex
                                            }), this.paintBezierLinkItems(N, t.labelRenderer, H, mt / W, tt, et, mt, g.currentItems, g.renderBounds, Mt, !0)), N.beginPath(), g.fromDecoration && this.paintLinkDecoration(N, tt[0], et[0], yt, St, vt, g.fromDecoration, g.fillColor), g.toDecoration && this.paintLinkDecoration(N, tt[4], et[4], bt, Ct, vt, g.toDecoration, g.fillColor), N.moveTo(K[0], $[0]), N.quadraticCurveTo(K[1], $[1], K[2], $[2]), N.quadraticCurveTo(K[3], $[3], K[4], $[4]), N.lineTo(it[4], nt[4]), N.quadraticCurveTo(it[3], nt[3], it[2], nt[2]), N.quadraticCurveTo(it[1], nt[1], it[0], nt[0]), N.closePath(), d.Graphics.fill(N, g), It && g.currentItems && !g.removed && (g.currentItems.sort(function (t, e) {
                                                return t.style.zIndex - e.style.zIndex
                                            }), this.paintBezierLinkItems(N, t.labelRenderer, H, mt / W, tt, et, mt, g.currentItems, g.renderBounds, Mt, !1))
                                        } else g.fillColor && (N.beginPath(), N.lineWidth = Math.max(.1, 2 * mt), N.strokeStyle = g.fillColor, N.moveTo(tt[0], et[0]), N.quadraticCurveTo(tt[1], et[1], tt[2], et[2]), N.quadraticCurveTo(tt[3], et[3], tt[4], et[4]), N.stroke());
                                        var S = b * x - C * w;
                                        C = b * w + C * x, b = S
                                    }
                                }
                            }
                        }
                    }, i.prototype.paintHiddenLinks = function (t, e, i, n, r, s, a, o, l) {
                        for (var h, u, c, d = 0, p = 0, f = 0, g = !1, m = 0; m < e.links.length; m++) {
                            var v = e.links[m];
                            if (v.from === v.to) g = !0;
                            else {
                                var y = v.otherEnd(e);
                                d += y.x, p += y.y, f++
                            }
                        }
                        if (0 === f) h = 1, u = 0, c = 2 * Math.PI / a / 3;
                        else {
                            d = e.x - d / e.links.length, p = e.y - p / e.links.length;
                            var S = 1 / Math.sqrt(d * d + p * p);
                            if (h = d * S, u = p * S, g) {
                                c = Math.PI / a / 2;
                                var b = Math.SQRT2 / 2,
                                    C = b * (h + u);
                                u = b * (u - h), h = C
                            } else c = 2 * Math.PI / a / 3
                        }
                        var x = Math.cos(-c * (a - 1) / 2),
                            w = Math.sin(-c * (a - 1) / 2),
                            L = h * x - u * w,
                            T = h * w + u * x,
                            k = L;
                        x = Math.cos(c), w = Math.sin(c), t.beginPath();
                        for (var A = 1; A <= a; A++) {
                            var M = e.shape.distanceToEdge(r, s, k, T);
                            t.moveTo(i + k * M, n + T * M), t.lineTo(i + k * (M + l), n + T * (M + l)), L = k * x - T * w, T = k * w + T * x, k = L
                        }
                        t.strokeStyle = o.lineColor, t.lineWidth = o.lineWidth, t.stroke()
                    }, i.prototype.findObjectAt = function (t, e, i) {
                        var n = this.scene,
                            r = n.fromDisplay(t, e),
                            s = r.x,
                            a = r.y,
                            o = 1 / n.zoom,
                            l = this.scaleLinksWithZoom ? o : 1,
                            h = null,
                            u = [],
                            c = null,
                            p = i,
                            f = n.hoverNode;
                        if (f && f.layer === this && !f.invisible) {
                            var g = f.shape.hitTest(s, a, o, p * o);
                            if (g / o < p) {
                                p = g / o, h = f;
                                var m = this.findItem(t, e, h, i);
                                if (m && (c = m.item, p = Math.min(p, m.distance)), p <= 0) return {
                                    object: h,
                                    details: c
                                }
                            }
                        }
                        for (var v = this.nodes(), y = v.length - 1; y >= 0; y--) {
                            var S = v[y];
                            if (!S.removed && !S.invisible && d.Geometry.distanceToRect(s - S.x, a - S.y, S.outerBounds) < p * o) {
                                var g = S.shape.hitTest(s, a, o, p * o);
                                if (g <= 0) {
                                    p = 0, h = S;
                                    break
                                }
                                g / o < p && (p = g / o, h = S), u.push(S)
                            }
                        }
                        if (p > 0) {
                            var b = n.hoverLink;
                            if (b && b.layer === this && !b.invisible)
                                for (var C = b.targetRadius / 2 * l, y = 1; y < b.renderPointsX.length; y++) {
                                    var x = d.Geometry.distanceToSegmentSq(b.renderPointsX[y - 1], b.renderPointsY[y - 1], b.renderPointsX[y], b.renderPointsY[y], t, e);
                                    if (x <= (p + C) * (p + C)) {
                                        p = 0, h = b;
                                        var m = this.findItem(t, e, h, i);
                                        if (m && (c = m.item, p = Math.min(p, m.distance)), p <= 0) return {
                                            object: h,
                                            details: c
                                        };
                                        break
                                    }
                                }
                        }
                        if (p > 0)
                            for (var w = 0, L = this.links(); w < L.length; w++) {
                                var T = L[w];
                                if (!T.removed && !T.invisible && T.renderPointsX && d.Geometry.distanceToRect(t, e, T.renderBounds) < p) {
                                    for (var C = T.targetRadius / l * 2, k = Math.min(p * p, C * C), y = 1; y < T.renderPointsX.length; y++) {
                                        var x = d.Geometry.distanceToSegmentSq(T.renderPointsX[y - 1], T.renderPointsY[y - 1], T.renderPointsX[y], T.renderPointsY[y], t, e);
                                        if (x < k) {
                                            p = Math.sqrt(x), h = T;
                                            break
                                        }
                                    }
                                    u.push(T)
                                }
                            }
                        if (0 === p) {
                            var m = this.findItem(t, e, h, i);
                            return {
                                object: h,
                                details: m ? m.item : null
                            }
                        }
                        for (var y = 0; y < u.length; y++) {
                            var A = u[y],
                                m = this.findItem(t, e, A, i);
                            m && m.distance < p && (p = m.distance, h = A, c = m.item)
                        }
                        return p > i && (h = null, c = null), {
                            object: h,
                            details: c
                        }
                    }, i.prototype.findItem = function (t, e, i, n) {
                        if (!i) return null;
                        var r = n * n,
                            s = this.scene.hoverItem;
                        if (s && s.hwidth && i.currentItems.indexOf(s) > -1) {
                            var a = d.Geometry.distanceToRect(t, e, s.currentBounds, !0);
                            if (a <= r) return {
                                item: s,
                                distance: Math.sqrt(a)
                            }
                        }
                        var o = null,
                            l = n * n;
                        if (i instanceof h) {
                            var u = i.shape.currentLabel;
                            if (u && u.currentBounds) {
                                var a = d.Geometry.distanceToRect(t, e, u.currentBounds, !0);
                                a < l && (o = u, l = a)
                            }
                        }
                        for (var c = 0; c < i.currentItems.length; c++) {
                            var p = i.currentItems[c];
                            if (p.hwidth) {
                                var a = d.Geometry.distanceToRect(t, e, p.currentBounds, !0);
                                a <= l && (o = p, l = a)
                            }
                        }
                        return l > r || !o ? null : {
                            item: o,
                            distance: Math.sqrt(l)
                        }
                    }, i.prototype.getGraphBounds = function (t) {
                        if (void 0 === t && (t = this.nodes()), !t || !t.length) return new d.Rect(0, 0, 0, 0);
                        for (var e = d.Rect.createEmpty(), i = 0; i < t.length; i++) {
                            var n = t[i];
                            if (!n.removed) {
                                var r = n.x,
                                    s = n.y,
                                    a = n.outerBounds;
                                e.addBounds(a.x0 + r, a.y0 + s, a.x1 + r, a.y1 + s)
                            }
                        }
                        return e
                    }, i.prototype.getNodeNeighborsBounds = function (t) {
                        if (!t || 0 === this.nodes().length) return new d.Rect(0, 0, 0, 0);
                        for (var e = t.outerBounds.clone().moveBy(t.x, t.y), i = t, n = 0; n < t.links.length; n++) {
                            var r = t.links[n];
                            if (i = r.otherEnd(t), !i.removed) {
                                var s = i.outerBounds,
                                    a = i.x,
                                    o = i.y;
                                e.addBounds(s.x0 + a, s.y0 + o, s.x1 + a, s.y1 + o)
                            }
                        }
                        return e
                    }, i.prototype.placePies = function () {
                        for (var t = 2 * Math.PI, e = [], i = 0, n = this.nodes(); i < n.length; i++) {
                            for (var r = n[i], s = 0, a = 0; a < r.links.length; a++) {
                                var o = r.links[a];
                                o.to === r && o.toPieValue > 0 && (s += o.toPieValue, e.push(o), o._angle = Math.atan2(o.to.y - o.from.y, o.to.x - o.from.x))
                            }
                            if (s > 0) {
                                e.sort(function (t, e) {
                                    return t._angle - e._angle
                                });
                                for (var l = t / s, h = 0, u = 0, c = 0; c < e.length; c++) {
                                    var d = e[c];
                                    d.toPie0 = h, h += d.toPieValue * l, d.toPie1 = h;
                                    var p = d._angle - (d.toPie0 + d.toPie1) / 2;
                                    p < 0 && (p += 2 * Math.PI), u += p
                                }
                                u /= e.length, u -= Math.PI;
                                for (var f = 0; f < e.length; f++) {
                                    var g = e[f];
                                    g.toPie0 += u, g.toPie1 += u
                                }
                                e = []
                            }
                        }
                    }, i
                }(c);
                t.NodesLayer = Z;
                var Y = function (t) {
                    function e(e, i, n) {
                        return t.call(this, e, i, n) || this
                    }
                    return n(e, t), e.prototype.zoomOut = function () {}, e.prototype.zoomOutPossible = function () {
                        return !1
                    }, e.prototype.setSelection = function (t) {
                        for (var e, i = [], n = 0; n < t.length; n++) {
                            var r = t[n];
                            r instanceof h || r instanceof u ? i.push(r) : d.Helpers.isString(r) && (e = this.getNode(r) || this.getLink(r)) ? i.push(e) : this.error("setSelection: Could not find a chart object with the ID `" + r + "`.")
                        }
                        this.scene.setSelection(i) && (this.events.notifySceneChanges({
                            selection: !0
                        }), this.notifySelectionChanged(this.createEventArguments(null, "api")))
                    }, e.prototype.createEventArguments = function (t, e) {
                        var i = null,
                            n = null;
                        if (t && (t.x || t.y)) {
                            var r = this.scene.fromDisplay(t.x, t.y);
                            i = r.x, n = r.y
                        }
                        return {
                            chart: this.api,
                            origin: e,
                            chartX: i,
                            chartY: n,
                            hoverLink: this.scene.hoverLink,
                            hoverNode: this.scene.hoverNode,
                            hoverItem: this.scene.hoverItem,
                            selection: this.scene.selection.slice()
                        }
                    }, e
                }(d.Impl);
                t.Impl = Y
            }(u = i.ItemsChart || (i.ItemsChart = {})),
            function (t) {
                var e, i = t.Gestures || (t.Gestures = {}),
                    r = t.Layouts || (t.Layouts = {}),
                    s = t.Bar || (t.Bar = {});
                ! function (t) {
                    t[t.NodeClass = 0] = "NodeClass", t[t.LinkClass = 1] = "LinkClass", t[t.Aura = 2] = "Aura"
                }(e = t.LegendItemType || (t.LegendItemType = {}));
                var a = function (t) {
                        function e(e, i, n, r, s, a, o, l, h) {
                            var u = t.call(this, i, n, r, s) || this;
                            return u.itemId = e, u.enabled = a, u.node = o, u.link = l, u.aura = h, u
                        }
                        return n(e, t), e
                    }(d.LegendEntry),
                    o = function (t) {
                        function e(e, i) {
                            var n = t.call(this, e, null) || this;
                            return n.halfSize = i, n
                        }
                        return n(e, t), e.prototype.distanceToEdge = function () {
                            return this.halfSize
                        }, e
                    }(u.Shape),
                    l = function (t) {
                        function e(e, i) {
                            var n = t.call(this, null, null, !0) || this;
                            return n.data = {
                                id: null,
                                loaded: !0
                            }, n.hHeight = e, n.hWidth = e, n.renderHheight = e, n.renderHwidth = e, n.x = i ? 2 * -e : e + e / 2, n.y = 0, n.shape = new o(n, e), n
                        }
                        return n(e, t), e
                    }(u.Node),
                    h = function (t) {
                        function e() {
                            var e = t.apply(this, arguments) || this;
                            return e.textColorDisabled = "rgba(64,62,62,0.3)", e.showItemsWithClasses = "any", e
                        }
                        return n(e, t), e
                    }(d.SettingsLegendAdvanced);
                t.SettingsLegendAdvanced = h;
                var c = function (t) {
                    function e() {
                        var e = t.call(this) || this;
                        return e.panel = new d.SettingsLegendPanel("bottom", "left"), e.advanced = new h, e.marker.size = 30, e.padding = 15, e
                    }
                    return n(e, t), e
                }(d.SettingsLegend);
                t.SettingsLegend = c;
                var p = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.paintOrder = 51, e.updateOrder = 100, e.linkClassState = Object.create(null), e.nodeClassState = Object.create(null), e.allNodeClassesEnabled = !0, e.allLinkClassesEnabled = !0, e
                    }
                    return n(e, t), e.prototype.onSceneChange = function (e) {
                        t.prototype.onSceneChange.call(this, e);
                        var i = e.changes.settingsChanges;
                        (e.changes.auras || i && (i.style && (i.style.nodeClasses || i.style.linkClasses) || i.legend && i.legend.text)) && (this.rebuildItems(), e.changes.bounds = !0, e.changes.filters = !0)
                    }, e.prototype.doAnimations = function () {
                        return 1
                    }, e.prototype.paintMarker = function (t, e, i, n, r) {
                        if (r.node) {
                            var s = {
                                geometry: this.getGeometry(e, i, .6),
                                paintDetails: !1
                            };
                            this.chart.renderer.paintNodes(t, [r.node], s, 0)
                        } else if (r.link) {
                            var s = {
                                geometry: this.getGeometry(e, i, 1),
                                paintDetails: !0
                            };
                            this.chart.renderer.paintLinks(t, [r.link], {}, s)
                        } else this.paintAuraMarker(t.context, e, i, n, r.aura)
                    }, e.prototype.paintAuraMarker = function (t, e, i, n, r) {
                        var s = n / 527,
                            a = e - n,
                            o = i - n,
                            l = d.Graphics.beginStrokeAndFill(t, r);
                        l.moveTo(878.4 * s + a, 413.8 * s + o), l.bezierCurveTo(856.4 * s + a, 404.2 * s + o, 817.1 * s + a, 388.9 * s + o, 769.7 * s + a, 378.2 * s + o), l.bezierCurveTo(696.1 * s + a, 361.5 * s + o, 679.5 * s + a, 324.1 * s + o, 676.7 * s + a, 308.7 * s + o), l.bezierCurveTo(674.4 * s + a, 296.1 * s + o, 652.9 * s + a, 188.3 * s + o, 589.9 * s + a, 107 * s + o), l.bezierCurveTo(543 * s + a, 42.5 * s + o, 466.9 * s + a, .6 * s + o, 381 * s + a, .6 * s + o), l.bezierCurveTo(238.4 * s + a, .6 * s + o, 122.8 * s + a, 116.2 * s + o, 122.8 * s + a, 258.8 * s + o), l.bezierCurveTo(122.8 * s + a, 264.7 * s + o, 123 * s + a, 270.5 * s + o, 123.4 * s + a, 276.3 * s + o), l.lineTo(122.8 * s + a, 276.9 * s + o), l.bezierCurveTo(122.8 * s + a, 276.9 * s + o, 127 * s + a, 333.8 * s + o, 136.7 * s + a, 389.3 * s + o), l.bezierCurveTo(146.4 * s + a, 444.8 * s + o, 138.1 * s + a, 500.4 * s + o, 106.2 * s + a, 543.4 * s + o), l.bezierCurveTo(74.3 * s + a, 586.4 * s + o, 2.1 * s + a, 689.2 * s + o, 4.9 * s + a, 754.4 * s + o), l.bezierCurveTo(5 * s + a, 755.9 * s + o, 5.2 * s + a, 757.3 * s + o, 5.4 * s + a, 758.8 * s + o), l.bezierCurveTo(4.1 * s + a, 769.2 * s + o, 3.5 * s + a, 779.8 * s + o, 3.5 * s + a, 790.5 * s + o), l.bezierCurveTo(3.5 * s + a, 933.1 * s + o, 119.1 * s + a, 1048.7 * s + o, 261.7 * s + a, 1048.7 * s + o), l.bezierCurveTo(349.6 * s + a, 1048.7 * s + o, 427.2 * s + a, 1004.7 * s + o, 473.9 * s + a, 937.6 * s + o), l.lineTo(474.1 * s + a, 937.6 * s + o), l.bezierCurveTo(474.1 * s + a, 937.6 * s + o, 510.2 * s + a, 891.8 * s + o, 518.5 * s + a, 884.8 * s + o), l.bezierCurveTo(526.8 * s + a, 877.9 * s + o, 568.5 * s + a, 854.3 * s + o, 608.7 * s + a, 869.5 * s + o), l.bezierCurveTo(631.7 * s + a, 878.2 * s + o, 675.6 * s + a, 894.2 * s + o, 719.1 * s + a, 905 * s + o), l.bezierCurveTo(743.4 * s + a, 912.6 * s + o, 769.3 * s + a, 916.7 * s + o, 796.1 * s + a, 916.7 * s + o), l.bezierCurveTo(938.7 * s + a, 916.7 * s + o, 1054.3 * s + a, 801.1 * s + o, 1054.3 * s + a, 658.5 * s + o), l.bezierCurveTo(1054.3 * s + a, 544.8 * s + o, 980.6 * s + a, 448.1 * s + o, 878.4 * s + a, 413.8 * s + o), l.closePath(), d.Graphics.endStrokeAndFill(t, l, r), l = d.Graphics.beginStrokeAndFill(t, {
                            fillColor: "white"
                        }), l.moveTo(796.1 * s + a, 825.2 * s + o), l.bezierCurveTo(718.8 * s + a, 825.2 * s + o, 653.8 * s + a, 772.6 * s + o, 635 * s + a, 701.2 * s + o), l.lineTo(423.3 * s + a, 750 * s + o), l.bezierCurveTo(426.5 * s + a, 763 * s + o, 428.3 * s + a, 776.5 * s + o, 428.3 * s + a, 790.5 * s + o), l.bezierCurveTo(428.3 * s + a, 882.5 * s + o, 353.7 * s + a, 957.1 * s + o, 261.7 * s + a, 957.1 * s + o), l.bezierCurveTo(169.7 * s + a, 957.1 * s + o, 95.1 * s + a, 882.5 * s + o, 95.1 * s + a, 790.5 * s + o), l.bezierCurveTo(95.1 * s + a, 698.5 * s + o, 169.7 * s + a, 623.9 * s + o, 261.7 * s + a, 623.9 * s + o), l.bezierCurveTo(270.7 * s + a, 623.9 * s + o, 279.4 * s + a, 624.6 * s + o, 288 * s + a, 626 * s + o), l.lineTo(331.2 * s + a, 417.8 * s + o), l.bezierCurveTo(263.6 * s + a, 396.6 * s + o, 214.5 * s + a, 333.4 * s + o, 214.5 * s + a, 258.8 * s + o), l.bezierCurveTo(214.5 * s + a, 166.8 * s + o, 289.1 * s + a, 92.2 * s + o, 381.1 * s + a, 92.2 * s + o), l.bezierCurveTo(473.1 * s + a, 92.2 * s + o, 547.7 * s + a, 166.8 * s + o, 547.7 * s + a, 258.8 * s + o), l.bezierCurveTo(547.7 * s + a, 298.1 * s + o, 534.1 * s + a, 334.1 * s + o, 511.4 * s + a, 362.6 * s + o), l.lineTo(684 * s + a, 535.3 * s + o), l.bezierCurveTo(713.6 * s + a, 508.4 * s + o, 752.9 * s + a, 492 * s + o, 796.1 * s + a, 492 * s + o), l.bezierCurveTo(888.1 * s + a, 492 * s + o, 962.7 * s + a, 566.6 * s + o, 962.7 * s + a, 658.6 * s + o), l.bezierCurveTo(962.7 * s + a, 750.6 * s + o, 888.1 * s + a, 825.2 * s + o, 796.1 * s + a, 825.2 * s + o), l.closePath(), l.moveTo(381 * s + a, 425.4 * s + o), l.bezierCurveTo(374.2 * s + a, 425.4 * s + o, 367.6 * s + a, 425 * s + o, 361 * s + a, 424.2 * s + o), l.lineTo(317.5 * s + a, 633.5 * s + o), l.bezierCurveTo(359.9 * s + a, 648.6 * s + o, 394.3 * s + a, 680.4 * s + o, 413 * s + a, 721 * s + o), l.lineTo(630 * s + a, 671 * s + o), l.bezierCurveTo(629.7 * s + a, 666.9 * s + o, 629.5 * s + a, 662.8 * s + o, 629.5 * s + a, 658.6 * s + o), l.bezierCurveTo(629.5 * s + a, 620.8 * s + o, 642.1 * s + a, 585.9 * s + o, 663.4 * s + a, 557.9 * s + o), l.lineTo(490.2 * s + a, 384.6 * s + o), l.bezierCurveTo(460.9 * s + a, 410 * s + o, 422.8 * s + a, 425.4 * s + o, 381 * s + a, 425.4 * s + o), l.closePath(), d.Graphics.endStrokeAndFill(t, l, {
                            fillColor: "white"
                        })
                    }, e.prototype.rebuildItems = function () {
                        var t = this.chart.scene.settings.style,
                            e = [],
                            i = this.settings.marker.size / 2,
                            n = this.settings.text.fillColor,
                            r = this.settings.advanced.textColorDisabled,
                            s = this.nodeClassState,
                            o = this.linkClassState;
                        this.nodeClassState = Object.create(null), this.linkClassState = Object.create(null), this.allLinkClassesEnabled = !0, this.allNodeClassesEnabled = !0;
                        for (var h = 0; h < t.nodeClasses.length; h++) {
                            var c = t.nodeClasses[h];
                            if (c.showInLegend && null != c.style) {
                                var p = d.Helpers.clone(t.node);
                                d.Helpers.extendStyleTo(c.style, p);
                                var f = new l(i, !1);
                                d.Helpers.extendStyleTo(p, f), this.chart.layer.styleUpdater.postprocessNode(f);
                                var g = !d.Helpers.hasProperty(s, c.className) || s[c.className];
                                this.nodeClassState[c.className] = g, g || (this.allNodeClassesEnabled = !1), e.push(new a(c.className, c.nameLegend || c.className, n, r, c.legendGroupId, g, f, null, null))
                            }
                        }
                        for (var m = 0; m < t.linkClasses.length; m++) {
                            var v = t.linkClasses[m];
                            if (v.showInLegend && null != v.style) {
                                var p = d.Helpers.clone(t.link);
                                d.Helpers.extendStyleTo(v.style, p);
                                var y = new u.Link(null, null);
                                d.Helpers.extendStyleTo(p, y), y.currentRadius = y.radius, y.from = new l(i, !0), y.to = new l(i, !1);
                                var g = !d.Helpers.hasProperty(o, v.className) || o[v.className];
                                this.linkClassState[v.className] = g, this.allLinkClassesEnabled = this.allLinkClassesEnabled && g, e.push(new a(v.className, v.nameLegend || v.className, n, r, v.legendGroupId, g, null, y, null))
                            }
                        }
                        for (var S = this.chart.settings.auras._calculatedStyles, b = Object.keys(S), C = 0; C < b.length; C++) {
                            var x = b[C],
                                w = S[x];
                            w.enabled || (this.allNodeClassesEnabled = !1), (w.showInLegend || null == w.showInLegend) && e.push(new a(x, w.nameLegend || x, n, r, w.legendGroupId, w.enabled, null, null, w))
                        }
                        this.resetEntries(e)
                    }, e.prototype.getGeometry = function (t, e, i) {
                        var n = this.settings.marker.size,
                            r = -n,
                            s = n,
                            a = -n,
                            o = n,
                            l = i,
                            h = i,
                            u = t,
                            c = e,
                            d = t - n,
                            p = t + n,
                            f = e - n,
                            g = e + n;
                        return {
                            txm: l,
                            txa: u,
                            tym: h,
                            tya: c,
                            zoom: i,
                            x0s: d,
                            x1s: p,
                            y0s: f,
                            y1s: g,
                            x0w: r,
                            y0w: a,
                            x1w: s,
                            y1w: o,
                            linkZoom: i
                        }
                    }, e.prototype.itemClicked = function (e, i) {
                        t.prototype.itemClicked.call(this, e, i), this.nodeClassState = Object.create(null), this.linkClassState = Object.create(null), this.allLinkClassesEnabled = !0, this.allNodeClassesEnabled = !0;
                        for (var n = 0; n < this.entries.length; n++) {
                            var r = this.entries[n];
                            if (r.node) this.nodeClassState[r.itemId] = r.enabled, r.enabled || (this.allNodeClassesEnabled = !1);
                            else if (r.link) this.linkClassState[r.itemId] = r.enabled, r.enabled || (this.allLinkClassesEnabled = !1);
                            else {
                                var s = this.chart.settings.auras;
                                s._calculatedStyles[r.itemId].enabled = r.enabled, s.style[r.itemId].enabled = r.enabled, s._defaultStyles[r.itemId].enabled = r.enabled, this.chart.events.notifySceneChanges({
                                    settingsChanges: {
                                        auras: {}
                                    }
                                }), r.enabled || (this.allNodeClassesEnabled = !1)
                            }
                        }
                        this.chart.events.notifySceneChanges({
                            filters: !0
                        })
                    }, e.prototype.isNodeVisible = function (t) {
                        if (this.allNodeClassesEnabled) return !0;
                        var e = t.className,
                            i = t.style ? t.style.aura : null;
                        if (!e && !i) return !0;
                        var n = u.ItemsStyle.getClasses(e),
                            r = Array.isArray(i) ? i : [i],
                            s = this.chart.settings.auras._calculatedStyles;
                        if ("any" === this.settings.advanced.showItemsWithClasses) {
                            for (var a = !1, o = !1, l = 0; l < n.length; l++)
                                if (d.Helpers.hasProperty(this.nodeClassState, n[l])) {
                                    if (this.nodeClassState[n[l]]) {
                                        o = !0;
                                        break
                                    }
                                    a = !0
                                }
                            for (var l = 0; l < r.length; l++)
                                if (d.Helpers.hasProperty(s, r[l])) {
                                    if (s[r[l]].enabled) {
                                        o = !0;
                                        break
                                    }
                                    a = !0
                                }
                            return o || !a
                        }
                        for (var l = 0; l < n.length; l++)
                            if (d.Helpers.hasProperty(this.nodeClassState, n[l]) && !this.nodeClassState[n[l]]) return !1;
                        for (var l = 0; l < r.length; l++)
                            if (d.Helpers.hasProperty(s, r[l]) && !s[r[l]].enabled) return !1;
                        return !0
                    }, e.prototype.isLinkVisible = function (t) {
                        if (this.allLinkClassesEnabled) return !0;
                        var e = t.className;
                        if (!e) return !0;
                        var i = u.ItemsStyle.getClasses(e);
                        if ("any" === this.settings.advanced.showItemsWithClasses) {
                            for (var n = !1, r = !1, s = 0; s < i.length; s++)
                                if (d.Helpers.hasProperty(this.linkClassState, i[s])) {
                                    if (this.linkClassState[i[s]]) {
                                        r = !0;
                                        break
                                    }
                                    n = !0
                                }
                            return r || !n
                        }
                        for (var s = 0; s < i.length; s++)
                            if (d.Helpers.hasProperty(this.linkClassState, i[s]) && !this.linkClassState[i[s]]) return !1;
                        return !0
                    }, e
                }(d.Legend);
                t.Legend = p,
                    function (e) {
                        var i = function (t) {
                            function e(e, i) {
                                var n = t.call(this, e, i) || this;
                                n.scene = e.scene, n.events = e.events;
                                var r = d.Helpers.createDom("li", null, null, null),
                                    s = d.Helpers.createDom("span", "DVSL-NC-zoom", null, r);
                                return n.handle = d.Helpers.createDom("em", null, null, s), n.mouse = new d.MouseEvents(r, n.scene.settings.advanced.pointer), n.mouse.listen("drag", function (t) {
                                    return n.zoomMove(t)
                                }), n.mouse.listen("down", function (t) {
                                    return n.zoomDown(t)
                                }), n.domElement = r, n
                            }
                            return n(e, t), e.prototype.zoomDown = function (t) {
                                t.y < 100 && this.zoomMove(t)
                            }, e.prototype.zoomMove = function (t) {
                                var e = t.y - 10;
                                e = Math.max(0, Math.min(180, e)), this.handle.style.top = e + "px";
                                var i = this.getZoomValue(e / 180);
                                this.chart.autoZoom.manualZoom(i / this.scene.zoom), this.events.notifySceneChanges({
                                    position: !0
                                }), t.consumed = !0
                            }, e.prototype.getSliderPosition = function () {
                                var t = this.scene.settings.interaction.zooming.zoomExtent,
                                    e = Math.min(t[0], this.chart.autoZoom.minimumAutoZoom),
                                    i = t[1],
                                    n = Math.log(Math.max(e, Math.min(i, this.scene.zoom)));
                                return e = Math.log(e), i = Math.log(i), 1 - (n - e) / (i - e)
                            }, e.prototype.getZoomValue = function (t) {
                                var e = this.scene.settings.interaction.zooming.zoomExtent,
                                    i = Math.min(e[0], this.chart.autoZoom.minimumAutoZoom),
                                    n = e[1];
                                i = Math.log(i), n = Math.log(n);
                                var r = (1 - t) * (n - i) + i;
                                return Math.exp(r)
                            }, e.prototype.doAnimations = function (t) {
                                var e = this.getSliderPosition();
                                this.handle.style.top = 180 * e + "px"
                            }, e.prototype.remove = function () {
                                this.mouse.remove()
                            }, e
                        }(d.Bar.Item);
                        e.ZoomControl = i, d.Bar.ToolbarItemNames.zoomControl = d.Bar.ToolbarItemNames.zoomcontrol = function (e, i) {
                            return new t.Bar.ZoomControl(e, i)
                        }, d.Bar.ToolbarItemNames.rearrange = function (t, e) {
                            var i = t.settings.localization.toolbar;
                            e.label = e.label || i.rearrangeButton, e.title = e.title || i.rearrangeTitle, e.cssClass = e.cssClass || "DVSL-bar-btn-rearrange";
                            var n = e.onClick;
                            return e.onClick = function (e, i) {
                                t.resetLayout(), n && n(e, i)
                            }, new d.Bar.Button(t, e)
                        }, d.Bar.ToolbarItemNames.freeze = function (t, e) {
                            var i = t.settings.localization.toolbar;
                            return new d.Bar.ToggleButton(t, e, {
                                labelDisabled: e.label || i.freezeButton,
                                cssClassEnabled: "DVSL-bar-btn-lock-all-active",
                                cssClassDisabled: e.cssClass || "DVSL-bar-btn-lock-all",
                                titleEnabled: i.unfreezeTitle,
                                titleDisabled: i.freezeTitle,
                                getChartState: function () {
                                    return t.isLayoutFrozen
                                },
                                onEnable: function () {
                                    return t.freezeLayout()
                                },
                                onDisable: function () {
                                    return t.unfreezeLayout()
                                }
                            })
                        }, d.Bar.ToolbarItemNames.fit = function (t, e) {
                            // console.log('---------------DVSL-bar-btn-fit--------');
                            // console.log(t);
                            // console.log(e);
                            var i = t.settings.localization.toolbar;
                            return new d.Bar.ToggleButton(t, e, {
                                labelDisabled: e.label || i.fitButton,
                                cssClassEnabled: "DVSL-bar-btn-fit-active",
                                cssClassDisabled: e.cssClass || "DVSL-bar-btn-fit",
                                titleDisabled: e.title || i.fitTitle,
                                getChartState: function () {
                                    return "overview" === t.scene.autoZoomMode
                                },
                                onEnable: function () {
                                    return t.autoZoom.setZoom("overview")
                                },
                                onDisable: function () {
                                    return t.autoZoom.setZoom("auto")
                                }
                            })
                        };
                        var r = function (t) {
                            function e() {
                                var e = t.call(this) || this;
                                return e.zoomControl = !0, e.enabled = !0, e.side = "bottom", e.align = "left", e.showLabels = !1, e.fullscreen = !0, e.export = !1, e.items = [new d.SettingsToolbarItem("fit"), new d.SettingsToolbarItem("rearrange"), new d.SettingsToolbarItem("freeze"), new d.SettingsToolbarItem("back"), new d.SettingsToolbarItem("fullscreen"), new d.SettingsToolbarItem("export"), new d.SettingsToolbarItem("zoomControl", "bottom", "left")], e
                            }
                            return n(e, t), e
                        }(d.SettingsToolbar);
                        e.SettingsToolbar = r;
                        var s = function (t) {
                            function e() {
                                var e = t.apply(this, arguments) || this;
                                return e.rearrangeButton = "Rearrange", e.rearrangeTitle = "Rearrange elements", e.freezeButton = "Freeze", e.freezeTitle = "Lock all", e.unfreezeTitle = "Unlock all", e.fitButton = "Fit", e.fitTitle = "Fit to screen", e
                            }
                            return n(e, t), e
                        }(d.SettingsLocalizationToolbar);
                        e.SettingsLocalizationToolbar = s
                    }(s = t.Bar || (t.Bar = {}));
                var f = function (t) {
                    function e(i) {
                        var n = t.call(this, d.SettingsMapping.NetChartSettings) || this;
                        return n.theme = e.FlatTheme, n.data = [], n.area = new m, n.events = new L, n.style = new w, n.auras = new u.SettingsNodesLayerAuras, n.layout = new x, n.filters = {
                            nodeFilter: null,
                            linkFilter: null,
                            nodeLinksProcessor: null,
                            multilinkProcessor: null
                        }, n.interaction = new v, n.navigation = new b, n.toolbar = new s.SettingsToolbar, n.localization = new g, n.legend = new c, n.nodeMenu.buttons = ["hide", "expand", "focus", "lock"], n.apply(i), n._initializing = !1, n
                    }
                    return n(e, t), e.prototype.apply = function (e) {
                        return this.applyCompatibility(e, [{
                            from: "interaction.zooming.autoZoomPositionEllasticity",
                            to: "interaction.zooming.autoZoomPositionElasticity"
                        }, {
                            from: "navigation.nodeExpansionRadius",
                            to: "navigation.focusNodeExpansionRadius"
                        }, {
                            from: "localization.menu.dynaminc",
                            to: "localization.menu.dynamic"
                        }]), t.prototype.apply.call(this, e)
                    }, e
                }(u.Settings);
                f.FlatTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-flat"
                    }
                }, f.DarkTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-dark"
                    },
                    area: {
                        style: {
                            fillColor: "rgba(28,26,28,.1)"
                        }
                    },
                    title: {
                        margin: 15,
                        style: {
                            fillColor: "#A8A7A8"
                        }
                    },
                    legend: {
                        text: {
                            fillColor: "#A8A7A8"
                        }
                    },
                    style: {
                        node: {
                            fillColor: "gray"
                        },
                        link: {
                            fillColor: "#09c"
                        },
                        linkHovered: {
                            shadowColor: "#09c"
                        },
                        hiddenLinks: {
                            lineColor: "#A8A7A8"
                        },
                        nodeHovered: {
                            shadowColor: "#fff",
                            shadowOffsetY: 0,
                            shadowBlur: 12
                        },
                        nodeLabel: {
                            padding: 4,
                            borderRadius: 10,
                            textStyle: {
                                fillColor: "rgba(180,180,180,1)"
                            },
                            backgroundStyle: {
                                fillColor: "rgba(60,60,60,0.8)",
                                lineColor: null
                            }
                        },
                        linkLabel: {
                            padding: .6,
                            backgroundStyle: {
                                lineColor: "#09c",
                                fillColor: "#333333"
                            },
                            textStyle: {
                                fillColor: "#A8A7A8"
                            }
                        },
                        selection: {
                            fillColor: "white",
                            shadowColor: "rgba(255,255,255,0.6)",
                            sizeConstant: 4,
                            shadowBlur: 24,
                            shadowOffsetY: 4
                        }
                    }
                }, t.Settings = f;
                var g = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.toolbar = new s.SettingsLocalizationToolbar, e.menu = {
                            dynamic: "Pin",
                            fixed: "Unpin",
                            focus: "Focus",
                            unfocus: "Unfocus",
                            collapse: "Collapse",
                            close: "Close",
                            expand: "Expand",
                            hide: "Hide",
                            add: "Add"
                        }, e
                    }
                    return n(e, t), e
                }(d.SettingsLocalization);
                t.SettingsLocalization = g;
                var m = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.centerX = .5, e.centerY = .5, e.paddingTop = 0, e.paddingLeft = 0, e.paddingRight = 0, e.paddingBottom = 0, e
                    }
                    return n(e, t), e
                }(d.SettingsArea);
                t.SettingsArea = m;
                var v = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.zooming = new S, e.selection = new y, e.rotation = {
                            fingers: !1
                        }, e
                    }
                    return n(e, t), e
                }(u.SettingsInteraction);
                t.SettingsInteraction = v;
                var y = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.dragSelect = !0, e
                    }
                    return n(e, t), e
                }(u.SettingsInteractionSelection);
                t.SettingsInteractionSelection = y;
                var S = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.initialAutoZoom = "overview", e.zoomExtent = [.5, 4], e.autoZoomExtent = [null, 1], e.autoZoomSize = .9, e.autoZoomPositionElasticity = 2.5e-7, e
                    }
                    return n(e, t), e
                }(u.SettingsInteractionZooming);
                t.SettingsInteractionZooming = S;
                var b = function () {
                    function t() {
                        this.mode = "showall", this.initialNodes = null, this.focusNodeExpansionRadius = 2, this.focusNodeTailExpansionRadius = null, this.focusAutoFadeout = !1, this.numberOfFocusNodes = 3, this.minNumberOfFocusNodes = 1, this.expandDelay = 0, this.expandOnClick = !0, this.autoZoomOnFocus = !1, this.autoUnfocus = !0
                        // console.log('---------');
                        // console.log(this);
                        // console.log(this.expandOnClick);
                    }
                    return t
                }();
                t.SettingsNavigation = b;
                var C = function () {
                    function t() {
                        this.strength = .01, this.from = "auto", this.fromCenter = "weighted", this.to = "graph", this.toCenter = "weighted"
                    }
                    return t
                }();
                t.GravitySettings = C;
                var x = function () {
                    function t() {
                        this.mode = "dynamic", this.nodeSpacing = 16, this.rowSpacing = null, this.groupSpacing = null, this.incrementalLayoutMaxTime = 300, this.initialLayoutMaxTime = 2e3, this.layoutFreezeTimeout = 1e4, this.layoutFreezeMinTimeout = 1500, this.aspectRatio = !1, this.globalLayoutOnChanges = !0, this.advanced = {
                            adaptiveFreezeTreshold: 1.2
                        }, this.twoRingRadialLayout = !1, this.rotation = 0, this.gravity = new C
                    }
                    return t
                }();
                t.SettingsLayout = x;
                var w = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.dragSelection = {
                            fillColor: "rgba(30,160,220,0.15)",
                            lineColor: "#000000",
                            lineWidth: 1,
                            lineDash: [1, 2]
                        }, e
                    }
                    return n(e, t), e
                }(u.SettingsNodesLayerStyle);
                t.SettingsStyle = w;
                var L = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.onPointerDown = null, e.onPointerUp = null, e.onPointerDrag = null, e.onPointerMove = null, e.onDataUpdated = null, e
                    }
                    return n(e, t), e
                }(d.SettingsEvents);
                t.SettingsEvents = L;
                var T = function (t) {
                    function e() {
                        return t.apply(this, arguments) || this
                    }
                    return n(e, t), e
                }(u.Scene);
                t.Scene = T,
                    function (t) {
                        function e(t) {
                            if (0 === t.children.length) return 0;
                            var e = t.children[0],
                                i = t.children[t.children.length - 1];
                            return (e.node.x - e.hWidth + (i.node.x + i.hWidth)) / 2
                        }

                        function i(t, e, i, n, r) {
                            null == e && (t[0].node.x = 0, e = t[0]);
                            for (var s = e.levelIndex + 1, a = null === i ? t.length : i.levelIndex, o = e.node.x + e.hWidth, l = s; l < a; l++) {
                                var h = t[l];
                                o += h.hWidth + (null == t[l].parent || t[l - 1].parent !== t[l].parent ? r : n), h.node.x = o, o += h.hWidth
                            }
                        }
                        var r = function () {
                                function t() {
                                    this.forceLinkList = null, this.fx = 0, this.fy = 0, this.sizeEstimate = 0, this.left = null, this.right = null, this.leafCount = 0, this.leaves = null, this.x = 0, this.y = 0, this.z = 0, this.r = 1, this.repulsiveForceX = 0, this.repulsiveForceY = 0, this.repulsiveForceZ = 0
                                }
                                return t
                            }(),
                            s = function () {
                                function t() {
                                    this.maxLeafCount = 5, this.root = null, this.freeNodeRoot = null, this.temperature = 0, this.nodeCount = 0
                                }
                                return t._swap = function (t, e, i) {
                                    var n = t[e];
                                    t[e] = t[i], t[i] = n
                                }, t.prototype.buildTree = function (t) {
                                    this.iters = 0;
                                    var e = t.length;
                                    this.root && this.freeNode(this.root), this.root = this.newNode(), e > 0 && this.buildTreeRecursive(t, 0, e, this.root);
                                    for (var i = 0; i <= e - 1; i++) t[i].repulsiveForceX = 0, t[i].repulsiveForceY = 0, t[i].repulsiveForceZ = 0;
                                    this.calculateForces()
                                }, t.prototype.freeNode = function (t) {
                                    t.left && this.freeNode(t.left), t.right && this.freeNode(t.right), t.left = this.freeNodeRoot, this.freeNodeRoot = t
                                }, t.prototype.newNode = function () {
                                    var t;
                                    return this.freeNodeRoot ? (t = this.freeNodeRoot, this.freeNodeRoot = t.left, t.left = null, t.right = null, t.leafCount = 0, t.sizeEstimate = 0, t.forceLinkList.length = 0) : (t = new r, t.forceLinkList = [], t.leaves = new Array(this.maxLeafCount)), t.repulsiveForceX = 0, t.repulsiveForceY = 0, t.repulsiveForceZ = 0, t
                                }, t.prototype.addForceLink = function (t, e) {
                                    t.forceLinkList.push(e)
                                }, t.prototype.getMedianX = function (e, i, n) {
                                    n -= 1;
                                    for (var r = (i + n) / 2 | 0;;) {
                                        if (n <= i) return r;
                                        if (n === i + 1 && e[i].x > e[n].x) return t._swap(e, i, n), r;
                                        var s = (i + n) / 2 | 0;
                                        e[s].x > e[n].x && t._swap(e, s, n), e[i].x > e[n].x && t._swap(e, i, n), e[s].x > e[i].x && t._swap(e, s, i), t._swap(e, s, i + 1);
                                        for (var a = i + 1, o = n;;) {
                                            for (;;)
                                                if (a += 1, !(e[i].x > e[a].x)) break;
                                            for (;;)
                                                if (o -= 1, !(e[o].x > e[i].x)) break;
                                            if (o < a) break;
                                            var l = e[a];
                                            e[a] = e[o], e[o] = l
                                        }
                                        t._swap(e, i, o), o <= r && (i = a), o >= r && (n = o - 1)
                                    }
                                }, t.prototype.getMedianY = function (e, i, n) {
                                    n -= 1;
                                    for (var r = (i + n) / 2 | 0;;) {
                                        if (n <= i) return r;
                                        if (n === i + 1) return e[i].y > e[n].y && t._swap(e, i, n), r;
                                        var s = (i + n) / 2 | 0;
                                        e[s].y > e[n].y && t._swap(e, s, n), e[i].y > e[n].y && t._swap(e, i, n), e[s].y > e[i].y && t._swap(e, s, i), t._swap(e, s, i + 1);
                                        for (var a = i + 1, o = n;;) {
                                            for (;;)
                                                if (a += 1, !(e[i].y > e[a].y)) break;
                                            for (;;)
                                                if (o -= 1, !(e[o].y > e[i].y)) break;
                                            if (o < a) break;
                                            var l = e[a];
                                            e[a] = e[o], e[o] = l
                                        }
                                        t._swap(e, i, o), o <= r && (i = a), o >= r && (n = o - 1)
                                    }
                                }, t.prototype.buildTreeRecursive = function (t, e, i, n) {
                                    for (var r = t[e].x, s = t[e].y, a = r, o = s, l = e + 1; l < i; l++) {
                                        var h = t[l],
                                            u = h.x,
                                            c = h.y;
                                        u < r && (r = u), u > a && (a = u), c < s && (s = c), c > o && (o = c)
                                    }
                                    n.sizeEstimate = Math.max(a - r, o - s), n.sizeEstimate = n.sizeEstimate * n.sizeEstimate + .1, n.sizeEstimate *= 2;
                                    var d = i - e;
                                    if (d <= this.maxLeafCount) {
                                        n.leafCount = d;
                                        for (var u = 0, c = 0, p = 0, f = 0, l = 0; l < d; l++) {
                                            var g = t[l + e];
                                            u += g.x, c += g.y, p += g.z, f += g.r, n.leaves[l] = g
                                        }
                                        var m = 1 / d;
                                        return n.r = f, n.x = u * m, n.y = c * m, void(n.z = p * m)
                                    }
                                    var v;
                                    v = a - r > o - s ? this.getMedianX(t, e, i) : this.getMedianY(t, e, i), v++;
                                    var y = this.newNode();
                                    n.left = y, this.buildTreeRecursive(t, e, v, y), y = this.newNode(), n.right = y, this.buildTreeRecursive(t, v, i, y);
                                    var S = 1 / d;
                                    n.r = n.right.r + n.left.r, n.x = (n.left.x * (v - e) + n.right.x * (i - v)) * S, n.y = (n.left.y * (v - e) + n.right.y * (i - v)) * S, n.z = (n.left.z * (v - e) + n.right.z * (i - v)) * S
                                }, t.prototype.calculateForces = function () {
                                    var t = new Array(this.nodeCount),
                                        e = 0,
                                        i = 0;
                                    for (null !== this.root.left ? (t[i] = this.root.left, i++, t[i] = this.root.right, i++, this.addForceLink(this.root.left, this.root.right)) : (t[i] = this.root, i++); e < i;) {
                                        var n = t[e];
                                        e++;
                                        var r = 1 / n.r;
                                        if (null !== n.left) {
                                            this.processTreeNode(n, n.left), this.processTreeNode(n, n.right), t[i] = n.left, i++, t[i] = n.right, i++;
                                            var s = n.left.r * r,
                                                a = n.repulsiveForceX * s,
                                                o = n.repulsiveForceY * s;
                                            n.left.repulsiveForceX += a, n.left.repulsiveForceY += o, n.right.repulsiveForceX += n.repulsiveForceX - a, n.right.repulsiveForceY += n.repulsiveForceY - o, this.addForceLink(n.left, n.right)
                                        } else
                                            for (var l = 0; l <= n.leafCount - 1; l++) {
                                                var h = n.leaves[l];
                                                this.processLeafNode(n, h);
                                                var s = h.r * r;
                                                h.repulsiveForceX += n.repulsiveForceX * s, h.repulsiveForceY += n.repulsiveForceY * s;
                                                for (var u = l + 1; u <= n.leafCount - 1; u++) {
                                                    var c = n.leaves[u];
                                                    this.forceBetweenParticles(h, c)
                                                }
                                            }
                                        n.forceLinkList.length = 0
                                    }
                                }, t.prototype.processTreeNode = function (t, e) {
                                    for (var i = t.forceLinkList.length, n = 0; n < i; n++) {
                                        var s = t.forceLinkList[n],
                                            a = e.x - s.x,
                                            o = e.y - s.y,
                                            l = a * a + o * o,
                                            h = e.sizeEstimate;
                                        if (s instanceof r && (h += s.sizeEstimate), h < l) {
                                            var u = e.r * s.r / (l * Math.sqrt(l)),
                                                c = a * u;
                                            e.repulsiveForceX += c, s.repulsiveForceX -= c;
                                            var d = o * u;
                                            e.repulsiveForceY += d, s.repulsiveForceY -= d
                                        } else s instanceof r ? this.addForceLink(s, e) : this.addForceLink(e, s)
                                    }
                                }, t.prototype.processLeafNode = function (t, e) {
                                    for (var i = 0; i < t.forceLinkList.length; i++) {
                                        var n = t.forceLinkList[i];
                                        if (n instanceof r) {
                                            var s = e.x - n.x,
                                                a = e.y - n.y,
                                                o = s * s + a * a,
                                                l = n.sizeEstimate;
                                            if (l < o) {
                                                var h = e.r * n.r / (o * Math.sqrt(o)),
                                                    u = s * h;
                                                e.repulsiveForceX += u, n.repulsiveForceX -= u;
                                                var c = a * h;
                                                e.repulsiveForceY += c, n.repulsiveForceY -= c
                                            } else this.addForceLink(n, e)
                                        } else this.forceBetweenParticles(e, n)
                                    }
                                }, t.prototype.forceBetweenParticles = function (t, e) {
                                    var i, n = t.x - e.x,
                                        r = t.y - e.y,
                                        s = t.z - e.z,
                                        a = n * n + r * r + s * s,
                                        o = t.r + e.r;
                                    i = a * this.temperature < o ? .25 * this.temperature * Math.sqrt(this.temperature * o) : .25 * o * o / (a * Math.sqrt(a)), t.repulsiveForceX += n * i, e.repulsiveForceX -= n * i, t.repulsiveForceY += r * i, e.repulsiveForceY -= r * i, t.repulsiveForceZ += s * i, e.repulsiveForceZ -= s * i
                                }, t
                            }();
                        t.BHTree = s;
                        var a = function (t) {
                            function e(e) {
                                var i = t.call(this) || this;
                                return i.animationOrder = 600, i.paintOrder = 10, i.updateOrder = 1600, i.chart = e, i
                            }
                            return n(e, t), e.ConstructLayout = function (t) {
                                switch (t.settings.layout.mode) {
                                    case "dynamic":
                                        return new y(t);
                                    case "radial":
                                        return new S(t);
                                    case "hierarchy":
                                        return new C(t);
                                    case "static":
                                        return new x(t);
                                    default:
                                        return t.error("Unknown layout mode: '" + t.settings.layout.mode + "'"), new y(t)
                                }
                            }, e
                        }(d.ChartElement);
                        t.LayoutBase = a;
                        var o = function () {
                                function t(t, e) {
                                    this.strength = t, this.nodes = e
                                }
                                return t.prototype.filterLockedNodes = function (t) {
                                    for (var e = new Array(t.length), i = 0, n = 0; n < t.length; n++) t[n].layerNode.locked && (e[i++] = t[n]);
                                    return e.length = i, e
                                }, t.prototype.filterUnlockedNodes = function (t) {
                                    for (var e = new Array(t.length), i = 0, n = 0; n < t.length; n++) t[n].layerNode.locked || (e[i++] = t[n]);
                                    return e.length = i, e
                                }, t
                            }(),
                            l = function (t) {
                                function e(e, i) {
                                    var n = t.call(this, e, i) || this;
                                    return n.clusters = n.calculateClusters(i), n
                                }
                                return n(e, t), e.prototype.calculateClusters = function (t) {
                                    for (var e = [], i = new Array(t.length), n = new Object(null), r = 0; r < t.length; r++) {
                                        var s = t[r],
                                            a = s.layerNode.id;
                                        if (!n[a]) {
                                            var o = [s];
                                            e.push(o), n[a] = !0;
                                            var l = 0,
                                                h = 0;
                                            for (i[h] = s, h++; l < h;) {
                                                s = i[l], l++;
                                                for (var u = 0; u < s.edges.length; u++) {
                                                    var c = s.edges[u],
                                                        d = c.to,
                                                        p = d.layerNode.id;
                                                    n[p] || (n[p] = !0, o.push(d), i[h] = d, h++)
                                                }
                                            }
                                        }
                                    }
                                    return e
                                }, e
                            }(o),
                            h = function (t) {
                                function e(e, i, n, r) {
                                    var s = t.call(this, e, i) || this;
                                    return s.toCenter = n, s.lockedOnly = r, s
                                }
                                return n(e, t), e.prototype.recalculate = function () {
                                    for (var t = 0; t < this.clusters.length; t++)
                                        for (var e = this.clusters[t], i = this.lockedOnly ? this.toCenter(this.filterLockedNodes(e)) : this.toCenter(e), n = 0; n < e.length; n++) {
                                            var r = e[n];
                                            r.layerNode.userLock || (r.gravityForceX = (i.x - r.x) * this.strength, r.gravityForceY = (i.y - r.y) * this.strength)
                                        }
                                }, e
                            }(l),
                            u = function (t) {
                                function e(e, i, n, r) {
                                    var s = t.call(this, e, i) || this;
                                    return s.toCenter = n, s.lockedOnly = r, s
                                }
                                return n(e, t), e.prototype.recalculate = function () {
                                    for (var t = this.lockedOnly ? this.toCenter(this.filterLockedNodes(this.nodes)) : this.toCenter(this.nodes), e = 0; e < this.nodes.length; e++) {
                                        var i = this.nodes[e];
                                        i.layerNode.userLock || (i.gravityForceX = (t.x - i.x) * this.strength, i.gravityForceY = (t.y - i.y) * this.strength)
                                    }
                                }, e
                            }(o),
                            c = function (t) {
                                function e(e, i, n, r, s) {
                                    var a = t.call(this, e, i) || this;
                                    return a.fromCenter = n, a.toCenter = r, a.lockedOnly = s, a
                                }
                                return n(e, t), e.prototype.recalculate = function () {
                                    for (var t = 0; t < this.clusters.length; t++) {
                                        var e = this.clusters[t],
                                            i = this.filterUnlockedNodes(e);
                                        if (!(i.length < 1)) {
                                            var n = this.fromCenter(i),
                                                r = void 0;
                                            if (this.lockedOnly) {
                                                var s = this.filterLockedNodes(e);
                                                r = s.length < 1 ? this.toCenter(e) : this.toCenter(s)
                                            } else r = this.toCenter(e);
                                            if (r.x !== n.x || r.y !== n.y)
                                                for (var a = Math.min(10, Math.sqrt(i.length)) * this.strength, o = (r.x - n.x) * a, l = (r.y - n.y) * a, h = 0; h < e.length; h++) {
                                                    var u = e[h];
                                                    u.gravityForceX = o, u.gravityForceY = l
                                                }
                                        }
                                    }
                                }, e
                            }(l),
                            p = function (t) {
                                function e(e, i, n, r, s) {
                                    var a = t.call(this, e, i) || this;
                                    return a.fromCenter = n, a.toCenter = r, a.lockedOnly = s, a
                                }
                                return n(e, t), e.prototype.recalculate = function () {
                                    var t;
                                    if (this.lockedOnly) {
                                        var e = this.filterLockedNodes(this.nodes);
                                        t = e.length < 1 ? this.toCenter(this.nodes) : this.toCenter(e)
                                    } else t = this.toCenter(this.nodes);
                                    for (var i = 0; i < this.clusters.length; i++) {
                                        var n = this.clusters[i],
                                            r = this.filterUnlockedNodes(n);
                                        if (!(r.length < 1)) {
                                            var s = this.fromCenter(r);
                                            if (t.x !== s.x || t.y !== s.y)
                                                for (var a = Math.min(10, Math.sqrt(r.length)) * this.strength, o = (t.x - s.x) * a, l = (t.y - s.y) * a, h = 0; h < n.length; h++) {
                                                    var u = n[h];
                                                    u.gravityForceX = o, u.gravityForceY = l
                                                }
                                        }
                                    }
                                }, e
                            }(l),
                            f = function (t) {
                                function e() {
                                    return t.apply(this, arguments) || this
                                }
                                return n(e, t), e.prototype.recalculate = function () {
                                    for (var t = new Object(null), e = new Array(this.nodes.length), i = 0, n = 0, r = 0; r < this.nodes.length; r++) {
                                        var s = this.nodes[r];
                                        s.layerNode.userLock && (e[n++] = s, t[s.layerNode.id] = s)
                                    }
                                    for (; i < n;)
                                        for (var s = e[i++], a = t[s.layerNode.id], r = 0; r < s.edges.length; r++) {
                                            var o = s.edges[r].to;
                                            t[o.layerNode.id] || (t[o.layerNode.id] = a, e[n++] = o)
                                        }
                                    for (var l = null, r = 0; r < this.nodes.length; r++) {
                                        var s = this.nodes[r];
                                        if (!s.layerNode.userLock) {
                                            var h = t[s.layerNode.id];
                                            h ? (s.gravityForceX = (h.x - s.x) * this.strength, s.gravityForceY = (h.y - s.y) * this.strength) : (null == l && (l = d.Geometry.findWeightedCenter(this.nodes)), s.gravityForceX = (l.x - s.x) * this.strength, s.gravityForceY = (l.y - s.y) * this.strength)
                                        }
                                    }
                                }, e
                            }(o),
                            g = function () {
                                function t(t) {
                                    this._needsReset = !0, this._calculation = null, this._chart = t
                                }
                                return t.prototype.reset = function () {
                                    this._needsReset = !0
                                }, t.prototype.guessBestMode = function (t) {
                                    if (t.length < 1) return "node";
                                    var e = new Object(null),
                                        i = new Array(t.length),
                                        n = 0,
                                        r = 1;
                                    for (e[t[0].layerNode.id] = !0, i[0] = t[0]; n < r;)
                                        for (var s = i[n++], a = 0; a < s.edges.length; a++) {
                                            var o = s.edges[a].to;
                                            e[o.layerNode.id] || (e[o.layerNode.id] = !0, i[r++] = o)
                                        }
                                    return r < t.length ? "node" : "cluster"
                                }, t.prototype.resetCalculation = function (t) {
                                    var e = this._chart.settings.layout.gravity;
                                    if (this._calculation = null, 0 !== e.strength) {
                                        var i = e.from;
                                        if ("nearestLockedNode" === e.to) return void("node" !== i && "auto" !== i || (this._calculation = new f(e.strength, t)));
                                        var n = "weighted" === e.toCenter ? d.Geometry.findWeightedCenter : d.Geometry.circumscribeCircle;
                                        if ("auto" === i && (i = this.guessBestMode(t)), "cluster" === i) {
                                            var r = "weighted" === e.fromCenter ? d.Geometry.findWeightedCenter : d.Geometry.circumscribeCircle;
                                            "cluster" === e.to ? this._calculation = new c(e.strength, t, r, n, !1) : "clusterLockedNodes" === e.to ? this._calculation = new c(e.strength, t, r, n, !0) : "graph" === e.to ? this._calculation = new p(e.strength, t, r, n, !1) : "graphLockedNodes" === e.to && (this._calculation = new p(e.strength, t, r, n, !0))
                                        } else "node" === i && ("cluster" === e.to ? this._calculation = new h(e.strength, t, n, !1) : "clusterLockedNodes" === e.to ? this._calculation = new h(e.strength, t, n, !0) : "graph" === e.to ? this._calculation = new u(e.strength, t, n, !1) : "graphLockedNodes" === e.to && (this._calculation = new u(e.strength, t, n, !0)))
                                    }
                                }, t.prototype.recalculate = function (t) {
                                    t.length < 2 || (this._needsReset && (this.resetCalculation(t), this._needsReset = !1), this._calculation && this._calculation.recalculate())
                                }, t
                            }();
                        t.Gravity = g;
                        var m = function () {
                                function t(t, e, i) {
                                    this.pair = null, this.K = null, this.len = null, this.strength = null, this.visibility = null, this.to = t, this.direction = e, this.links = i
                                }
                                return t
                            }(),
                            v = function () {
                                function t() {
                                    this.layerNode = null, this.x = 0, this.y = 0, this.z = 0, this.r = 1, this.zattr = 1, this.repulsiveForceX = 0, this.repulsiveForceY = 0, this.repulsiveForceZ = 0, this.gravityForceX = 0, this.gravityForceY = 0, this.forceX = null, this.forceY = null, this.forceZ = null, this.forceSum = null, this.oldForceX = null, this.oldForceY = null, this.oldForceZ = null, this.locked = !1, this.offsetX = 0, this.offsetY = 0, this.minr = 0, this.fsum = 0, this.edges = []
                                }
                                return t
                            }(),
                            y = function (t) {
                                function e(e) {
                                    var i = t.call(this, e) || this;
                                    return i.enableDebugState = !1, i.debugState = [], i.nodeRepulsionFactor = 15, i.linkForceFactor = .2, i.nodeDegreeModifier = 1, i.forceReductionFactor = 1, i.random = new d.Random(1), i.nodeCount = 0, i.nodes = [], i.edges = [], i.nodesAspect = 1, i.idToNode = {}, i.temperature = 0, i.unitTemperature = 0, i.randomLayoutRadius = 0, i.zAxisAttraction = 1, i.repulsiveForceTree = new s, i.aspectRatio = null, i.idleSince = 0, i.noMovementSince = 0, i.layoutMovement = 0, i.gravity = null, i.gravity = new g(e), i
                                }
                                return n(e, t), e.prototype.updateGraph = function (t, e, i) {
                                    (i || t.length !== this.nodeCount) && (this.rebuildGraph(t, e), i = !0);
                                    for (var n = 0; n < this.edges.length; n++) {
                                        for (var r = this.edges[n], s = r.links, a = 0; a < s.length; a++) {
                                            var o = s[a],
                                                l = o.targetStrength,
                                                h = o.targetLength,
                                                u = o.visibility;
                                            if (o.added) {
                                                var c = o.from.links.length > 1 && o.to.links.length > 1,
                                                    d = c || o.removed ? .2 : l;
                                                h = .2 + (h - .2) * u, l = l * u + d * (1 - u)
                                            }
                                            0 === a ? (r.strength = l, r.len = h, r.visibility = u) : (r.strength = Math.max(l, r.strength), r.len = Math.max(h, r.len), r.visibility = Math.max(u, r.visibility))
                                        }
                                        r.pair.strength = r.strength, r.pair.len = r.len, r.pair.visibility = r.visibility, r.K = r.pair.K = 0
                                    }
                                    for (var p = this.chart.settings.layout.nodeSpacing / 2, n = 0; n < t.length; n++) {
                                        var f = this.nodes[n],
                                            g = f.layerNode,
                                            m = g.outerBounds.w(),
                                            v = g.outerBounds.h();
                                        f.offsetX = g.outerBounds.x0 + g.outerBounds.x1, f.offsetY = g.outerBounds.y0 + g.outerBounds.y1, f.x = g.x + f.offsetX, f.y = g.y + f.offsetY, f.zattr = g.visibility, f.locked = g.locked, f.forceX = 0, f.forceY = 0, f.forceZ = 0, f.forceSum = 0;
                                        for (var y = 0, S = 0; S < f.edges.length; S++) {
                                            var b = f.edges[S];
                                            y += b.to.edges.length * b.visibility
                                        }
                                        var C = Math.sqrt(y);
                                        f.r = .5 * Math.max(1, m) + p, f.minr = Math.max(1, (v + .5 * m) / 3) + p, C > 4 && (f.r += (C - 4) * f.r / 4 * this.nodeDegreeModifier, f.minr += (C - 4) * f.minr / 4 * this.nodeDegreeModifier)
                                    }
                                    for (var x = 0, w = 0, L = 0, n = 0; n < this.nodes.length; n++) {
                                        for (var f = this.nodes[n], T = 0, a = 0; a < f.edges.length; a++) {
                                            var b = f.edges[a],
                                                k = b.to;
                                            if (!(f.locked && k.locked || f === k)) {
                                                L++;
                                                var A = f.minr + k.minr;
                                                b.len > 0 ? (b.len = Math.max(1, A * b.len), b.K = 30 * Math.min(20, b.strength) / b.len, T += b.K, x += b.len) : (b.K = b.strength, T += b.K, x += A)
                                            }
                                        }
                                        f.fsum = T, w += f.r * f.r
                                    }
                                    L > 0 ? (this.randomLayoutRadius = Math.max(1, x / 10), this.unitTemperature = x / (50 * L)) : (this.randomLayoutRadius = Math.max(1, Math.sqrt(w)), this.unitTemperature = 1), i && this.saveDebugState("updateGraph: Graph rebuilt.")
                                }, e.prototype.rebuildGraph = function (t, e) {
                                    var i = this.idToNode;
                                    this.nodeCount = t.length, this.nodes = new Array(this.nodeCount), this.idToNode = {};
                                    for (var n = 0, r = 0, s = 0; s < t.length; s++) {
                                        var a = t[s],
                                            o = a.id,
                                            l = new v;
                                        l.layerNode = a;
                                        var h = a.outerBounds.w(),
                                            u = a.outerBounds.h();
                                        if (u > 0 && (n += u / h, r += 1), this.idToNode[o] = l, this.nodes[s] = l, d.Helpers.hasProperty(i, o)) {
                                            var c = i[o];
                                            l.z = c.z, l.oldForceX = c.oldForceX, l.oldForceY = c.oldForceY, l.oldForceZ = c.oldForceZ
                                        } else l.oldForceX = 0, l.oldForceY = 0, l.oldForceZ = 0
                                    }
                                    r > 0 ? this.nodesAspect = Math.max(.3, n / r) : this.nodesAspect = 1;
                                    var p = {},
                                        f = {
                                            U: "D",
                                            null: null,
                                            D: "U",
                                            L: "R",
                                            R: "L"
                                        };
                                    this.edges = [];
                                    for (var s = 0; s < e.length; s++) {
                                        var g = e[s],
                                            y = g.multiId;
                                        if (d.Helpers.hasProperty(p, y)) p[y].push(g);
                                        else {
                                            var S = this.idToNode[g.from.id],
                                                b = this.idToNode[g.to.id],
                                                C = [g],
                                                x = new m(b, g.direction, C),
                                                w = new m(S, f[g.direction], C);
                                            x.pair = w, w.pair = x, p[y] = C, S.edges.push(x), b.edges.push(w), this.edges.push(x)
                                        }
                                    }
                                    this.gravity.reset()
                                }, e.prototype.saveDebugState = function (t) {
                                    this.enableDebugState && this.debugState.push({
                                        extra: {
                                            comment: t
                                        },
                                        nodes: this.nodes.map(function (t) {
                                            return {
                                                id: t.layerNode.id,
                                                x: t.x - t.offsetX,
                                                y: t.y - t.offsetY,
                                                style: t.layerNode.data.style,
                                                extra: t.layerNode.data.extra,
                                                loaded: !0
                                            }
                                        }),
                                        links: this.edges.map(function (t) {
                                            return {
                                                from: t.to.layerNode.id,
                                                to: t.pair.to.layerNode.id
                                            }
                                        })
                                    })
                                }, e.prototype.globalLayout = function (t, e) {
                                    if (!(this.nodeCount <= 0)) {
                                        if (e) {
                                            if (1 === this.nodeCount) return this.nodes[0].locked || (this.nodes[0].layerNode.x = this.nodes[0].layerNode.y = 0), void this.saveDebugState("globalLayout: resetPositions");
                                            this.initialRandomLayout(), this.saveDebugState("globalLayout: resetPositions")
                                        }
                                        for (var i = 0, n = 0; n < this.nodes.length; n++) {
                                            var r = this.nodes[n];
                                            r.locked || i++
                                        }
                                        var s = Math.floor(Math.sqrt(i) + 10),
                                            a = 2 * s;
                                        this.forceReductionFactor = 1, this.temperature = (2 * Math.sqrt(i) + 20) * this.unitTemperature, this.zAxisAttraction = .02;
                                        for (var o = d.Helpers.performanceNow(), l = 3; this.temperature > this.unitTemperature && (a-- <= 0 && (a = 3 * s / l++, this.temperature = this.temperature / 1.5 - .5, this.temperature < 20 * this.unitTemperature && (this.zAxisAttraction = 1.5 * this.zAxisAttraction + .02)), this.randomnodesForRepulsion(), this.repulsiveForceTree.temperature = 1.75 * this.zAxisAttraction, this.repulsiveForceTree.buildTree(this.nodes), this.moveNodesGlobal(), this.saveDebugState("globalLayout: iteration"), !(d.Helpers.performanceNow() > o + t)););
                                        e && (this.centerNodes(), this.saveDebugState("globalLayout: centerNodes")), this.storeNodes()
                                    }
                                }, e.prototype.initialRandomLayout = function () {
                                    for (var t = this.nodeCount, e = new Array(t), i = 0; i <= t - 1; i++) e[i] = this.nodes[i];
                                    for (var i = 0; i < t; i++) {
                                        var n = Math.floor(this.random.get() * (t - i)) + i,
                                            r = e[i];
                                        e[i] = e[n], e[n] = r
                                    }
                                    for (var s = this.randomLayoutRadius, a = 2 * Math.PI / this.nodeCount, o = 0; o < t; o++) {
                                        var l = e[o];
                                        if (l.oldForceX = 0, l.oldForceY = 0, l.oldForceZ = 0, l.z = this.random.get() - .5, !l.locked) {
                                            var h = s + l.r;
                                            l.x = h * Math.cos(o * a), l.y = h * Math.sin(o * a)
                                        }
                                    }
                                }, e.prototype.timedLayout = function (t) {
                                    if (!(this.nodeCount <= 1) && t > 0) {
                                        var e = 0;
                                        t < .1 ? (e = 2, this.forceReductionFactor = Math.max(.002, Math.min(this.forceReductionFactor, 10 * t))) : e = Math.min(6, Math.round(2 + 10 * t)), this.zAxisAttraction = this.nodeRepulsionFactor / 28, this.temperature = this.unitTemperature;
                                        for (var i = 0; i <= e - 1; i++) this.randomnodesForRepulsion(), this.applyAspect(1 / this.nodesAspect), this.repulsiveForceTree.temperature = 1.75 * this.zAxisAttraction, this.repulsiveForceTree.buildTree(this.nodes), this.applyAspect(this.nodesAspect), this.moveNodesIncremental(), this.saveDebugState("timedLayout: iteration");
                                        this.storeNodes()
                                    }
                                }, e.prototype.prepareAspectRatio = function (t) {
                                    for (var e, i, n, r, s, a, o, l = this.nodes, h = l[0].x, u = l[0].y, c = h, d = u, p = !0, f = 1; f <= this.nodeCount - 1; f++) h = Math.min(h, l[f].x), c = Math.max(c, l[f].x), u = Math.min(u, l[f].y), d = Math.max(d, l[f].y);
                                    var g = (h + c) / 2,
                                        m = (u + d) / 2,
                                        v = c - h,
                                        y = d - u;
                                    return 0 === v || 0 === y ? p = !1 : (e = Math.sqrt(this.aspectRatio), i = Math.sqrt(v * y), n = i * e / v, r = i / e / y, n = t * n + (1 - t), r = t * r + (1 - t), s = g - g * n, a = m - m * r, o = 1 / this.forceReductionFactor), {
                                        scaleX: n,
                                        incX: s,
                                        scaleY: r,
                                        incY: a,
                                        invForce: o,
                                        aspectRatioPrepared: p
                                    }
                                }, e.prototype.updateAspectRatioNode = function (t, e) {
                                    e.forceX += (e.x * (t.scaleX - 1) + t.incX) * t.invForce, e.forceY += (e.y * (t.scaleY - 1) + t.incY) * t.invForce
                                }, e.prototype.updateAspectRatio = function (t) {
                                    for (var e = this.prepareAspectRatio(t), i = this.nodes, n = 0; n <= this.nodeCount - 1; n++) this.updateAspectRatioNode(e, i[n])
                                }, e.prototype.moveNodesGlobal = function () {
                                    this.gravity.recalculate(this.nodes);
                                    var t, e = .5 * this.temperature,
                                        i = this.forceReductionFactor;
                                    this.aspectRatio && (t = this.prepareAspectRatio(.005), t.aspectRatioPrepared || (this.aspectRatio = null));
                                    for (var n = 0; n <= this.nodeCount - 1; n++) {
                                        var r = this.nodes[n];
                                        if (!r.locked) {
                                            this.calculateForce(r, .5), this.aspectRatio && this.updateAspectRatioNode(t, r);
                                            var s = r.oldForceX = r.forceX,
                                                a = r.oldForceY = r.forceY,
                                                o = r.oldForceZ = r.forceZ,
                                                l = r.forceSum;
                                            s *= l, a *= l, o *= l;
                                            var h = s * s + a * a + o * o;
                                            h < this.temperature * this.temperature && h > .001 && (h = this.temperature / Math.sqrt(h), s *= h, a *= h, o *= h), r.x += s * i + (this.random.get() - .5) * e, r.y += a * i + (this.random.get() - .5) * e, r.z += o * i + (this.random.get() - .5) * e
                                        }
                                    }
                                }, e.prototype.moveNodesIncremental = function () {
                                    this.gravity.recalculate(this.nodes);
                                    for (var t = 0; t <= this.nodeCount - 1; t++) this.nodes[t].locked || this.calculateForce(this.nodes[t], 0);
                                    if (this.aspectRatio) {
                                        var e = Math.min(.4, .5 / Math.pow(this.nodeCount, .5));
                                        this.updateAspectRatio(e)
                                    }
                                    for (var i = 0, n = 0, r = 0, s = 0, a = new Array(this.nodeCount), t = 0; t <= this.nodeCount - 1; t++) {
                                        var o = this.nodes[t];
                                        if (!o.locked) {
                                            var l = o.forceX,
                                                h = o.forceY,
                                                u = o.forceZ,
                                                c = o.forceSum,
                                                d = l * l + h * h + u * u;
                                            if (d * c * c > this.unitTemperature * this.unitTemperature * .05 * .05) {
                                                s += d;
                                                var p = o.oldForceX * l + o.oldForceY * h + o.oldForceZ * u;
                                                r += p, p > 0 ? n += p : i -= p
                                            } else a[t] = !0
                                        }
                                    }
                                    this.layoutMovement = (n - 5 * i) / this.nodeCount, r > 1e-7 ? this.forceReductionFactor *= 1 + .4 / 1.618033989 : r < -1e-7 && (this.forceReductionFactor /= 1.4), this.forceReductionFactor = Math.min(1, this.forceReductionFactor), this.forceReductionFactor = Math.max(.002, this.forceReductionFactor);
                                    for (var t = 0; t <= this.nodeCount - 1; t++) {
                                        var f = this.nodes[t];
                                        if (!f.locked && !a[t]) {
                                            var c = f.forceSum * this.forceReductionFactor;
                                            f.x += f.forceX * c, f.y += f.forceY * c, f.z += f.forceZ * c
                                        }
                                        f.oldForceX = f.forceX, f.oldForceY = f.forceY, f.oldForceZ = f.forceZ
                                    }
                                }, e.prototype.applyAspect = function (t) {
                                    for (var e = 0; e < this.nodes.length; e++) {
                                        var i = this.nodes[e];
                                        i.y *= t
                                    }
                                }, e.prototype.calculateForce = function (t, e) {
                                    for (var i = t.oldForceX * e, n = t.oldForceY * e, r = t.oldForceZ * e, s = 0; s < t.edges.length; s++) {
                                        var a = t.edges[s],
                                            o = a.to,
                                            l = a.len,
                                            h = t.x - t.offsetX - o.x + o.offsetX,
                                            u = t.y - t.offsetY - o.y + o.offsetY,
                                            c = t.z - o.z;
                                        a.direction && ("U" === a.direction ? (u -= l, l = 0) : "D" === a.direction ? (u += l, l = 0) : "L" === a.direction ? (h -= l, l = 0) : "R" === a.direction && (h += l, l = 0));
                                        var d = Math.sqrt(h * h + u * u + c * c);
                                        d < .01 && (d = .01);
                                        var p = (l - d) * a.K / d * this.linkForceFactor;
                                        i += p * h, n += p * u, r += p * c
                                    }
                                    i += t.repulsiveForceX * this.nodeRepulsionFactor, n += t.repulsiveForceY * this.nodeRepulsionFactor, r += t.repulsiveForceZ * this.nodeRepulsionFactor;
                                    var f = t.zattr * this.zAxisAttraction;
                                    if (r -= t.z * f, i += t.gravityForceX, n += t.gravityForceY, isNaN(i)) throw "Internal error: Nan in layout";
                                    t.forceX = i, t.forceY = n, t.forceZ = r, t.fsum + f !== 0 && (t.forceSum = 1 / (t.fsum + f))
                                }, e.prototype.storeNodes = function () {
                                    for (var t = 0; t <= this.nodeCount - 1; t++) {
                                        var e = this.nodes[t];
                                        e.locked || (e.layerNode.x = e.x - e.offsetX, e.layerNode.y = e.y - e.offsetY)
                                    }
                                }, e.prototype.centerNodes = function () {
                                    for (var t = new d.Random(243178931), e = this.nodes, i = e[0].x, n = i, r = e[0].y, s = r, a = 1; a <= this.nodeCount - 1; a++) i = Math.min(i, e[a].x), n = Math.max(n, e[a].x), r = Math.min(r, e[a].y), s = Math.max(s, e[a].y);
                                    for (var o = (i + n) / 2, l = (r + s) / 2, a = 0; a <= this.nodeCount - 1; a++) {
                                        var h = e[a];
                                        if (h.x -= o, h.y -= l, !h.locked) {
                                            var u = .3 * h.r;
                                            h.x += t.get() * u, h.y += t.get() * u
                                        }
                                    }
                                }, e.prototype.randomnodesForRepulsion = function () {
                                    for (var t = 0; t <= this.nodeCount - 1; t++) {
                                        var e = Math.floor(this.random.get() * (this.nodeCount - t)) + t,
                                            i = this.nodes[t];
                                        this.nodes[t] = this.nodes[e], this.nodes[e] = i
                                    }
                                }, e.prototype.onSceneChange = function (t) {
                                    var e = t.changes.settingsChanges;
                                    if (e && e.layout || t.changes.navigation || this.chart.layer.hasTopologyChanges())
                                        for (var i = this.chart.layer, n = i.links(), r = 0; r < n.length; r++) {
                                            var s = n[r];
                                            s.background && (s.background = !1, i.touchLink(s))
                                        }
                                    e && e.layout && this.gravity.reset()
                                }, e.prototype.doAnimations = function (t) {
                                    var e = this.chart.settings.layout,
                                        i = this.chart.layer,
                                        n = e.layoutFreezeTimeout,
                                        r = e.layoutFreezeMinTimeout,
                                        s = i.hasTopologyChanges(),
                                        a = t.dtime;
                                    (0 === this.idleSince || t.changes.dynamicLayout || s || t.changes.coordinates || t.changes.layout || t.changes.bounds) && (this.idleSince = t.timeStamp, this.noMovementSince = 0);
                                    var o = 1;
                                    if (!s) {
                                        var l = t.timeStamp - this.idleSince;
                                        if (this.layoutMovement < e.advanced.adaptiveFreezeTreshold)
                                            if (0 !== this.noMovementSince) {
                                                var h = t.timeStamp - this.noMovementSince;
                                                o = Math.min((r - h) / r, o)
                                            } else this.noMovementSince = t.timeStamp;
                                        o = Math.min((n - l) / n, o)
                                    }
                                    o > 0 && (this.doForceLayout(a * o, !1), t.animating = !0, t.changes.position = !0)
                                }, e.prototype.placeNewNodes = function () {
                                    for (var t = {}, e = this.chart.layer, i = !1, n = 0, r = e.nodes(); n < r.length; n++) {
                                        var s = r[n];
                                        null !== s.x && null !== s.y || (t[s.id] = !0)
                                    }
                                    for (var n = 0, r = e.nodes(); n < r.length; n++) {
                                        var s = r[n],
                                            a = 1;
                                        if (t.hasOwnProperty(s.id)) {
                                            var o = 0,
                                                l = 0,
                                                h = 0;
                                            a = 1;
                                            for (var u = void 0, c = 0; c < s.links.length; c++) {
                                                var d = s.links[c],
                                                    p = d.otherEnd(s);
                                                t.hasOwnProperty(p.id) || (u = p, l += p.x, h += p.y, o += 1)
                                            }
                                            var f = void 0,
                                                g = void 0;
                                            if (o > 1) f = l / o, g = h / o, a = .5;
                                            else if (1 === o) {
                                                for (var m = 0, v = 0, y = 0, c = 0; c < u.links.length; c++) {
                                                    var d = u.links[c],
                                                        S = d.otherEnd(u);
                                                    S === s || t.hasOwnProperty(S.id) || (v += S.x - u.x, y += S.y - u.y, m += 1)
                                                }
                                                if (m > 0) {
                                                    var b = Math.sqrt(v * v + y * y);
                                                    if (b > 0) {
                                                        var C = 1 / (b * m);
                                                        v *= C, y *= C, f = u.x - v * u.hHeight * 1.2, g = u.y - y * u.hHeight * 1.2, a = .2
                                                    } else f = u.x, g = u.y
                                                } else i = !0, f = u.x, g = u.y
                                            } else i = !0, f = 0, g = 0;
                                            s.x = f + (this.random.get() - .5) * a * (s.hHeight + 1), s.y = g + (this.random.get() - .5) * a * (s.hHeight + 1)
                                        }
                                    }
                                    return {
                                        newNodes: t,
                                        majorChanges: i
                                    }
                                }, e.prototype.doForceLayout = function (t, e) {
                                    var i, n = this.chart.scene,
                                        r = this.chart.layer,
                                        s = this.chart.settings.layout,
                                        a = r.nodes(),
                                        o = r.links(),
                                        l = {},
                                        h = !1;
                                    if (e) {
                                        this.random = new d.Random(1);
                                        for (var u = 0; u < a.length; u++) {
                                            var c = a[u];
                                            l[c.id] = !0, c.x = 0, c.y = 0, c.userLock = !1
                                        }
                                        i = !0, h = !0
                                    } else if (r.hasTopologyChanges()) {
                                        i = !0, this.random = new d.Random(1);
                                        var p = this.placeNewNodes();
                                        l = p.newNodes, h = p.majorChanges
                                    }
                                    var f = (n.width + 1) / (n.height + 1);
                                    f > 0 || (f = null);
                                    var g = n.settings.layout.aspectRatio ? f : null;
                                    this.aspectRatio = g;
                                    for (var m = !1, u = 0; u < a.length; u++) {
                                        var c = a[u];
                                        c.locked = c.userLock || c.locks > 0, m = m || c.locked
                                    }
                                    if (d.Helpers.hasProperties(l)) {
                                        for (var u = 0; u < a.length; u++) {
                                            var c = a[u];
                                            c.locked = c.locked || !d.Helpers.hasProperty(l, c.id)
                                        }
                                        this.updateGraph(a, o, i), h || n.settings.layout.globalLayoutOnChanges ? (this.aspectRatio = f, this.globalLayout(h ? s.initialLayoutMaxTime : s.incrementalLayoutMaxTime, h && !m)) : this.timedLayout(.001 * t)
                                    } else this.updateGraph(a, o, i), this.timedLayout(.001 * t)
                                }, e.prototype.resetLayout = function () {
                                    this.doForceLayout(1, !0), this.idleSince = 0
                                }, e
                            }(a);
                        t.TimedSpringEmbedder = y;
                        var S = function (t) {
                            function e() {
                                var e = t.apply(this, arguments) || this;
                                return e.twoCircles = !1, e
                            }
                            return n(e, t), e.getNodeSize = function (t) {
                                return Math.max(t.hHeight, t.hWidth) * t.visibility * 2
                            }, e.getNodesBounds = function (t) {
                                if (t.length < 1) return new d.Rect(0, 0, 0, 0);
                                for (var e = t[0], i = new d.Rect(e.x - e.hWidth, e.y - e.hHeight, e.x + e.hWidth, e.y + e.hHeight), n = 1; n < t.length; n++) e = t[n], i.addBounds(e.x - e.hWidth, e.y - e.hHeight, e.x + e.hWidth, e.y + e.hHeight);
                                return i
                            }, e.prototype.onSceneChange = function (t) {
                                var e = t.changes.settingsChanges;
                                (e && e.layout || t.changes.navigation || this.chart.layer.hasTopologyChanges() || t.changes.highlight) && this.updateBackgroundLinks(this.chart.getLastFocusNode(), !1)
                            }, e.prototype.doAnimations = function (t) {
                                var e = t.changes.settingsChanges,
                                    i = null != e && null != e.layout || t.changes.navigation || this.chart.layer.hasTopologyChanges(),
                                    n = t.changes.position || t.changes.dynamicLayout;
                                (i || n) && (this.performLayout(i), t.changes.position = !0)
                            }, e.prototype.resetLayout = function () {
                                for (var t = this.chart.layer.nodes(), e = 0; e < t.length; e++) t[e].userLock = !1;
                                this.performLayout(!0)
                            }, e.prototype.performLayout = function (t) {
                                var i = [];
                                this.visitedNodes = {}, this.subnodes = {}, this.minAngle = {}, this.radiuses = [];
                                var n = this.chart.getLastFocusNode();
                                if (n) {
                                    i.push(this.layoutCircle(n, t));
                                    for (var r = this.chart.layer.nodes(), s = 0; s < r.length; s++) {
                                        var a = r[s];
                                        d.Helpers.hasProperty(this.visitedNodes, a.id) || i.push(this.layoutCircle(a, t))
                                    }
                                    if (i.length > 1)
                                        for (var o = 2 * this.chart.settings.layout.nodeSpacing, l = e.getNodesBounds(i[0]).x1 + o, s = 1; s < i.length; s++) {
                                            var h = i[s];
                                            if (!(h.length < 1)) {
                                                var u = e.getNodesBounds(h);
                                                l -= u.x0;
                                                for (var c = 0; c < h.length; c++) h[c].x += l;
                                                l += u.x1 + o
                                            }
                                        }
                                    this.updateBackgroundLinks(n, !0) && this.chart.events.notifySceneChanges({
                                        highlight: !0
                                    })
                                }
                            }, e.prototype.layoutCircle = function (t, e) {
                                var i = [];
                                return this.visitedNodes[t.id] = !0, this.computeMaxRadius(t, e), this.placeNodeRec(t, 0, .5 * -Math.PI, 2 * Math.PI, i), i
                            }, e.prototype.updateBackgroundLinks = function (t, e) {
                                if (t) {
                                    if (this.visitedNodes = {}, this.updateBackgroudLinkCircle(t, e) && e) return !0;
                                    for (var i = this.chart.layer.nodes(), n = 0; n < i.length; n++) {
                                        var r = i[n];
                                        if (!d.Helpers.hasProperty(this.visitedNodes, r.id) && this.updateBackgroudLinkCircle(r, e) && e) return !0
                                    }
                                    return !1
                                }
                            }, e.prototype.updateBackgroudLinkCircle = function (t, e) {
                                var i = [t];
                                this.visitedNodes[t.id] = !0;
                                for (var n = {}, r = this.chart.layer; i.length > 0;) {
                                    for (var s = [], a = 0; a < i.length; a++)
                                        for (var o = i[a], l = 0; l < o.links.length; l++) {
                                            var h = o.links[l];
                                            if (!d.Helpers.hasProperty(n, h.id)) {
                                                n[h.id] = !0;
                                                var u = h.otherEnd(o),
                                                    c = !0;
                                                if (d.Helpers.hasProperty(this.visitedNodes, u.id) || (this.visitedNodes[u.id] = !0, s.push(u), c = !1), h.background !== c) {
                                                    if (e) return !0;
                                                    h.background = c, r.touchLink(h)
                                                }
                                            }
                                        }
                                    i = s
                                }
                                return !1
                            }, e.prototype.getSubnodes = function (t) {
                                var e = t.id;
                                if (this.subnodes[e]) return this.subnodes[e];
                                for (var i = [], n = 0; n < t.links.length; n++) {
                                    var r = t.links[n],
                                        s = r.otherEnd(t);
                                    d.Helpers.hasProperty(this.visitedNodes, s.id) || (i.push(s), this.visitedNodes[s.id] = !0)
                                }
                                return this.subnodes[e] = i, i
                            }, e.prototype.computeMaxRadius = function (t, i) {
                                var n = this.chart.settings.layout.nodeSpacing,
                                    r = 0;
                                this.radiuses[0] = r;
                                for (var s = 1, a = [t]; a.length > 0;) {
                                    var o = void 0;
                                    if (1 === s && this.chart.settings.layout.twoRingRadialLayout) {
                                        t = a[0];
                                        var l = e.getNodeSize(t);
                                        o = this.getSubnodes(t);
                                        for (var h = Math.floor(o.length / 2), u = new Array(h), c = new Array(o.length - h), d = 0; d < o.length; d++)(d % 2 === 0 ? c : u)[Math.floor(d / 2)] = o[d];
                                        for (var p = 0, f = 0, d = 0; d < u.length; d++) {
                                            var g = u[d],
                                                m = e.getNodeSize(g);
                                            p = Math.max(p, m), f += n + m
                                        }
                                        for (var v = 0, y = 0, d = 0; d < c.length; d++) {
                                            var g = c[d],
                                                m = e.getNodeSize(g);
                                            v = Math.max(v, m), y += n + m
                                        }
                                        var S = Math.max(.5 * (Math.max(p, v) + l) + n, (f + y) / (2 * Math.PI)),
                                            b = Math.max(.5 * (p + l) + n, f / (2 * Math.PI)),
                                            C = Math.max(b + .5 * (v + p), y / (2 * Math.PI));
                                        i && (this.twoCircles = C < S),
                                            this.twoCircles ? (this.radiuses[1] = b, this.radiuses[2] = C) : (this.radiuses[1] = S, this.radiuses[2] = S), r = this.radiuses[2], s = 3
                                    } else {
                                        var x = 0,
                                            w = 0;
                                        o = [];
                                        for (var L = 0; L < a.length; L++) {
                                            t = a[L];
                                            for (var l = e.getNodeSize(t), T = 0, k = this.getSubnodes(t); T < k.length; T++) {
                                                var g = k[T],
                                                    m = e.getNodeSize(g);
                                                x = Math.max(x, m + l), w += n + m, o.push(g)
                                            }
                                        }
                                        var A = r + .5 * x + n,
                                            M = w / (2 * Math.PI),
                                            I = Math.max(A, M);
                                        this.radiuses[s] = I, r = I, s += 1
                                    }
                                    a = o
                                }
                            }, e.prototype.computeMinAngle = function (t, i) {
                                var n = t.id;
                                if (d.Helpers.hasProperty(this.minAngle, n)) return this.minAngle[n];
                                for (var r = this.chart.settings.layout.nodeSpacing, s = this.radiuses[i], a = e.getNodeSize(t), o = (a + r) / s, l = 0, h = this.chart.settings.layout.twoRingRadialLayout && 1 === i ? 3 : i + 1, u = 0, c = this.getSubnodes(t); u < c.length; u++) {
                                    var p = c[u];
                                    l += this.computeMinAngle(p, h)
                                }
                                return o = Math.max(o, l), this.minAngle[n] = o, o
                            }, e.prototype.placeNodeRec = function (t, e, i, n, r) {
                                var s = i + .5 * n,
                                    a = this.radiuses[e];
                                t.userLock || (t.x = a * Math.cos(s), t.y = a * Math.sin(s), r.push(t));
                                var o = this.getSubnodes(t),
                                    l = e + 1,
                                    h = !1;
                                if (this.chart.settings.layout.twoRingRadialLayout && (0 === e ? h = !0 : 1 === e && (l = 3)), o.length > 0) {
                                    for (var u = 0, c = 0; c < o.length; c++) {
                                        var d = o[c];
                                        u += this.computeMinAngle(d, h ? c % 2 === 0 ? 2 : 1 : l)
                                    }
                                    for (var p = n / u, f = i, c = 0; c < o.length; c++) {
                                        var d = o[c];
                                        h && (l = c % 2 === 0 ? 2 : 1);
                                        var g = this.computeMinAngle(d, l) * p;
                                        this.placeNodeRec(d, l, f, g, r), f += g
                                    }
                                }
                            }, e
                        }(a);
                        t.RadialLayout = S;
                        var b = function () {
                                function t(t, e) {
                                    this.children = [], this.parent = null, this.node = t, this.level = e, this.reset()
                                }
                                return t.prototype.reset = function () {
                                    this.hWidth = this.node.hWidth, this.origX = this.node.x, this.shift = 0
                                }, t
                            }(),
                            C = function (t) {
                                function r() {
                                    var e = t.apply(this, arguments) || this;
                                    return e.forest = null, e
                                }
                                return n(r, t), r.prototype.wrapNodes = function () {
                                    for (var t = d.Helpers.clone(this.chart.layer.idToNode), e = [];;) {
                                        var i = null;
                                        for (var n in t)
                                            if (d.Helpers.hasProperty(t, n)) {
                                                i = t[n], delete t[n];
                                                break
                                            }
                                        if (null == i) return e;
                                        var r = {},
                                            s = [new b(i, 0)],
                                            a = 0,
                                            o = 0;
                                        r[i.id] = s[0];
                                        for (var l = 0; l < s.length; l++)
                                            for (var h = s[l], u = h.node, c = 0; c < u.links.length; c++) {
                                                var p = u.links[c];
                                                if (p.to === u) {
                                                    var f = void 0;
                                                    d.Helpers.hasProperty(r, p.from.id) ? f = r[p.from.id] : (f = new b(p.from, h.level - 1), a === h.level && a--, r[p.from.id] = f, s.push(f)), null === h.parent && h.level === f.level + 1 && (h.parent = f, f.children.push(h))
                                                } else {
                                                    var f = void 0;
                                                    d.Helpers.hasProperty(r, p.to.id) ? f = r[p.to.id] : (f = new b(p.to, h.level + 1), o === h.level && o++, r[p.to.id] = f, s.push(f)), null === f.parent && f.level === h.level + 1 && (h.children.push(f), f.parent = h)
                                                }
                                            }
                                        for (var g = new Array(o - a + 1), l = 0; l < g.length; l++) g[l] = [];
                                        for (var l = 0; l < s.length; l++) {
                                            var h = s[l];
                                            delete t[h.node.id], h.level -= a, null === h.parent && (h.levelIndex = g[h.level].length, g[h.level].push(h))
                                        }
                                        for (var m = 0; m < g.length; m++)
                                            for (var v = g[m], y = 0; y < v.length; y++)
                                                for (var S = v[y], C = 0; C < S.children.length; C++) {
                                                    var x = m + 1,
                                                        w = S.children[C];
                                                    w.level = x, w.levelIndex = g[x].length, g[x].push(w)
                                                }
                                        e.push({
                                            levels: g,
                                            levelStarts: new Array(g.length),
                                            levelEnds: new Array(g.length)
                                        })
                                    }
                                }, r.prototype.layoutNodes = function (t) {
                                    var n = t.levels,
                                        r = this.chart.settings.layout,
                                        s = r.nodeSpacing,
                                        a = null === r.groupSpacing ? 2 * s : r.groupSpacing,
                                        o = null === r.rowSpacing ? s : r.rowSpacing;
                                    i(n[n.length - 1], null, null, s, a);
                                    for (var l = n.length - 2; l >= 0; l--) {
                                        for (var h = n[l], u = null, c = void 0, d = 0; d < h.length; d++)
                                            if (h[d].children.length > 0) {
                                                c = h[d];
                                                break
                                            }
                                        if (c.node.x = e(c), c.levelIndex > 0) {
                                            i(h, null, c, s, a);
                                            var p = h[c.levelIndex - 1],
                                                f = p.node.x + p.hWidth + s + c.hWidth;
                                            f > c.node.x && (c.shift = f - c.node.x, c.node.x += c.shift)
                                        }
                                        for (;;) {
                                            u = c, c = null;
                                            for (var d = u.levelIndex + 1; d < h.length; d++)
                                                if (h[d].children.length > 0) {
                                                    c = h[d];
                                                    break
                                                }
                                            if (null === c) break;
                                            c.node.x = e(c) + u.shift, c.shift = u.shift;
                                            for (var g = 0, m = 0, d = u.levelIndex + 1; d < c.levelIndex; d++) g += 2 * h[d].hWidth, null != h[d].parent && h[d].parent === h[d - 1].parent || m++;
                                            null != c.parent && c.parent === h[c.levelIndex - 1].parent || m++;
                                            var v = c.levelIndex - u.levelIndex,
                                                y = u.hWidth + c.hWidth + g + (v - m) * s + m * a,
                                                S = c.node.x - u.node.x;
                                            if (y > S) {
                                                var b = y - S;
                                                c.node.x += b, c.shift += b, S = y, i(h, u, c, s, a)
                                            } else if (0 === m) {
                                                var C = (S - u.hWidth - c.hWidth - g) / (c.levelIndex - u.levelIndex);
                                                i(h, u, c, C, 0)
                                            } else {
                                                var x = (S - u.hWidth - c.hWidth - g - (v - m) * s) / m;
                                                i(h, u, c, s, x)
                                            }
                                        }
                                        i(h, u, null, s, a)
                                    }
                                    for (var w = 0, l = 0; l < n.length; l++) {
                                        for (var h = n[l], L = 0, d = 0; d < h.length; d++) L = Math.max(L, 2 * h[d].node.hHeight);
                                        w += L / 2, t.levelStarts[l] = h[0].node.x - h[0].hWidth, t.levelEnds[l] = h[h.length - 1].node.x + h[h.length - 1].hWidth;
                                        for (var d = 0; d < h.length; d++) {
                                            var T = h[d];
                                            T.node.userLock ? T.node.x = T.origX : T.node.y = w;
                                            for (var k = 0; k < T.children.length; k++) {
                                                var A = T.children[k];
                                                A.node.x += T.shift, A.shift += T.shift
                                            }
                                        }
                                        w += L / 2 + o
                                    }
                                }, r.prototype.layoutTrees = function (t) {
                                    var e = this.chart.settings.layout;
                                    t.sort(function (t, e) {
                                        var i = e.levels.length - t.levels.length;
                                        return 0 !== i ? i : t.levels[0][0].node.id.localeCompare(e.levels[0][0].node.id)
                                    });
                                    for (var i = t[0].levelEnds.slice(), n = null == e.groupSpacing ? 4 * e.nodeSpacing : 2 * e.groupSpacing, r = 1; r < t.length; r++) {
                                        for (var s = t[r], a = 0, o = 0; o < s.levels.length; o++) {
                                            var l = i[o] + n,
                                                h = a + s.levelStarts[o];
                                            h < l && (a += l - h)
                                        }
                                        for (var o = 0; o < s.levels.length; o++) {
                                            for (var u = s.levels[o], c = 0; c < u.length; c++) {
                                                var d = u[c];
                                                d.node.userLock || (d.node.x += a)
                                            }
                                            i[o] = a + s.levelEnds[o]
                                        }
                                    }
                                    var p = (e.rotation || 0) % 360;
                                    if (0 !== p) {
                                        p = p * Math.PI / 180;
                                        for (var f = Math.sin(p), g = Math.cos(p), m = this.chart.layer.nodes(), r = 0; r < m.length; r++) {
                                            var d = m[r];
                                            if (!d.userLock) {
                                                var c = d.x,
                                                    o = d.y;
                                                d.x = c * g - o * f, d.y = c * f + o * g
                                            }
                                        }
                                    }
                                }, r.prototype.performLayout = function (t) {
                                    if (t || null == this.forest) this.forest = this.wrapNodes();
                                    else
                                        for (var e = 0; e < this.forest.length; e++)
                                            for (var i = this.forest[e], n = 0; n < i.levels.length; n++)
                                                for (var r = i.levels[n], s = 0; s < r.length; s++) r[s].reset();
                                    if (!(this.forest.length < 1)) {
                                        for (var e = 0; e < this.forest.length; e++) this.layoutNodes(this.forest[e]);
                                        this.layoutTrees(this.forest), this.setBackgroundFlag(!0) && this.chart.events.notifySceneChanges({
                                            highlight: !0
                                        })
                                    }
                                }, r.prototype.setBackgroundFlag = function (t) {
                                    for (var e = d.Helpers.clone(this.chart.layer.idToNode);;) {
                                        var i = null;
                                        for (var n in e)
                                            if (d.Helpers.hasProperty(e, n)) {
                                                i = e[n], delete e[n];
                                                break
                                            }
                                        if (null == i) return !1;
                                        var r = {},
                                            s = {},
                                            a = [{
                                                node: i,
                                                level: 0,
                                                hasParent: !1
                                            }],
                                            o = this.chart.layer;
                                        r[i.id] = a[0];
                                        for (var l = 0; l < a.length; l++)
                                            for (var h = a[l], u = h.node, c = 0; c < u.links.length; c++) {
                                                var p = u.links[c];
                                                if (!d.Helpers.hasProperty(s, p.id)) {
                                                    s[p.id] = !0;
                                                    var f = !0;
                                                    if (p.to === u) {
                                                        var g = void 0;
                                                        d.Helpers.hasProperty(r, p.from.id) ? g = r[p.from.id] : (g = {
                                                            node: p.from,
                                                            level: h.level - 1,
                                                            hasParent: !1
                                                        }, delete e[g.node.id], r[p.from.id] = g, a.push(g)), h.hasParent || h.level !== g.level + 1 || (h.hasParent = !0, f = !1)
                                                    } else {
                                                        var g = void 0;
                                                        d.Helpers.hasProperty(r, p.to.id) ? g = r[p.to.id] : (g = {
                                                            node: p.to,
                                                            level: h.level + 1,
                                                            hasParent: !1
                                                        }, delete e[g.node.id], r[p.to.id] = g, a.push(g)), g.hasParent || g.level !== h.level + 1 || (g.hasParent = !0, f = !1)
                                                    }
                                                    if (p.background !== f) {
                                                        if (t) return !0;
                                                        p.background = f, o.touchLink(p)
                                                    }
                                                }
                                            }
                                    }
                                }, r.prototype.onSceneChange = function (t) {
                                    var e = t.changes.settingsChanges;
                                    (e && e.layout || t.changes.navigation || this.chart.layer.hasTopologyChanges() || t.changes.highlight) && this.setBackgroundFlag(!1)
                                }, r.prototype.doAnimations = function (t) {
                                    var e = t.changes.settingsChanges,
                                        i = this.chart.layer.hasTopologyChanges();
                                    (e && e.layout || t.changes.navigation || i || t.changes.position || t.changes.dynamicLayout) && (this.performLayout(i), t.changes.position = !0)
                                }, r.prototype.resetLayout = function () {
                                    for (var t = this.chart.layer.nodes(), e = 0; e < t.length; e++) t[e].userLock = !1;
                                    this.performLayout(!1)
                                }, r
                            }(a);
                        t.HierarchyLayout = C;
                        var x = function (t) {
                            function e() {
                                return t.apply(this, arguments) || this
                            }
                            return n(e, t), e.prototype.resetLayout = function () {
                                for (var t = this.chart.layer.nodes(), e = 0; e < t.length; e++) {
                                    var i = t[e],
                                        n = i.data;
                                    d.Helpers.isNumber(n.x) && (i.x = n.x), d.Helpers.isNumber(n.y) && (i.y = n.y), i.userLock = !1
                                }
                            }, e
                        }(a);
                        t.StaticLayout = x
                    }(r = t.Layouts || (t.Layouts = {}));
                var k = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.animationOrder = 500, i.paintOrder = 35, i.updateOrder = 1800, i.chart = e, i.scene = e.scene, i.events = e.events, i
                    }
                    return n(e, t), e.prototype.doAnimations = function (t) {
                        var e = this.chart.layer;
                        e.updateStyle(t), e.postprocessStyle(t)
                    }, e.prototype.paintScene = function (t) {
                        d.Graphics.pushClip(t, this.scene.x0, this.scene.y0, this.scene.width, this.scene.height);
                        var e = this.chart.layer;
                        e.setBounds(this.scene.x0, this.scene.y0, this.scene.x0 + this.scene.width, this.scene.y0 + this.scene.height), e.paint(t), d.Graphics.popClip(t)
                    }, e.prototype.paintLinks = function (t, e, i, n) {
                        this.chart.layer.paintLinksImpl(t, e, i, n)
                    }, e.prototype.paintNodes = function (t, e, i, n) {
                        this.chart.layer.paintNodesImpl(t, e, i, n)
                    }, e.prototype.findObjectAt = function (t, e, i) {
                        return this.chart.layer.findObjectAt(t, e, i)
                    }, e
                }(d.ChartElement);
                t.Renderer = k;
                var A = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.dataFunction = null, e.preloaded = null, e
                    }
                    return n(e, t), e
                }(u.SettingsData);
                t.SettingsData = A;
                var M = function (t) {
                    function e(e, i) {
                        var n = t.call(this, e, i) || this;
                        return n.nodes = {}, n.links = {}, n.nodeToLinks = {}, n.pendingNodes = {}, n.requestedNodes = {}, n.pendingAllData = !1, n.requestedAllData = !1, n.nextLinkId = 0, n.hasAllData = !n.hasDataFunc(), n
                    }
                    return n(e, t), e.otherEnd = function (t, e) {
                        return e === t.from ? t.to : e === t.to ? t.from : null
                    }, e.multiLinkId = function (t) {
                        return t.from < t.to ? t.from + d.Helpers.SeparatorChar + t.to : t.to + d.Helpers.SeparatorChar + t.from
                    }, e.prototype.buildRequest = function () {
                        if (this.pendingAllData) return this.requestedAllData ? null : (this.requestedAllData = !0, {
                            nodes: []
                        });
                        var t = [];
                        for (var e in this.pendingNodes)
                            if (t.push(e), delete this.pendingNodes[e], this.requestedNodes[e] = !0, t.length >= this.dataSettings.requestMaxUnits) break;
                        return 0 === t.length ? null : {
                            nodes: t
                        }
                    }, e.prototype.dataFunc = function (t, e, i) {
                        var n = this.dataSettings;
                        if (n.dataFunction) n.dataFunction(t.nodes || null, e, i);
                        else if (n.url) {
                            var r = [];
                            if (t.nodes) {
                                for (var s = "", a = 0; a < t.nodes.length; a++) s.length && (s += ","), s += encodeURIComponent(t.nodes[a]);
                                r.push(["nodes", s])
                            }
                            d.Data.doRequest(n.url, n, r, e, i)
                        } else i({
                            error: "Chart configuration does not define data retrieval function"
                        })
                    }, e.prototype.verifyData = function (t, e) {
                        d.Helpers.hasProperty(e, "links") || (e.links = []), d.Helpers.hasProperty(e, "nodes") || (e.nodes = []);
                        var i = !0;
                        if (!Array.isArray(e.nodes)) {
                            var n = e.nodes;
                            e.nodes = [];
                            for (var r = Object.keys(n), s = 0; s < r.length; s++) {
                                var a = r[s],
                                    o = n[a];
                                o.id = a, e.nodes.push(o)
                            }
                        }
                        if (!Array.isArray(e.links)) {
                            var l = e.links;
                            e.links = [];
                            for (var r = Object.keys(l), s = 0; s < r.length; s++) {
                                var a = r[s],
                                    h = l[a];
                                h.id = a, e.links.push(h)
                            }
                        }
                        for (var u = {}, c = !t && !this.hasDataFunc(), s = 0; s < e.nodes.length; s++) {
                            var o = e.nodes[s];
                            null == o.id ? (o.id = d.Helpers.getIdentifierStr(), d.Helpers.warn("Data response: `id` property is mandatory for all nodes in the NetChart data object.", null, !0)) : o.id = o.id.toString(), u.hasOwnProperty(o.id) && d.Helpers.warn('Data response: Multiple nodes with the same ID: "' + o.id + '". Data will be merged.'), u[o.id] = !0, c ? o.loaded = !0 : d.Helpers.hasProperty(o, "loaded") ? o.loaded = !!o.loaded : (d.Helpers.warn('Data response: Node with ID "' + o.id + '" does not have the "loaded" flag. Assuming "false".'), o.loaded = !1), d.Helpers.hasProperty(o, "className") && null != o.className && !d.Helpers.isString(o.className) && (d.Helpers.warn('Data response: Node property "className" must be a string. Node ID: "' + o.id + '".'), o.className = "" + o.className), d.Helpers.hasProperty(o, "error") && null != o.error && !d.Helpers.isString(o.error) && (d.Helpers.warn('Data response: Node property "error" must be a string. Node ID: "' + o.id + '".'), o.error = "" + o.error), d.Helpers.hasProperty(o, "x") && null != o.x && !d.Helpers.isNumber(o.x) && (d.Helpers.warn('Data response: Node property "x" must be a number. Node ID: "' + o.id + '".'), o.x = d.Helpers.tryParseFloat(o.x, null)), d.Helpers.hasProperty(o, "y") && null != o.y && !d.Helpers.isNumber(o.y) && (d.Helpers.warn('Data response: Node property "y" must be a number. Node ID: "' + o.id + '".'), o.y = d.Helpers.tryParseFloat(o.y, null))
                        }
                        for (var p = {}, s = 0; s < e.links.length; s++) {
                            var h = e.links[s];
                            null != h.from ? (h.from = h.from.toString(), null != h.to ? (h.to = h.to.toString(), null == h.id ? (h.id = d.Helpers.SeparatorChar + this.nextLinkId, this.nextLinkId += 1) : h.id = h.id.toString(), p.hasOwnProperty(h.id) && d.Helpers.warn('Data response: Multiple links with the same ID: "' + h.id + '". Data will be merged.'), p[h.id] = !0, d.Helpers.hasProperty(h, "className") && null != h.className && !d.Helpers.isString(h.className) && (d.Helpers.warn('Data response: Link property "className" must be a string. Link ID: "' + h.id + '".'), h.className = "" + h.className), d.Helpers.hasProperty(h, "error") && null != h.error && !d.Helpers.isString(h.error) && (d.Helpers.warn('Data response: Link property "error" must be a string. Link ID: "' + h.id + '".'), h.error = "" + h.error), d.Helpers.hasProperty(this.nodes, h.from) || d.Helpers.hasProperty(u, h.from) || e.nodes.push({
                                id: h.from,
                                loaded: c
                            }), d.Helpers.hasProperty(this.nodes, h.to) || d.Helpers.hasProperty(u, h.to) || e.nodes.push({
                                id: h.to,
                                loaded: c
                            })) : d.Helpers.warn('Data response: Link missing property "to" and will be ignored. Link id: "' + h.id + '"')) : d.Helpers.warn('Data response: Link missing property "from" and will be ignored. Link id: "' + h.id + '"')
                        }
                        if (t ? this.chart.log("Got " + e.nodes.length + " nodes on [" + t.nodes.join(", ") + "]") : this.chart.log("Got " + e.nodes.length + " nodes on all nodes"), t && t.nodes.length > 0) {
                            for (var f = !1, g = !1, m = 0; m < e.nodes.length; m++) {
                                var o = e.nodes[m];
                                t.nodes.indexOf(o.id) > -1 && (f = !0, g = g || o.loaded)
                            }
                            f ? g || (this.chart.error("Data response: loaded field was not set on any of the requested nodes!"), i = !1) : (this.chart.error("Data response: Results set did not contain any of requested nodes!", t.nodes), i = !1)
                        }
                        return i
                    }, e.prototype.addVerifiedData = function (t, e) {
                        for (var i = this.updateGraph(e), n = 0; n < e.nodes.length; n++) {
                            var r = e.nodes[n];
                            (r.loaded || r.error) && (delete this.requestedNodes[r.id], delete this.pendingNodes[r.id])
                        }
                        if (t)
                            if (0 === t.nodes.length) this.hasAllData = !0, this.pendingAllData = !1, this.requestedAllData = !1;
                            else
                                for (var n = 0; n < t.nodes.length; n++) {
                                    var s = t.nodes[n];
                                    this.requestedNodes[s] && (this.pendingNodes[s] = !0, delete this.requestedNodes[s])
                                }
                        return i
                    }, e.prototype.requestFailedPermanently = function (t) {
                        if (t.nodes) {
                            for (var e = [], i = 0; i < t.nodes.length; i++) {
                                var n = t.nodes[i];
                                e.push({
                                    id: n,
                                    error: "Bad response",
                                    loaded: !0
                                })
                            }
                            var r = this.addVerifiedData(t, {
                                nodes: e,
                                links: []
                            });
                            r.dataArrived || (r.dataArrived = {}), r.dataArrived[this.dataSettings.id] = !0, this.chart.events.notifySceneChanges(r)
                        }
                        this.chart.error("Failed data request, giving up on nodes: ", t.nodes)
                    }, e.prototype.removeData = function (t) {
                        var e = {},
                            i = [];
                        if (t.nodes)
                            for (var n = 0; n < t.nodes.length; n++) {
                                var r = t.nodes[n];
                                e[r.id] = !0, i = this.removeNode(r.id, i)
                            }
                        if (t.links)
                            for (var s = 0; s < t.links.length; s++) {
                                var a = t.links[s],
                                    o = this.links[a.id];
                                o && (e[o.from] = !0, e[o.to] = !0, this.removeLink(o))
                            }
                        for (var l = 0; l < i.length; l++) {
                            var o = i[l];
                            e[o.from] = !0, e[o.to] = !0, this.removeLink(o)
                        }
                        var h = this.chart.createEventArguments(null, "api");
                        return h.dataArrived = null, h.dataRemoved = t, this.chart.notifyDataUpdated(h), {
                            netChartDataNodes: e
                        }
                    }, e.prototype.exportData = function () {
                        var t = [],
                            e = [];
                        for (var i in this.nodes) {
                            var n = this.nodes[i];
                            t.push(n)
                        }
                        for (var i in this.links) {
                            var r = this.links[i];
                            e.push(r)
                        }
                        return {
                            nodes: t,
                            links: e
                        }
                    }, e.prototype.applyPreloadedData = function () {
                        this.dataSettings.randomNodes > 0 ? this.addData(this.genRandomGraph(this.dataSettings)) : t.prototype.applyPreloadedData.call(this)
                    }, e.prototype.getNode = function (t, e, i) {
                        void 0 === e && (e = !0), void 0 === i && (i = null);
                        var n = d.Helpers.hasProperty(this.nodes, t) ? this.nodes[t] : null;
                        if (i && (i.loading = !1), n) {
                            if (this.settings.legend.enabled && !this.chart.legend.isNodeVisible(n)) return null;
                            var r = this.settings.filters.nodeFilter;
                            if (r) {
                                var s = d.Helpers.hasProperty(this.nodeToLinks, t) ? this.nodeToLinks[t] : null;
                                if (!r(n, s)) return null
                            }!n.loaded && e && (i && (i.loading = !0), this.requestNodeData(t))
                        } else e ? (i && (i.loading = !0), this.requestNodeData(t)) : i && (i.loading = this.isNodeLoading(t));
                        return n
                    }, e.prototype.isNodeLoading = function (t) {
                        return this.pendingAllData || this.requestedAllData || d.Helpers.hasProperty(this.pendingNodes, t) || d.Helpers.hasProperty(this.requestedNodes, t)
                    }, e.prototype.getLinks = function (t, i) {
                        void 0 === i && (i = !0);
                        var n = this.settings.legend.enabled,
                            r = d.Helpers.hasProperty(this.nodes, t) ? this.nodes[t] : null;
                        if (!r) return i && this.requestNodeData(t), [];
                        if (n && !this.chart.legend.isNodeVisible(r)) return [];
                        var s = d.Helpers.hasProperty(this.nodeToLinks, t) ? this.nodeToLinks[t] : [],
                            a = this.settings.filters.nodeFilter;
                        if (a && !a(r, s)) return [];
                        !r.loaded && i && this.requestNodeData(t);
                        var o = this.settings.filters.linkFilter,
                            l = this.settings.filters.nodeLinksProcessor,
                            h = this.settings.filters.multilinkProcessor,
                            u = {};
                        if (u[t] = !0, s.length > 0 && (a || o || n)) {
                            for (var c = new Array(s.length), p = 0, f = 0; f < s.length; f++) {
                                var g = s[f],
                                    m = e.otherEnd(g, t);
                                if (null != m)
                                    if (d.Helpers.hasProperty(this.nodes, m)) {
                                        var v = this.nodes[m];
                                        if (a || n)
                                            if (d.Helpers.hasProperty(u, m)) {
                                                if (!u[m]) continue
                                            } else {
                                                var y = !n || this.chart.legend.isNodeVisible(v);
                                                if (y && a && (y = a(v, d.Helpers.hasProperty(this.nodeToLinks, m) ? this.nodeToLinks[m] : null)), u[m] = y, !y) continue
                                            }
                                        if (o || n) {
                                            var S = void 0,
                                                b = void 0;
                                            if (g.from === t ? (S = r, b = v) : (S = v, b = r), n && !this.chart.legend.isLinkVisible(g)) continue;
                                            if (o && !o(g, S, b)) continue
                                        }
                                        c[p++] = g
                                    } else d.Helpers.error("Invalid situation: link data found from '" + t + "' to '" + m + "', but no node data found for '" + m + "'");
                                else d.Helpers.error("Invalid situation: link data found from '" + g.from + "' to '" + g.to + "' in the collection of links for '" + t + "'")
                            }
                            c.length = p, s = c
                        }
                        if (l && (s = l(r, s)), !Array.isArray(s)) return [];
                        if (h) {
                            for (var C = {}, x = !1, f = 0; f < s.length; f++) {
                                var w = e.otherEnd(s[f], t);
                                if (w) {
                                    if (d.Helpers.hasProperty(C, w)) {
                                        x = !0;
                                        break
                                    }
                                    C[w] = !0
                                }
                            }
                            if (x) {
                                for (var c = [], L = {}, T = {}, f = 0; f < s.length; f++) {
                                    var k = s[f],
                                        A = e.multiLinkId(k);
                                    L.hasOwnProperty(A) ? T.hasOwnProperty(A) ? T[A].push(k) : T[A] = [L[A], k] : L[A] = k
                                }
                                for (var f = 0; f < s.length; f++) {
                                    var k = s[f],
                                        A = e.multiLinkId(k);
                                    T.hasOwnProperty(A) || c.push(k)
                                }
                                for (var M = Object.keys(T), f = 0; f < M.length; f++) {
                                    var I = T[M[f]],
                                        k = I[0],
                                        P = h(I, this.nodes[k.from], this.nodes[k.to]);
                                    Array.isArray(P) ? c = c.concat(P) : P && c.push(P)
                                }
                                s = c
                            }
                        }
                        return s
                    }, e.prototype.getAllNodes = function (t) {
                        void 0 === t && (t = !0);
                        for (var e = this.settings.filters.nodeFilter, i = Object.keys(this.nodes), n = new Array(i.length), r = 0, s = 0; s < i.length; s++) {
                            var a = i[s],
                                o = this.nodes[a];
                            this.settings.legend.enabled && !this.chart.legend.isNodeVisible(o) || e && !e(o, d.Helpers.hasProperty(this.nodeToLinks, a) ? this.nodeToLinks[a] : null) || (n[r++] = o)
                        }
                        return n.length = r, this.hasAllData || this.pendingAllData || !t || (this.pendingAllData = !0, this.scheduleRequests()), n
                    }, e.prototype.requestNodeData = function (t) {
                        return this.hasDataFunc() ? void(this.pendingNodes.hasOwnProperty(t) || this.requestedNodes.hasOwnProperty(t) || (this.pendingNodes[t] = !0, this.scheduleRequests())) : void this.chart.error("Cannot request node data! Please specify either data function or data URL in the settings!")
                    }, e.prototype.hasDataFunc = function () {
                        return null != this.dataSettings.dataFunction || null != this.dataSettings.url
                    }, e.prototype.updateGraph = function (t) {
                        for (var e = {}, i = 0; i < t.nodes.length; i++) {
                            var n = t.nodes[i];
                            if (d.Helpers.hasProperty(this.nodes, n.id)) {
                                var r = this.nodes[n.id];
                                n.error || r.loaded && !n.loaded || (d.Helpers.extendDataItem(r, n), r.resetCoordinates = (null != n.x || null != n.y) && null != r.x && null != r.y, r.resetLocked = null != n.locked, e[n.id] = !0)
                            } else {
                                var s = d.Helpers.extendDataItem({}, n);
                                s.resetCoordinates = null != s.x && null != s.y, s.resetLocked = null != s.locked, this.nodes[n.id] = s, this.nodeToLinks[n.id] = [], e[n.id] = !0
                            }
                        }
                        for (var a = 0; a < t.links.length; a++) {
                            var o = t.links[a];
                            if (d.Helpers.hasProperty(this.links, o.id)) {
                                var r = this.links[o.id];
                                if (o.from && r.from !== o.from || o.to && r.to !== o.to) {
                                    this.chart.error('Changing link from/to not supported. Link ignored. Link ID: "' + o.id + '"');
                                    continue
                                }
                                d.Helpers.extendDataItem(r, o)
                            } else {
                                if (!o.from || !o.to) continue;
                                this.links[o.id] = o, this.nodeToLinks[o.from].push(o), o.from !== o.to && this.nodeToLinks[o.to].push(o)
                            }
                            e[o.from] = !0, e[o.to] = !0
                        }
                        return {
                            netChartDataNodes: e
                        }
                    }, e.prototype.removeNode = function (t, e) {
                        return delete this.pendingNodes[t], delete this.requestedNodes[t], d.Helpers.hasProperty(this.nodes, t) && delete this.nodes[t], d.Helpers.hasProperty(this.nodeToLinks, t) && (e = e.concat(this.nodeToLinks[t]), delete this.nodeToLinks[t]), e
                    }, e.prototype.removeLink = function (t) {
                        delete this.links[t.id], d.Helpers.hasProperty(this.nodeToLinks, t.from) && d.Helpers.removeFromArrayHasty(this.nodeToLinks[t.from], t), d.Helpers.hasProperty(this.nodeToLinks, t.to) && d.Helpers.removeFromArrayHasty(this.nodeToLinks[t.to], t)
                    }, e.prototype.genRandomGraph = function (t) {
                        var e, i = t.randomNodes,
                            n = t.randomLinks;
                        e = "grid" === t.random ? this.genRandomGrid(i, t.randomGridLinkProbability) : "tree" === t.random ? this.genRandomTree(i, t.randomTreeDensity) : this.genRandomUniform(i, n);
                        for (var r = 0; r < e.nodes.length; r++) {
                            var s = e.nodes[r];
                            s.style = {
                                label: "Node " + s.id
                            }
                        }
                        for (var a = 0; a < e.links.length; a++) {
                            var o = e.links[a];
                            o.style = {
                                label: "Link " + o.id
                            }
                        }
                        return e
                    }, e.prototype.genRandomGrid = function (t, e) {
                        for (var i = [], n = [], r = 0; r <= t - 1; r++) {
                            var s = {
                                id: "n" + r,
                                loaded: !0
                            };
                            i.push(s)
                        }
                        for (var a = Math.ceil(Math.sqrt(t)), o = new d.Random(32131), l = 0; l <= a - 1; l++)
                            for (var h = 0; h <= a - 1; h++) {
                                var u = h + l * a;
                                u >= t || (h > 0 && o.get() <= e && n.push({
                                    from: "n" + u,
                                    to: "n" + (u - 1)
                                }), l > 0 && o.get() <= e && n.push({
                                    from: "n" + u,
                                    to: "n" + (u - a)
                                }))
                            }
                        for (var c = 0; c < n.length; c++) {
                            var p = n[c];
                            p.id = "" + c
                        }
                        return {
                            nodes: i,
                            links: n
                        }
                    }, e.prototype.genRandomUniform = function (t, e) {
                        for (var i = new d.Random(32131), n = [], r = [], s = 0; s < t; s++) {
                            var a = {
                                id: "n" + s,
                                loaded: !0
                            };
                            if (n.length > 0) {
                                var o = {
                                    id: "l" + s,
                                    from: a.id,
                                    to: n[i.get() * n.length | 0].id
                                };
                                r.push(o)
                            }
                            n.push(a)
                        }
                        for (var s = r.length; s <= e - 1; s++) {
                            var o = {
                                id: "l" + (s + 1),
                                from: n[i.get() * n.length | 0].id,
                                to: n[i.get() * n.length | 0].id
                            };
                            r.push(o)
                        }
                        return {
                            nodes: n,
                            links: r
                        }
                    }, e.prototype.genRandomTree = function (t, e) {
                        for (var i = new d.Random(31927832), n = {
                                id: "n0",
                                loaded: !0
                            }, r = [n], s = [n], a = []; s.length < t;) {
                            var o = i.getArrayElement(r);
                            d.Helpers.removeFromArrayHasty(r, o);
                            for (var l = Math.max(1, Math.ceil(i.get() * e)), h = 0; h < l; h++) {
                                var u = {
                                        id: "n" + s.length,
                                        loaded: !0
                                    },
                                    c = {
                                        id: "l" + s.length,
                                        from: o.id,
                                        to: u.id
                                    };
                                a.push(c), s.push(u), r.push(u)
                            }
                        }
                        return {
                            nodes: s,
                            links: a
                        }
                    }, e
                }(d.Data);
                t.Data = M;
                var I = function () {
                    function t(t) {
                        this.restoredState = {}, this.chart = t
                    }
                    return t.prototype.exportCoordinates = function (t) {
                        for (var e = this.chart.layer.idToNode, i = 0; i < t.length; i++) {
                            var n = t[i],
                                r = n.id;
                            if (d.Helpers.hasProperty(e, r)) {
                                var s = e[r];
                                s.removed || (n.x = s.x, n.y = s.y)
                            }
                        }
                    }, t.prototype.save = function () {
                        for (var t = {}, e = this.chart.layer.idToNode, i = Object.keys(e), n = 0; n < i.length; n++) {
                            var r = e[i[n]];
                            r.removed || (t[r.id] = {
                                x: r.x,
                                y: r.y,
                                r: r.hHeight,
                                w: r.hWidth
                            })
                        }
                        return t
                    }, t.prototype.restore = function (t) {
                        this.restoredState = {};
                        for (var e = this.chart.layer.idToNode, i = Object.keys(t), n = 0; n < i.length; n++) {
                            var r = i[n],
                                s = t[r];
                            if (d.Helpers.hasProperty(e, r)) {
                                var a = e[r];
                                a.x = s.x, a.y = s.y, a.hHeight = s.r, a.hWidth = s.w ? s.w : s.r
                            } else this.restoredState[r] = s
                        }
                    }, t.prototype.applyRestoredCoordinates = function (t) {
                        if (d.Helpers.hasProperty(this.restoredState, t.id)) {
                            var e = this.restoredState[t.id];
                            delete this.restoredState[t.id], t.x = e.x, t.y = e.y, t.hHeight = e.r, t.hWidth = e.w ? e.w : e.r
                        }
                    }, t.prototype.lockNode = function (t, e, i) {
                        void 0 === e && (e = null), void 0 === i && (i = null);
                        var n = this.chart.layer.idToNode;
                        if (d.Helpers.hasProperty(n, t)) {
                            var r = n[t];
                            r.userLock = !0, null !== e && null !== i && (r.x = e, r.y = i), this.chart.layer.touchNode(r)
                        } else this.chart.error("Locking nonexistant node: " + t)
                    }, t.prototype.unlockNode = function (t) {
                        var e = this.chart.layer.idToNode;
                        if (d.Helpers.hasProperty(e, t)) {
                            var i = e[t];
                            i.userLock && (i.userLock = !1, this.chart.layer.touchNode(i), this.chart.events.notifySceneChanges({
                                dynamicLayout: !0
                            }))
                        } else this.chart.error("Unlocking nonexistant node: " + t)
                    }, t.prototype.exportData = function () {
                        for (var t = this.chart.layer.idToNode, e = Object.keys(t), i = new Array(e.length), n = 0, r = 0; r < e.length; r++) {
                            var s = t[e[r]];
                            s.removed || (i[n++] = s.data)
                        }
                        i.length = n;
                        var a = this.chart.layer.idToLink;
                        e = Object.keys(a);
                        var o = new Array(e.length);
                        n = 0;
                        for (var r = 0; r < e.length; r++) {
                            var l = a[e[r]];
                            l.removed || (o[n++] = l.data)
                        }
                        return o.length = n, {
                            nodes: i,
                            links: o
                        }
                    }, t
                }();
                t.Graph = I;
                var P = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        i.numPointers = 0, i.resetZoom = !1, i.minimumAutoZoom = 1 / 0, i.animationOrder = 700, i.paintOrder = 20, i.updateOrder = 2e3, i.chart = e, i.scene = e.scene, i.layer = e.layer, i.events = e.events, i.settings = i.scene.settings;
                        var n = i._getInertiaAccelerations();
                        return i.inertiaX = new d.Inertia(n.x, 0), i.inertiaY = new d.Inertia(n.y, 0), i.inertiaZ = new d.Inertia(n.z, 1), i
                    }
                    return n(e, t), e.prototype.setZoom = function (t, e) {
                        void 0 === e && (e = !0);
                        var i = 1 + this.scene.settings.interaction.zooming.sensitivity;
                        if ("auto" === t) this.scene.autoZoomMode = !0, this.autoZoom(e);
                        else if ("overview" === t) this.scene.autoZoomMode = "overview", this.autoZoom(e);
                        else {
                            var n = void 0;
                            "in" === t ? n = 1 / this.inertiaZ.getTargetValue() * i : "out" === t ? n = 1 / this.inertiaZ.getTargetValue() / i : null === (n = d.Helpers.tryParseFloat(t, null)) && (this.chart.error("Invalid zoom value: " + t), n = 1 / this.inertiaZ.getTargetValue()), this.manualZoom(n / this.scene.zoom, void 0, void 0, e)
                        }
                        this.chart.events.notifySceneChanges({
                            position: !0
                        })
                    }, e.prototype.previewPointerDown = function () {
                        this.numPointers += 1
                    }, e.prototype.previewPointerUp = function () {
                        this.numPointers -= 1
                    }, e.prototype.previewPointerCancel = function () {
                        this.numPointers -= 1
                    }, e.prototype.doAnimations = function (t) {
                        var e = t.changes.settingsChanges;
                        if (e && e.interaction && e.interaction.zooming) {
                            this.minimumAutoZoom = 1 / 0;
                            var i = e.interaction.zooming.initialAutoZoom;
                            "true" === i ? i = !0 : "false" === i && (i = !1), this.scene.autoZoomMode = i, i && this.autoZoom(!0)
                        }
                        if (this.resetZoom || t.changes.newGraph) this.resetZoom = !1, this.setZoom("overview", !1);
                        else if (0 === this.numPointers && this.layer.nodes().length > 0) {
                            this.scene.autoZoomMode && this.autoZoom(!0) && (t.changes.position = !0);
                            var n = t.timeStamp,
                                r = this.inertiaX.getValue(n),
                                s = this.inertiaY.getValue(n),
                                a = 1 / this.inertiaZ.getValue(n);
                            r === this.scene.centerX && s === this.scene.centerY && a === this.scene.zoom || (this.scene.centerX = r, this.scene.centerY = s, this.scene.zoom = a, t.changes.position = !0), this.inertiaX.finished(n) && this.inertiaY.finished(n) && this.inertiaZ.finished(n) || (t.animating = !0)
                        } else this.inertiaX.jump(this.scene.centerX), this.inertiaY.jump(this.scene.centerY), this.inertiaZ.jump(1 / this.scene.zoom)
                    }, e.prototype._getInertiaAccelerations = function () {
                        var t = this.scene.settings.interaction.zooming.autoZoomPositionElasticity,
                            e = .5 * (this.scene.width + this.scene.height) * t;
                        return {
                            x: e,
                            y: e,
                            z: 2 * t
                        }
                    }, e.prototype.autoZoom = function (t, e) {
                        var i = !1,
                            n = this.computeAutoZoom("overview" === this.scene.autoZoomMode);
                        if (null == n) return !1;
                        var r = n.centerX,
                            s = n.centerY,
                            a = n.zoom,
                            o = .01,
                            l = 1 + o,
                            h = 1 - o,
                            u = 1 / this.inertiaZ.getTargetValue() / a,
                            c = this._getInertiaAccelerations();
                        (u > l || u < h) && (t ? this.inertiaZ.setTarget(1 / a, e, c.z) : (this.inertiaZ.jump(1 / a), this.scene.zoom = a), i = !0);
                        var d = this.scene.width,
                            p = (this.inertiaX.getTargetValue() - r) * a / d;
                        (p > o || p < -o) && (t ? this.inertiaX.setTarget(r, e, c.x) : (this.inertiaX.jump(r), this.scene.centerX = r), i = !0);
                        var f = this.scene.height,
                            g = (this.inertiaY.getTargetValue() - s) * a / f;
                        return (g > o || g < -o) && (t ? this.inertiaY.setTarget(s, e, c.y) : (this.inertiaY.jump(s), this.scene.centerY = s), i = !0), i
                    }, e.prototype.computeAutoZoom = function (t, e, i) {
                        var n, r = this.scene;
                        n = t ? this.layer.getGraphBounds(e) : this.layer.getNodeNeighborsBounds(r.lastClickedNode);
                        var s = n.x0,
                            a = n.y0,
                            o = n.x1,
                            l = n.y1;
                        if (0 === s && 0 === o && 0 === a && 0 === l) return null;
                        i && (n.y0 -= i[0], n.x1 += i[1], n.y1 += i[2], n.x0 -= i[3]);
                        var h = r.getVisibleBounds(),
                            u = r.settings.interaction.zooming,
                            c = (1 - u.autoZoomSize) / 2,
                            d = c * n.w(),
                            p = c * n.h(),
                            f = n.clone();
                        if (f.x0 -= d, f.x1 += d, f.y0 -= p, f.y1 += p, n.isInside(h) && !f.isInside(h)) return null;
                        var g = Math.min(r.width / f.w(), r.height / f.h()),
                            m = u.autoZoomExtent;
                        m && (g = Math.min(m[1], g), null === m[0] ? this.minimumAutoZoom = Math.min(g, this.minimumAutoZoom) : g = Math.max(m[0], g));
                        var v = (f.x0 + f.x1) / 2,
                            y = (f.y0 + f.y1) / 2,
                            S = (h.x0 + h.x1) / 2,
                            b = (h.y0 + h.y1) / 2;
                        return this.scene.zoom === g && Math.abs(v - S) <= d && Math.abs(y - b) <= p ? null : {
                            centerX: v,
                            centerY: y,
                            zoom: g
                        }
                    }, e.prototype.manualZoom = function (t, e, i, n) {
                        void 0 === e && (e = null), void 0 === i && (i = null), void 0 === n && (n = !1);
                        var r = this.scene,
                            s = this.settings.interaction.zooming.zoomExtent,
                            a = this.layer.getGraphBounds(),
                            o = a.x0,
                            l = a.y0,
                            h = a.x1,
                            c = a.y1,
                            d = r.zoom * t;
                        d = Math.min(d, Math.max(r.zoom, s[1])), d = Math.max(d, Math.min(r.zoom, Math.min(this.minimumAutoZoom, s[0]))), t = d / r.zoom;
                        var p, f;
                        if (null !== e && null !== i) {
                            var g = r.fromDisplay(e, i);
                            p = g.x, f = g.y
                        } else if (r.selection.length > 0) {
                            for (var m = 0, v = 0, y = 0, S = 0; S < r.selection.length; S++) {
                                var b = r.selection[S];
                                b instanceof u.Node && (m += b.x, v += b.y, y += 1)
                            }
                            y > 0 && (p = m / y, f = v / y)
                        }
                        var C, x;
                        p && f ? (C = (r.centerX - p) / t + p, x = (r.centerY - f) / t + f) : (C = p = r.centerX, x = f = r.centerY);
                        var w = r.zoom * t,
                            L = r.getVisibleBounds();
                        if (p < o || p > h) {
                            var T = void 0;
                            T = L.x0 > o && L.x1 > h ? Math.max(h - L.x1, o - L.x0) : L.x1 < h && L.x0 < o ? Math.min(h - L.x1, o - L.x0) : 0, C += T
                        }
                        if (f < l || f > c) {
                            var k = void 0;
                            k = L.y0 > l && L.y1 > c ? Math.max(c - L.y1, l - L.y0) : L.y1 < c && L.y0 < o ? Math.min(c - L.y1, l - L.y0) : 0, x += k
                        }
                        if (n && w !== r.zoom ? this.inertiaZ.setTarget(1 / w) : (this.inertiaZ.jump(1 / w), r.zoom = w), !n || C === r.centerX && x === r.centerY) r.centerX = C, r.centerY = x, this.inertiaX.jump(C), this.inertiaY.jump(x);
                        else {
                            var A = this._getInertiaAccelerations();
                            this.inertiaX.setTarget(C, null, A.x), this.inertiaY.setTarget(x, null, A.y)
                        }
                        r.autoZoomMode = !1
                    }, e.prototype.scrollIntoView = function (t, e) {
                        if (t && t.length) {
                            var i = d.Helpers.performanceNow();
                            this.scene.autoZoomMode = !1;
                            var n = this._getInertiaAccelerations(),
                                r = this.computeAutoZoom(!0, t, e);
                            r && (this.inertiaX.setTarget(r.centerX, i, n.x), this.inertiaY.setTarget(r.centerY, i, n.y), this.inertiaZ.setTarget(1 / r.zoom, i, n.z), this.chart.events.notifySceneChanges({
                                position: !0
                            }))
                        }
                    }, e
                }(d.ChartElement);
                t.AutoZoom = P;
                var D = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.updateOrder = 150, i.chart = e, i
                    }
                    return n(e, t), e.CreateNavigator = function (t) {
                        switch (t.settings.navigation.mode) {
                            case "manual":
                                return new N(t);
                            case "showall":
                                return new F(t);
                            case "focusnodes":
                                return new E(t);
                            default:
                                return t.error("Unknown navigation mode: '" + t.settings.navigation.mode + "'"), new F(t)
                        }
                    }, e.prototype.updateGraphWithNewData = function (t, e) {
                        for (var i = this.chart.layer, n = this.chart.scene.mainData, r = i.idToNode, s = Object.keys(t ? t : r), a = {
                                loading: !1
                            }, o = 0; o < s.length; o++) {
                            var l = s[o];
                            if (d.Helpers.hasProperty(r, l)) {
                                var h = r[l];
                                if (!h.removed) {
                                    var u = n.getNode(l, !1, a);
                                    u ? (this.updateNodeWithNewData(h, u, n.getLinks(l, !1)), i.touchNode(h)) : a.loading ? h.loading || (h.loading = !0, i.touchNode(h)) : this.ensureNodeRemoved(h)
                                }
                            }
                        }
                    }, e.prototype.calcExpanded = function (t) {
                        var e = t.expanded;
                        if (t.links.length < t.dataLinks.length) return t.expanded = !1, e;
                        for (var i = 0; i < t.links.length; i++)
                            if (t.links[i].removed) return t.expanded = !1, e;
                        return t.expanded = !0, !e
                    }, e.prototype.syncNodeLinks = function (t) {
                        for (var e = this.chart.layer, i = t.links, n = t.dataLinks, r = {}, s = 0; s < n.length; s++) r[n[s].id] = n[s];
                        for (var a = 0; a < i.length; a++) {
                            var o = i[a];
                            o.removed || (d.Helpers.hasProperty(r, o.id) ? (o.data = r[o.id], e.touchLink(o), delete r[o.id]) : this.ensureLinkRemoved(o))
                        }
                        for (var l = Object.keys(r), h = t.id, s = 0; s < l.length; s++) {
                            var o = r[l[s]],
                                u = M.otherEnd(o, h);
                            d.Helpers.hasProperty(e.idToNode, u) && !e.idToNode[u].removed && this.ensureLink(o)
                        }
                        this.calcExpanded(t)
                    }, e.prototype.updateNodeWithNewData = function (t, e, i) {
                        t.data = e, e.resetCoordinates && (t.x = e.x, t.y = e.y, e.resetCoordinates = !1), e.resetLocked && (t.userLock = e.locked, e.resetLocked = !1), e.loaded && (t.loading = !1), t.dataLinks = i, this.syncNodeLinks(t)
                    }, e.prototype.ensureNode = function (t, e) {
                        var i = this.chart.layer,
                            n = d.Helpers.hasProperty(i.idToNode, t.id) ? i.idToNode[t.id] : null;
                        return !(n && !n.removed) && (n = i.addNode(t.id), null != t.x && (n.x = t.x), null != t.y && (n.y = t.y), null != t.locked && (n.userLock = t.locked), t.resetCoordinates = !1, n.loading = !t.loaded, n.data = t, n.dataLinks = e, this.chart.graph.applyRestoredCoordinates(n), this.syncNodeLinks(n), !0)
                    }, e.prototype.ensureLink = function (t) {
                        var e = this.chart.layer,
                            i = d.Helpers.hasProperty(e.idToLink, t.id) ? e.idToLink[t.id] : null;
                        if (i && !i.removed) return !1;
                        var n = d.Helpers.hasProperty(e.idToNode, t.from) ? e.idToNode[t.from] : null,
                            r = d.Helpers.hasProperty(e.idToNode, t.to) ? e.idToNode[t.to] : null;
                        return !(!n || n.removed || !r || r.removed) && (i = e.addLink(t.id, t.from, t.to), i.data = t, this.calcExpanded(n), this.calcExpanded(r), !0)
                    }, e.prototype.ensureNodeRemoved = function (t) {
                        if (!t || t.removed) return !1;
                        for (var e = this.chart.layer, i = t.links, n = i.length - 1; n >= 0; n--) {
                            var r = i[n];
                            if (!r.removed) {
                                var s = r.otherEnd(t);
                                s !== t && !s.removed && s.expanded && (s.expanded = !1, e.touchNode(s)), e.removeLink(r)
                            }
                        }
                        return e.removeNode(t), !0
                    }, e.prototype.ensureLinkRemoved = function (t) {
                        if (!t || t.removed) return !1;
                        var e = this.chart.layer;
                        return !t.from.removed && t.from.expanded && (t.from.expanded = !1, e.touchNode(t.from)), !t.to.removed && t.to.expanded && (t.to.expanded = !1, e.touchNode(t.to)), e.removeLink(t), !0
                    }, e
                }(d.Navigator);
                t.Navigator = D;
                var N = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.saveHack = null, e.retryList = [], e
                    }
                    return n(e, t), e.prototype.executeAllSceneChanges = function (t) {
                        var e = this.retryList;
                        this.retryList = [];
                        for (var i = 0; i < e.length; i++) {
                            var n = e[i].fun(t);
                            null === n ? this.retryList.push(e[i]) : n && e[i].origin && this.chart.notifyChartUpdate(e[i].origin);
                        }
                    }, e.prototype.notifyNavigation = function (t, e) {
                        this.chart.events.notifySceneChanges({
                            navigation: !0
                        }), this.retryList.push({
                            fun: e,
                            origin: t
                        })
                    }, e.prototype.clearFocusNodes = function (t) {
                        var e = this;
                        this.notifyNavigation(t, function () {
                            for (var t = !1, i = e.chart.layer, n = i.idToNode, r = Object.keys(n), s = 0; s < r.length; s++) {
                                var a = n[r[s]];
                                a.focused && !a.removed && (t = !0, a.focused = !1, i.touchNode(a))
                            }
                            return t
                        })
                    }, e.prototype.hideNode = function (t, e) {
                        var i = this;
                        this.notifyNavigation(e, function () {
                            return i.ensureNodeRemoved(d.Helpers.hasProperty(i.chart.layer.idToNode, t) ? i.chart.layer.idToNode[t] : null)
                        })
                    }, e.prototype.showNode = function (t, e) {
                        var i = this;
                        this.notifyNavigation(e, function () {
                            var e = {
                                    loading: !1
                                },
                                n = i.chart.scene.mainData,
                                r = n.getNode(t, !0, e);
                            return r ? (i.ensureNode(r, n.getLinks(t)), !0) : !!e.loading && null
                        })
                    }, e.prototype.collapseNode = function (t, e) {
                        var i = this;
                        this.notifyNavigation(e, function () {
                            var e = i.chart.layer,
                                n = d.Helpers.hasProperty(e.idToNode, t) ? e.idToNode[t] : null;
                            if (!n || n.removed) return !1;
                            for (var r = !1, s = 0; s < n.links.length; s++) {
                                var a = n.links[s];
                                if (!a.removed) {
                                    var o = a.otherEnd(n);
                                    o !== n && (r = i.ensureNodeRemoved(o) || r)
                                }
                            }
                            return i.canHideNode(n) && (r = i.ensureNodeRemoved(n) || r), r
                        })
                    }, e.prototype.calculateCloseNodes = function (t) {
                        for (var e = {}, i = [], n = 0; n < t.links.length; n++) {
                            var r = t.links[n];
                            if (!r.removed) {
                                var s = r.otherEnd(t);
                                s === t || s.removed || (i.push(s), e[s.id] = !0)
                            }
                        }
                        e[t.id] = !0;
                        for (var a = [], n = 0; n < i.length; n++) {
                            for (var o = i[n], l = !0, h = 0; h < o.links.length; h++) {
                                var s = o.links[h].otherEnd(o);
                                if (!d.Helpers.hasProperty(e, s.id)) {
                                    l = !1;
                                    break
                                }
                            }
                            l && a.push(o)
                        }
                        return a
                    }, e.prototype.closeNode = function (t, e) {
                        var i = this;
                        this.notifyNavigation(e, function () {
                            var e = i.chart.layer,
                                n = d.Helpers.hasProperty(e.idToNode, t) ? e.idToNode[t] : null;
                            if (!n || n.removed) return !1;
                            for (var r = !1, s = i.calculateCloseNodes(n), a = 0; a < s.length; a++) r = i.ensureNodeRemoved(s[a]) || r;
                            return r
                        })
                    }, e.prototype.focusNode = function (t, e, i) {
                        var n = this;
                        this.chart.settings.navigation.autoUnfocus && this.clearFocusNodes("single"), this.notifyNavigation(i, function () {
                            var e = n.chart.layer.idToNode[t];
                            return e instanceof u.Node && !e.removed && (!e.focused && (e.focused = !0, n.chart.layer.touchNode(e), !0))
                        })
                    }, e.prototype.expandNode = function (t, e) {
                        var i = this,
                            n = {},
                            r = !1;
                        this.notifyNavigation(e, function () {
                            var e = i.chart.layer,
                                s = e.idToNode[t];
                            if (!(s instanceof u.Node) || s.removed) return !1;
                            var a = i.chart.scene.mainData,
                                o = s.dataLinks;
                            if (null != o)
                                for (var l = 0; l < o.length; l++) {
                                    var h = o[l];
                                    if (!d.Helpers.hasProperty(n, h.id)) {
                                        n[h.id] = !0;
                                        var c = d.Helpers.hasProperty(e.idToLink, h.id) ? e.idToLink[h.id] : null;
                                        if (!c || c.removed) {
                                            var p = M.otherEnd(h, t);
                                            if (p !== t) {
                                                var f = d.Helpers.hasProperty(e.idToNode, p) ? e.idToNode[p] : null;
                                                if (!f || f.removed) {
                                                    var g = a.getNode(p);
                                                    if (!g) continue;
                                                    i.ensureNode(g, a.getLinks(p))
                                                }
                                            }
                                            r = !0
                                        }
                                    }
                                }
                            return s.data.loaded ? r : null
                        })
                    }, e.prototype.unfocusNode = function (t, e) {
                        var i = this;
                        this.notifyNavigation(e, function () {
                            var e = i.chart.layer.idToNode[t];
                            return e instanceof u.Node && !e.removed && (!!e.focused && (e.focused = !1, i.chart.layer.touchNode(e), !0))
                        })
                    }, e.prototype.save = function () {
                        if (this.saveHack) return this.saveHack;
                        for (var t = {}, e = this.chart.layer.idToNode, i = Object.keys(e), n = 0; n < i.length; n++) {
                            var r = e[i[n]];
                            r.removed || (t[r.id] = r.focused)
                        }
                        return t
                    }, e.prototype.restore = function (t) {
                        var e = this,
                            i = t;
                        if (i) {
                            this.saveHack = i, this.chart.notifyChartUpdate("restore"), this.saveHack = null;
                            var n = {},
                                r = !1,
                                s = !1;
                            this.notifyNavigation(null, function () {
                                var t, a = e.chart.layer,
                                    o = e.chart.scene.mainData,
                                    l = !1,
                                    h = {
                                        loading: !1
                                    },
                                    u = a.idToNode;
                                if (!s) {
                                    t = Object.keys(u);
                                    for (var c = 0; c < t.length; c++) {
                                        var p = t[c];
                                        d.Helpers.hasProperty(i, p) || u[p].removed || (r = e.ensureNodeRemoved(u[p]) || r)
                                    }
                                    s = !0
                                }
                                t = Object.keys(i);
                                for (var c = 0; c < t.length; c++) {
                                    var p = t[c];
                                    if (!d.Helpers.hasProperty(n, p)) {
                                        var f = d.Helpers.hasProperty(a.idToNode, p) ? a.idToNode[p] : null;
                                        if (!f || f.removed) {
                                            var g = o.getNode(p, !0, h);
                                            if (!g) {
                                                h.loading ? l = !0 : n[p] = !0;
                                                continue
                                            }
                                            e.ensureNode(g, o.getLinks(p)), a.idToNode[p].focused = i[p], r = !0
                                        } else f && f.focused !== i[p] && (f.focused = i[p], a.touchNode(f), r = !0);
                                        n[p] = !0
                                    }
                                }
                                return l ? null : r
                            })
                        }
                    }, e.prototype.onNewDataObject = function () {
                        for (var t = this, e = this.save(), i = this.chart.scene.mainData, n = Object.keys(e), r = 0; r < n.length; r++) i.getNode(n[r]);
                        this.notifyNavigation(null, function () {
                            var n, r = t.chart.layer,
                                s = r.idToNode,
                                a = {
                                    loading: !1
                                };
                            n = Object.keys(e);
                            for (var o = 0; o < n.length; o++) {
                                var l = n[o];
                                if (d.Helpers.hasProperty(s, l) && !s[l].removed) {
                                    var h = i.getNode(l, !0, a);
                                    if (h) delete e[l];
                                    else if (a.loading) return null
                                } else delete e[l]
                            }
                            return !0
                        })
                    }, e.prototype.showInitialNodes = function () {
                        var t = this,
                            e = !1,
                            i = this.chart.settings.navigation.initialNodes,
                            n = !1,
                            r = !1;
                        this.retryList = [], this.notifyNavigation("init", function (s) {
                            var a = t.chart.layer;
                            if (e || (d.Helpers.hasProperties(a.nodes) && (a.clearObjects(), n = !0), e = !0), null == i || i.length < 1) return n;
                            var o = {
                                    loading: !1
                                },
                                l = t.chart.scene.mainData,
                                h = !1,
                                u = i;
                            i = [];
                            for (var c = 0; c < u.length; c++) {
                                var p = u[c],
                                    f = l.getNode(p, !0, o);
                                f ? (n = t.ensureNode(f, l.getLinks(p)) || n, r || (r = !0, s.changes.newGraph = !0)) : o.loading && (i.push(p), h = !0)
                            }
                            return h ? null : n
                        })
                    }, e.prototype.onSceneChange = function (t) {
                        t.changes.filters ? this.updateGraphWithNewData(null, t) : (t.changes.dataArrived || t.changes.data) && this.updateGraphWithNewData(t.changes.netChartDataNodes, t), this.retryList.length > 0 && (t.changes.navigation || t.changes.dataArrived) && this.executeAllSceneChanges(t)
                    }, e.prototype.canFocusNode = function (t) {
                        return !t.focused
                    }, e.prototype.canUnfocusNode = function (t) {
                        return t.focused
                    }, e.prototype.canExpandNode = function (t) {
                        return !t.expanded
                    }, e.prototype.canCollapseNode = function (t) {
                        return this.canHideNode(t)
                    }, e.prototype.canHideNode = function (t) {
                        for (var e = this.chart.layer, i = Object.keys(e.idToNode), n = 0; n < i.length; n++) {
                            var r = e.idToNode[i[n]];
                            if (r !== t && !r.removed) return !0
                        }
                        return !1
                    }, e.prototype.canCloseNode = function (t) {
                        return this.calculateCloseNodes(t).length > 0
                    }, e
                }(D);
                t.ManualNavigator = N;
                var F = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.hiddenNodes = {}, e.isInitialized = !1, e
                    }
                    return n(e, t), e.prototype.showNode = function (e, i) {
                        delete this.hiddenNodes[e], t.prototype.showNode.call(this, e, i)
                    }, e.prototype.hideNode = function (e, i) {
                        var n = this.chart.layer.idToNode;
                        d.Helpers.hasProperty(n, e) && (this.hiddenNodes[e] = !0, t.prototype.hideNode.call(this, e, i))
                    }, e.prototype.collapseNode = function (e, i) {
                        var n = this.chart.layer.idToNode;
                        if (d.Helpers.hasProperty(n, e)) {
                            this.hiddenNodes[e] = !0;
                            for (var r = n[e], s = 0; s < r.links.length; s++) {
                                var a = r.links[s];
                                if (!a.removed) {
                                    var o = a.otherEnd(r);
                                    o !== r && (this.hiddenNodes[o.id] = !0)
                                }
                            }
                            t.prototype.collapseNode.call(this, e, i)
                        }
                    }, e.prototype.closeNode = function (e, i) {
                        var n = this.chart.layer.idToNode;
                        if (d.Helpers.hasProperty(n, e)) {
                            for (var r = this.calculateCloseNodes(n[e]), s = 0; s < r.length; s++) this.hiddenNodes[r[s].id] = !0;
                            t.prototype.closeNode.call(this, e, i)
                        }
                    }, e.prototype.save = function () {
                        if (this.saveHack) return this.saveHack;
                        var t;
                        t = [];
                        for (var e = this.chart.layer.idToNode, i = Object.keys(e), n = 0; n < i.length; n++) {
                            var r = e[i[n]];
                            !r.removed && r.focused && t.push(r.id)
                        }
                        return {
                            hidden: Object.keys(this.hiddenNodes),
                            focused: t
                        }
                    }, e.prototype.restore = function (t) {
                        var e = this,
                            i = t;
                        this.hiddenNodes = {};
                        for (var n = 0; n < i.hidden.length; n++) this.hiddenNodes[i.hidden[n]] = !0;
                        this.saveHack = i, this.chart.notifyChartUpdate("restore"), this.saveHack = null, this.notifyNavigation(null, function (t) {
                            e.updateGraphWithNewData(null, t);
                            for (var n = {}, r = 0; r < i.focused.length; r++) n[i.focused[r]] = !0;
                            for (var s = e.chart.layer, a = s.idToNode, o = Object.keys(a), r = 0; r < o.length; r++) {
                                var l = a[o[r]],
                                    h = d.Helpers.hasProperty(n, o[r]);
                                l.removed || l.focused === h || (l.focused = h, s.touchNode(l))
                            }
                            return !1
                        })
                    }, e.prototype.expandNode = function (e, i) {
                        var n = this.chart.layer.idToNode;
                        if (d.Helpers.hasProperty(n, e)) {
                            for (var r = n[e], s = 0; s < r.dataLinks.length; s++) {
                                var a = r.dataLinks[s],
                                    o = M.otherEnd(a, e);
                                o !== e && delete this.hiddenNodes[o]
                            }
                            t.prototype.expandNode.call(this, e, i)
                        }
                    }, e.prototype.showInitialNodes = function () {
                        var t = this;
                        this.retryList = [], this.notifyNavigation("init", function (e) {
                            var i = t.chart.layer,
                                n = t.chart.scene.mainData;
                            t.hiddenNodes = {}, i.clearObjects(), t.isInitialized = !0;
                            var r, s = t.chart.settings.navigation.initialNodes,
                                a = {};
                            if (null == s || s.length < 1) {
                                r = n.getAllNodes();
                                for (var o = 0; o < r.length; o++) a[r[o].id] = !0
                            } else {
                                r = n.getAllNodes(!1);
                                for (var o = 0; o < r.length; o++) a[r[o].id] = !0;
                                for (var o = 0; o < s.length; o++) {
                                    var l = s[o];
                                    if (!d.Helpers.hasProperty(a, l)) {
                                        var h = n.getNode(l);
                                        h && (r.push(h), a[l] = !0)
                                    }
                                }
                            }
                            for (var o = 0; o < r.length; o++) {
                                var u = r[o],
                                    c = n.getLinks(u.id);
                                t.ensureNode(u, c);
                                for (var p = 0; p < c.length; p++) {
                                    var f = M.otherEnd(c[p], u.id);
                                    if (f && f !== u.id && !d.Helpers.hasProperty(a, f)) {
                                        a[f] = !0;
                                        var g = n.getNode(f);
                                        g && r.push(g)
                                    }
                                }
                            }
                            return r.length > 0 && (e.changes.newGraph = !0), !0
                        })
                    }, e.prototype.onNewDataObject = function () {
                        var t = this,
                            e = this.chart.settings.navigation.initialNodes;
                        (null == e || e.length < 1) && this.chart.scene.mainData.getAllNodes(), this.notifyNavigation(null, function (e) {
                            return t.updateGraphWithNewData(null, e), !1
                        })
                    }, e.prototype.updateGraphWithNewData = function (t, e) {
                        if (this.isInitialized) {
                            var i, n = this.chart.layer,
                                r = this.chart.scene.mainData,
                                s = n.idToNode,
                                a = {};
                            if (t) {
                                i = Object.keys(t);
                                for (var o = 0; o < i.length; o++) a[i[o]] = r.getNode(i[o], !1)
                            } else {
                                for (var l = r.getAllNodes(!1), o = 0; o < l.length; o++) a[l[o].id] = l[o];
                                for (var h = Object.keys(s), o = 0; o < h.length; o++) d.Helpers.hasProperty(a, h[o]) || (a[h[o]] = null);
                                h = Object.keys(this.hiddenNodes);
                                for (var o = 0; o < h.length; o++) d.Helpers.hasProperty(a, h[o]) || (a[h[o]] = null);
                                i = Object.keys(a)
                            }
                            for (var u = !1, c = Object.keys(s), o = 0; o < c.length; o++)
                                if (!s[c[o]].removed) {
                                    u = !0;
                                    break
                                }
                            for (var p = !1, o = 0; o < i.length; o++) {
                                var f = i[o],
                                    g = a[f],
                                    m = d.Helpers.hasProperty(s, f) ? s[f] : null;
                                if (g) {
                                    if (d.Helpers.hasProperty(this.hiddenNodes, f)) {
                                        this.ensureNodeRemoved(m);
                                        continue
                                    }
                                    var v = r.getLinks(f, !1);
                                    m && !m.removed ? (this.updateNodeWithNewData(m, g, v), n.touchNode(m)) : (this.ensureNode(g, v), m = s[f], p = !0);
                                    for (var y = 0; y < v.length; y++) {
                                        var S = M.otherEnd(v[y], f);
                                        if (S && S !== f && !d.Helpers.hasProperty(this.hiddenNodes, S)) {
                                            var b = d.Helpers.hasProperty(s, S) ? s[S] : null;
                                            if (!b || b.removed) {
                                                var C = r.getNode(S);
                                                C && this.ensureNode(C, r.getLinks(S))
                                            }
                                        }
                                    }
                                } else r.isNodeLoading(f) ? m && !m.loading && (m.loading = !0, n.touchNode(m)) : (this.ensureNodeRemoved(m), delete this.hiddenNodes[f])
                            }!u && p && (e.changes.newGraph = !0)
                        }
                    }, e
                }(N);
                t.ShowAllNavigator = F;
                var O;
                ! function (t) {
                    t[t.Hidden = 1] = "Hidden", t[t.Expanded = 2] = "Expanded"
                }(O || (O = {}));
                var E = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.focusNodes = [], e.extraFlags = {}, e.needsFullRecalculate = !1, e.wasReset = !1, e
                    }
                    return n(e, t), e.prototype.expandNode = function (t, e) {
                        var i = this.chart.layer.idToNode,
                            n = d.Helpers.hasProperty(i, t) ? i[t] : null,
                            r = !1;
                        if (n && !n.removed) {
                            n.relevance < 2 && (this.extraFlags[t] = O.Expanded, r = !0);
                            for (var s = 0; s < n.dataLinks.length; s++) {
                                var a = M.otherEnd(n.dataLinks[s], t);
                                a && a !== t && d.Helpers.hasProperty(this.extraFlags, a) && this.extraFlags[a] === O.Hidden && (delete this.extraFlags[a], r = !0)
                            }
                            r && (this.scheduleFullRecalculate(), this.chart.notifyChartUpdate(e))
                        }
                    }, e.prototype.collapseNode = function (t, e) {
                        var i = this.chart.layer.idToNode,
                            n = d.Helpers.hasProperty(i, t) ? i[t] : null,
                            r = !1;
                        if (n && !n.removed) {
                            d.Helpers.hasProperty(this.extraFlags, t) && (delete this.extraFlags[t], r = !0);
                            for (var s = 0; s < n.links.length; s++) {
                                var a = n.links[s].otherEnd(n);
                                a && a !== n && !a.removed && a.baseRelevance < n.baseRelevance && (this.extraFlags[a.id] = O.Hidden, r = !0)
                            }
                            r && (this.scheduleFullRecalculate(), this.chart.notifyChartUpdate(e))
                        }
                    }, e.prototype.closeNode = function (t, e) {}, e.prototype.focusNode = function (t, e, i) {
                        for (var n = 0; n < this.focusNodes.length; n++)
                            if (this.focusNodes[n].id === t) return;
                        if (this.focusNodes.length >= this.chart.settings.navigation.numberOfFocusNodes) {
                            if (!this.chart.settings.navigation.autoUnfocus) return;
                            this.focusNodes.pop()
                        }
                        this.focusNodes.unshift({
                            id: t,
                            assignedRelevance: e,
                            calculatedRelevance: null
                        }), d.Helpers.hasProperty(this.extraFlags, t) && this.extraFlags[t] === O.Hidden && delete this.extraFlags[t];
                        var r = this.chart.scene.mainData.getLinks(t, !1);
                        if (r)
                            for (var n = 0; n < r.length; n++) {
                                var s = M.otherEnd(r[n], t);
                                s && s !== t && d.Helpers.hasProperty(this.extraFlags, s) && this.extraFlags[s] === O.Hidden && delete this.extraFlags[s]
                            }
                        this.chart.notifyChartUpdate(i), this.scheduleFullRecalculate()
                    }, e.prototype.unfocusNode = function (t, e) {
                        if (!(this.focusNodes.length <= Math.max(this.chart.settings.navigation.minNumberOfFocusNodes, 1)))
                            for (var i = 0; i < this.focusNodes.length; i++)
                                if (this.focusNodes[i].id === t) return this.focusNodes.splice(i, 1), this.chart.notifyChartUpdate(e), void this.scheduleFullRecalculate()
                    }, e.prototype.clearFocusNodes = function (t) {
                        this.focusNodes = [], this.extraFlags = {}, this.wasReset = !0, this.chart.notifyChartUpdate(t), this.scheduleFullRecalculate()
                    }, e.prototype.hideNode = function (t, e) {
                        var i = this.chart.layer.idToNode,
                            n = d.Helpers.hasProperty(i, t) ? i[t] : null;
                        n && !n.removed && this.canHideNode(n) && (this.extraFlags[t] = O.Hidden, this.chart.notifyChartUpdate(e), this.scheduleFullRecalculate())
                    }, e.prototype.showNode = function (t, e) {
                        d.Helpers.hasProperty(this.extraFlags, t) && this.extraFlags[t] === O.Hidden && (delete this.extraFlags[t], this.scheduleFullRecalculate())
                    }, e.prototype.showInitialNodes = function () {
                        this.extraFlags = {};
                        var t = this.chart.settings.navigation.initialNodes;
                        if (t) {
                            var e = {};
                            this.focusNodes = new Array(t.length);
                            for (var i = 0, n = 0; n < t.length; n++) {
                                var r = t[n];
                                d.Helpers.hasProperty(e, r) || (e[r] = !0, this.focusNodes[i++] = {
                                    id: r,
                                    assignedRelevance: -1,
                                    calculatedRelevance: null
                                })
                            }
                            i < this.chart.settings.navigation.minNumberOfFocusNodes && this.chart.error("Too few initialNodes. minNumberOfFocusNodes is " + this.chart.settings.navigation.minNumberOfFocusNodes + " but there are only " + i + " nodes in initialNodes"), i > this.chart.settings.navigation.numberOfFocusNodes && (this.chart.error("Too many initialNodes. numberOfFocusNodes is " + this.chart.settings.navigation.numberOfFocusNodes + " but there are " + i + " nodes in initialNodes. Discarding excess focus nodes."), i = this.chart.settings.navigation.numberOfFocusNodes), this.focusNodes.length = i
                        } else this.focusNodes = [];
                        this.wasReset = !0, this.chart.notifyChartUpdate("init"), this.scheduleFullRecalculate()
                    }, e.prototype.save = function () {
                        return {
                            focusNodes: this.focusNodes,
                            extraFlags: this.extraFlags
                        }
                    }, e.prototype.restore = function (t) {
                        this.focusNodes = d.Helpers.realClone(t.focusNodes), this.extraFlags = d.Helpers.clone(t.extraFlags), this.scheduleFullRecalculate(), this.chart.notifyChartUpdate("restore")
                    }, e.prototype.onNewDataObject = function () {
                        for (var t = this.chart.scene.mainData, e = Object.keys(this.chart.layer.idToNode), i = 0; i < e.length; i++) t.getNode(e[i])
                    }, e.prototype.onSceneChange = function (t) {
                        t.changes.filters ? (this.updateGraphWithNewData(null, t), this.needsFullRecalculate = !0) : t.changes.dataArrived || t.changes.data ? (this.updateGraphWithNewData(t.changes.netChartDataNodes, t), this.needsFullRecalculate = !0) : t.changes.settings && t.changes.settingsChanges.navigation && (this.needsFullRecalculate = !0), this.needsFullRecalculate && (this.needsFullRecalculate = !1, this.fullRecalculate(t.timeStamp, t))
                    }, e.prototype.scheduleFullRecalculate = function () {
                        this.needsFullRecalculate = !0, this.chart.events.notifySceneChanges({
                            navigation: !0
                        })
                    }, e.prototype.fullRecalculate = function (t, e) {
                        var i = this,
                            n = this.chart.settings.navigation,
                            r = this.chart.layer,
                            s = this.chart.scene.mainData;
                        if (this.focusNodes.length < 1) return r.clearObjects(), this.wasReset && (e.changes.newGraph = !0), void(this.wasReset = !1);
                        for (var a = t - this.chart.settings.navigation.expandDelay, o = r.idToNode, l = Object.keys(o), h = r.idToLink, u = 0; u < l.length; u++) {
                            var c = o[l[u]];
                            c.baseRelevance = -(1 / 0), c.relevance = -(1 / 0), c.focused = !1, r.touchNode(c)
                        }
                        if (n.numberOfFocusNodes > 1)
                            for (var p = null == n.focusNodeTailExpansionRadius ? n.focusNodeExpansionRadius : n.focusNodeTailExpansionRadius, f = Math.max(n.focusNodeExpansionRadius + 1, 1), g = Math.max(p + 1, 1), m = (f - g) / (n.numberOfFocusNodes - 1), u = 0; u < this.focusNodes.length; u++) this.focusNodes[u].calculatedRelevance = f - u * m;
                        else this.focusNodes[0].calculatedRelevance = Math.max(n.focusNodeExpansionRadius + 1, 1);
                        for (var v = [], y = {}, S = {}, u = 0; u < this.focusNodes.length; u++) {
                            var b = this.focusNodes[u],
                                c = d.Helpers.hasProperty(o, b.id) ? o[b.id] : null;
                            if (!c || c.removed) {
                                var C = s.getNode(b.id);
                                if (!C) continue;
                                this.ensureNode(C, s.getLinks(b.id)), c = o[b.id]
                            }
                            c.focused = !0, c.baseRelevance = b.assignedRelevance >= 1 ? b.assignedRelevance : b.calculatedRelevance, c.relevance = c.baseRelevance, c.showTimestamp = -(1 / 0), v.push(c), y[b.id] = !0, S[b.id] = !0, this.wasReset && (this.wasReset = !1, e.changes.newGraph = !0)
                        }
                        for (var x = Object.keys(this.extraFlags), u = 0; u < x.length; u++) {
                            var w = x[u],
                                c = d.Helpers.hasProperty(o, w) ? o[w] : null;
                            if (c && !c.removed)
                                if (this.extraFlags[w] === O.Hidden) c.relevance = -100;
                                else if (c.relevance < 2) {
                                c.relevance = 2;
                                for (var L = 0; L < c.links.length; L++) {
                                    var T = c.links[L].otherEnd(c);
                                    T && T !== c && T.relevance < 1 && T.relevance !== -100 && (T.relevance = 1)
                                }
                            } else delete this.extraFlags[w]
                        }
                        for (var k = 1 / 0, u = 0; u < v.length; u++) {
                            var c = v[u];
                            delete y[c.id];
                            for (var w = c.id, A = c.baseRelevance - 1, I = c.relevance - 1, P = d.Helpers.hasProperty(S, w) && c.relevance > 0, L = 0; L < c.dataLinks.length; L++) {
                                var D = c.dataLinks[L],
                                    N = M.otherEnd(D, w);
                                if (N && N !== w) {
                                    P && (S[N] = !0);
                                    var F = d.Helpers.hasProperty(this.extraFlags, N) ? this.extraFlags[N] : null;
                                    if (F !== O.Hidden) {
                                        var E = I;
                                        F === O.Expanded && I >= 2 && delete this.extraFlags[N];
                                        var T = d.Helpers.hasProperty(o, N) ? o[N] : null,
                                            R = !1;
                                        if (!T || T.removed) {
                                            if (E <= 0) continue;
                                            var C = s.getNode(N);
                                            if (!C) continue;
                                            if (c.showTimestamp > a) {
                                                k > c.showTimestamp && (k = c.showTimestamp);
                                                continue
                                            }
                                            this.ensureNode(C, s.getLinks(N)), T = o[N], T.relevance = E, T.baseRelevance = A, T.showTimestamp = t, R = !0
                                        } else T.relevance < E && (T.relevance = E, r.touchNode(T), R = !0), T.baseRelevance < A && (T.baseRelevance = A, r.touchNode(T), R = !0);
                                        var H = h[D.id],
                                            B = Math.min(c.relevance, T.relevance);
                                        H.relevance !== B && (H.relevance = B, r.touchLink(H)), R && !d.Helpers.hasProperty(y, N) && (y[N] = !0, v.push(T))
                                    }
                                }
                            }
                        }
                        for (var u = 0; u < l.length; u++) {
                            var w = l[u],
                                c = o[w];
                            c.removed || (d.Helpers.hasProperty(S, w) ? c.relevance <= 0 && this.ensureNodeRemoved(c) : (this.ensureNodeRemoved(c), delete this.extraFlags[w]))
                        }
                        k < 1 / 0 && window.setTimeout(function () {
                            return i.scheduleFullRecalculate()
                        }, k + this.chart.settings.navigation.expandDelay - t)
                    }, e.prototype.canFocusNode = function (t) {
                        return !t.focused && (this.focusNodes.length < this.chart.settings.navigation.numberOfFocusNodes || this.chart.settings.navigation.autoUnfocus)
                    }, e.prototype.canUnfocusNode = function (t) {
                        return t.focused && this.focusNodes.length > Math.max(this.chart.settings.navigation.minNumberOfFocusNodes, 1)
                    }, e.prototype.canExpandNode = function (t) {
                        return !t.expanded
                    }, e.prototype.canCollapseNode = function (t) {
                        for (var e = 0; e < t.links.length; e++) {
                            var i = t.links[e].otherEnd(t);
                            if (i && i !== t && !i.removed && i.baseRelevance < t.baseRelevance) return !0
                        }
                        return !1
                    }, e.prototype.canHideNode = function (t) {
                        return !t.focused || this.canUnfocusNode(t)
                    }, e.prototype.canCloseNode = function (t) {
                        return !1
                    }, e
                }(D);
                t.FocusNodesNavigator = E,
                    function (t) {
                        var e = function () {
                            function t(t) {
                                this.pointers = [], this.manager = t
                            }
                            return t.prototype.addPointer = function (t, e) {
                                this.pointers.push(t.identifier), t.consumed = !0
                            }, t.prototype.removePointer = function (t) {
                                d.Helpers.removeFromArrayHasty(this.pointers, t.identifier), t.consumed = !0
                            }, t.prototype.movePointer = function (t) {
                                t.consumed = !0
                            }, t
                        }();
                        t.Gesture = e;
                        // console.log('begin')
                        var i = function (t) {
                            // console.log('-------t----------');
                            // console.log(t);
                            function e() {
                                var e = t.apply(this, arguments) || this;
                                // console.log('-------arguments----------');
                                // console.log(arguments);
                                return e.startX = 0, e.startY = 0, e.lastX = 0, e.lastY = 0, e.selectedNodes = null, e
                            }
                            return n(e, t), e.prototype.addPointer = function (e, i) {
                                // console.log('-------e----------');
                                // console.log(e);
                                t.prototype.addPointer.call(this, e, i), this.startX = this.lastX = e.x, this.startY = this.lastY = e.y, this.selectedNodes = new Object(null), e.cursor = "crosshair";
                                    // console.log('-------i----------');
                                    // console.log(i);
                                    var n = this.manager.chart.scene;
                                    // console.log('-------n----------');
                                    // console.log(n);
                                n.disableSelectionChangeNotification();
                                var r = n.selection.filter(function (t) {
                                    return t.dragging
                                });
                                r.length !== n.selection.length && n.setSelection(r), this.manager.chart.events.requestPaint()
                            }, e.prototype.movePointer = function (e) {
                                t.prototype.movePointer.call(this, e), this.lastX = e.x, this.lastY = e.y, this.manager.chart.events.requestPaint(), e.cursor = "crosshair", this.updateSelection()
                            }, e.prototype.removePointer = function (e) {
                                t.prototype.removePointer.call(this, e);
                                for (var i in this.selectedNodes) this.selectedNodes[i].selectionLock = !1;
                                this.manager.chart.scene.enableSelectionChangeNotification(), this.manager.chart.scene.notifySelectionChangesIfNeeded(this.manager.chart, "user"), this.manager.chart.events.requestPaint()
                            }, e.prototype.doAnimations = function (t) {
                                this.pointers.length > 0 && (t.changes.position || t.changes.selection || this.manager.chart.layer.hasTopologyChanges()) && this.updateSelection()
                            }, e.prototype.updateSelection = function () {
                                for (var t = this.manager.chart.layer.nodes(), e = this.manager.chart.scene, i = e.fromDisplay(this.startX, this.startY), n = e.fromDisplay(this.lastX, this.lastY), r = Math.min(i.x, n.x), s = Math.min(i.y, n.y), a = Math.max(i.x, n.x), o = Math.max(i.y, n.y), l = 0; l < t.length; l++) {
                                    var h = t[l];
                                    h.removed ? this.selectedNodes[h.id] && delete this.selectedNodes[h.id] : h.dragging || (h.x >= r && h.x <= a && h.y >= s && h.y <= o ? this.selectedNodes[h.id] || (this.selectedNodes[h.id] = h, h.selectionLock = !0, h.selected || e.addToSelection(h)) : this.selectedNodes[h.id] && (delete this.selectedNodes[h.id], h.selectionLock = !1, h.selected && e.removeFromSelection(h)))
                                }
                            }, e.prototype.paintScene = function (t) {
                                if (this.pointers.length > 0) {
                                    var e = this.manager.chart.settings.style.dragSelection,
                                        i = d.Graphics.beginStrokeAndFill(t.context, e);
                                    i.rect(this.startX - .5, this.startY - .5, this.lastX - this.startX, this.lastY - this.startY), d.Graphics.endStrokeAndFill(t.context, i, e)
                                }
                            }, e
                        }(e);
                        t.MultiSelectGesture = i;
                        var r = function (t) {
                            function e() {
                                var e = t.apply(this, arguments) || this;
                                return e.dragPointers = {}, e
                            }
                            return n(e, t), e.prototype.addPointer = function (e, i) {
                                t.prototype.addPointer.call(this, e, i);
                                var n = this.manager.chart.scene.selection.filter(function (t) {
                                    return !t.dragging
                                });
                                n.indexOf(i.object) < 0 && n.push(i.object);
                                for (var r = n.filter(function (t) {
                                        return t instanceof u.Node
                                    }), s = 0; s < r.length; s++) r[s].locks++;
                                for (var s = 0; s < n.length; s++) n[s].dragging = !0;
                                var a = this.manager.chart.scene.fromDisplay(e.x, e.y);
                                this.dragPointers[e.identifier] = {
                                    nodes: r,
                                    all: n,
                                    mainNode: i.object,
                                    startPointerX: e.x,
                                    startPointerY: e.y,
                                    lastPointerX: e.x,
                                    lastPointerY: e.y,
                                    lastSceneX: a.x,
                                    lastSceneY: a.y
                                }
                            }, e.prototype.removePointer = function (e) {
                                t.prototype.removePointer.call(this, e);
                                var i = this.dragPointers[e.identifier];
                                delete this.dragPointers[e.identifier];
                                for (var n = 0; n < i.nodes.length; n++) i.nodes[n].locks--;
                                for (var n = 0; n < i.all.length; n++) i.all[n].dragging = !1;
                                this.manager.autoZoomIn(e, i.mainNode)
                            }, e.prototype.movePointer = function (e) {
                                t.prototype.movePointer.call(this, e);
                                var i = this.dragPointers[e.identifier];
                                i.lastPointerX = e.x, i.lastPointerY = e.y;
                                var n = this.manager.chart.settings.interaction.selection,
                                    r = this.manager.chart.scene,
                                    s = r.fromDisplay(e.x, e.y),
                                    a = s.x - i.lastSceneX,
                                    o = s.y - i.lastSceneY;
                                if (0 !== a || 0 !== o) {
                                    i.lastSceneX = s.x, i.lastSceneY = s.y;
                                    var l = n.lockNodesOnMove;
                                    if (l) {
                                        var h = e.x - i.startPointerX,
                                            u = e.y - i.startPointerY,
                                            c = this.manager.chart.settings.advanced.pointer,
                                            d = Math.max(c.clickSensitivity, c.longPressSensitivity);
                                        l = h * h + u * u > d * d
                                    }
                                    this.moveNodes(i.nodes, a, o, l), this.manager.chart.events.notifySceneChanges({
                                        coordinates: !0
                                    })
                                }
                            }, e.prototype.moveNodes = function (t, e, i, n) {
                                for (var r = this.manager.chart.scene, s = r.getVisibleBounds(), a = r.zoom, o = this.manager.chart.settings.interaction.selection.allowMoveNodesOffscreen, l = this.manager.chart.layer, h = 0; h < t.length; h++) {
                                    var u = t[h];
                                    if (u.x += e, u.y += i, n && !u.userLock && (u.userLock = !0, l.touchNode(u)), !o) {
                                        var c = 1.2 * u.renderHwidth / a,
                                            d = 1.2 * u.renderHheight / a;
                                        u.x = Math.min(Math.max(u.x, s.x0 + c), s.x1 - c), u.y = Math.min(Math.max(u.y, s.y0 + d), s.y1 - d)
                                    }
                                }
                            }, e.prototype.doAnimations = function (t) {
                                for (var e = this.manager.chart.scene, i = 0; i < this.pointers.length; i++) {
                                    var n = this.dragPointers[this.pointers[i]],
                                        r = e.fromDisplay(n.lastPointerX, n.lastPointerY),
                                        s = r.x - n.lastSceneX,
                                        a = r.y - n.lastSceneY;
                                    0 === s && 0 === a || (n.lastSceneX = r.x, n.lastSceneY = r.y, this.moveNodes(n.nodes, s, a, !1), t.changes.coordinates = !0)
                                }
                            }, e
                        }(e);
                        t.NodeDragGesture = r;
                        var s = function (t) {
                            function e() {
                                var e = t.apply(this, arguments) || this;
                                return e.pinnedSceneX = 0, e.pinnedSceneY = 0, e
                            }
                            return n(e, t), e.prototype.addPointer = function (e, i) {
                                t.prototype.addPointer.call(this, e, i);
                                var n = this.manager.chart.scene.fromDisplay(e.x, e.y);
                                this.pinnedSceneX = n.x, this.pinnedSceneY = n.y
                            }, e.prototype.movePointer = function (e) {
                                t.prototype.movePointer.call(this, e);
                                var i = this.manager.chart.scene;
                                i.autoZoomMode = !1;
                                var n = i.fromDisplay(e.x, e.y);
                                i.centerX += this.pinnedSceneX - n.x, i.centerY += this.pinnedSceneY - n.y, e.changes.position = !0
                            }, e
                        }(e);
                        t.PanGesture = s;
                        var a = function (t) {
                            function e() {
                                var e = t.apply(this, arguments) || this;
                                return e.x1 = 0, e.y1 = 0, e.x2 = 0, e.y2 = 0, e.centerX = 0, e.centerY = 0, e.centerDistance = 0, e
                            }
                            return n(e, t), e.prototype.addPointer = function (e, i) {
                                if (t.prototype.addPointer.call(this, e, i), 1 === this.pointers.length) this.x1 = e.x, this.y1 = e.y;
                                else {
                                    this.x2 = e.x, this.y2 = e.y;
                                    var n = this.manager.chart.scene,
                                        r = n.fromDisplay((this.x1 + this.x2) / 2, (this.y1 + this.y2) / 2);
                                    this.centerX = r.x, this.centerY = r.y;
                                    var s = this.x1 - this.x2,
                                        a = this.y1 - this.y2,
                                        o = Math.sqrt(s * s + a * a);
                                    this.centerDistance = o / n.zoom
                                }
                            }, e.prototype.movePointer = function (e) {
                                t.prototype.movePointer.call(this, e), e.identifier === this.pointers[0] ? (this.twoFingerDrag(e.x, e.y, this.x2, this.y2), this.x1 = e.x, this.y1 = e.y) : (this.twoFingerDrag(this.x1, this.y1, e.x, e.y), this.x2 = e.x, this.y2 = e.y), e.changes.position = !0
                            }, e.prototype.twoFingerDrag = function (t, e, i, n) {
                                var r = this.manager.chart.settings.interaction,
                                    s = this.manager.chart.scene;
                                s.autoZoomMode = !1;
                                var a = i - t,
                                    o = n - e,
                                    l = this.manager.chart.settings.layout.mode;
                                !r.rotation.fingers || "static" !== l && "dynamic" !== l || this._twoFingerRotation(t, e, i, n);
                                var h = Math.sqrt(a * a + o * o) / s.zoom,
                                    u = (i + t) / 2,
                                    c = (n + e) / 2;
                                if (!r.rotation.fingers && r.panning.enabled) {
                                    var d = s.fromDisplay(u, c);
                                    s.centerX += this.centerX - d.x, s.centerY += this.centerY - d.y
                                }
                                if (r.zooming.fingers) {
                                    var p = h / this.centerDistance;
                                    this.manager.chart.autoZoom.manualZoom(p, u, c)
                                }
                            }, e.prototype._twoFingerRotation = function (t, e, i, n) {
                                var r = i - t,
                                    s = n - e,
                                    a = Math.atan2(s, r),
                                    o = Math.atan2(this.y2 - this.y1, this.x2 - this.x1),
                                    l = a - o;
                                if (0 === l) return !1;
                                var h, u, c, p, f, g = t - this.x1,
                                    m = e - this.y1,
                                    v = i - this.x2,
                                    y = n - this.y2,
                                    S = g * g + m * m,
                                    b = v * v + y * y;
                                S >= b ? (h = this.x1, u = this.y1, c = t, p = e, f = Math.sqrt(S)) : (h = this.x2, u = this.y2, c = i, p = n, f = Math.sqrt(b));
                                var C = c - h,
                                    x = p - u,
                                    w = C / f,
                                    L = x / f,
                                    T = (Math.PI + l) / 2,
                                    k = Math.PI - T,
                                    A = d.Geometry.rotateVector(w, L, Math.sin(k), Math.cos(k)),
                                    M = d.Geometry.rotateVector(w, L, Math.sin(T), Math.cos(T)),
                                    I = d.Geometry.lineIntersectsLine(0, 0, A.x, A.y, C, x, C + M.x, x + M.y);
                                if (I === 1 / 0) return !1;
                                for (var P, D = h + A.x * I, N = u + A.y * I, F = this.manager.chart.scene.fromDisplay(D, N), O = F.x, E = F.y, R = this.manager.chart.layer.nodes(), H = Math.sin(l), B = Math.cos(l), z = 0; z < R.length; z++) {
                                    var U = R[z];
                                    U.dragging || (P = d.Geometry.rotateVector(U.x - O, U.y - E, H, B), U.x = O + P.x, U.y = E + P.y)
                                }
                                return !0
                            }, e
                        }(e);
                        t.TwoFingerGesture = a;
                        var o = {
                                object: null,
                                details: null
                            },
                            l = function (t) {
                                function l(n) {
                                    var o = t.call(this) || this;
                                    return o.animationOrder = 2e3, o.updateOrder = 1100, o.paintOrder = 37, o.hoverPointer = null, o.ignoreGesture = new e(o), o.postponeGesture = new e(o), o.multiSelectGesture = new i(o), o.nodeDragGesture = new r(o), o.panGesture = new s(o), o.twoFingerGesture = new a(o), o.pointerMap = {}, o.chart = n, o
                                }
                                return n(l, t), l.prototype.findObject = function (t) {
                                    var e = this.chart.renderer.findObjectAt(t.x, t.y, this.chart.settings.interaction.selection.tolerance);
                                    return e || o
                                }, l.prototype.assignPointer = function (t, e, i) {
                                    var n = this.pointerMap[t.identifier];
                                    return n ? (n.gesture.removePointer(t), n.gesture = i) : n = this.pointerMap[t.identifier] = {
                                        gesture: i,
                                        lastX: t.x,
                                        lastY: t.y,
                                        longPressGesture: null
                                    }, i.addPointer(t, e), n
                                }, l.prototype.reassignToTwoFinger = function (t, e, i) {
                                    var n = this.pointerMap[t],
                                        r = new d.MouseEvent(n.lastX, n.lastY, e.timeStamp, t);
                                    n.longPressGesture = null, this.assignPointer(r, o, this.twoFingerGesture), this.assignPointer(e, i, this.twoFingerGesture)
                                }, l.prototype.assignUnknownPointer = function (t, e) {
                                    e.object instanceof u.Node && this.chart.settings.interaction.nodesMovable && e.object.draggable ? this.assignNodePointer(t, e) : this.assignEmptyPointer(t, e)
                                }, l.prototype.assignEmptyPointer = function (t, e) {
                                    var i = this.chart.settings.interaction,
                                        n = i.rotation.fingers || i.zooming.fingers,
                                        r = i.selection.enabled && i.selection.dragSelect;
                                    if (this.twoFingerGesture.pointers.length > 0) {
                                        var s = this.assignPointer(t, e, this.ignoreGesture);
                                        r && (s.longPressGesture = this.multiSelectGesture)
                                    } else if (n && this.panGesture.pointers.length > 0) this.reassignToTwoFinger(this.panGesture.pointers[0], t, e);
                                    else if (n && this.postponeGesture.pointers.length > 0) this.reassignToTwoFinger(this.postponeGesture.pointers[0], t, e);
                                    else if (n && this.nodeDragGesture.pointers.length > 0) this.reassignToTwoFinger(this.nodeDragGesture.pointers[0], t, e);
                                    else {
                                        var s = this.assignPointer(t, e, i.panning.enabled && this.panGesture.pointers.length < 1 ? this.panGesture : this.postponeGesture);
                                        r && (s.longPressGesture = this.multiSelectGesture)
                                    }
                                }, l.prototype.assignNodePointer = function (t, e) {
                                    var i = this.chart.settings.interaction,
                                        n = i.rotation.fingers || i.zooming.fingers;
                                    if (n && this.panGesture.pointers.length > 0) this.reassignToTwoFinger(this.panGesture.pointers[0], t, e);
                                    else if (n && this.postponeGesture.pointers.length > 0 && this.twoFingerGesture.pointers.length < 1) this.reassignToTwoFinger(this.postponeGesture.pointers[0], t, e);
                                    else if (e.object.dragging) {
                                        var r = this.assignPointer(t, e, this.postponeGesture);
                                        r.longPressGesture = this.ignoreGesture
                                    } else {
                                        var r = this.assignPointer(t, e, this.nodeDragGesture);
                                        r.longPressGesture = this.ignoreGesture
                                    }
                                }, l.prototype.updateSelection = function (t, e) {
                                    var i = this.chart.settings.interaction.selection;
                                    if (i.enabled && (e.object instanceof u.Node && i.nodesSelectable || e.object instanceof u.Link && i.linksSelectable) && !e.object.selectionLock && !e.object.dragging) {
                                        var n = !1;
                                        if (t.shiftKey || t.ctrlKey) n = e.object.selected ? this.chart.scene.removeFromSelection(e.object) : this.chart.scene.addToSelection(e.object);
                                        else if (!e.object.selected) {
                                            var r = this.chart.scene.selection.filter(function (t) {
                                                return t.dragging || t.selectionLock
                                            });
                                            r.push(e.object), n = this.chart.scene.setSelection(r)
                                        }
                                        n && this.chart.scene.notifySelectionChangesIfNeeded(this.chart, "user")
                                    }
                                }, l.prototype.onPointerDown = function (t) {
                                    var e = this.findObject(t);
                                    this.chart.notifyPointerDown(t, this.buildClickEventArgs(t)), t.defaultPrevented && (t.consumed = !0), this.updateSelection(t, e), this.assignUnknownPointer(t, e)
                                }, l.prototype.onPointerUp = function (t) {
                                    this.chart.notifyPointerUp(t, this.buildClickEventArgs(t)), t.defaultPrevented && (t.consumed = !0);
                                    var e = this.pointerMap[t.identifier];
                                    if (e.gesture.removePointer(t), delete this.pointerMap[t.identifier], e.gesture === this.twoFingerGesture) {
                                        var i = this.twoFingerGesture.pointers[0],
                                            n = this.pointerMap[i];
                                        delete this.pointerMap[i];
                                        var r = new d.MouseEvent(n.lastX, n.lastY, t.timeStamp, i);
                                        this.twoFingerGesture.removePointer(r), this.assignPointer(r, o, this.chart.settings.interaction.panning.enabled ? this.panGesture : this.postponeGesture)
                                    }
                                }, l.prototype.onPointerDrag = function (t) {
                                    this.chart.notifyPointerDrag(t, this.buildClickEventArgs(t)), t.defaultPrevented && (t.consumed = !0);
                                    var e = this.findObject(t);
                                    t.cursor = e.object && e.object.cursor || "default";
                                    var i = this.pointerMap[t.identifier];
                                    i.lastX = t.x, i.lastY = t.y, i.gesture.movePointer(t)
                                }, l.prototype.onPointerCancel = function (t) {
                                    this.onPointerUp(t)
                                }, l.prototype.onInstantClick = function (t) {
                                    if (!t.shiftKey && !t.ctrlKey && !this.findObject(t).object) {
                                        var e = this.chart.scene.selection.filter(function (t) {
                                            return t.dragging || t.selectionLock
                                        });
                                        e.length !== this.chart.scene.selection.length && (this.chart.scene.setSelection(e), this.chart.scene.notifySelectionChangesIfNeeded(this.chart, "user"))
                                    }
                                }, l.prototype.doAnimations = function (t) {
                                    this.nodeDragGesture.doAnimations(t), this.multiSelectGesture.doAnimations(t)
                                }, l.prototype.paintScene = function (t) {
                                    this.multiSelectGesture.paintScene(t)
                                }, l.prototype.buildClickEventArgs = function (t) {
                                    var e = this.chart.createEventArguments(t, "user"),
                                        i = this.findObject(t);
                                    e.clickItem = i.details;
                                    var n = i.object;
                                    return n instanceof u.Node ? (e.clickNode = n, this.autoZoomIn(t, n)) : e.clickLink = n, e
                                }, l.prototype.updateHover = function (t, e) {
                                    t.changes.current = !0, this.chart.scene.setActiveObject(e.object, e.details), this.chart.notifyHoverChanged(t, this.chart.createEventArguments(null, "api"))
                                }, l.prototype.autoZoomIn = function (t, e) {
                                    this.chart.scene.lastClickedNode = e, this.chart.settings.interaction.zooming.autoZoomAfterClick && (this.chart.scene.autoZoomMode = !0, t.changes.zoom = !0)
                                }, l.prototype.onPointerMove = function (t) {
                                    if (this.chart.notifyPointerMove(t, this.chart.createEventArguments(null, "user")), t.defaultPrevented && (t.consumed = !0), !this.chart.scene.xyInChart(t.x, t.y)) return void this.onPointerOut(t);
                                    this.hoverPointer = t.identifier;
                                    var e = this.findObject(t);
                                    // netchart 默认鼠标图标 xrh
                                    t.cursor = e.object && e.object.cursor || "move", e.object === (this.chart.scene.hoverLink || this.chart.scene.hoverNode) && e.details === this.chart.scene.hoverItem || this.updateHover(t, e);
                                }, l.prototype.onPointerOut = function (t) {
                                    this.hoverPointer === t.identifier && (this.hoverPointer = null, this.updateHover(t, o)), this.pointerMap[t.identifier] && this.onPointerUp(t)
                                }, l.prototype.onWheel = function (t) {
                                    if (this.chart.scene.xyInChart(t.x, t.y) && this.chart.settings.interaction.zooming.wheel) {
                                        var e = Math.pow(1 + this.chart.settings.interaction.zooming.sensitivity, .004 * t.wheely);
                                        this.chart.autoZoom.manualZoom(e, t.x, t.y), t.consumed = !0, t.changes.position = !0
                                    }
                                }, l.prototype.onClick = function (t) {
                                    this.chart.notifyClick(t, this.buildClickEventArgs(t)), t.defaultPrevented && (t.consumed = !0)
                                }, l.prototype.onRightClick = function (t) {
                                    this.chart.scene.xyInChart(t.x, t.y) && (this.chart.notifyRightClick(t, this.buildClickEventArgs(t)), t.defaultPrevented && (t.consumed = !0))
                                }, l.prototype.onLongPress = function (t) {
                                    if (this.chart.scene.xyInChart(t.x, t.y)) {
                                        var e = this.pointerMap[t.identifier];
                                        e && (e.longPressGesture && (e.longPressGesture === this.multiSelectGesture && this.multiSelectGesture.pointers.length > 0 && (e.longPressGesture = this.ignoreGesture), this.assignPointer(t, o, e.longPressGesture), e.longPressGesture = null), t.consumed = e.gesture !== this.ignoreGesture)
                                    }
                                }, l.prototype.onDoubleClick = function (t) {
                                    if (this.chart.scene.xyInChart(t.x, t.y))
                                        if (this.chart.notifyDoubleClick(t, this.buildClickEventArgs(t)), t.defaultPrevented) t.consumed = !0;
                                        else {
                                            var e = this.chart.settings.interaction.zooming.doubleClickZoom;
                                            e && this.chart.settings.interaction.zooming.zoomInOnDoubleClick && (this.chart.autoZoom.manualZoom(e, t.x, t.y), t.changes.position = !0, t.consumed = !0)
                                        }
                                }, l
                            }(d.ChartElement);
                        t.GestureManager = l
                    }(i = t.Gestures || (t.Gestures = {}));
                var R = function (t) {
                    function e() {
                        return t.apply(this, arguments) || this
                    }
                    return n(e, t), e.prototype.showHide = function (t, e) {
                        t.style.display = e ? "" : "none"
                    }, e.prototype.btnExpand = function (t) {
                        var e = this;
                        this.buildButton(t, "DVSL-NC-button-expand", this.scene.settings.localization.menu.expand, this.scene.settings.localization.menu.expand, null, function (t, i) {
                            e.chart.expandNode(t.id)
                        }, function (t, i) {
                            e.showHide(i, e.chart.navigator.canExpandNode(t))
                        })
                    }, e.prototype.btnCollapse = function (t) {
                        var e = this;
                        this.buildButton(t, "DVSL-NC-button-collapse", this.scene.settings.localization.menu.collapse, this.scene.settings.localization.menu.collapse, null, function (t, i) {
                            e.chart.collapseNode(t.id)
                        }, function (t, i) {
                            e.showHide(i, e.chart.navigator.canCollapseNode(t))
                        })
                    }, e.prototype.btnClose = function (t) {
                        var e = this;
                        this.buildButton(t, "DVSL-NC-button-collapse", this.scene.settings.localization.menu.close, this.scene.settings.localization.menu.close, null, function (t, i) {
                            e.chart.closeNode(t.id)
                        }, function (t, i) {
                            e.showHide(i, e.chart.navigator.canCloseNode(t))
                        })
						//添加新增节点按钮start
                    }, e.prototype.btnFocus = function (t) {
                        var e = this;
                        this.buildButton(t, "DVSL-NC-button-add", this.scene.settings.localization.menu.add, this.scene.settings.localization.menu.add, null, function (t, i) {
                            e.chart.addFocusNode(t.id, -1)
                        }, function (t, i) {
                            e.showHide(i, e.chart.navigator.canFocusNode(t))
                        })
						//添加新增节点按钮end
                    },e.prototype.btnFocus = function (t) {
                        var e = this;
                        this.buildButton(t, "DVSL-NC-button-focus", this.scene.settings.localization.menu.focus, this.scene.settings.localization.menu.focus, null, function (t, i) {
                            e.chart.addFocusNode(t.id, -1)
                        }, function (t, i) {
                            e.showHide(i, e.chart.navigator.canFocusNode(t))
                        })
                    }, e.prototype.btnUnfocus = function (t) {
                        var e = this;
                        this.buildButton(t, "DVSL-NC-button-unfocus", this.scene.settings.localization.menu.unfocus, this.scene.settings.localization.menu.unfocus, null, function (t, i) {
                            e.chart.removeFocusNode(t.id)
                        }, function (t, i) {
                            e.showHide(i, e.chart.navigator.canUnfocusNode(t))
                        })
                    }, e.prototype.btnLock = function (t) {
                        var e = this;
                        this.buildButton(t, "DVSL-NC-button-lock", this.scene.settings.localization.menu.fixed, this.scene.settings.localization.menu.fixed, null, function (t, i) {
                            e.chart.unlockNode(t.id)
                        }, function (t, i) {
                            e.showHide(i, t.userLock)
                        })
                    }, e.prototype.btnUnlock = function (t) {
                        var e = this;
                        this.buildButton(t, "DVSL-NC-button-unlock", this.scene.settings.localization.menu.dynamic, this.scene.settings.localization.menu.dynamic, null, function (t, i) {
                            e.chart.lockNode(t.id)
                        }, function (t, i) {
                            e.showHide(i, !t.userLock)
                        })
                    }, e.prototype.btnHide = function (t) {
                        var e = this;
                        this.buildButton(t, "DVSL-NC-button-hide", this.scene.settings.localization.menu.hide, this.scene.settings.localization.menu.hide, null, function (t, i) {
                            e.chart.hideNode(t.id)
                        }, function (t, i) {
                            e.showHide(i, e.chart.navigator.canHideNode(t))
                        })
                    }, e.prototype.buildDefaultButton = function (t, e) {
                        if (t instanceof u.Node) switch (e) {
                            case "btn:expand":
                                this.btnExpand(t);
                                break;
                            case "btn:collapse":
                                this.btnCollapse(t);
                                break;
                            case "btn:close":
                                this.btnClose(t);
                                break;
                            case "btn:focus":
                                this.btnFocus(t);
                                break;
                            case "btn:unfocus":
                                this.btnUnfocus(t);
                                break;
                            case "btn:lock":
                                this.btnLock(t);
                                break;
                            case "btn:unlock":
                                this.btnUnlock(t);
                                break;
                            case "btn:hide":
                                this.btnHide(t);
                                break;
                            case "expand":
                                this.btnExpand(t), this.btnCollapse(t), this.btnClose(t);
                                break;
                            case "focus":
                                this.btnFocus(t), this.btnUnfocus(t);
                                break;
                            case "lock":
                                this.btnLock(t), this.btnUnlock(t);
                                break;
                            case "hide":
                                this.btnHide(t);
                                break;
                            default:
                                this.chart.error("The node menu button with name `" + e + "` was not recognized.")
                        } else this.chart.error("The link menu does not support any named buttons.")
                    }, e
                }(u.Menu);
                t.Menu = R;
                var H = function (e) {
                    function s(n, s) {
                        var a = e.call(this, new f(n), new T, s) || this;
                        a.isLayoutFrozen = !1, a.focusNodeStack = [];
                        var o = "focusnodes" === a.settings.navigation.mode && a.settings.navigation.focusAutoFadeout;
                        return a.layer = new u.NodesLayer(a, a.settings, o), a.graph = new I(a), a.navigator = a.events.addElement(D.CreateNavigator(a)), a.gestures = a.events.addElement(new i.GestureManager(a)), a.layout = a.events.addElement(r.LayoutBase.ConstructLayout(a)), a.info = a.events.addElement(new u.InfoPopup(a)), a.menu = a.events.addElement(new t.Menu(a)), a.autoZoom = a.events.addElement(new P(a)), a.renderer = a.events.addElement(new k(a)), a.legend = a.events.addElement(new p(a)), a.autoZoom.resetZoom = !0, a.scene.loading = !1, a.navigator.showInitialNodes(), a.finalInitialize(), a
                    }
                    return n(s, e), s.prototype.createDataObj = function (t) {
                        return new M(this, t)
                    }, s.prototype.getData = function (t) {
                        return e.prototype.getData.call(this, t)
                    }, s.prototype.onSettingsChanged = function (t) {
                        var e = {};
                        this.layer.onSettingsChanged(t), t.navigation && t.navigation.mode && (this.events.removeElement(this.navigator), this.navigator = D.CreateNavigator(this), this.events.addElement(this.navigator));
                        var i = !(!t.navigation || !t.navigation.mode && !t.navigation.initialNodes);
                        if (t.data && t.data.length) {
                            var n = t.data[0];
                            (n.dataFunction || n.format || n.preloaded || n.url || n.randomNodes) && (i = !0)
                        }
                        i && (this.navigator.showInitialNodes(), this.autoZoom.resetZoom = !0), t.filters && (e.filters = !0), t.style && (e.style = !0), t.layout && t.layout.mode && (this.events.removeElement(this.layout), this.layout = r.LayoutBase.ConstructLayout(this), this.events.addElement(this.layout), this.isLayoutFrozen = !1), this.events.notifySceneChanges(e)
                    }, s.prototype.save = function () {
                        var t = this.graph.save(),
                            e = this.navigator.save();
                        return JSON.stringify({
                            xy: t,
                            nav: e
                        })
                    }, s.prototype.restore = function (t, e) {
                        if (t) {
                            var i = JSON.parse(t),
                                n = i.xy,
                                r = i.nav;
                            r && this.navigator.restore(r), n && this.graph.restore(n), this.autoZoom.resetZoom = !0
                        }
                    }, s.prototype.saveNavigation = function () {
                        var t = JSON.stringify(this.navigator.save());
                        return "{}" === t ? null : t
                    }, s.prototype.restoreNavigation = function (t) {
                        this.navigator.restore(JSON.parse(t))
                    }, s.prototype.getCurrentNodes = function () {
                        for (var t = [], e = 0, i = this.layer.nodes(); e < i.length; e++) {
                            var n = i[e];
                            n.removed || t.push(n)
                        }
                        return t
                    }, s.prototype.getCurrentLinks = function () {
                        for (var t = [], e = 0, i = this.layer.links(); e < i.length; e++) {
                            var n = i[e];
                            n.removed || t.push(n)
                        }
                        return t
                    }, s.prototype.getNodeDimensions = function (t) {
                        var e;
                        if (e = d.Helpers.isString(t) ? this.getNode(t) : t, !e) return null;
                        var i = this.scene.toDisplay(e.x, e.y),
                            n = i.x,
                            r = i.y,
                            s = e.hHeight * this.scene.zoom,
                            a = e.hWidth * this.scene.zoom;
                        return {
                            x: n,
                            y: r,
                            radius: s,
                            hwidth: a
                        }
                    }, s.prototype.lockNode = function (t, e, i) {
                        void 0 === e && (e = null), void 0 === i && (i = null), d.Helpers.isObjectOrArray(t) && (t = t.id), this.graph.lockNode(t, e, i)
                    }, s.prototype.unlockNode = function (t) {
                        t.id && (t = t.id), this.graph.unlockNode(t)
                    }, s.prototype.addFocusNode = function (t, e) {
                        return t.id && (t = t.id), this.settings.navigation.autoZoomOnFocus && (this.scene.autoZoomMode = !0), this.focusNodeStack.push(t), this.navigator.focusNode(t, e, "api")
                    }, s.prototype.getLastFocusNode = function () {
                        for (; this.focusNodeStack.length > 0;) {
                            var t = this.focusNodeStack[this.focusNodeStack.length - 1],
                                e = d.Helpers.hasProperty(this.layer.idToNode, t) ? this.layer.idToNode[t] : null;
                            if (e && e.focused) return e;
                            this.focusNodeStack.pop()
                        }
                        if (this.settings.navigation.initialNodes)
                            for (var i = 0; i < this.settings.navigation.initialNodes.length; i++) {
                                var t = this.settings.navigation.initialNodes[i],
                                    e = d.Helpers.hasProperty(this.layer.idToNode, t) ? this.layer.idToNode[t] : null;
                                if (e) return e
                            }
                        var n = this.layer.nodes();
                        return n.length > 0 ? n[0] : null
                    }, s.prototype.clearFocus = function () {
                        this.navigator.clearFocusNodes("api")
                    }, s.prototype.removeFocusNode = function (t) {
                        return t.id && (t = t.id), this.navigator.unfocusNode(t, "api")
                    }, s.prototype.expandNode = function (t) {
                        return t.id && (t = t.id), this.navigator.expandNode(t, "api")
                    }, s.prototype.collapseNode = function (t) {
                        return t.id && (t = t.id), this.navigator.collapseNode(t, "api")
                    }, s.prototype.closeNode = function (t) {
                        return t.id && (t = t.id), this.navigator.closeNode(t, "api")
                    }, s.prototype.hideNode = function (t) {
                        return t.id && (t = t.id), this.navigator.hideNode(t, "api")
                    }, s.prototype.showNode = function (t) {
                        return this.navigator.showNode(t, "api")
                    }, s.prototype.getNode = function (t) {
                        return this.layer.idToNode[t]
                    }, s.prototype.getLink = function (t) {
                        return this.layer.idToLink[t]
                    }, s.prototype.touchObjects = function (t) {
                        for (var e = 0; e < t.length; e++) {
                            var i = this.layer,
                                n = i.findObjectById(t[e]);
                            n && i.touchNodeOrLink(n)
                        }
                    }, s.prototype.setZoom = function (t, e) {
                        this.autoZoom.setZoom(t, e)
                    }, s.prototype.resetLayout = function () {
                        this.layout.resetLayout(), this.autoZoom.setZoom("overview", !1), this.events.notifySceneChanges({
                            layout: !0
                        })
                    }, s.prototype.removeData = function (t, e) {
                        if (void 0 === e && (e = "default"), null == e && (e = "default"), !this.removed) {
                            var i = this.getData(e),
                                n = i.removeData(t);
                            n.data = {}, n.data[e] = !0, this.events.notifySceneChanges(n)
                        }
                    }, s.prototype.exportData = function (t, e) {
                        var i;
                        return i = t ? this.graph.exportData() : this.scene.mainData.exportData(), e && this.graph.exportCoordinates(i.nodes), i
                    }, s.prototype.hideMenu = function () {
                        this.menu.hideMenu()
                    }, s.prototype.createEventArguments = function (t, i) {
                        var n = e.prototype.createEventArguments.call(this, t, i),
                            r = this.layer;
                        return r && (n.nodes = r.nodes(), n.links = r.links()), n
                    }, s.prototype.defaultClick = function (t, e) {
                        if (!t.shiftKey && !t.ctrlKey) {
                            var i = e.clickNode;
                            i && this.scene.settings.navigation.expandOnClick && (i.expanded || (this.expandNode(i.id), t.preventDefault()))
                        }
                    }, s.prototype.defaultRightClick = function (t, e) {
                        e.clickNode && (this.scene.mainData.getLinks(e.clickNode.id), this.menu.toggleNodeMenu(e.clickNode), t.preventDefault()), e.clickLink && (this.menu.toggleLinkMenu(t.x, t.y, e.clickLink), t.preventDefault())
                    }, s.prototype.defaultDoubleClick = function (t, e) {
                        var i = e.clickNode;
                        i && (this.addFocusNode(i.id, -1), t.preventDefault())
                    }, s.prototype.scrollIntoView = function (t, e) {
                        for (var i, n = [], r = 0; r < t.length; r++) {
                            var s = t[r];
                            s instanceof u.Node ? n.push(s) : d.Helpers.isString(s) && (i = this.getNode(s)) ? n.push(i) : this.error("scrollIntoView: the argument is not a node or the ID cannot be found: `" + s + "`.")
                        }
                        this.autoZoom.scrollIntoView(n, e)
                    }, s.prototype.freezeLayout = function () {
                        this.isLayoutFrozen || (this.events.removeElement(this.layout), this.isLayoutFrozen = !0, this.events.notifySceneChanges({
                            layout: !0
                        }))
                    }, s.prototype.unfreezeLayout = function () {
                        this.isLayoutFrozen && (this.events.addElement(this.layout), this.isLayoutFrozen = !1, this.events.notifySceneChanges({
                            layout: !0
                        }))
                    }, s.prototype.remove = function () {
                        e.prototype.remove.call(this), this.info.remove(), this.menu.remove()
                    }, s
                }(u.Impl);
                t.Impl = H
            }(h = i.NetChart || (i.NetChart = {})),
            function (t) {
                var e = t.Bar || (t.Bar = {}),
                    i = t.Series || (t.Series = {}),
                    r = t.Renderers || (t.Renderers = {}),
                    s = function (t) {
                        function e() {
                            var e = t.apply(this, arguments) || this;
                            return e.panel = new d.SettingsLegendPanel("bottom", "left", void 0, 95), e.advanced = new o, e.marker = new a, e
                        }
                        return n(e, t), e
                    }(d.SettingsLegend);
                t.SettingsLegend = s;
                var a = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.shape = null, e
                    }
                    return n(e, t), e
                }(d.SettingsLegendMarker);
                t.SettingsLegendMarker = a;
                var o = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.disabledSeries = {
                            fillColor: "rgba(191,187,185,0.3)",
                            lineColor: "rgba(64,62,62,0.3)",
                            textColor: "rgba(64,62,62,0.3)"
                        }, e
                    }
                    return n(e, t), e
                }(d.SettingsLegendAdvanced);
                t.SettingsLegendAdvanced = o;
                var l = function (t) {
                        function e(e, i, n, r, s, a, o) {
                            var l = t.call(this, i, n, r, s) || this;
                            return l.seriesHovered = !1, l.disabledSeries = o, l.series = e, l.enabled = a, l
                        }
                        return n(e, t), e.prototype.isHovered = function () {
                            return this.hoverCount > 0 || this.seriesHovered
                        }, e
                    }(d.LegendEntry),
                    h = function (t) {
                        function e(e) {
                            var i = t.call(this, e) || this;
                            return i.paintOrder = 75, i.updateOrder = 100, i
                        }
                        return n(e, t), e.prototype.notifyHoveredSeries = function (t) {
                            for (var e = 0; e < this.entries.length; e++) {
                                var i = this.entries[e];
                                i.seriesHovered = i.series.indexOf(t) >= 0
                            }
                        }, e.prototype.getLastHoveredSeries = function () {
                            var t = this.getLastHoveredEntry();
                            return t ? t.series[0] : null
                        }, e.prototype.onSceneChange = function (e) {
                            t.prototype.onSceneChange.call(this, e);
                            var i = e.changes;
                            i.linearChartSeries && (this.rebuildItems(e), i.bounds = !0)
                        }, e.prototype.paintMarker = function (t, e, i, n, s) {
                            var a = t.context,
                                o = s.isEnabled() ? s.series[0] : s.disabledSeries,
                                l = this.settings.marker,
                                h = o.style.legend.marker,
                                u = h.shape || l.shape;
                            if (a.beginPath(), u) {
                                var c = {
                                    fillColor: h.fillColor || o.style.fillColor || o.style.lineColor,
                                    lineColor: h.lineColor || l.lineColor,
                                    lineWidth: h.lineWidth || 1
                                };
                                null != h.width && (n = h.width / 2), d.Graphics.strokeMarker(a, u, e, i, n), d.Graphics.paint(a, c)
                            } else {
                                var p = l.size,
                                    f = e - p / 2,
                                    g = e,
                                    m = e + p / 2,
                                    v = p / 2.1,
                                    y = p / 2,
                                    S = 3 * p / 4,
                                    b = i + p / 2;
                                if (o instanceof x) {
                                    var L = o.style.marker.width;
                                    o.style.marker.width *= .8;
                                    var T = [
                                            [v, y, S]
                                        ],
                                        k = [f, g, m],
                                        A = [k, [b - v, b - y, b - S]],
                                        M = b - y,
                                        I = new r.Line(null, [o]);
                                    I.paintLines(a, [o], [{
                                        markerY: null,
                                        segments: A
                                    }], k, [null], T, b), I.paintMarkers(a, o, [g], [y], [M]), o.style.marker.width = L
                                } else if (o instanceof C) {
                                    var T = [p, p],
                                        P = new r.Columns(this.chart.scene, [o]);
                                    P.paintStack(t, [e], [p / 2], [T], [null], b)
                                } else if (o instanceof w) {
                                    var D = new r.Candlestick(this.chart.scene, [o]),
                                        N = [
                                            [0],
                                            [p / 3],
                                            [2 * p / 3],
                                            [p]
                                        ];
                                    D.paintStack(t, [e], [p / 2], N, [null], b)
                                }
                            }
                        }, e.prototype.rebuildItems = function (t) {
                            for (var e = [], n = this.chart.scene.settings._computedSeries, r = this.settings.advanced.disabledSeries, s = {}, a = this.settings.text.fillColor, o = 0; o < n.length; o++) {
                                var h = n[o];
                                if (h.showInLegend) {
                                    var u = void 0;
                                    if (h instanceof w) {
                                        if (d.Helpers.hasProperty(s, h.stack)) {
                                            s[h.stack].push(h);
                                            continue
                                        }
                                        u = [h], s[h.stack] = u
                                    } else u = [h];
                                    var c = h.nameLegend || h.name || this.chart.settings.localization.unnamedSeries,
                                        p = d.Helpers.realClone(h),
                                        f = p.style;
                                    f.fillColor = f._currentFillStyle = f.fillColor && r.fillColor, f._currentFillStyleKey = null, f.fillPattern && (f._fillPatternOpacity = .3, i.Stack.computeFillPattern(this.chart, t.context, f)), f.lineColor = r.lineColor;
                                    var g = f.legend.marker;
                                    g.fillColor = g.fillColor && r.fillColor, g.lineColor = g.lineColor && r.lineColor, e.push(new l(u, c, h.style.legend.textColor || a, r.textColor, h.legendGroupId, h.enabled, p))
                                }
                            }
                            this.resetEntries(e)
                        }, e.prototype.itemClicked = function (e, i) {
                            t.prototype.itemClicked.call(this, e, i);
                            for (var n = 0; n < this.entries.length; n++)
                                for (var r = this.entries[n], s = 0; s < r.series.length; s++) r.series[s].enabled = r.enabled;
                            this.chart.events.notifySceneChanges({
                                linearChartSeries: !0
                            })
                        }, e
                    }(d.Legend);
                t.Legend = h;
                var u = function () {
                    function t() {
                        this.enabled = !0, this.animate = "auto", this.initialAnimationValue = null, this.initialAnimationValueMultiplier = 4.5, this.logScale = !1, this.position = "outside", this.side = "left", this.title = null, this.minValue = null, this.maxValue = null, this.size = null, this.hgrid = null, this.axisLine = !1, this.scaleAdjustmentTolerance = .3, this.scaleAdjustmentAnimationDelay = 200, this.scaleAdjustmentAnimation = "=", this.scaleStep = null, this.scaleMinStep = 0, this.zeroLine = "visible", this.valueFormatterFunction = null, this.style = {
                            title: {
                                textStyle: {
                                    fillColor: "#000000",
                                    font: "13px Arial"
                                },
                                reverseDirection: !1,
                                align: "center",
                                margin: 5
                            },
                            tick: {
                                lineColor: "#AAAAAA"
                            },
                            axisLine: {
                                lineColor: "rgba(127,127,127,0.5)",
                                lineWidth: 1
                            },
                            valueLabel: {
                                textStyle: {
                                    fillColor: "#000000",
                                    font: "11px Arial"
                                },
                                margin: 0
                            },
                            labelSpacing: 25,
                            baseLine: {
                                lineColor: "rgba(127,127,127,0.5)",
                                depthColor: "rgba(127,127,127,0.5)",
                                lineWidth: 1,
                                lineDepth: 0,
                                showLabel: 1
                            },
                            hgrid: {
                                lineColor: "rgba(255,255,255,0.2)"
                            }
                        }, this.thresholds = []
                    }
                    return t
                }();
                t.SettingsValueAxis = u;
                var c = function () {
                    function t() {
                        this.from = -(1 / 0), this.to = 1 / 0, this.position = "under", this.style = {
                            fillColor: "rgba(255,133,152,0.2)",
                            lineColor: "rgba(255,0,0,0.5)",
                            lineWidth: 1,
                            lineDash: null
                        }
                    }
                    return t
                }();
                t.SettingsValueAxisThreshold = c;
                var p = function () {
                    function t(t, e) {
                        var i = this;
                        this.locations = [], this.values = [], this.labels = [], this.title = null, this.cachedUnits = {
                            lin: [],
                            log: []
                        }, this.isPrimary = !1, this._chart = t, this.options = e, this.events = t.events, this.scene = t.scene, this.isLogScale = this.options.logScale, this.isInside = "inside" === this.options.position, this.panel = new d.ChartPanel, this.panel.packingOrder = 110, this.panel.computeSize = function (t, e, n, r) {
                            return i.computePanelSize(t, e, n, r)
                        }, this.lastMaxValue = 0, this.lastMinValue = 0, this.minValue = 0, this.maxValue = 0, this.scale = 0, this.zeroY = 0, this.logOffset = 1, this.minValueAnimation = null, this.maxValueAnimation = null, this.axisChanged = !1, this.seriesDepth = 0, this.seriesMinValue = null, this.seriesMaxValue = null, this.series = 0, this.createTitle()
                    }
                    return t.prototype.createTitle = function () {
                        var t = this.options,
                            e = t.style.title,
                            i = this.title = new d.Label(e);
                        i.text = t.title, i.allowCache = !1;
                        var n = i.style.angle;
                        null == n && (n = "right" === t.side ? 90 : -90), e.reverseDirection && (n = -n), i.style.angle = n
                    }, t.prototype.getPanel = function () {
                        var t = this.options;
                        return t.enabled ? (this.panel.location = t.position, this.panel.side = t.side, this.panel) : null
                    }, t.prototype.setPanel = function (t) {
                        null != t && (this.panel = t)
                    }, t.prototype.computePanelSize = function (t, e, i, n) {
                        if (!this._chart.assetsLoaded) return {
                            width: 0,
                            height: 0
                        };
                        var r = 8,
                            s = this.title;
                        s && (s.style.maxWidth = e);
                        var a = this.options;
                        if (a.size) r = a.size;
                        else {
                            var o = a.style.valueLabel,
                                l = "9999 M";
                            a.valueFormatterFunction ? l = a.valueFormatterFunction(1e7 - 1 - 2e-4, "M", 1e6, l) || l : r++, r += 2 * o.margin + d.Graphics.getTextWidth(i, o.textStyle, l), s && s.text && (n.measure(i, s), r += 2 * (s.style.margin + s.hheight))
                        }
                        return {
                            width: Math.ceil(r),
                            height: e
                        }
                    }, t.prototype.receiveSeriesGeometry = function (t, e, i) {
                        null !== this.options.minValue ? this.seriesMinValue = this.options.minValue : void 0 !== t && (null !== this.seriesMinValue ? this.seriesMinValue = Math.min(t, this.seriesMinValue) : this.seriesMinValue = t), null !== this.options.maxValue ? this.seriesMaxValue = this.options.maxValue : void 0 !== e && (null !== this.seriesMaxValue ? this.seriesMaxValue = Math.max(e, this.seriesMaxValue) : this.seriesMaxValue = e), this.seriesDepth = Math.max(i, this.seriesDepth)
                    }, t.prototype.updateMinMax = function (t) {
                        var e = t.changes,
                            i = e.bounds || e.assets || 0 === this.locations.length;
                        if (e.settings && (this.isLogScale = this.options.logScale, this.isInside = "inside" === this.options.position, i = !0), this.shouldChangeScale() && (this.seriesMinValue !== this.lastMinValue && (i = !0, "always" === this.options.animate || null !== this.lastMinValue && !e.displayUnit && this.minValue !== this.maxValue ? this.minValueAnimation ? this.minValueAnimation.retarget(this.seriesMinValue, t.timeStamp) : this.minValueAnimation = new d.Animator(this.lastMinValue, this.seriesMinValue, this.options.scaleAdjustmentAnimationDelay, this.options.scaleAdjustmentAnimation, t.timeStamp) : this.minValueAnimation = null, this.lastMinValue = this.seriesMinValue), this.seriesMaxValue !== this.lastMaxValue)) {
                            if (i = !0, "always" === this.options.animate || null !== this.lastMaxValue && !e.displayUnit && this.minValue !== this.maxValue)
                                if (this.maxValueAnimation) this.maxValueAnimation.retarget(this.seriesMaxValue, t.timeStamp);
                                else {
                                    var n = this.lastMaxValue;
                                    this.lastMaxValue || (null !== this.options.initialAnimationValue ? n = this.options.initialAnimationValue : this.seriesMaxValue && (n = this.seriesMaxValue * this.options.initialAnimationValueMultiplier)), this.maxValueAnimation = new d.Animator(n, this.seriesMaxValue, this.options.scaleAdjustmentAnimationDelay, this.options.scaleAdjustmentAnimation, t.timeStamp)
                                }
                            else this.maxValueAnimation = null;
                            this.lastMaxValue = this.seriesMaxValue
                        }
                        this.seriesMaxValue = this.options.minValue, this.seriesMinValue = this.options.maxValue;
                        var r, s;
                        this.minValueAnimation ? (i = !0, r = this.minValueAnimation.get(t.timeStamp), this.minValueAnimation.finished(t.timeStamp) && (this.minValueAnimation = null)) : r = this.lastMinValue, this.maxValueAnimation ? (i = !0, s = this.maxValueAnimation.get(t.timeStamp), this.maxValueAnimation.finished(t.timeStamp) && (this.maxValueAnimation = null)) : s = this.lastMaxValue, this.axisChanged = i, i && this.computeNewScale(r, s), (this.minValueAnimation || this.maxValueAnimation) && (t.animating = !0)
                    }, t.prototype.doAnimations = function (t) {
                        if (this.axisChanged && this._chart.assetsLoaded) {
                            this.axisChanged = !1;
                            var e = this.options;
                            if (e.enabled) {
                                this.locations = [], this.values = [];
                                var i, n = "right" === e.side,
                                    r = this.scene.y0,
                                    s = r + this.scene.height;
                                if (this.scale <= 0) {
                                    i = e.scaleStep ? e.scaleStep : 100;
                                    var a = e.style.labelSpacing,
                                        o = s - a,
                                        l = 1;
                                    for (e.logScale || (l = i); o > r;) this.locations.push(o), this.values.push(l), e.logScale ? l *= 10 : l += i, o -= a
                                } else {
                                    if (this.fontHeight || (this.fontHeight = 1.4 * d.Graphics.getTextHeight(t.context, e.style.valueLabel.textStyle.font) || 0), 0 === r && (r += this.fontHeight / 2), this.scene.bottomAxisSize < this.fontHeight && (s -= this.fontHeight / 2), this.isLogScale) {
                                        for (var h = this.calcExpValuePerLine(), u = h.unit, c = h.valueMultiplier, p = 1 / u;;) {
                                            p *= c;
                                            var f = this.zeroY - this.valueToRelativeY(p);
                                            if (f <= r) break;
                                            f >= s || (this.locations.push((0 | f) - .5), this.values.push(p))
                                        }
                                        for (p = -1 / u;;) {
                                            p *= c;
                                            var f = this.zeroY - this.valueToRelativeY(p);
                                            if (f >= s) break;
                                            this.locations.push((0 | f) - .5), this.values.push(p)
                                        }
                                    } else {
                                        i = this.calcLinearValuePerLine();
                                        var p = 0;
                                        for (e.scaleStep && (i = Math.max(i, this.fontHeight / this.scale));;) {
                                            p += i;
                                            var f = this.zeroY - this.valueToRelativeY(p);
                                            if (f <= r) break;
                                            f >= s || (this.locations.push(0 | f), this.values.push(p))
                                        }
                                        for (p = 0;;) {
                                            p -= i;
                                            var f = this.zeroY - this.valueToRelativeY(p);
                                            if (f >= s) break;
                                            this.locations.push(0 | f), this.values.push(p)
                                        }
                                    }
                                    var g = this.minValue,
                                        m = this.maxValue;
                                    if (g <= 0 && m >= 0) {
                                        var v = e.style.baseLine.showLabel;
                                        (2 === v || 1 === v && (g < 0 || !this.isInside && 0 === g)) && (this.locations.push(0 | this.zeroY), this.values.push(0))
                                    }
                                }
                                var y, S, b, C = e.valueFormatterFunction;
                                if (!this.isLogScale) {
                                    var x = this.getUnitAndName(i, this.scene.settings);
                                    y = x.unit, S = x.digitsAfterComma, b = x.name
                                }
                                for (var w = 0; w < this.values.length; w++) {
                                    var p = this.values[w];
                                    if (this.isLogScale) {
                                        var x = this.getUnitAndName(p, this.scene.settings);
                                        y = x.unit, S = x.digitsAfterComma, b = x.name
                                    }
                                    var L = (p / y).toFixed(S);
                                    if (p && (L = L + " " + b), C && (L = C(p, b, y, L)), !C && e.valueFormat) {
                                        var T = d.Helpers.matchPercentFormat(e.valueFormat),
                                            k = d.Helpers.matchCurrencyFormat(e.valueFormat);
                                        if (T) {
                                            var x = this.getUnitAndName(100 * p, this.scene.settings);
                                            y = x.unit, b = x.name, L = d.Helpers.printPercentValue(p / y, T, b)
                                        } else {
                                            var x = this.getUnitAndName(p, this.scene.settings);
                                            y = x.unit, b = x.name, L = d.Helpers.printCurrencyValue(p / y, k, b)
                                        }
                                    }
                                    var A = new d.Label(e.style.valueLabel);
                                    A.text = L.toString(), this.isInside || (A.style.align = n ? "left" : "right"), this.labels[w] = A
                                }
                            }
                        }
                    }, t.prototype.paintUnder = function (t) {
                        var e = this.options;
                        if (e.enabled) {
                            var i = t.context;
                            if (e.thresholds)
                                for (var n = 0; n < e.thresholds.length; n++) {
                                    var r = e.thresholds[n];
                                    "under" === r.position && this.paintThreshold(i, r)
                                }
                            this.paintZeroLineDepth(i)
                        }
                    }, t.prototype.paint = function (t) {
                        var e = this.options;
                        if (e.enabled) {
                            var i = t.context;
                            if (e.thresholds)
                                for (var n = 0; n < e.thresholds.length; n++) {
                                    var r = e.thresholds[n];
                                    "above" === r.position && this.paintThreshold(i, r)
                                }
                            if (this.locations.length > 0 && (this.paintGrid(i), this.paintZeroLine(i), this.paintLabels(i, t.labelRenderer)), e.axisLine) {
                                var s = d.Graphics.beginStrokeAndFill(i, e.style.axisLine);
                                this.paintAxisLine(s), d.Graphics.endStrokeAndFill(i, s, e.style.axisLine)
                            }
                        }
                    }, t.prototype.shouldChangeScale = function () {
                        var t = this.seriesMinValue,
                            e = this.seriesMaxValue;
                        if (null === t || null === e) return !1;
                        if (null === this.lastMinValue || null === this.lastMaxValue || !(this.lastMinValue < this.lastMaxValue)) return !0;
                        if ("center" === this.options.zeroLine ? (e = Math.max(e, -t), t = -e) : "visible" === this.options.zeroLine && (t = Math.min(t, 0), e = Math.max(e, 0)), t < this.minValue || e > this.maxValue) return !0;
                        var i = (this.lastMaxValue - this.lastMinValue) * this.options.scaleAdjustmentTolerance;
                        return t > this.lastMinValue + i || e < this.lastMaxValue - i
                    }, t.prototype.computeNewScale = function (t, e) {
                        var i = this.scene.height,
                            n = this.scene.y0;
                        if ("center" === this.options.zeroLine ? (e = Math.max(e, -t), t = -e) : "visible" === this.options.zeroLine && (t = Math.min(t, 0), e = Math.max(e, 0)), null !== this.options.minValue && (t = this.options.minValue), null !== this.options.maxValue && (e = this.options.maxValue), !(i > 0 && t < e)) return this.minValue = 0, this.maxValue = 0, this.logOffset = 1, this.scale = 0, void(this.zeroY = n + i);
                        var r = 0;
                        this.options.scaleStep > 0 ? r = this.options.scaleStep : this.options.scaleMinStep > 0 && (r = this.options.scaleMinStep), r > 0 && (t < 0 && (t = Math.floor(t / r) * r), e > 0 && (e = Math.ceil(e / r) * r));
                        var s = e - t;
                        if (this.isLogScale) t = d.Helpers.sign(t) * Math.pow(Math.abs(t), 1 - d.Helpers.sign(t) * this.options.scaleAdjustmentTolerance);
                        else {
                            var a = t - s * this.options.scaleAdjustmentTolerance;
                            t > 0 ? t = Math.max(0, a) : t < 0 && (t = Math.min(0, a))
                        }
                        if (this.isLogScale) e = d.Helpers.sign(e) * Math.pow(Math.abs(e), 1 + d.Helpers.sign(e) * this.options.scaleAdjustmentTolerance);
                        else {
                            var o = e + s * this.options.scaleAdjustmentTolerance;
                            e > 0 ? e = Math.max(0, o) : e < 0 && (e = Math.min(0, o))
                        }
                        null !== this.options.minValue && (t = this.options.minValue), null !== this.options.maxValue && (e = this.options.maxValue), this.minValue = t, this.maxValue = e;
                        var l;
                        this.isLogScale ? t <= 0 && e >= 0 ? (this.logOffset = 1, l = Math.log(e + this.logOffset) + Math.log(-t + this.logOffset)) : t < 0 ? (this.logOffset = 1 - t, l = Math.log(-t + this.logOffset)) : e > 0 && (this.logOffset = 1 + e, l = Math.log(e + this.logOffset)) : l = e - t, this.scale = i / l;
                        var h = this.valueToRelativeY(t);
                        this.zeroY = n + i + h
                    }, t.prototype.valueToRelativeY = function (t) {
                        return this.isLogScale ? t > 0 ? this.scale * Math.log(t + this.logOffset) : t < 0 ? -this.scale * Math.log(-t + this.logOffset) : 0 : this.scale * t
                    }, t.prototype.calcLinearValuePerLine = function () {
                        if (this.options.scaleStep) return this.options.scaleStep;
                        var t = this.options.style.labelSpacing / this.scale,
                            e = Math.log(t) / Math.log(10),
                            i = Math.pow(10, Math.floor(e - 1));
                        for (i = Math.max(i, this.options.scaleMinStep); i < t;) {
                            if (2 * i >= t) return 2 * i;
                            if (i > 10 && 2.5 * i >= t) return 2.5 * i;
                            if (5 * i >= t) return 5 * i;
                            i *= 10
                        }
                        return i
                    }, t.prototype.calcExpValuePerLine = function () {
                        var t = this.valueToRelativeY(10) - this.valueToRelativeY(1),
                            e = 10,
                            i = 10,
                            n = t;
                        if (n > 4 * this.options.style.labelSpacing) return {
                            unit: 2,
                            valueMultiplier: 2
                        };
                        for (; n < this.options.style.labelSpacing;) e *= 10, n += t;
                        return {
                            unit: i,
                            valueMultiplier: e
                        }
                    }, t.prototype.getUnitAndName = function (t, e) {
                        t = Math.abs(t);
                        var i = this.isLogScale ? this.cachedUnits.log : this.cachedUnits.lin,
                            n = 1,
                            r = "";
                        if (i[t]) return i[t];
                        for (var s in e.localization.valueUnits) {
                            var a = e.localization.valueUnits[s],
                                o = Math.abs(t / a);
                            if (this.isLogScale) t === Math.round(t / a) * a && n < a && (n = a, r = s);
                            else if (o < 1e3 && o >= 1) {
                                n = a, r = s;
                                break
                            }
                        }
                        var l = 0;
                        if (t > 0)
                            for (var h = 1; t < h;) l += 1, h /= 10;
                        return i[t] = {
                            unit: n,
                            digitsAfterComma: l,
                            name: r
                        }
                    }, t.prototype.paintGrid = function (t) {
                        if (this.options.hgrid !== !1 && (null != this.options.hgrid || this.isPrimary)) {
                            var e = this.options.style.hgrid.lineColor;
                            this.options.style.hgrid.lineWidth = 1, d.Graphics.clearShadow(t);
                            for (var i = d.Graphics.beginStrokeAndFill(t, this.options.style.hgrid), n = this.scene.x0, r = this.scene.x0 + this.scene.width, s = 0; s < this.locations.length; s++) {
                                var a = this.locations[s];
                                0 !== this.values[s] && (i.moveTo(n, a + .5), i.lineTo(r, a + .5))
                            }
                            d.Graphics.endStrokeAndFill(t, i, this.options.style.hgrid);
                            var o = d.Colors.colorTone(e, .5, .5);
                            if (o.opacity < .3) {
                                this.options.style.hgrid.lineColor = o.color, i = d.Graphics.beginStrokeAndFill(t, this.options.style.hgrid);
                                for (var s = 0; s < this.locations.length; s++) {
                                    var a = this.locations[s];
                                    0 !== this.values[s] && (i.moveTo(n, a - .5), i.lineTo(r, a - .5))
                                }
                                d.Graphics.endStrokeAndFill(t, i, this.options.style.hgrid), this.options.style.hgrid.lineColor = e
                            }
                        }
                    }, t.prototype.paintAxisLine = function (t) {
                        var e, i = this.options.side,
                            n = this.panel.left,
                            r = this.panel.right,
                            s = this.scene.y0 + this.scene.height;
                        this.isInside ? ("right" === i && (e = n), "left" === i && (e = r)) : e = "right" === i ? n - .5 : r + .5, t.moveTo(e, this.scene.y0), t.lineTo(e, s)
                    }, t.prototype.paintZeroLineDepth = function (t) {
                        if (!(this.zeroY > this.scene.chartHeight)) {
                            var e = this.options.style.baseLine,
                                i = Math.max(e.lineDepth, this.seriesDepth);
                            if (i > 0) {
                                var n = d.Graphics.beginStroke(t, this.options.style.baseLine),
                                    r = this.scene.x0,
                                    s = r + this.scene.width,
                                    a = Math.round(this.zeroY) - .5 * (e.lineWidth || 1);
                                n.moveTo(r, a), n.lineTo(r + i, a - i), n.lineTo(s, a - i), n.lineTo(s, a), t.fillStyle = e.depthColor, t.fill(), d.Graphics.endStroke(t, n, e)
                            }
                        }
                    }, t.prototype.paintZeroLine = function (t) {
                        if (!(this.zeroY > this.scene.chartHeight)) {
                            var e = this.options.style.baseLine,
                                i = this.scene.x0,
                                n = i + this.scene.width,
                                r = Math.round(this.zeroY) - .5 * (e.lineWidth || 1),
                                s = d.Graphics.beginStroke(t, e);
                            s.moveTo(i, r), s.lineTo(n, r), d.Graphics.endStroke(t, s, e)
                        }
                    }, t.prototype.paintThreshold = function (t, e) {
                        if (0 !== this.scale) {
                            var i = this.scene.x0,
                                n = this.scene.x0 + this.scene.width,
                                r = this.scene.y0,
                                s = r + this.scene.height,
                                a = this.zeroY - this.valueToRelativeY(e.from),
                                o = this.zeroY - this.valueToRelativeY(e.to);
                            a = a >= s - .5 ? (0 | s) + .5 : (this.zeroY - this.valueToRelativeY(e.from) | 0) - .5, o = o <= r - .5 ? (0 | r) + .5 : (this.zeroY - this.valueToRelativeY(e.to) | 0) - .5, e.style.fillColor && (t.fillStyle = e.style.fillColor, t.beginPath(), t.rect(i, o, this.scene.width, a - o), t.fill(), t.closePath());
                            var l = d.Graphics.beginStroke(t, e.style);
                            a - .5 !== s && (l.moveTo(i, a), l.lineTo(n, a)), o - .5 !== r && (l.moveTo(i, o), l.lineTo(n, o)), d.Graphics.endStroke(t, l, e.style)
                        }
                    }, t.prototype.paintLabels = function (t, e) {
                        if (this._chart.assetsLoaded) {
                            var i = this.scene,
                                n = this.panel.left,
                                r = this.panel.right,
                                s = "right" === this.options.side,
                                a = this.title;
                            if (this.options.title && a) {
                                var o = i.y0,
                                    l = i.height,
                                    h = a.hheight,
                                    u = a.style.margin || 0,
                                    c = o + .5 * l,
                                    p = void 0;
                                s ? (p = r - u - h, r -= h + 2 * u) : (p = n + u + h, n += h + 2 * u), e.paint(t, p, c, 1, a)
                            }
                            var f, g = (n + r) / 2;
                            if (f = s ? n : r - 4, !this.isInside) {
                                t.beginPath();
                                for (var m = 0; m < this.locations.length; m++) {
                                    var v = this.locations[m];
                                    t.moveTo(f, v), t.lineTo(f + 4, v)
                                }
                                d.Graphics.stroke(t, this.options.style.tick)
                            }
                            for (var y = 0; y < this.locations.length; y++) {
                                var S = this.locations[y],
                                    b = this.labels[y],
                                    C = void 0;
                                e.measure(t, b), C = this.isInside ? g : s ? f + b.hwidth + 7 : f - b.hwidth - 3, C = Math.min(C, i.chartLeft + i.chartWidth - b.hwidth), C = Math.max(C, i.chartLeft + b.hwidth), e.paint(t, C, S, 1, b)
                            }
                        }
                    }, t
                }();
                t.ValueAxis = p,
                    function (t) {
                        var e = function () {
                            function t(t, e) {
                                this.series = e, this.scene = t, this.prevy = []
                            }
                            return t.prototype.paintStack = function (t, e, i, n, r, s, a) {
                                if (this.zeroY = s, e.length > 0) {
                                    var o = this.series,
                                        l = this.prevy;
                                    l.length < e.length && (l = this.prevy = new Array(e.length));
                                    for (var h = 0; h <= e.length - 1; h++) l[h] = s;
                                    for (var u = 0; u < o.length; u++) {
                                        var c = o[u],
                                            d = r[u],
                                            p = a && a.length ? a[u] : null;
                                        this.plainColumns(t, c.style, e, i, l, n, d, u, p)
                                    }
                                }
                            }, t.prototype.hitTest = function (t, e, i, n, r, s, a, o) {
                                var l = t.length;
                                if (!(l > 1)) return {
                                    result: null,
                                    distance: 1 / 0
                                };
                                var h = this.series,
                                    u = d.Helpers.binSearch(t, s),
                                    c = t[u] - e[u],
                                    p = t[u] + e[u];
                                if (c > s && u > 0) {
                                    var f = t[u - 1] - e[u - 1],
                                        g = t[u - 1] + e[u - 1];
                                    (g > s || Math.abs(g - s) < Math.abs(c - s)) && (u -= 1, c = f, p = g)
                                }
                                for (var m = null, v = 1 / 0, y = r, S = 0; S < h.length; S++) {
                                    var b = i[S][u];
                                    if (d.Helpers.isNumber(b)) {
                                        var C = y - b,
                                            x = Math.min(y, C),
                                            w = Math.max(y, C),
                                            L = d.Geometry.distanceToRect(s, a, c, x, p, w);
                                        L < v && (v = L, m = {
                                            x0: c,
                                            y0: x,
                                            x1: p,
                                            y1: w,
                                            seriesIndex: S,
                                            isMarker: !1
                                        }), y = C
                                    }
                                }
                                return {
                                    result: m,
                                    distance: v
                                }
                            }, t.prototype.plainColumns = function (t, e, i, n, r, s, a, o, l) {
                                for (var h, u, c, p, f, g = t.context, m = this.scene.y0, v = this.scene.height, y = e.minHeight, S = m + v, b = s[o], C = null, x = 0; x < i.length; x++) {
                                    var w = i[x],
                                        L = b[x];
                                    if (d.Helpers.isNumber(L)) {
                                        var T = n[x],
                                            k = r[x],
                                            A = k - L;
                                        r[x] = A;
                                        var M = w - T,
                                            I = T + T,
                                            P = void 0,
                                            D = void 0,
                                            N = void 0,
                                            F = !0;
                                        if (k < A) {
                                            F = !1, P = Math.max(A - k, y), D = k;
                                            for (var O = !0, E = o - 1; E > 0;) {
                                                if (null !== s[E][x]) {
                                                    O = !1;
                                                    break
                                                }
                                                E--
                                            }
                                            N = O
                                        } else {
                                            if (!(k > A)) continue;
                                            P = Math.max(k - A, y), D = k - P;
                                            for (var R = !0, E = o + 1; E < s.length;) {
                                                if (null !== s[E][x]) {
                                                    R = !1;
                                                    break
                                                }
                                                E++
                                            }
                                            N = R
                                        }
                                        var H = a ? a[x] || e : e;
                                        if (C !== H) {
                                            C = H, f = C.lineColor ? C.lineWidth : 0, u = C.shadowColor, h = C.depth, c = C._currentFillStyle;
                                            var B = C.gradient,
                                                z = d.Helpers.isString(c);
                                            if (z && h ? (p = C.fillColor, d.Helpers.isNumber(C.depthBrightness) && (p = d.Colors.derive(p, C.depthBrightness, 1))) : p = null, B && 1 !== B && z) {
                                                var U = g.createLinearGradient(0, S, 0, S - 2 * v / 3);
                                                U.addColorStop(0, d.Colors.derive(c, B, 1)), U.addColorStop(1, c), c = U
                                            }
                                            g.fillStyle = c
                                        }
                                        if (e.fillGradientMode) {
                                            var G = null,
                                                j = e.fillGradient ? e.fillGradient : [];
                                            if ("horizontal" === e.fillGradientMode && I > 2 ? G = g.createLinearGradient(w - I / 2, 0, w + I / 2, 0) : "vertical" === e.fillGradientMode && P > 2 && (G = g.createLinearGradient(0, D, 0, D + P)), "cylinder" === e.fillGradientType) {
                                                var W = d.Colors.parse(e.fillColor);
                                                j.push([0, d.Colors.format(d.Colors.derive(W, .6, 1))]), j.push([.25, d.Colors.format(d.Colors.derive(W, .8, 1))]),
                                                    j.push([.75, d.Colors.format(d.Colors.derive(W, 1.1, 1))]), j.push([1, d.Colors.format(d.Colors.derive(W, .8, 1))])
                                            }
                                            if (G) {
                                                for (var V = 0, Z = j; V < Z.length; V++) {
                                                    var Y = Z[V];
                                                    G.addColorStop(Y[0], Y[1])
                                                }
                                                g.fillStyle = G
                                            }
                                        }
                                        if (p && (g.beginPath(), d.Graphics.applyShadow(g, C), N ? (g.moveTo(M + h, D - h), g.lineTo(M + I + h, D - h), g.lineTo(M + I + h, D + P - h), g.lineTo(M + I, D + P), g.lineTo(M + I, D), g.lineTo(M, D)) : (g.moveTo(M + I, D), g.lineTo(M + I + h, D - h), g.lineTo(M + I + h, D + P - h), g.lineTo(M + I, D + P), g.lineTo(M + I, D)), g.closePath(), g.fillStyle = p, g.fill(), d.Graphics.clearShadow(g), g.fillStyle = c), !p && u && d.Graphics.applyShadow(g, C), c) {
                                            var q = C.radius;
                                            if (q[0] || q[1] || q[2] || q[3]) {
                                                var _ = [];
                                                F ? _ = q : (_[0] = q[2], _[1] = q[3], _[2] = q[0], _[3] = q[1]), g.beginPath();
                                                var X = P / 2,
                                                    Q = I / 2;
                                                _[0] ? (g.moveTo(M, D + Math.min(X, _[0])), g.quadraticCurveTo(M, D, M + Math.min(Q, _[0]), D)) : g.moveTo(M, D), _[1] ? (g.lineTo(M + I - Math.min(_[1], Q), D), g.quadraticCurveTo(M + I, D, M + I, D + Math.min(_[1], X))) : g.lineTo(M + I, D), _[2] ? (g.lineTo(M + I, D + P - Math.min(_[2], X)), g.quadraticCurveTo(M + I, D + P, M + I - Math.min(_[2], Q), D + P)) : g.lineTo(M + I, D + P), _[3] ? (g.lineTo(M + Math.min(Q, _[3]), D + P), g.quadraticCurveTo(M, D + P, M, D + P - Math.min(X, _[2]))) : g.lineTo(M, D + P), g.closePath(), g.fill()
                                            } else g.fillRect(M, D, I, P);
                                            !p && u && d.Graphics.clearShadow(g)
                                        }
                                        if (f > 0) {
                                            D += f / 2, M += f / 2, I -= f, P -= f;
                                            var X = P / 2,
                                                Q = I / 2,
                                                J = d.Graphics.beginStroke(g, C);
                                            if (I > 0)
                                                if (P > 0) {
                                                    var K = C.radius,
                                                        _ = [];
                                                    F ? _ = K : (_[0] = K[2], _[1] = K[3], _[2] = K[0], _[3] = K[1]), _[0] ? (J.moveTo(M, D + Math.min(X, _[0])), J.quadraticCurveTo(M, D, M + Math.min(Q, _[0]), D)) : J.moveTo(M, D), _[1] ? (J.lineTo(M + I - Math.min(_[1], Q), D), J.quadraticCurveTo(M + I, D, M + I, D + Math.min(_[1], X))) : J.lineTo(M + I, D), _[2] ? (J.lineTo(M + I, D + P - Math.min(_[2], X)), J.quadraticCurveTo(M + I, D + P, M + I - Math.min(_[2], Q), D + P)) : J.lineTo(M + I, D + P), _[3] ? (J.lineTo(M + Math.min(Q, _[3]), D + P), J.quadraticCurveTo(M, D + P, M, D + P - Math.min(X, _[2]))) : J.lineTo(M, D + P), J.closePath()
                                                } else f > 0 && (g.moveTo(M, k), g.lineTo(M + I, k));
                                            else f > 0 && (g.moveTo(w, D), g.lineTo(w, D + P));
                                            d.Graphics.endStroke(g, J, C)
                                        }
                                        c || p || !u || d.Graphics.clearShadow(g);
                                        var $ = C.previewLineColor;
                                        if (l && l[x]) {
                                            g.beginPath();
                                            for (var tt = 0, et = A - k, it = l[x], nt = 0; nt < it.length; nt++) {
                                                var rt = it[nt];
                                                tt += rt, L = k + tt * et, g.moveTo(M, L), g.lineTo(M + I, L)
                                            }
                                            g.lineWidth = 1, g.strokeStyle = $, g.stroke()
                                        }
                                    }
                                }
                            }, t
                        }();
                        t.Columns = e;
                        var i = function () {
                            function t(t, e) {
                                this.stack = t, this.series = e, this.seriesData = [];
                                for (var i = 0; i < e.length; i++) this.seriesData.push({
                                    markerY: [],
                                    segments: []
                                });
                                this.prevyL = [], this.prevyR = []
                            }
                            return t.prototype.paintStack = function (t, e, i, n, r, s) {
                                if (0 !== e.length) {
                                    var a = t.context;
                                    this.paintLines(a, this.series, this.seriesData, e, i, n, s);
                                    for (var o = 0; o < this.series.length; o++) {
                                        var l = this.series[o];
                                        l.style.markerStyleFunction ? this.paintCustomMarkers(a, l, e, n[o], this.seriesData[o].markerY) : this.paintMarkers(a, l, e, n[o], this.seriesData[o].markerY)
                                    }
                                }
                            }, t.prototype.paintLines = function (t, e, i, n, r, s, a) {
                                this.computeLineSegments(n, r, a, s);
                                for (var o = [
                                        [-(1 / 0), 0, 1 / 0],
                                        [a, a, a]
                                    ], l = 0; l < e.length; l++) {
                                    var h = e[l];
                                    this.paintLine(t, h.style, o, i[l].segments, a), l < e.length - 1 && (o = this.mergePreviousSegments(o, this.seriesData[l].segments))
                                }
                            }, t.prototype.mergePreviousSegments = function (t, e) {
                                for (var i = [], n = [], r = 0, s = t[0], a = t[1], o = 0; o < e.length; o += 2) {
                                    for (var l = e[o], h = e[o + 1]; s[r] <= l[0];) i.push(s[r]), n.push(a[r]), r++;
                                    for (s[r - 1] !== l[0] && (i.push(l[0]), n.push(a[r - 1])), i.push.apply(i, l), n.push.apply(n, h); s[r] < l[l.length - 1];) r++;
                                    l[l.length - 1] !== s[r] && (i.push(l[l.length - 1]), n.push(a[r]))
                                }
                                for (; r < s.length;) i.push(s[r]), n.push(a[r]), r++;
                                return [i, n]
                            }, t.prototype.paintCustomMarkers = function (t, e, i, n, r) {
                                var s = e.style.markerStyleFunction(this.stack.externalItems(), n);
                                if (!s || s.length !== n.length) return void d.Helpers.error("markerStyleFunction() must return an array with the same number of elements as the input arrays.");
                                for (var a = e.style.marker, o = 0; o < n.length; o++) {
                                    var l = s[o];
                                    l && l.shape && (l.fillColor || (l.fillColor = a.fillColor || e.style.lineColor || e.style.fillColor), l.width || (l.width = a.width || 10), t.beginPath(), d.Graphics.strokeMarker(t, l.shape, i[o], r[o], l.width / 2), d.Graphics.paint(t, l))
                                }
                            }, t.prototype.paintMarkers = function (t, e, i, n, r) {
                                var s = e.style.marker;
                                if (s.shape) {
                                    var a = {
                                            fillColor: s.fillColor || e.style.lineColor || e.style.fillColor,
                                            lineColor: s.lineColor,
                                            lineWidth: s.lineWidth
                                        },
                                        o = s.width / 2,
                                        l = s.shape;
                                    t.beginPath();
                                    for (var h = 0; h < n.length; h++) {
                                        var u = n[h];
                                        null !== u && d.Graphics.strokeMarker(t, l, i[h], r[h], o)
                                    }
                                    d.Graphics.paint(t, a)
                                }
                            }, t.prototype.hitTest = function (t, e, i, n, r, s, a, o) {
                                var l = this.series,
                                    h = t.length;
                                if (0 === h) return {
                                    result: null,
                                    distance: 1 / 0
                                };
                                for (var u = Math.min(d.Helpers.binSearch(t, s), h - 2), c = null, p = 1 / 0, f = r - a, g = 0; g < l.length; g++) {
                                    for (var m = l[g], v = m.style, y = this.seriesData[g], S = Math.max(0, u - 2); S < Math.min(h, u + 3); S++) {
                                        var b = i[g][S];
                                        if (null !== b && v.marker) {
                                            var C = t[S],
                                                x = y.markerY[S],
                                                w = v.marker.width / 2,
                                                L = s - C,
                                                T = a - x,
                                                k = Math.sqrt(L * L + T * T);
                                            k < w + o && p > k - w && (p = k - w, c = {
                                                x0: C,
                                                y0: x,
                                                x1: C,
                                                y1: x,
                                                seriesIndex: g,
                                                isMarker: !0
                                            })
                                        }
                                    }
                                    for (var A = null, M = y.segments, S = 0; S < M.length; S += 2)
                                        for (var I = M[S], P = M[S + 1], D = I[0], N = 1; N < I.length; N++) {
                                            var F = I[N];
                                            if (D <= s + o && F >= s - o) {
                                                var O = P[N - 1],
                                                    E = P[N],
                                                    R = Math.sqrt(d.Geometry.distanceToSegmentSq(D, O, F, E, s, a));
                                                R < o && R <= p && (p = R, c = {
                                                    x0: D,
                                                    y0: O,
                                                    x1: F,
                                                    y1: E,
                                                    seriesIndex: g,
                                                    isMarker: !1
                                                })
                                            }
                                            if (D <= s && F >= s) {
                                                var O = P[N - 1],
                                                    E = P[N],
                                                    H = d.Geometry.lineIntersectsSegment(s, a, 0, 1, D, O, F, E);
                                                H !== 1 / 0 && (A = H)
                                            }
                                            D = F
                                        }
                                    null !== A && (d.Helpers.sign(A) !== d.Helpers.sign(f) && (v.fillColor || v.fillGradient) && p >= 0 && (p = 0, c = {
                                        x0: 0,
                                        y0: 0,
                                        x1: 1,
                                        y1: 1,
                                        seriesIndex: g,
                                        isMarker: !1
                                    }), f = A)
                                }
                                return {
                                    result: c,
                                    distance: Math.max(p, 0)
                                }
                            }, t.prototype.computeLineSegments = function (t, e, i, n) {
                                var r = t.length,
                                    s = this.prevyL,
                                    a = this.prevyR;
                                s.length < r && (s.length = r, a.length = r);
                                for (var o = 0; o < r; o++) s[o] = i, a[o] = i;
                                for (var l = s, h = 0; h < this.series.length; h++) {
                                    var u = this.series[h],
                                        c = this.seriesData[h];
                                    if (c.segments.length = 0, c.markerY.length < r && (c.markerY.length = r), u.style.steps) {
                                        var d = this.buildStepSegments(t, e, i, s, a, l, n[h], u.data.noDataPolicy);
                                        c.segments = d.segments, c.markerY = d.markerY
                                    } else {
                                        var p = this.buildLineSegments(t, i, s, a, l, n[h], u.data.noDataPolicy);
                                        if (c.segments = p.segments, c.markerY = p.markerY, u.style.smoothing)
                                            for (var f = 0; f < c.segments.length; f += 2) {
                                                var g = this.smoothLine(c.segments[f], c.segments[f + 1]);
                                                c.segments[f] = g.x, c.segments[f + 1] = g.y
                                            }
                                    }
                                    l = c.markerY
                                }
                            }, t.prototype.buildLineSegments = function (t, e, i, n, r, s, a) {
                                var o = [],
                                    l = [],
                                    h = [];
                                if ("zero" === a) {
                                    for (var u = 0; u < t.length; u++) {
                                        var c = t[u],
                                            d = s[u],
                                            p = i[u],
                                            f = n[u];
                                        null !== d ? (o.push(r[u] - d), l.push(c), h.push(p - d), p !== f && (l.push(c), h.push(f - d)), i[u] -= d, n[u] -= d) : (o.push(r[u]), p !== f ? (h.push(p), h.push(f), l.push(c), l.push(c)) : (h.push(p), l.push(c)))
                                    }
                                    return {
                                        segments: [l, h],
                                        markerY: o
                                    }
                                }
                                if ("join" === a) {
                                    for (var g = null, u = 0; u < t.length; u++) {
                                        var c = t[u],
                                            d = s[u],
                                            p = i[u],
                                            f = n[u];
                                        if (null !== d) {
                                            if (null === g) o.push(r[u] - d), l.push(c), h.push(f - d), n[u] -= d;
                                            else {
                                                if (g < u - 1)
                                                    for (var m = s[g], v = t[g], y = (d - m) / (c - v), S = g + 1; S < u; S++) {
                                                        var b = t[S],
                                                            C = m + y * (b - v);
                                                        o.push(r[S] - C);
                                                        var x = i[S],
                                                            w = n[S];
                                                        l.push(b), h.push(x - C), x !== w && (l.push(b), h.push(w - C)), i[S] -= C, n[S] -= C
                                                    }
                                                o.push(r[u] - d), l.push(c), h.push(p - d), p !== f && (l.push(c), h.push(f - d)), i[u] -= d, n[u] -= d
                                            }
                                            g = u
                                        } else null === g && o.push(r[u])
                                    }
                                    return l.length > 2 && l[l.length - 1] === l[l.length - 2] && (l.pop(), h.pop()), {
                                        segments: [l, h],
                                        markerY: o
                                    }
                                }
                                for (var L = !1, T = [], u = 0; u < t.length; u++) {
                                    var c = t[u],
                                        d = s[u],
                                        p = i[u],
                                        f = n[u];
                                    null !== d ? (o.push(r[u] - d), L ? (l.length > 1 && i[u - 1] !== n[u - 1] && (l.push(t[u - 1]), h.push(n[u - 1])), l.push(c), h.push(p - d), i[u] -= d, n[u] -= d) : (l.push(c), h.push(f - d), n[u] -= d), L = !0) : (o.push(r[u]), L && (l.length > 0 && (1 === l.length && (l.push(l[0]), h.push(h[0])), T.push(l, h), l = [], h = []), n[u - 1] += s[u - 1]), L = !1)
                                }
                                return l.length > 0 && (1 === l.length && (l.push(l[0]), h.push(h[0])), T.push(l, h)), {
                                    segments: T,
                                    markerY: o
                                }
                            }, t.prototype.buildStepSegments = function (t, e, i, n, r, s, a, o) {
                                for (var l = [], h = [], u = [], c = [], d = null, p = 0, f = 0; f < t.length; f++) {
                                    var g = t[f] - e[f],
                                        m = a[f];
                                    if (null !== m) {
                                        null !== d && (u.push(g), c.push(d));
                                        var v = s[f] - m;
                                        u.push(g), c.push(v), d = v, p = g + 2 * e[f], h.push(v), n[f] = r[f] = v
                                    } else if ("zero" === o) {
                                        var v = s[f];
                                        h.push(v), r[f] = n[f] = v, null !== d && (u.push(p), c.push(d)), u.push(g), c.push(v), d = v, p = g + 2 * e[f]
                                    } else if ("join" === o) {
                                        var v = null !== d ? d : s[f];
                                        h.push(v), r[f] = n[f] = v
                                    } else {
                                        var v = s[f];
                                        h.push(v), r[f] = n[f] = v, u.length > 0 && (null !== d && (u.push(p), c.push(d)), d = null, l.push(u, c), u = [], c = [])
                                    }
                                }
                                return u.length > 0 && (null !== d && (u.push(p), c.push(d)), l.push(u, c)), {
                                    segments: l,
                                    markerY: h
                                }
                            }, t.prototype.smoothLine = function (t, e) {
                                var i = t[0],
                                    n = t[t.length - 1],
                                    r = (n - i) / t.length;
                                if (r < 2) return {
                                    x: t,
                                    y: e
                                };
                                var s = [],
                                    a = [];
                                s.push(i), a.push(e[0]);
                                for (var o = 0; o + 1 < t.length;) {
                                    var l = o + 1;
                                    if (t[o] !== t[l])
                                        for (; l + 1 < t.length && t[l] !== t[l + 1];) l += 1;
                                    if (l - o === 1) s.push(t[l]), a.push(e[l]);
                                    else {
                                        var h = new d.MonotoneCurve(t, e, o, l + 1);
                                        n = t[o];
                                        for (var u = o + 1; u <= l; u++) {
                                            i = n, n = t[u];
                                            var c = e[u];
                                            r = n - i;
                                            for (var p = Math.ceil(Math.min(50, Math.max(2, r / 3))), f = r / p, g = s.length;
                                                (i += f) < n;) s.push(i);
                                            h.interpolateArray(u - 1, s, g, s.length, a), s.push(n), a.push(c)
                                        }
                                        h.clear()
                                    }
                                    o = l
                                }
                                return t.length = 0, e.length = 0, {
                                    x: s,
                                    y: a
                                }
                            }, t.prototype.paintLine = function (t, e, i, n, r) {
                                if (e._currentFillStyle) {
                                    e.shadowColor && d.Graphics.applyShadow(t, e), t.fillStyle = e._currentFillStyle, t.beginPath();
                                    for (var s = 0; s < n.length; s += 2) this.paintArea(t, n[s], n[s + 1], i, r);
                                    t.fill(), e.shadowColor && d.Graphics.clearShadow(t)
                                }
                                if (e.lineColor) {
                                    !e.fillColor && e.shadowColor && d.Graphics.applyShadow(t, e);
                                    for (var a = d.Graphics.beginStroke(t, e), s = 0; s < n.length; s += 2) {
                                        var o = n[s],
                                            l = n[s + 1];
                                        a.moveTo(o[0], l[0]);
                                        for (var h = 1; h < o.length; h++) a.lineTo(o[h], l[h])
                                    }
                                    d.Graphics.endStroke(t, a, e), !e.fillColor && e.shadowColor && d.Graphics.clearShadow(t)
                                }
                            }, t.prototype.paintArea = function (t, e, i, n, r) {
                                t.moveTo(e[0], i[0]);
                                for (var s = 1; s < e.length; s++) t.lineTo(e[s], i[s]);
                                for (var a = e[0], o = e[e.length - 1], l = r, h = o, u = n.length - 2; u >= 0; u += -2) {
                                    var c = n[u],
                                        d = n[u + 1];
                                    if (!(c.length < 2 || c[0] > h || c[c.length - 1] < a)) {
                                        var p = c.length - 1,
                                            f = c[p];
                                        f < h && (t.lineTo(h, l), t.lineTo(f, l), h = f);
                                        var s = void 0,
                                            g = void 0;
                                        for (s = p; s >= 0; s--) {
                                            if (g = c[s], h === f) t.lineTo(f, d[s + 1]), h = g;
                                            else if (h < f && h > g) {
                                                var m = d[s],
                                                    v = d[s + 1],
                                                    y = (h - g) / (f - g),
                                                    S = m + y * (v - m);
                                                t.lineTo(h, S), h = g
                                            }
                                            if (h <= a) {
                                                h = a;
                                                var m = d[s],
                                                    v = d[s + 1],
                                                    y = (h - g) / (f - g),
                                                    S = m + y * (v - m);
                                                t.lineTo(h, S);
                                                break
                                            }
                                            f = g
                                        }
                                        s === -1 && h === g && t.lineTo(h, d[0])
                                    }
                                }
                                h !== a && (t.lineTo(h, l), t.lineTo(a, l)), t.closePath()
                            }, t
                        }();
                        t.Line = i;
                        var n = function () {
                            function t(t, e) {
                                this.series = e, this.scene = t, this.prevy = []
                            }
                            return t.prototype.paintStack = function (t, e, i, n, r, s) {
                                if (e.length > 0) {
                                    var a = this.series[0];
                                    this.seriesEnabled = a.enabled;
                                    var o = this.prevy;
                                    o.length < e.length && (o = this.prevy = new Array(e.length));
                                    for (var l = 0; l <= e.length - 1; l++) o[l] = s;
                                    this.plainBar(t.context, a.style, e, i, o, n)
                                }
                            }, t.prototype.hitTest = function (t, e, i, n, r, s, a, o) {
                                var l = t.length;
                                if (!(l > 1)) return {
                                    result: null,
                                    distance: 1 / 0
                                };
                                var h = this.series,
                                    u = d.Helpers.binSearch(t, s),
                                    c = t[u] - e[u],
                                    p = t[u] + e[u];
                                if (c > s && u > 0) {
                                    var f = t[u - 1] - e[u - 1],
                                        g = t[u - 1] + e[u - 1];
                                    (g > s || Math.abs(g - s) < Math.abs(c - s)) && (u -= 1, c = f, p = g)
                                }
                                for (var m = null, v = 1 / 0, y = r, S = 0; S < h.length; S++) {
                                    var b = i[S][u];
                                    if (null !== b) {
                                        var C = y - b,
                                            x = Math.min(y, C),
                                            w = Math.max(y, C),
                                            L = d.Geometry.distanceToRect(s, a, c, x, p, w);
                                        L < v && (v = L, m = {
                                            x0: c,
                                            y0: x,
                                            x1: p,
                                            y1: w,
                                            seriesIndex: S,
                                            isMarker: !1
                                        }), y = C
                                    }
                                }
                                return {
                                    result: m,
                                    distance: v
                                }
                            }, t.prototype.plainBar = function (t, e, i, n, r, s) {
                                for (var a = 0; a < i.length; a++) {
                                    var o = i[a],
                                        l = r[a],
                                        h = s[0][a],
                                        u = s[1][a],
                                        c = s[2][a],
                                        p = s[3][a];
                                    if (void 0 !== p && null !== p || void 0 !== h && null !== h || void 0 !== u && null !== u || void 0 !== c && null !== c) {
                                        var f = (o - n[a] || 0) + .5,
                                            g = (o + n[a] || 0) + .5,
                                            m = (l - p || 0) + .5,
                                            v = (l - h || 0) + .5,
                                            y = (l - u || 0) + .5,
                                            S = (l - c || 0) + .5,
                                            b = this.applyPatternStyle(t, e, y, S);
                                        if ("bar" === e.pattern) {
                                            var C = d.Graphics.beginStroke(t, b);
                                            C.moveTo(o, v), C.lineTo(o, m), C.moveTo(f, y), C.lineTo(o, y), C.moveTo(g, S), C.lineTo(o, S), d.Graphics.endStroke(t, C, b)
                                        } else {
                                            var C = d.Graphics.beginStroke(t, b);
                                            C.moveTo(o, v), C.lineTo(o, y), C.moveTo(o, S), C.lineTo(o, m), d.Graphics.endStroke(t, C, b), C = d.Graphics.beginStroke(t, b, !0), C.moveTo(f, y), C.lineTo(g, y), C.lineTo(g, S), C.lineTo(f, S), C.closePath(), d.Graphics.endStroke(t, C, b, !0)
                                        }
                                        e.shadowColor && d.Graphics.clearShadow(t)
                                    }
                                }
                            }, t.prototype.applyPatternStyle = function (t, e, i, n) {
                                var r = i >= n ? e.increase : e.decrease,
                                    s = "candlestick" === e.pattern ? r.candlestick : r.bar,
                                    a = s;
                                if (!this.seriesEnabled) {
                                    a = d.Helpers.realClone(s);
                                    var o = this.scene.settings.legend.advanced.disabledSeries;
                                    a.lineColor = o.lineColor, void 0 !== a.fillColor && (a.fillColor = o.fillColor)
                                }
                                return e.lineColor && e.shadowColor && d.Graphics.applyShadow(t, e), a
                            }, t
                        }();
                        t.Candlestick = n
                    }(r = t.Renderers || (t.Renderers = {}));
                var f = function () {
                    function t(t, e, i) {
                        this.scene = e, this.chart = t, this.valueAxis = i
                    }
                    return t.prototype.setSeriesFont = function (t, e, i, n, r, s) {
                        var a = this.scene.dataLabels.metaData,
                            o = 2 * n[0];
                        null === a.styles && (a.styles = {});
                        for (var l = 0; l < i.length; l++) {
                            var h = i[l],
                                u = this.getLongestNumber(r[l]);
                            if (a.styles[h.id] = null, u.max === -(1 / 0)) break;
                            var c = this.createContent(u.max, s[u.index], h.valueLabels.contentsFunction) || "",
                                d = this.reduceFontWidth(t, e, h.id, h.valueLabels, o, c);
                            d && (a.styles[h.id] = d)
                        }
                    }, t.prototype.scanValueLabels = function (t, e, i, n, r, s, a, o, l) {
                        for (var h = this.chart.shell.getChartInnerArea(), u = this.chart.getBottomHeight(), c = 0; c < 2; c++) {
                            var d = 0 === c ? s : a;
                            if (null !== d)
                                for (var p = 0; p < n.length; p++)
                                    for (var f = n[p], g = this.valueAxis.zeroY, m = 0, v = 0; v < d.length; v++) {
                                        var y = o[v][p],
                                            S = d[v][p];
                                        if (null !== S && null !== y) {
                                            m += y, g -= S;
                                            var b = r[v];
                                            if (b.valueLabels && b.valueLabels.enabled) {
                                                var x = b.valueLabels.useStackedValue,
                                                    w = this.chart.settings._computedStacks[b.stack],
                                                    L = w && "based" === w.type;
                                                if (null === x && (x = !L), !L || 0 !== S || 0 === m) {
                                                    if (b instanceof C) {
                                                        var T = S >= 0 ? 1 : -1,
                                                            k = b.style.minHeight;
                                                        k && (S = S * T < k ? k * T : S)
                                                    }
                                                    this.createDrawingSpots(t, h, S, g + S, f, b, x ? m : y, u, i[0], l[p])
                                                }
                                            }
                                        }
                                    }
                        }
                        this.paintDataLabels(t, e, i[0], r.length)
                    }, t.prototype.createDrawingSpots = function (t, e, i, n, r, s, a, o, l, h) {
                        var u = s.id,
                            c = s.valueLabels.position,
                            p = this.scene.dataLabels,
                            f = r.toFixed(1),
                            g = this.scene.dataLabels.spots[f];
                        if (null !== p.metaData.styles[u]) {
                            var m = this.createContent(a, h, s.valueLabels.contentsFunction);
                            if (null != m) {
                                var v = (new d.LabelLayoutBase).totalPadding(s.valueLabels.style);
                                i = Math.abs(i);
                                var y = this.getPositionVerticalDimensions(t, a, n, i, p.metaData.styles[u], s.valueLabels.minFontSize, c, v);
                                if (null !== y) {
                                    var S = y.min,
                                        b = y.max,
                                        C = e.findTopPosition(r, Math.min(r + l, this.scene.x0 + this.scene.width));
                                    C > S && (b = b - S + C, S = C);
                                    var x = this.scene.chartTop + this.scene.chartHeight - this.scene.bottomAxisSize;
                                    if (b > x && (S = S - b + x, b = x), g)
                                        for (var w = 0; w < g.length; w++) {
                                            var L = g[w];
                                            if (null != L) {
                                                var T = L.edges[0],
                                                    k = L.edges[1];
                                                if (S < k && b > T) {
                                                    if (!(s.type === L.type && a > L.value)) return;
                                                    g[w] = null
                                                }
                                            }
                                        }
                                    g || (g = this.scene.dataLabels.spots[f] = []), g.push({
                                        value: a,
                                        type: s.type,
                                        edges: [S, b],
                                        x: parseInt(f, 10),
                                        y: S + y.fontHeight / 2,
                                        font: y.font,
                                        id: u,
                                        style: s.valueLabels.style,
                                        function: s.valueLabels.contentsFunction,
                                        timestamp: h
                                    })
                                }
                            }
                        }
                    }, t.prototype.reduceFontSize = function (t, e, i, n, r) {
                        var s = e.match(/^([^\"\d]*)(\d+\.?\d*)(.*)$/i);
                        if (!s) return d.Helpers.warn("Could not parse the font size from the value `" + e + "`."), {
                            font: e,
                            value: n(e)
                        };
                        for (var a = s[2], o = s[1], l = s[3], h = parseFloat(a); h >= i;) {
                            var u = o + h + l,
                                c = n(u);
                            if (c <= r) return {
                                font: u,
                                value: c
                            };
                            if (h === i) break;
                            h = Math.round((h - 1) * r / c * 100) / 100, h < i && (h = i)
                        }
                        return null
                    }, t.prototype.getPositionVerticalDimensions = function (t, e, i, n, r, s, a, o) {
                        var l = e >= 0 ? -1 : 1,
                            h = null,
                            u = null,
                            c = l * n,
                            p = d.Graphics.getTextHeight(t, r) + 2 * o + 4,
                            f = p < n;
                        if (!f && ("insideTop" === a || "insideCenter" === a || "insideBase" === a)) {
                            var g = this.reduceFontSize(t, r, s, function (e) {
                                return d.Graphics.getTextHeight(t, e)
                            }, n);
                            if (!g) return null;
                            r = g.font, p = g.value + 2 * o + 4
                        }
                        switch (a) {
                            case "outside":
                                h = i + c, u = h + l * p;
                                break;
                            case "insideTop":
                                h = i + c, u = h - l * p;
                                break;
                            case "insideCenter":
                                h = i + c / 2 + p / 2, u = h - p;
                                break;
                            case "insideBase":
                                h = i + l * p, u = i;
                                break;
                            case "aboveValue":
                                h = i + c, u = h - p;
                                break;
                            case "belowValue":
                                h = i + c, u = h + p;
                                break;
                            case "insideTopAuto":
                                f ? (h = i + c, u = h - l * p) : (h = i + c, u = h + l * p);
                                break;
                            case "value":
                                f && (h = i + c - p / 2, u = h + p);
                                break;
                            default:
                                d.Helpers.warn("Invalid position: '" + a + "'. Possible values: outside, insideTop, insideCenter, insideBase, aboveValue, belowValue, belowValueAuto, value."), h = i + c, u = h + l * p
                        }
                        return null === h ? null : h > u ? {
                            min: u,
                            max: h,
                            font: r,
                            fontHeight: p
                        } : {
                            min: h,
                            max: u,
                            font: r,
                            fontHeight: p
                        }
                    }, t.prototype.reduceFontWidth = function (t, e, i, n, r, s) {
                        var a = this.scene.dataLabels.fontWidths,
                            o = n.style.textStyle;
                        if (s = s.replace(/\d/g, "9"), (a[o.font + ";" + s] || 1 / 0) <= r) return o.font;
                        var l = new d.Label(n.style),
                            h = l.style.textStyle,
                            u = h.font;
                        l.text = s;
                        var c = this.reduceFontSize(t, u, n.minFontSize, function (i) {
                            var n = a[i + ";" + s];
                            return n || (h.font = i, e.labelRenderer.measure(t, l), a[i + ";" + s] = n = 2 * l.hwidth), n
                        }, r);
                        return c ? c.font : null
                    }, t.prototype.getLongestNumber = function (t) {
                        for (var e = 0, i = -1, n = 0; n < t.length; n++) {
                            var r = t[n];
                            r < 0 && (r *= -10), e <= r && (e = r, i = n)
                        }
                        return {
                            max: i === -1 || null === t[i] ? -(1 / 0) : t[i],
                            index: i
                        }
                    }, t.prototype.createContent = function (t, e, i) {
                        if (i) {
                            var n = i.call(this.chart.api, t, e) || null;
                            return null != n && "string" != typeof n ? void d.Helpers.warn("`valueLabels.contentsFunction` has to return `null` or a string value.") : n
                        }
                        return t === (0 | t) ? t.toFixed(0) : t.toFixed(2)
                    }, t.prototype.paintDataLabels = function (t, e, i, n) {
                        var r = this.scene,
                            s = r.dataLabels.metaData,
                            a = 2 * i,
                            o = s.availableWidth !== a;
                        if (s.processed += n, s.processed >= r.seriesWithLabels) {
                            s.processed = 0;
                            for (var l = r.dataLabels.spots, h = Object.keys(l), u = 0, c = h.length; u < c; u++) {
                                var p = l[h[u]];
                                if (p)
                                    for (var f = 0; f < p.length; f++) {
                                        var g = p[f];
                                        if (null != g) {
                                            var m = new d.Label(g.style);
                                            m.text = this.createContent(g.value, g.timestamp, g.function), m.style.textStyle.font = g.font, e.labelRenderer.paint(t, g.x, g.y, 1, m)
                                        }
                                    }
                            }
                            r.dataLabels.spots = {}, o && (s.availableWidth = a)
                        }
                    }, t
                }();
                t.ValueLabels = f,
                    function (t) {
                        var e = function () {
                            function t(t, e, i, n, r) {
                                this.series = [], this.seriesId = [], this.min = 0, this.max = 0, this.renderingType = null, this.needsAfterProcess = !1, this.paddingLeft = 0, this.paddingRight = 0, this.centers = [], this.radii = [], this.vstack = [], this.countStack = [], this.ystack = [], this.xes = [], this.times = [], this.styles = [], this.previewData = [], this.calculatedDepth = 0, this.ystackNegative = null, this.valueLabels = null, this.externalItems = null, this.externalItemsCache = null, this.va = r, this.options = n, this.cluster = i, this.scene = e, this.chart = t, this.va.series++
                            }
                            return t.computeFillPattern = function (t, e, i) {
                                var n = i.fillPattern,
                                    r = i._currentFillStyleKey,
                                    s = i.fillColor,
                                    a = s + "|" + n;
                                if (!r || r.pattern !== a) {
                                    var o, l, h = t.assetsLoader.getAssetImage(i.fillPattern);
                                    if (h) {
                                        var u = i._fillPatternOpacity;
                                        if (s || u) {
                                            var c = document.createElement("canvas");
                                            c.width = h.width, c.height = h.height;
                                            var d = c.getContext("2d");
                                            s && (d.fillStyle = s, d.fillRect(0, 0, h.width, h.height)), d.globalAlpha = i._fillPatternOpacity, d.drawImage(h, 0, 0), h = c
                                        }
                                        o = e.createPattern(h, "repeat"), l = {
                                            pattern: a
                                        }
                                    } else o = s || null, l = null;
                                    i._currentFillStyle = o, i._currentFillStyleKey = l
                                }
                            }, t.prototype.addSeries = function (t, e) {
                                this.renderingType || (this.renderingType = e.type), this.series.push(e), this.seriesId.push(t);
                                var i = e;
                                this.calculatedDepth = Math.max(this.calculatedDepth, i.style.depth), "columns" === this.renderingType && (this.paddingLeft = Math.max(this.paddingLeft, i.style.padding[0]), this.paddingRight = Math.max(this.paddingRight, i.style.padding[1]))
                            }, t.prototype.afterInit = function () {
                                "line" === this.renderingType ? this.renderer = new r.Line(this, this.series) : "columns" === this.renderingType ? this.renderer = new r.Columns(this.scene, this.series) : "candlestick" === this.renderingType && (this.candleStacks = !0, this.renderer = new r.Candlestick(this.scene, this.series))
                            }, t.prototype.process = function (t) {
                                this.processData(t), this.computeMinMax(), this.addLeads(t), this.needsAfterProcess = !0
                            }, t.prototype.afterProcess = function () {
                                if (this.needsAfterProcess || this.va.axisChanged) return this.needsAfterProcess = !1, this.computeY()
                            }, t.prototype.paint = function (t, e) {
                                if (0 !== this.ystack.length && !isNaN(this.radii[0])) {
                                    for (var i = 0; i < this.series.length; i++) {
                                        var n = this.series[i];
                                        this.computeFillStyle(e, n.style), this.chart.assetsLoaded && n.valueLabels && n.valueLabels.enabled && (null === this.valueLabels && (this.valueLabels = new f(this.chart, this.scene, this.va)), this.valueLabels.setSeriesFont(e, t, this.series, this.radii, this.vstack, this.times))
                                    }
                                    var r = this.styles;
                                    if (r)
                                        for (var s = 0; s < r.length; s++) {
                                            var a = r[s];
                                            if (a)
                                                for (var o = 0; o < a.length; o++) this.computeFillStyle(e, a[o])
                                        }
                                    this.ystackNegative && this.renderer.paintStack(t, this.centers, this.radii, this.ystackNegative, this.styles, this.va.zeroY, this.previewData), this.renderer.paintStack(t, this.centers, this.radii, this.ystack, this.styles, this.va.zeroY, this.previewData), null !== this.valueLabels && this.valueLabels.scanValueLabels(e, t, this.radii, this.centers, this.series, this.ystack, this.ystackNegative, this.vstack, this.times)
                                }
                            }, t.prototype.hitTestStack = function (t, e) {
                                var i = d.Helpers.binSearch(this.centers, t),
                                    n = this.centers[i] - this.radii[i],
                                    r = this.centers[i] + this.radii[i];
                                if (n > t && i > 0) {
                                    var s = this.centers[i - 1] - this.radii[i - 1],
                                        a = this.centers[i - 1] + this.radii[i - 1];
                                    (a > t || Math.abs(a - t) < Math.abs(n - t)) && (i -= 1, n = s, r = a)
                                }
                                return {
                                    result: {
                                        x0: n,
                                        y0: 0,
                                        x1: r,
                                        y1: 0,
                                        seriesIndex: null,
                                        isMarker: !1,
                                        stack: this
                                    },
                                    distance: d.Geometry.distanceToRect(t, 0, n, 0, r, 0)
                                }
                            }, t.prototype.hitTest = function (t, e, i) {
                                var n = this.renderer.hitTest(this.centers, this.radii, this.ystack, this.styles, this.va.zeroY, t, e, i),
                                    r = n.result,
                                    s = n.distance;
                                return this.ystackNegative && (n = this.renderer.hitTest(this.centers, this.radii, this.ystackNegative, this.styles, this.va.zeroY, t, e, i), n.distance < s && (r = n.result, s = n.distance)), null !== r && (r.seriesIndex = this.seriesId[r.seriesIndex], r.stack = this), {
                                    result: r,
                                    distance: s
                                }
                            }, t.prototype.computeFillStyle = function (e, i) {
                                if (i)
                                    if (i.fillPattern) t.computeFillPattern(this.chart, e, i);
                                    else {
                                        if (i.fillGradient) return void this.computeFillGradient(e, i);
                                        i._currentFillStyle = i.fillColor || null, i._currentFillStyleKey = null
                                    }
                            }, t.prototype.computeFillGradient = function (t, e) {
                                var i = e.fillGradient,
                                    n = this.va,
                                    r = n.zeroY,
                                    s = this.scene.y0,
                                    a = this.scene.x0,
                                    o = this.scene.height,
                                    l = e._currentFillStyleKey,
                                    h = n.scale + "|" + r + "|" + s + "|" + a + "|" + o + "|" + r;
                                if (!l || !e._currentFillStyle || i !== l.gradient || h !== l.hash) {
                                    for (var u = [], c = 0; c < i.length; c++) {
                                        var p = i[c],
                                            f = r - n.valueToRelativeY(p[0]),
                                            g = (f - s) / o;
                                        u.push([g, p[1]])
                                    }
                                    u.sort(function (t, e) {
                                        return t[0] - e[0]
                                    });
                                    for (var m = t.createLinearGradient(a, s, a, s + o), v = null, y = 0; y < u.length; y++) {
                                        var S = u[y],
                                            b = S[0],
                                            C = S[1];
                                        if (b > 0) {
                                            if (v && v[0] < 0 && m.addColorStop(0, d.Colors.blend(v[1], C, (0 - v[0]) / (b - v[0]), !1)), b > 1) {
                                                v && m.addColorStop(1, d.Colors.blend(v[1], C, (1 - v[0]) / (b - v[0]), !1));
                                                break
                                            }
                                            m.addColorStop(b, C)
                                        }
                                        v = S
                                    }
                                    e._currentFillStyle = m, e._currentFillStyleKey = {
                                        hash: h,
                                        gradient: i
                                    }
                                }
                            }, t.prototype.processData = function (t) {
                                var e = this;
                                this.vstack = [], this.countStack = [], this.styles = [];
                                var i = t[this.seriesId[0]];
                                if (0 !== i.times.length) {
                                    this.xes = i.xes.slice(i.fromIndex, i.toIndex), this.times = i.times.slice(i.fromIndex, i.toIndex), this.centers = new Array(this.xes.length - 1), this.radii = new Array(this.xes.length - 1), this.cluster.computeStackCenterRadius(this, this.xes, this.centers, this.radii), this.externalItemsCache = null, this.externalItems = function () {
                                        var t = e.externalItemsCache;
                                        return null === t && (t = e.externalItemsCache = i.externalItems(i.fromIndex, i.toIndex - 1)), t
                                    }, this.previewData = [];
                                    for (var n = 0; n < this.seriesId.length; n++) {
                                        var r = this.seriesId[n];
                                        if (i = t[r], this.vstack.push(i.values.slice(i.fromIndex, i.toIndex - 1)), this.countStack.push(i.counts.slice(i.fromIndex, i.toIndex - 1)), i.config) {
                                            for (var s = [], a = [], o = i.fromIndex; o < i.toIndex - 1; o++) {
                                                var l = i.config[o];
                                                l && (s.push(l.style), a.push(l.previewData))
                                            }
                                            this.styles.push(s), this.previewData.push(a)
                                        } else this.styles.push(null)
                                    }
                                }
                            }, t.prototype.addLeads = function (t) {
                                for (var e = 0; e < this.seriesId.length; e++) {
                                    var i = this.seriesId[e],
                                        n = t[i];
                                    n.leadIn && this.injectLead(n.leadIn, e), n.leadOut && this.injectLead(n.leadOut, e)
                                }
                            }, t.prototype.injectLead = function (t, e) {
                                var i = this.series.length,
                                    n = t.values[0],
                                    r = t.times[0],
                                    s = [0],
                                    a = [0];
                                this.cluster.computeStackCenterRadius(this, t.xes, s, a);
                                for (var o = s[0], l = a[0], h = 0; h < this.centers.length && this.centers[h] < o;) h++;
                                if (h === this.centers.length || this.centers[h] > o) {
                                    this.centers.splice(h, 0, o), this.radii.splice(h, 0, l), this.times.splice(h, 0, r);
                                    for (var u = 0; u <= i - 1; u++) this.vstack[u].splice(h, 0, null), this.countStack[u].splice(h, 0, null), this.styles[u] && this.styles[u].splice(h, 0, null)
                                }
                                this.vstack[e][h] = n, this.countStack[e][h] = t.counts[0]
                            }, t.prototype.getSeparateNegative = function () {
                                var t = this.options.separateNegativeValues;
                                return null === t && (t = "line" !== this.renderingType), t
                            }, t.prototype.computeMinMax = function () {
                                var t = 1 / 0,
                                    e = -(1 / 0);
                                if (this.vstack.length > 0) {
                                    for (var i = this.vstack, n = i[0].length, r = i.length, s = this.options.type, a = this.getSeparateNegative(), o = this.scene.x0, l = o + this.scene.width, h = 0, u = n - 1; h < n && this.centers[h] + this.radii[h] < o;) h += 1;
                                    for (; u >= h && this.centers[u] - this.radii[u] > l;) u -= 1;
                                    if ("proportional" === s) t = 0, e = 100;
                                    else if (this.candleStacks)
                                        for (var c = h; c <= u; c++)
                                            for (var p = 0; p <= r - 1; p++) {
                                                var f = i[p][c];
                                                d.Helpers.isNumber(f) && (t = Math.min(t, f), e = Math.max(e, f))
                                            } else if (1 === r)
                                                for (var g = i[0], c = h; c <= u; c++) {
                                                    var f = g[c];
                                                    d.Helpers.isNumber(f) && (t = Math.min(t, f), e = Math.max(e, f))
                                                } else if ("based" === s)
                                                    for (var c = h; c <= u; c++)
                                                        for (var p = 0; p <= r - 1; p++) {
                                                            var f = i[p][c];
                                                            d.Helpers.isNumber(f) && (t = Math.min(t, f), e = Math.max(e, f))
                                                        } else if ("normal" !== s || a) {
                                                            if ("normal" !== s) throw "stack.type unknown value: " + s;
                                                            for (var c = h; c <= u; c++)
                                                                for (var m = 0, v = 0, p = 0; p <= r - 1; p++) {
                                                                    var f = i[p][c];
                                                                    d.Helpers.isNumber(f) && (f > 0 ? v += f : f < 0 && (m += f), t = Math.min(t, m), e = Math.max(e, v))
                                                                }
                                                        } else
                                                            for (var c = h; c <= u; c++)
                                                                for (var y = 0, p = 0; p <= r - 1; p++) {
                                                                    var f = i[p][c];
                                                                    d.Helpers.isNumber(f) && (null !== f && (y += f), t = Math.min(t, y), e = Math.max(e, y))
                                                                }
                                }
                                this.min = t, this.max = e, t <= e ? this.va.receiveSeriesGeometry(t, e, this.calculatedDepth) : this.va.receiveSeriesGeometry(void 0, void 0, this.calculatedDepth)
                            }, t.prototype.computeY = function () {
                                var t = this.vstack,
                                    e = t.length;
                                if (0 !== e) {
                                    var i, n = this.options.type,
                                        r = this.getSeparateNegative(),
                                        s = t[0].length,
                                        a = this.va,
                                        o = null;
                                    if ("proportional" === n) {
                                        i = t.map(function () {
                                            return []
                                        }), a.options.scaleAdjustmentTolerance = 0;
                                        for (var l = 0; l <= s - 1; l++) {
                                            for (var h = 0, u = 0; u <= e - 1; u++) {
                                                var c = t[u][l];
                                                null !== c && (h += Math.abs(c))
                                            }
                                            if (h > 0) {
                                                h *= .01;
                                                for (var u = 0; u <= e - 1; u++) {
                                                    var c = t[u][l];
                                                    null !== c ? i[u].push(a.valueToRelativeY(Math.abs(c) / h)) : i[u].push(null)
                                                }
                                            } else
                                                for (var u = 0; u <= e - 1; u++) i[u].push(null)
                                        }
                                    } else if ("based" === n || 1 === e) {
                                        i = [];
                                        for (var d = t[0].map(function () {
                                                return 0
                                            }), p = 0; p < t.length; p++) {
                                            for (var f = t[p], g = new Array(s), m = 0; m < f.length; m++) {
                                                var c = f[m];
                                                if (null !== c) {
                                                    var v = a.valueToRelativeY(c),
                                                        y = d[m];
                                                    c >= 0 && v <= y || c < 0 && v >= y ? g[m] = 0 : (g[m] = v - y, d[m] = v)
                                                } else g[m] = null
                                            }
                                            i.push(g)
                                        }
                                    } else if ("normal" === n && r && this.min < 0 && this.max > 0) {
                                        i = t.map(function () {
                                            return []
                                        }), o = t.map(function () {
                                            return []
                                        });
                                        for (var l = 0; l <= s - 1; l++)
                                            for (var u = 0; u <= e - 1; u++) {
                                                var c = t[u][l];
                                                c > 0 ? (i[u].push(a.valueToRelativeY(c)), o[u].push(null)) : c < 0 ? (i[u].push(null), o[u].push(a.valueToRelativeY(c))) : (i[u].push(null), o[u].push(null))
                                            }
                                    } else if ("candlestick" === this.renderingType) {
                                        i = t.map(function () {
                                            return []
                                        });
                                        for (var l = 0; l <= s - 1; l++)
                                            for (var u = 0; u <= e - 1; u++) {
                                                var c = t[u][l];
                                                null !== c ? i[u].push(a.valueToRelativeY(c)) : i[u].push(null)
                                            }
                                    } else {
                                        if ("normal" !== n) throw "stack.type unknown value: " + n;
                                        var S = 0,
                                            b = 0,
                                            C = 0;
                                        i = t.map(function () {
                                            return []
                                        });
                                        for (var l = 0; l <= s - 1; l++)
                                            for (var u = 0; u <= e - 1; u++) {
                                                var c = t[u][l];
                                                if (0 === u && (S = b = C = 0), null !== c) {
                                                    b += c;
                                                    var x = a.valueToRelativeY(b);
                                                    i[u].push(x - C), C = x
                                                } else i[u].push(null)
                                            }
                                    }
                                    this.ystackNegative = o, this.ystack = i
                                }
                            }, t.prototype.exportData = function (t, e) {
                                var i;
                                if (this.times && this.vstack) {
                                    for (var n = this.times, r = this.centers.length, s = 0; s < r && n[s + 1] <= t;) s++;
                                    for (var a = s; a < r && n[a + 1] < e;) a++;
                                    i = [];
                                    for (var o = 0; o < this.vstack.length; o++) {
                                        var l = this.vstack[o],
                                            h = this.countStack[o],
                                            u = 0,
                                            c = -(1 / 0),
                                            d = 1 / 0,
                                            p = null,
                                            f = null;
                                        r = 0;
                                        var g = this.series[o].data.aggregation,
                                            m = !1,
                                            v = !1;
                                        "sum" === g ? (m = !1, v = !0) : "avg" === g && (m = !0, v = !0);
                                        for (var y = s; y <= a; y++) {
                                            var S = l[y],
                                                b = 0 | h[y];
                                            null == S || isNaN(S) || (u += m ? S * b : S, c = Math.max(c, S), d = Math.min(d, S), null === p && (p = S), f = S, r += b)
                                        }
                                        r > 0 ? i.push({
                                            sum: u,
                                            max: c,
                                            min: d,
                                            first: p,
                                            last: f,
                                            count: r,
                                            avg: v ? u / r : null,
                                            change: f - p
                                        }) : i.push(null)
                                    }
                                } else i = this.series.map(function () {
                                    return null
                                });
                                for (var C = [], x = this.series.length - 1; x >= 0; x--) {
                                    var w = this.series[x];
                                    C.push({
                                        name: w.name || "",
                                        values: i[x],
                                        config: w
                                    })
                                }
                                return {
                                    name: this.options.name,
                                    stack: this,
                                    config: this.options,
                                    data: C
                                }
                            }, t
                        }();
                        t.Stack = e
                    }(i = t.Series || (t.Series = {}));
                var g = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e._computedValueAxisList = [], e._computedValueAxis = {}, e._computedSeries = [], e._computedStacks = {}, e.area = new F, e.legend = new s, e.valueAxisDefault = new u, e.valueAxis = {}, e.chartTypes = {
                            columns: {
                                type: "columns"
                            },
                            line: {
                                type: "line"
                            },
                            candlestick: {
                                type: "candlestick"
                            }
                        }, e.stacks = {}, e.seriesDefault = {
                            type: "columns"
                        }, e.series = [], e.info = new A, e.events = new m, e.interaction = new P, e.localization = new M, e.style = {
                            columnColors: ["#32CD32", "#36BEFF", "#FBBD30", "#EE3431", "#894BBC", "#0EC9AC", "#524BBC"],
                            lineColors: ["#32CD32", "#36BEFF", "#FBBD30", "#EE3431", "#894BBC", "#0EC9AC", "#524BBC"]
                        }, e
                    }
                    return n(e, t), e.addSeparateSeries = function (t, e, i, n, r, s, a) {
                        var o = d.Helpers.extendCopy({}, t);
                        o.stack = r, o.id = "series" + d.Helpers.SeparatorChar + s, o.name = e, o.data = {
                            aggregation: n,
                            index: i
                        }, o.style = t.style, a.push(o)
                    }, e._hasSeriesSettingsChanged = function (t) {
                        return t.series || t.chartTypes || t.seriesDefault || t.stacks || t.style
                    }, e.prototype.apply = function (i, n) {
                        var r = i.valueAxis;
                        if (r) {
                            var s = [{
                                from: "style.baseLineColor",
                                to: "style.baseLine.lineColor"
                            }, {
                                from: "style.baseLineWidth",
                                to: "style.baseLine.lineWidth"
                            }, {
                                from: "style.hgridLineColor",
                                to: "style.hgrid.lineColor"
                            }, {
                                from: "style.title.alignment",
                                to: "style.title.align"
                            }, {
                                from: "style.title.font",
                                to: "style.title.textStyle.font"
                            }, {
                                from: "style.title.fillColor",
                                to: "style.title.textStyle.fillColor"
                            }, {
                                from: "style.valueLabel.font",
                                to: "style.valueLabel.textStyle.font"
                            }, {
                                from: "style.valueLabel.fillColor",
                                to: "style.valueLabel.textStyle.fillColor"
                            }];
                            for (var a in r) this.applyCompatibility(r[a], s, "valueAxis[" + a + "]")
                        }
                        this.applyCompatibility(i, [{
                            from: "valueAxis.default",
                            to: "valueAxisDefault"
                        }, {
                            from: "valueAxisDefault.style.baseLineColor",
                            to: "valueAxisDefault.style.baseLine.lineColor"
                        }, {
                            from: "valueAxisDefault.style.baseLineWidth",
                            to: "valueAxisDefault.style.baseLine.lineWidth"
                        }, {
                            from: "valueAxisDefault.style.hgridLineColor",
                            to: "valueAxisDefault.style.hgrid.lineColor"
                        }, {
                            from: "valueAxisDefault.style.title.alignment",
                            to: "valueAxisDefault.style.title.align"
                        }, {
                            from: "valueAxisDefault.style.title.font",
                            to: "valueAxisDefault.style.title.textStyle.font"
                        }, {
                            from: "valueAxisDefault.style.title.fillColor",
                            to: "valueAxisDefault.style.title.textStyle.fillColor"
                        }, {
                            from: "valueAxisDefault.style.valueLabel.font",
                            to: "valueAxisDefault.style.valueLabel.textStyle.font"
                        }, {
                            from: "valueAxisDefault.style.valueLabel.fillColor",
                            to: "valueAxisDefault.style.valueLabel.textStyle.fillColor"
                        }]);
                        var o = t.prototype.apply.call(this, i);
                        if (this._initializing || e._hasSeriesSettingsChanged(o)) {
                            this._initializing && !o.series && (o.series = []);
                            var l = this.series,
                                h = [],
                                c = null,
                                p = 0;
                            this._computedStacks = d.Helpers.clone(this.stacks);
                            for (var f = 0; f < l.length; f++) {
                                var g = l[f];
                                if (!g.valueAxis || "default" === g.valueAxis || this.valueAxis[g.valueAxis])
                                    if (g.data && 0 === g.data.index) d.Helpers.error("Value `0` references the timestamp and cannot be used when specifying `series.data.index`.");
                                    else if (g.data && 0 === g.data.countIndex) d.Helpers.error("Value `0` references the timestamp and cannot be used when specifying `series.data.countIndex`.");
                                else if ("candlestick" !== g.type || g.data && g.data.index) h.push(g);
                                else {
                                    if (void 0 === g.stack || null === g.stack) {
                                        c = "default" + d.Helpers.SeparatorChar + p++;
                                        var m = new v;
                                        m.name = g.name, this._computedStacks[c] = m
                                    }
                                    var y = g.data;
                                    if (null == y || null == y.high || null == y.low || null == y.open || null == y.close) {
                                        d.Helpers.error("Each candlestick series should define four data properties: low, high, open, close");
                                        continue
                                    }
                                    var S = g.localization;
                                    S || (S = this.chartTypes.candlestick.localization), S || (S = (new w).localization), e.addSeparateSeries(g, S.high || "high", y.high, "max", c, p++, h), e.addSeparateSeries(g, S.open || "open", y.open, "first", c, p++, h), e.addSeparateSeries(g, S.close || "close", y.close, "last", c, p++, h), e.addSeparateSeries(g, S.low || "low", y.low, "min", c, p++, h)
                                } else d.Helpers.error("The series reference a non-existant value axis `" + g.valueAxis + "`.")
                            }
                            this._computedSeries = d.SettingsHelper.mergeDefaultValues(h, this.seriesDefault, this.chartTypes, n.createInstance, n.getMapping, "series"), this.applySeriesColor(this._computedSeries)
                        }
                        if (this._initializing || o.valueAxis || o.valueAxisDefault || !this._computedValueAxisList.length) {
                            this._initializing && !o.valueAxis && (o.valueAxis = {});
                            for (var b = !1, C = 0; C < this._computedSeries.length; C++) {
                                var x = this._computedSeries[C];
                                b = b || "default" === x.valueAxis
                            }
                            this._computedValueAxisList = [], this._computedValueAxis = {};
                            var L = this.valueAxisDefault;
                            for (var T in this.valueAxis) {
                                var k = new u,
                                    A = this.valueAxis[T];
                                this.applyCompatibility(A, [{
                                        from: "style.baseLineColor",
                                        to: "style.baseLine.lineColor"
                                    }, {
                                        from: "style.baseLineWidth",
                                        to: "style.baseLine.lineWidth"
                                    }, {
                                        from: "style.hgridLineColor",
                                        to: "style.hgrid.lineColor"
                                    }]), d.SettingsHelper.updateRecursive(k, L, d.SettingsMapping.LinearChartSettingsValueAxis, {}, "valueAxisDefault"), d.SettingsHelper.updateRecursive(k, A, d.SettingsMapping.LinearChartSettingsValueAxis, {}, "valueAxis[" + T + "]"),
                                    k.id = T, this._computedValueAxis[T] = k, this._computedValueAxisList.push(k)
                            }
                            if (b && !this.valueAxis.default) {
                                var M = d.Helpers.realClone(L);
                                M.id = "default", this._computedValueAxis[M.id] = M, this._computedValueAxisList.push(M)
                            }
                            this._computedValueAxisList.sort(function (t, e) {
                                return t.id.localeCompare(e.id)
                            })
                        }
                        return o
                    }, e.prototype.applySeriesColor = function (t) {
                        for (var e = 0, i = 0, n = this.style.columnColors, r = this.style.lineColors, s = 0; s < t.length; s++) {
                            var a = t[s];
                            "columns" === a.type && null == a.style.fillColor ? (a.style.fillColor = n[e], e = (e + 1) % n.length) : "line" === a.type && null == a.style.lineColor && (a.style.lineColor = r[i], i = (i + 1) % r.length)
                        }
                    }, e
                }(d.Settings);
                t.Settings = g;
                var m = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.onAnimationDone = null, e
                    }
                    return n(e, t), e
                }(d.SettingsEvents);
                t.SettingsEvents = m;
                var v = function () {
                    function t() {
                        this.name = "", this.type = "normal", this.separateNegativeValues = null
                    }
                    return t
                }();
                t.SettingsStack = v;
                var y = function () {
                    function t() {
                        this.id = null, this.enabled = !0, this.data = new b, this.type = "columns", this.valueAxis = "default", this.name = null, this.nameLegend = null, this.showInLegend = !0, this.legendGroupId = null, this.stack = null, this.cluster = null, this.style = new S
                    }
                    return t.getMapping = function (t, e) {
                        throw new Error("This method is abstract.")
                    }, t.createInstance = function (t, e) {
                        throw new Error("This method is abstract.")
                    }, t
                }();
                t.SettingsSeries = y;
                var S = function () {
                    function t() {
                        this.fillColor = null, this.lineColor = null, this.fillGradient = null, this.fillPattern = null, this._fillPatternOpacity = 1, this._currentFillStyleKey = null, this.lineDash = null, this.lineWidth = 1, this.shadowOffsetX = 1, this.shadowOffsetY = -1, this.shadowColor = null, this.legend = {
                            textColor: null,
                            marker: {
                                shape: null
                            }
                        }, this.depth = 0
                    }
                    return t
                }();
                t.SettingsSeriesStyle = S;
                var b = function () {
                    function t() {
                        this.source = "default", this.valueFunction = null, this.aggregation = "sum", this.aggregatedValueFunction = null, this.noDataPolicy = "join"
                    }
                    return t
                }();
                t.SettingsSeriesData = b;
                var C = function (t) {
                    function e() {
                        var e = t.call(this) || this;
                        return e.valueLabels = {
                            enabled: !1,
                            style: {
                                padding: 1,
                                margin: 0,
                                aspectRatio: 3,
                                align: "center",
                                textStyle: {
                                    fillColor: "black",
                                    font: "12px Arial"
                                },
                                backgroundStyle: {
                                    lineColor: "rgba(255,255,255,0.4)",
                                    fillColor: "rgba(255,255,255,0.4)"
                                }
                            },
                            position: "insideTopAuto",
                            minFontSize: 7,
                            contentsFunction: null,
                            useStackedValue: null
                        }, e.style = new L, e.type = "columns", e
                    }
                    return n(e, t), e
                }(y);
                t.SettingsSeriesColumns = C;
                var x = function (t) {
                    function e() {
                        var e = t.call(this) || this;
                        return e.valueLabels = {
                            enabled: !1,
                            style: {
                                padding: 2,
                                margin: 0,
                                aspectRatio: 3,
                                align: "center",
                                textStyle: {
                                    fillColor: "black",
                                    font: "12px Arial"
                                },
                                backgroundStyle: {
                                    lineColor: "rgba(255,255,255,0.4)",
                                    fillColor: "rgba(255,255,255,0.4)"
                                }
                            },
                            position: "value",
                            minFontSize: 7,
                            contentsFunction: null,
                            useStackedValue: null
                        }, e.style = new T, e.type = "line", e
                    }
                    return n(e, t), e
                }(y);
                t.SettingsSeriesLines = x;
                var w = function (t) {
                    function e() {
                        var e = t.call(this) || this;
                        return e.style = new k, e.localization = {
                            high: "high",
                            low: "low",
                            open: "open",
                            close: "close"
                        }, e.type = "candlestick", e
                    }
                    return n(e, t), e
                }(y);
                t.SettingsSeriesCandleStick = w;
                var L = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.minHeight = 4, e.gradient = .8, e.fillGradientMode = null, e.fillGradientType = null, e.lineColor = "", e.padding = [3, 3], e.shadowBlur = 3, e.depth = 0, e.depthBrightness = .5, e.radius = [0, 0, 0, 0], e
                    }
                    return n(e, t), e
                }(S);
                t.SettingsSeriesColumnsStyle = L;
                var T = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.shadowBlur = 5, e.smoothing = !1, e.steps = !1, e.marker = {
                            shape: null,
                            width: 10,
                            fillColor: null,
                            lineColor: null,
                            lineWidth: 1
                        }, e.markerStyleFunction = null, e
                    }
                    return n(e, t), e
                }(S);
                t.SettingsSeriesLinesStyle = T;
                var k = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.pattern = "candlestick", e.padding = [1, 1], e.increase = {
                            bar: {
                                lineColor: "green",
                                shadowColor: null,
                                lineDash: null,
                                lineWidth: 1,
                                shadowOffsetX: 1,
                                shadowOffsetY: -1,
                                shadowBlur: 0
                            },
                            candlestick: {
                                lineColor: "#000",
                                shadowColor: null,
                                lineDash: null,
                                lineWidth: 1,
                                shadowOffsetX: 1,
                                shadowOffsetY: -1,
                                shadowBlur: 0,
                                fillColor: "yellow"
                            }
                        }, e.decrease = {
                            bar: {
                                lineColor: "red",
                                shadowColor: null,
                                lineDash: null,
                                lineWidth: 1,
                                shadowOffsetX: 1,
                                shadowOffsetY: -1,
                                shadowBlur: 0
                            },
                            candlestick: {
                                lineColor: "#000",
                                shadowColor: null,
                                lineDash: null,
                                lineWidth: 1,
                                shadowOffsetX: 1,
                                shadowOffsetY: -1,
                                shadowBlur: 0,
                                fillColor: "black"
                            }
                        }, e
                    }
                    return n(e, t), e
                }(S);
                t.SettingsSeriesCandleStickStyle = k;
                var A = function () {
                    function t() {
                        this.enabled = !0, this.showNoData = !0, this.position = "inside", this.valueFormatterFunction = null, this.aggregations = null, this.style = {
                            highlight: {
                                fillColor: "rgba(30,160,220,0.15)",
                                fadeIn: 200,
                                fadeOut: 200
                            }
                        }, this.advanced = {
                            contentsFunction: null,
                            showOnlyHoveredSeries: !1,
                            scope: null,
                            showHeader: !0
                        }
                    }
                    return t
                }();
                t.SettingsInfoPopup = A;
                var M = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.valueUnits = {
                            K: 1e3,
                            M: 1e6,
                            B: 1e9,
                            T: 1e12,
                            P: 1e15
                        }, e.noDataLabel = "暂无数据", e.unnamedSeries = "Unnamed", e.toolbar = new I, e
                    }
                    return n(e, t), e
                }(d.SettingsLocalization);
                t.SettingsLocalization = M;
                var I = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.linButton = "Lin", e.logButton = "Log", e.linLogTitle = "Switch lin/log scale", e
                    }
                    return n(e, t), e
                }(d.SettingsLocalizationToolbar);
                t.SettingsLocalizationToolbar = I;
                var P = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.swipeSensitivity = .6, e.ignoreBottomAxis = !1, e.scrolling = new N, e.zooming = new D, e
                    }
                    return n(e, t), e
                }(d.SettingsInteraction);
                t.SettingsInteraction = P;
                var D = function () {
                    function t() {
                        this.enabled = !0, this.wheel = !1, this.swipe = !0, this.fingers = !0, this.fingersMaxZoom = 10, this.sensitivity = 2, this.wheelSensitivity = 1.5, this.keyboardFactor = 2, this.upDownTreshold = 10, this.zoomHighlightThreshold = 1.5
                    }
                    return t
                }();
                t.SettingsInteractionZooming = D;
                var N = function () {
                    function t() {
                        this.enabled = !0, this.swipePageFlipping = !0, this.keyboardScrollingFactor = 1, this.kineticFriction = 1e-6, this.maxAnimationLength = 1500
                    }
                    return t
                }();
                t.SettingsInteractionScrolling = N;
                var F = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.style = new O, e
                    }
                    return n(e, t), e
                }(d.SettingsArea);
                t.SettingsArea = F;
                var O = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.noData = {
                            fillColor: "#888",
                            image: null
                        }, e.zoomHighlight = {
                            fillColor: "rgba(30,160,220,0.15)",
                            fadeIn: 100,
                            fadeOut: 500
                        }, e.zoomHighlightInactive = {
                            fillColor: "rgba(30,160,220,0.08)"
                        }, e
                    }
                    return n(e, t), e
                }(d.SettingsAreaStyle);
                t.SettingsAreaStyle = O,
                    function (e) {
                        var i = function (t) {
                            function e(e, i) {
                                var n, r = e.settings.localization.toolbar;
                                i.title = i.title || r.linLogTitle, i.label = i.label || r.linButton, n = t.call(this, e, i) || this;
                                var s = (i.cssClass || "") + " DVSL-bar-btn DVSL-bar-btn-l";
                                return n.linClass = s + "in", n.logClass = s + "og", n.logScale = n.chart.scene.settings.valueAxisDefault.logScale, n.updateElements(), n
                            }
                            return n(e, t), e.prototype.onClick = function (e) {
                                this.chart.setLogScale(!this.chart.scene.settings.valueAxisDefault.logScale, "user"), t.prototype.onClick.call(this, e)
                            }, e.prototype.updateElements = function () {
                                var t = this.chart.settings.localization.toolbar,
                                    e = this.logScale;
                                this.a.className = e ? this.logClass : this.linClass, this.options.showLabel !== !1 && (this.p.innerHTML = e ? t.logButton : t.linButton)
                            }, e.prototype.onSceneChange = function (t) {
                                var e = this.chart.scene.settings.valueAxisDefault.logScale;
                                t.settings && e !== this.logScale && (this.logScale = e, this.updateElements())
                            }, e
                        }(d.Bar.Button);
                        e.LinLogButton = i, d.Bar.ToolbarItemNames.logScale = function (e, i) {
                            return new t.Bar.LinLogButton(e, i)
                        }
                    }(e = t.Bar || (t.Bar = {}));
                var E = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.enabled = !0, e.export = !0, e.back = !0, e.zoomOut = !0, e.logScale = !0, e
                    }
                    return n(e, t), e
                }(d.SettingsToolbar);
                t.SettingsToolbar = E;
                var R = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.animationOrder = 1e3, i.chart = null, i.scene = null, i.events = null, i.pointer1 = null, i.pointer2 = null, i.t1 = 0, i.t2 = 0, i.x1 = 0, i.x2 = 0, i.scaleOrigin = null, i.initialZoom = null, i.dragStartFrom = null, i.dragStartTo = null, i.active = !1, i.lastScrollingY = 0, i.scrollingActive = !1, i.scalingActive = 0, i.hadSecondPointer = !1, i.wheelOrigin = null, i.wheelProportion = null, i.highlight = null, i.highlightRemoveWhenDone = !1, i._animationsDone = !0, i.chart = e, i.scene = e.scene, i.events = e.events, i._settings = e.settings.interaction, i.inertiaF = new d.Inertia(1, 0, !0), i.inertiaT = new d.Inertia(1, 0, !0), i
                    }
                    return n(e, t), e.prototype.getVisibleRange = function () {
                        return this._currentTo - this._currentFrom
                    }, e.prototype.onZoomOut = function (t, e, i, n) {
                        return null == n && (n = 2), {
                            from: i - (i - t) * n,
                            to: i + (e - i) * n,
                            center: i
                        }
                    }, e.prototype.onZoomIn = function (t, e, i, n) {
                        return void 0 === n && (n = .5), null == n && (n = .5), {
                            from: i - (i - t) * n,
                            to: i + (e - i) * n,
                            center: i
                        }
                    }, e.prototype.onScroll = function (t, e, i) {
                        return "<" === i ? {
                            from: 2 * t - e,
                            to: t
                        } : {
                            from: e,
                            to: 2 * e - t
                        }
                    }, e.prototype.onGoHome = function (t, e) {
                        return {
                            from: t,
                            to: e,
                            origin: e
                        }
                    }, e.prototype.getFrom = function (t) {
                        return null == t || t === 1 / 0 ? this.inertiaF.getTargetValue() : this.inertiaF.getValue(t)
                    }, e.prototype.getTo = function (t) {
                        return null == t || t === 1 / 0 ? this.inertiaT.getTargetValue() : this.inertiaT.getValue(t)
                    }, e.prototype.setFrom = function (t, e, i, n) {
                        void 0 === e && (e = !1), void 0 === n && (n = !1), e ? (this.inertiaF.setTarget(t, i, void 0, n ? this._settings.scrolling.maxAnimationLength : null), this._animationsDone = !1) : (this._currentFrom = t, this.inertiaF.jump(t))
                    }, e.prototype.setTo = function (t, e, i, n) {
                        void 0 === e && (e = !1), void 0 === n && (n = !1), e ? (this.inertiaT.setTarget(t, i, void 0, n ? this._settings.scrolling.maxAnimationLength : null), this._animationsDone = !1) : (this._currentTo = t, this.inertiaT.jump(t))
                    }, e.prototype.onWheel = function (t) {
                        if (null === this.pointer1) {
                            var e = this.getFrom(),
                                i = this.getTo();
                            if (!(e >= i)) {
                                var n = this._settings;
                                if (n.zooming.wheel && n.zooming.enabled && this.xyInArea(t.x, t.y)) {
                                    this.active = !0;
                                    var r = this.wheelOrigin;
                                    null === r && (this.wheelOrigin = this.scaleOrigin = r = this.xyToPosition(t.x, t.y), this.wheelProportion = (r - e) / (i - e), this.x1 = t.x);
                                    var s = this.wheelProportion,
                                        a = Math.pow(Math.max(1.1, n.zooming.wheelSensitivity), .004 * t.wheely);
                                    e = r - (i - e) * s * a, i = r + (i - e) * (1 - s) * a;
                                    var o = t.wheely < 0 ? 1 : -1,
                                        l = d.Helpers.performanceNow();
                                    this.handleZoomWheel(e, i, r, l, o), t.consumed = !0, this.active = !1
                                }
                            }
                        }
                    }, e.prototype.onPointerDown = function (t) {
                        this.wheelOrigin = null;
                        var e = this._settings;
                        if (this.xyInArea(t.x, t.y) && (e.scrolling.enabled || e.zooming.enabled)) {
                            var i = this.xyToPosition(t.x, t.y),
                                n = d.Helpers.performanceNow(),
                                r = this.getFrom(n),
                                s = this.getTo(n);
                            if (r > s) {
                                var a = s;
                                s = r, r = a
                            }
                            null === this.pointer1 ? (this.pointer1 = t.identifier, this.x1 = t.x, this.t1 = i, this.scaleOrigin = i, this.onStartDragging(r, s, i), this.lastScrollingY = t.y, this.dragStartFrom = r, this.dragStartTo = s, this.dragCurFrom = r, this.dragCurTo = s, t.consumed = !0, this.inertiaF.finished(n) && this.inertiaT.finished(n) || (this.setFrom(r), this.setTo(s), this.stopAnimations(), this.scrollingActive = !0), this.chart.cancelChartUpdateNotify(), t.consumed = !0) : null === this.pointer2 ? (this.pointer2 = t.identifier, this.x2 = t.x, this.t2 = i, this.initialZoom = s - r, this.scaleOrigin = (this.t1 + this.t2) / 2, t.consumed = !0) : (this.scalingActive || this.scrollingActive) && (t.consumed = !0)
                        }
                    }, e.prototype.xyToDragPosition = function (t, e) {
                        return this.dragCurFrom + (t - this.scene.x0) / this.scene.width * (this.dragCurTo - this.dragCurFrom)
                    }, e.prototype.scaleViewRange = function (t, e, i) {
                        var n = Math.pow(1 + this._settings.zooming.sensitivity, -t.dy / this.scene.height);
                        return e = (e - this.scaleOrigin) * n + this.scaleOrigin, i = (i - this.scaleOrigin) * n + this.scaleOrigin, {
                            from: e,
                            to: i
                        }
                    }, e.prototype.onPointerMove = function (t) {
                        null !== this.wheelOrigin && Math.abs(this.x1 - t.x) > this._settings.zooming.sensitivity && (this.wheelOrigin = null)
                    }, e.prototype.onPointerDrag = function (t) {
                        var e = this.dragCurFrom,
                            i = this.dragCurTo,
                            n = this._settings;
                        if (t.identifier === this.pointer1 && null === this.pointer2) {
                            this.scaleOrigin = this.t1, this.x1 = t.x;
                            var r = t.y - this.lastScrollingY;
                            if (Math.abs(t.dx) > 4 * Math.abs(t.dy) && n.scrolling.enabled && (this.scrollingActive = !0), !this.hadSecondPointer && (n.zooming.enabled && n.zooming.swipe && Math.abs(r) > n.zooming.upDownTreshold ? this.scalingActive = r > 0 ? 1 : -1 : this.scalingActive = 0, this.scalingActive)) {
                                this.clearZoomHighlight();
                                var s = this.scaleViewRange(t, e, i);
                                e = s.from, i = s.to, t.consumed = !0
                            }
                            if (this.scrollingActive) {
                                var a = this.xyToDragPosition(t.x, t.y),
                                    o = this.t1 - a;
                                e += o, i += o
                            }
                        } else if (t.identifier === this.pointer1 && n.scrolling.enabled) {
                            this.x1 = t.x, this.clearZoomHighlight();
                            var l = this.twoPointerDrag();
                            e = l.from, i = l.to
                        } else {
                            if (t.identifier !== this.pointer2 || !n.scrolling.enabled) return void((this.scalingActive || this.scrollingActive) && (t.consumed = !0));
                            this.x2 = t.x, this.clearZoomHighlight();
                            var l = this.twoPointerDrag();
                            e = l.from, i = l.to
                        }
                        this.dragCurFrom = e, this.dragCurTo = i;
                        var h = this.onSnapWhileDragging(e, i, this.scaleOrigin, this.scrollingActive, this.scalingActive);
                        this.goToPositionDragging(h.from, h.to), t.consumed = !0
                    }, e.prototype.twoPointerDrag = function () {
                        var t = this._settings,
                            e = t.zooming.fingersMaxZoom;
                        this.scaleOrigin = (this.t1 + this.t2) / 2;
                        var i = this.t2 - this.t1,
                            n = this.dragCurFrom,
                            r = this.dragCurTo,
                            s = this.xyToDragPosition(this.x1, 0),
                            a = this.xyToDragPosition(this.x2, 0);
                        if (t.scrolling.enabled && t.zooming.enabled && t.zooming.fingers && 0 !== i) {
                            var o = this.initialZoom,
                                l = ((s + a) / 2 - this._currentFrom) / (this._currentTo - this._currentFrom),
                                h = (a - s) / (this._currentTo - this._currentFrom),
                                u = void 0;
                            u = i * h > 0 ? i / h : 1 / 0;
                            var c = o * e,
                                d = o / e;
                            u = Math.max(d, Math.min(c, u)), n = this.scaleOrigin - l * u, r = this.scaleOrigin + (1 - l) * u, this.scalingActive = u < o ? 1 : -1, this.scrollingActive = !0, this.hadSecondPointer = !0
                        } else if (t.scrolling.enabled) {
                            var p = (this.t1 + this.t2) / 2,
                                f = (s + a) / 2,
                                g = p - f;
                            n += g, r += g, this.scrollingActive = !0
                        }
                        return {
                            from: n,
                            to: r
                        }
                    }, e.prototype.onPointerUp = function (t) {
                        var e = this._settings,
                            i = d.Helpers.performanceNow(),
                            n = this.scrollingActive,
                            r = this.scalingActive;
                        if (t.identifier === this.pointer2) this.pointer2 = null, t.consumed = !0, this.scaleOrigin = this.t1;
                        else if (t.identifier === this.pointer1 && null !== this.pointer2) this.pointer1 = this.pointer2, this.pointer2 = null, this.t1 = this.t2, this.scaleOrigin = this.t1, t.consumed = !0;
                        else if (t.identifier === this.pointer1) {
                            this.pointer1 = null, this.active = !0;
                            var s = void 0,
                                a = void 0,
                                o = void 0;
                            if (e.scrolling.enabled) {
                                o = -t.vx, o = o > 0 ? Math.min(o, .002 * this.scene.width) : Math.max(o, .002 * -this.scene.width);
                                var l = this.getVisibleRange();
                                o = o * l / this.scene.width
                            } else o = 0;
                            if (this.updateFriction(i), this.inertiaF.jump(this._currentFrom, o, i), this.inertiaT.jump(this._currentTo, o, i), this._animationsDone = !1, e.scrolling.swipePageFlipping && t.swipeUp && this.scalingActive && t.swipeSpeed > this.scene.height / e.swipeSensitivity) {
                                var h = this.onZoomOut(this.dragStartFrom, this.dragStartTo, this.scaleOrigin);
                                s = h.from, a = h.to
                            } else if (e.scrolling.swipePageFlipping && t.swipeDown && this.scalingActive && t.swipeSpeed > this.scene.height / e.swipeSensitivity) {
                                var u = this.onZoomIn(this.dragStartFrom, this.dragStartTo, this.scaleOrigin);
                                s = u.from, a = u.to
                            } else if (n || r) {
                                if (n && !r && e.scrolling.swipePageFlipping && (t.swipeLeft || t.swipeRight) && t.swipeSpeed > this.scene.width / e.swipeSensitivity * .7) {
                                    var c = t.swipeLeft ? "<" : ">",
                                        p = this.onScroll(this.dragStartFrom, this.dragStartTo, c);
                                    s = p.from, a = p.to
                                } else s = this._currentFrom, a = this._currentTo;
                                this.scaleOrigin = (s + a) / 2
                            }
                            if (s || a) {
                                var f = this.onSnapAfterDragging(this.inertiaF.getTargetValue(), this.inertiaT.getTargetValue(), this.scaleOrigin, n || 0 !== r, r);
                                f && this.goToPosition(f.from, f.to, !0, i, !1), t.consumed = !0, this.scaleOrigin = null
                            }
                            this.hadSecondPointer = !1, this.active = !1, this.dragStartFrom = null, this.dragStartTo = null, this.scalingActive = 0, this.scrollingActive = !1
                        } else(r || n) && (t.consumed = !0)
                    }, e.prototype.onPointerCancel = function (t) {
                        t.identifier === this.pointer2 ? (this.pointer2 = null, this.scaleOrigin = this.t1) : t.identifier === this.pointer1 && null !== this.pointer2 ? (this.pointer1 = this.pointer2, this.t1 = this.t2, this.scaleOrigin = this.t1, this.pointer2 = null, this.t2 = null) : t.identifier === this.pointer1 && (this.active = !0, this.pointer1 = null, this.t1 = null, this.scaleOrigin = null, this.dragStartFrom = null, this.dragStartTo = null, this.scalingActive = 0, this.scrollingActive = !1, this.active = !1, this.hadSecondPointer = !1)
                    }, e.prototype.onKeyDown = function (t) {}, e.prototype.goToPositionDragging = function (t, e) {
                        this.setFrom(t), this.setTo(e), this.clearZoomHighlight(), this.onPositionChanged(t, e)
                    }, e.prototype.goToPosition = function (t, e, i, n, r) {
                        if (t < e)
                            if (this._currentFrom < this._currentTo || (i = !1), this.stopAnimations(), i) {
                                var s = this._settings.zooming.zoomHighlightThreshold,
                                    a = this._currentFrom,
                                    o = this._currentTo;
                                this.updateFriction(n, t, e), this.setFrom(t, !0, n, r), this.setTo(e, !0, n, r);
                                var l = Math.abs((t - e) / (a - o + 1));
                                if (l < 1 / s) this.setZoomHighlight(t, e, !0);
                                else if (l > s) {
                                    var h = null !== this.dragStartFrom ? this.dragStartFrom : a,
                                        u = null !== this.dragStartTo ? this.dragStartTo : o;
                                    this.setZoomHighlight(h, u, !1)
                                }
                                this.events.notifySceneChanges({
                                    requestPaint: !0
                                })
                            } else this.setFrom(t), this.setTo(e), this.clearZoomHighlight(), this.onPositionChanged(t, e), this.onAnimationDone(t, e), this._animationsDone = !0
                    }, e.prototype.doAnimations = function (t) {
                        if (!this._animationsDone) {
                            var e = t.timeStamp,
                                i = this.inertiaF.finished(e),
                                n = this.inertiaT.finished(e);
                            this._animationsDone = i && n;
                            var r = this._currentFrom = this.getFrom(e),
                                s = this._currentTo = this.getTo(e);
                            this._animationsDone || isNaN(r + s) ? (this.stopAnimations(), this.onPositionChanged(r, s, !1), this.onAnimationDone(r, s)) : (this.onPositionChanged(r, s, !0), t.animating = !0)
                        }
                    }, e.prototype.stopAnimations = function () {
                        this.highlight && (this.highlightRemoveWhenDone ? this.clearZoomHighlight() : (this.highlight.style.fillColor = this.scene.settings.area.style.zoomHighlightInactive.fillColor, this.events.notifySceneChanges({
                            highlight: !0
                        })))
                    }, e.prototype.abort = function () {
                        this.isActive() && (this.pointer2 && this.onPointerCancel({
                            identifier: this.pointer2
                        }), this.pointer1 && this.onPointerCancel({
                            identifier: this.pointer1
                        }), this.setFrom(this._currentFrom), this.setTo(this._currentTo), this.clearZoomHighlight(), this._animationsDone = !0)
                    }, e.prototype.isActive = function () {
                        return this.active || null != this.pointer1 || !this._animationsDone
                    }, e.prototype.clearZoomHighlight = function () {
                        this.highlight && (this.scene.removeHighlight("zoomTrace"), this.highlight = null, this.events.notifySceneChanges({
                            highlight: !0
                        }))
                    }, e.prototype.setZoomHighlight = function (t, e, i) {
                        this.highlight = this.scene.setHighlight("zoomTrace", t, e, this.scene.settings.area.style.zoomHighlight), this.highlightRemoveWhenDone = i, this.events.notifySceneChanges({
                            highlight: !0
                        })
                    }, e.prototype.updateFriction = function (t, e, i) {
                        var n = this.getVisibleRange();
                        if (null != e && null != i) {
                            var r = i - e,
                                s = .3,
                                a = n * (1 - s) > r,
                                o = n * (1 + s) < r;
                            o && (n = r), (a || o) && (n *= 2)
                        }
                        var l = n * this._settings.scrolling.kineticFriction;
                        this.inertiaF.setAcceleration(l, t), this.inertiaT.setAcceleration(l, t)
                    }, e
                }(d.ChartElement);
                t.Scrolling = R;
                var H = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.highlights = {}, e.seriesWithLabels = 0, e.dataLabels = {
                            spots: {},
                            fontWidths: Object.create(null),
                            metaData: {
                                availableWidth: 0,
                                processed: 0,
                                styles: null
                            }
                        }, e.bottomAxisSize = 0, e
                    }
                    return n(e, t), e.prototype.xyInChart = function (t, e) {
                        return t >= this.x0 && t < this.x0 + this.width && e >= this.y0 && e < this.y0 + this.height
                    }, e.prototype.xyInChartOrBottom = function (t, e) {
                        var i = this.settings.interaction.ignoreBottomAxis ? 0 : this.bottomAxisSize;
                        return t >= this.x0 && t < this.x0 + this.width && e >= this.y0 && e < this.y0 + this.height + i
                    }, e.prototype.xyInBottom = function (t, e) {
                        return !this.settings.interaction.ignoreBottomAxis && (t >= this.x0 && t < this.x0 + this.width && e >= this.y0 + this.height && e < this.y0 + this.height + this.bottomAxisSize)
                    }, e.prototype.timeToX = function (t) {
                        throw "Need to implement timeToX"
                    }, e.prototype.xToTime = function (t) {
                        throw "Need to implement xToTime"
                    }, e.prototype.setHighlight = function (t, e, i, n) {
                        var r = this.highlights[t];
                        return r ? (r.from = e, r.to = i, r.style = n, r.removed = !1) : (r = {
                            from: e,
                            to: i,
                            style: n,
                            removed: !1
                        }, this.highlights[t] = r), r
                    }, e.prototype.removeHighlight = function (t) {
                        var e = this.highlights[t];
                        e && (e.removed = !0, delete this.highlights[t])
                    }, e
                }(d.Scene);
                t.Scene = H;
                var B = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.animationOrder = 2e3, i.paintOrder = 45, i.updateOrder = 700, i.scene = null, i.customId = 0, i.animating = !1, i.highlights = {}, i.chart = e, i.scene = e.scene, i
                    }
                    return n(e, t), e.prototype.doAnimations = function (t) {
                        if (t.changes.highlight) {
                            var e = [];
                            for (var i in this.highlights) {
                                var n = this.highlights[i];
                                n.exiting = !0, n.origin.removed && (delete this.highlights[i], n.animator = null, e.push(n))
                            }
                            for (var r = 0; r < e.length; r++) {
                                var n = e[r];
                                this.highlights["__" + ++this.customId] = n
                            }
                            for (var i in this.scene.highlights) {
                                var s = this.scene.highlights[i];
                                if (this.highlights[i]) {
                                    var n = this.highlights[i];
                                    n.exiting = !1, n.from = s.from, n.to = s.to, n.style = d.Helpers.clone(s.style)
                                } else {
                                    var n = {
                                        from: s.from,
                                        to: s.to,
                                        style: d.Helpers.clone(s.style),
                                        animator: null,
                                        exiting: !1,
                                        origin: s
                                    };
                                    this.highlights[i] = n, s.style.fadeIn > 0 && (this.animating = !0, n.animator = new d.ColorAnimator(d.Colors.derive(d.Colors.parse(n.style.fillColor), 1, 0), n.style.fillColor, n.style.fadeIn, "=", t.timeStamp))
                                }
                            }
                            for (var i in this.highlights) {
                                var n = this.highlights[i];
                                if (n.exiting && !n.animator) {
                                    var a = n.style;
                                    a.fadeOut > 0 ? (this.animating = !0, n.animator = new d.ColorAnimator(a.fillColor, d.Colors.derive(d.Colors.parse(a.fillColor), 1, 0), a.fadeOut, "=", t.timeStamp)) : delete this.highlights[i]
                                }
                            }
                        }
                        if (this.animating) {
                            var o = !1,
                                l = t.timeStamp;
                            for (var i in this.highlights) {
                                var n = this.highlights[i];
                                n.animator && (n.style.fillColor = n.animator.get(l), n.animator.finished(l) ? (n.animator = null, n.exiting && delete this.highlights[i]) : o = !0)
                            }
                            this.animating = o, t.animating = t.animating || o
                        }
                    }, e.prototype.paintScene = function (t) {
                        var e = this.scene.x0,
                            i = e + this.scene.width,
                            n = Math.round(this.scene.y0),
                            r = this.scene.height,
                            s = t.context;
                        for (var a in this.highlights) {
                            var o = this.highlights[a],
                                l = Math.max(this.scene.timeToX(o.from), e),
                                h = Math.min(this.scene.timeToX(o.to), i);
                            h < e || l > i || (d.Graphics.rectStyle(s, o.style), s.fillRect(l, n, h - l, r))
                        }
                    }, e
                }(d.ChartElement);
                t.Highlights = B;
                var z = function (t) {
                    function e(e) {
                        var i = t.call(this, e) || this;
                        return i.rightAxis = null, i.leftAxis = null, i.timeAxisPanel = null, i
                    }
                    return n(e, t), e.prototype.createDom = function (e) {
                        t.prototype.createDom.call(this, e), this.timeAxisPanel = d.Helpers.createDom("div", "DVSL-TC-timeAxis", null, this.backgroundContainer), d.DomLayer.setContainerStyle(this.timeAxisPanel), this.leftAxis = d.Helpers.createDom("div", "DVSL-valueAxis", null, this.backgroundContainer), d.DomLayer.setContainerStyle(this.leftAxis), this.rightAxis = d.Helpers.createDom("div", "DVSL-valueAxis", null, this.backgroundContainer), d.DomLayer.setContainerStyle(this.rightAxis)
                    }, e.prototype.doAnimations = function (e) {
                        t.prototype.doAnimations.call(this, e), e.changes.bounds && (this.background.style.left = this.scene.x0 + "px", this.background.style.right = this.scene.chartWidth - (this.scene.x0 + this.scene.width) + "px", this.leftAxis.style.width = this.scene.leftMargin + "px", this.leftAxis.style.bottom = this.scene.bottomMargin + "px", this.rightAxis.style.width = this.scene.rightMargin + "px", this.rightAxis.style.bottom = this.scene.bottomMargin + "px", this.timeAxisPanel.style.top = this.scene.y0 + this.scene.height + "px", this.timeAxisPanel.style.left = this.scene.x0 + "px", this.timeAxisPanel.style.width = this.scene.width + "px", this.outerBorder.style.left = this.scene.x0 + "px", this.outerBorder.style.width = this.scene.width + "px")
                    }, e
                }(d.DomLayer);
                t.DomLayer = z;
                var U = function (t) {
                    function e(e, i, n) {
                        var r = t.call(this, e, i, n) || this;
                        return r.scrolling = null, r.renderer = null, r
                    }
                    return n(e, t), e.prototype.createDomLayer = function () {
                        return new z(this)
                    }, e.prototype.notifyAnimationDone = function () {
                        var t = this;
                        window.setTimeout(function () {
                            t.removed || t.dispatchEventParams("animationDone", t.createEventArguments(null, "api"), null)
                        }, 0)
                    }, e.prototype.processChangedSettings = function (t) {
                        var e = t.settingsChanges;
                        e && (g._hasSeriesSettingsChanged(e) && (t.linearChartSeries = !0), (e.valueAxis || e.valueAxisDefault) && (t.linearChartValueAxis = !0))
                    }, e.prototype.updateSettings = function (e, i) {
                        t.prototype.updateSettings.call(this, e, i)
                    }, e.prototype.setLogScale = function (t, e) {
                        var i = {};
                        for (var n in this.settings.valueAxis) i[n] = {
                            logScale: t
                        };
                        this.updateSettings({
                            valueAxisDefault: {
                                logScale: t
                            },
                            valueAxis: i
                        }, e)
                    }, e.prototype.finalInitialize = function () {
                        t.prototype.finalInitialize.call(this), this.legend = this.events.addElement(new h(this))
                    }, e.prototype.getEnabledSeries = function () {
                        for (var t = [], e = this.settings._computedSeries, i = 0, n = e.length; i < n; i++) e[i].enabled && t.push(e[i]);
                        return t
                    }, e.prototype.getSeries = function () {
                        for (var t = [], e = this.settings._computedSeries, i = 0, n = e.length; i < n; i++) t.push(e[i]);
                        return t
                    }, e
                }(d.Impl);
                t.Impl = U;
                var G = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.animationOrder = 10, i.t0 = 0, i.t1 = 0, i.object = null, i.activePointer = null, i.pointerX = 0, i.pointerY = 0, i.chart = e, i.container = e.shell.interactiveContainer, i.scene = e.scene, i.events = e.events, i.popup = new d.InfoPopup(i.chart), i.settings = e.scene.settings.info, i
                    }
                    return n(e, t), e.prototype.getPopupAreaMouseMoved = function (t, e) {
                        return null
                    }, e.prototype.buildHeader = function (t, e) {
                        return ""
                    }, e.prototype.show = function (t) {
                        this.settings.enabled && (this.pointerX = t.x, this.pointerY = t.y, this.updatePopup(t))
                    }, e.prototype.previewPointerMove = function (t) {
                        !this.settings.enabled || null !== this.activePointer && this.activePointer !== t.identifier || (this.pointerX = t.x, this.pointerY = t.y, this.updatePopup(t))
                    }, e.prototype.previewPointerDrag = function (t) {
                        !this.settings.enabled || null !== this.activePointer && this.activePointer !== t.identifier || (this.activePointer = t.identifier, this.pointerX = t.x, this.pointerY = t.y)
                    }, e.prototype.previewPointerCancel = function (t) {
                        null !== this.activePointer && this.activePointer === t.identifier && (this.activePointer = null)
                    }, e.prototype.previewPointerUp = function (t) {
                        null !== this.activePointer && this.activePointer === t.identifier && (this.activePointer = null)
                    }, e.prototype.previewPointerOut = function (t) {
                        !this.settings.enabled || null !== this.activePointer && this.activePointer !== t.identifier || t.touch || (this.activePointer = null, this.pointerX = null, this.pointerY = null, d.Helpers.isParentOf(this.popup.popup, t.target) || this.hideInfoPopup(t))
                    }, e.prototype.previewRightClick = function (t) {
                        this.settings.enabled && t.touch && (this.activePointer = t.identifier, this.previewPointerMove(t))
                    }, e.prototype.previewPointerDown = function (t) {
                        this.settings.enabled && null === this.activePointer && (this.activePointer = t.identifier, this.hideInfoPopup(t))
                    }, e.prototype.updatePopup = function (t) {
                        if (!this.pointerX && !this.pointerY) return void this.hideInfoPopup(t);
                        var e = this.getPopupMouseMoved(this.pointerX, this.pointerY, this.t0, this.t1, this.object, this.contents);
                        e ? this.showInfoPopup(e.t0, e.t1, e.obj, e.contents, t) : this.hideInfoPopup(t)
                    }, e.prototype.manualShowInfoPopup = function (t, e, i) {
                        this.showInfoPopup(t, e, null, i || this.buildContent(t, e, null, null), null)
                    }, e.prototype.showInfoPopup = function (t, e, i, n, r) {
                        if (!this.popup.visible || t !== this.t0 || e !== this.t1 || i !== this.object || this.contents !== n) {
                            var s = this.scene,
                                a = this.settings;
                            this.t0 = t, this.t1 = e, this.object = i, this.contents = n, s.setHighlight("infoRange", t, e, a.style.highlight), this.popup.show(s.timeToX(this.t0), s.timeToX(this.t1), s.y0, n, d.InfoPopupPosition[a.position]), this.notifyChanges(r)
                        }
                    }, e.prototype.notifyChanges = function (t) {
                        t ? (t.changes.infoLabel = !0, t.changes.highlight = !0) : this.events.notifySceneChanges({
                            infoLabel: !0,
                            highlight: !0
                        })
                    }, e.prototype.hideInfoPopup = function (t) {
                        this.popup.visible && (this.popup.hide(), this.t0 = 0, this.t1 = 0, this.scene.removeHighlight("infoRange"), this.notifyChanges(t))
                    }, e.prototype.paintScene = function (t) {
                        this.popup.visible && this.updateXY()
                    }, e.prototype.updateXY = function () {
                        var t = this.scene;
                        this.popup.updateXY(t.timeToX(this.t0), t.timeToX(this.t1), t.y0, d.InfoPopupPosition[t.settings.info.position])
                    }, e.prototype.getPopupMouseMoved = function (t, e, i, n, r, s) {
                        if (this.scene.displayUnit && !this.scene.xyInChartOrBottom(t, e)) return null;
                        var a = this.getPopupAreaMouseMoved(t, e);
                        if (!a) return null;
                        var o = a.t0,
                            l = a.t1,
                            h = null,
                            u = null,
                            c = this.scene.hoverSeriesItem,
                            d = this.settings.advanced.scope,
                            p = o,
                            f = l;
                        if (c && (u = c.seriesIndex, ("stack" === d || "value" === d || "auto" === d && void 0 !== u && null !== u) && (p = this.scene.xToTime(c.x0), f = this.scene.xToTime(c.x1)), h = c.stack), null === p) return null;
                        if (p === i && f === n && u === r) return {
                            t0: i,
                            t1: n,
                            obj: r,
                            contents: s
                        };
                        var g = this.buildContent(o, l, u, h);
                        return {
                            t0: p,
                            t1: f,
                            obj: u,
                            contents: g
                        }
                    }, e.prototype.getContentsFunctionRange = function (t, e) {
                        return [t, e]
                    }, e.prototype.buildContent = function (t, e, i, n) {
                        var r, s = this.settings.advanced,
                            a = this.chart.renderer.exportData(t, e);
                        if (s.contentsFunction) {
                            var o = null;
                            null !== i && this.scene.settings._computedSeries.length > i && (o = this.scene.settings._computedSeries[i]), r = s.contentsFunction.call(this.chart.api, a, o, this.getContentsFunctionRange(t, e))
                        } else r = this.buildValues(a, i, n);
                        if (!s.showHeader) return r;
                        var l = this.buildHeader(t, e);
                        return l + r
                    }, e.prototype.buildValues = function (t, e, i) {
                        var n = this.chart.settings,
                            r = {},
                            s = 0;
                        for (var a in n.valueAxis)
                            if (n.valueAxis[a].valueFormat) {
                                var o = d.Helpers.matchPercentFormat(n.valueAxis[a].valueFormat);
                                r[a] = o, s++
                            }
                        var l = void 0;
                        n.valueAxisDefault && n.valueAxisDefault.valueFormat && (l = d.Helpers.matchPercentFormat(n.valueAxisDefault.valueFormat));
                        var h = {},
                            u = 0;
                        for (var a in n.valueAxis)
                            if (n.valueAxis[a].valueFormat) {
                                var o = d.Helpers.matchCurrencyFormat(n.valueAxis[a].valueFormat);
                                h[a] = o, u++
                            }
                        var c = void 0;
                        n.valueAxisDefault && n.valueAxisDefault.valueFormat && (c = d.Helpers.matchCurrencyFormat(n.valueAxisDefault.valueFormat));
                        for (var p = n.localization.noDataLabel, f = n.info.valueFormatterFunction, g = n.info.advanced.showOnlyHoveredSeries ? n.info.advanced.scope : null, m = i && ("stack" === g || "value" === g) || "auto" === g && void 0 !== e && null !== e, v = "value" === g, y = "", S = !1, b = 0; b < t.length; b++) {
                            var x = t[b];
                            if (m) {
                                for (var w = !1, L = 0; L < x.data.length; L++) {
                                    var T = x.data[L];
                                    T.config.showInLegend && (T.values || n.info.showNoData) && (w = w || null !== e && T.config === n._computedSeries[e] || i === x.stack)
                                }
                                if (!w) continue
                            }
                            var k = t.length + x.data.length === 2 ? "" : n.localization.unnamedSeries;
                            x.name && (S && (y += "</table>", S = !1), x.data.length > 1 ? y += "<h3>" + x.name + "</h3>" : k = x.name), S || (y += '<table cellspacing="0">', S = !0);
                            for (var L = 0; L < x.data.length; L++) {
                                var T = x.data[L],
                                    A = null !== e && T.config === this.scene.settings._computedSeries[e];
                                if (T.config.showInLegend && (T.values || n.info.showNoData) && (!v || A)) {
                                    y += "<tr><td";
                                    var M = void 0,
                                        I = void 0,
                                        P = T.config;
                                    if (n instanceof C ? (M = P.style.fillColor, I = P.style.lineColor) : (M = P.style.lineColor, I = P.style.fillColor), M && "transparent" !== M || (M = I), M && (y += ' data-color="' + M + '"'), A && (y += " data-selected"), y += ">", y += T.name || k, y += "</td><td>", f) y += f.call(this.chart.api, T.values, T.config);
                                    else if (s > 0 || l || u > 0 || c)
                                        if (T.values) {
                                            var D = P.data.aggregation ? T.values[P.data.aggregation] : T.values.sum;
                                            y += r[T.config.valueAxis] ? d.Helpers.printPercentValue(D, r[T.config.valueAxis]) : l ? d.Helpers.printPercentValue(D, l) : h[T.config.valueAxis] ? d.Helpers.printCurrencyValue(D, h[T.config.valueAxis]) : c ? d.Helpers.printPercentValue(D, c) : d.Helpers.numberFormat(D)
                                        } else y += n.localization.noDataLabel;
                                    else if (T.values)
                                        if (T.values.count > 1 && n.info.aggregations && n.info.aggregations.length > 0)
                                            for (var N = 0; N < n.info.aggregations.length; N++) {
                                                var F = n.info.aggregations[N];
                                                y += "" + d.Helpers.numberFormat(T.values[F]) + ("&nbsp;(" + F + ")")
                                            } else y += P.data.aggregation ? d.Helpers.numberFormat(T.values[P.data.aggregation]) : d.Helpers.numberFormat(T.values.sum);
                                        else y += p;
                                    y += "</td></tr>"
                                }
                            }
                        }
                        return S && (y += "</table>"), y
                    }, e.prototype.remove = function () {
                        this.popup.remove()
                    }, e
                }(d.ChartElement);
                t.InfoPopup = G;
                var j = function () {
                    function t(t, e) {
                        if (this.axisConfigList = e, this.chart = t, this.axis = Object.create(null), 0 !== e.length)
                            for (var i = !1, n = 0; n < e.length; n++) {
                                var r = e[n];
                                this.axis[r.id] = new p(t, r), !i && r.enabled && (i = !0, this.axis[r.id].isPrimary = !0)
                            }
                    }
                    return t.prototype.getAxis = function (t) {
                        return this.axis[t]
                    }, t.prototype.getPanels = function (t) {
                        for (var e = [], i = 0; i < this.axisConfigList.length; i++) {
                            var n = this.axisConfigList[i],
                                r = this.axis[n.id].getPanel();
                            (r || t) && e.push(r)
                        }
                        return e
                    }, t.prototype.setPanels = function (t) {
                        for (var e = 0; e < this.axisConfigList.length; e++) {
                            var i = this.axisConfigList[e];
                            this.axis[i.id].setPanel(t[e])
                        }
                    }, t.prototype.updateMinMax = function (t) {
                        for (var e in this.axis) this.axis[e].updateMinMax(t)
                    }, t.prototype.doAnimations = function (t) {
                        for (var e in this.axis) this.axis[e].doAnimations(t)
                    }, t.prototype.paintUnder = function (t) {
                        for (var e in this.axis) this.axis[e].paintUnder(t)
                    }, t.prototype.paint = function (t) {
                        for (var e in this.axis) this.axis[e].paint(t)
                    }, t
                }();
                t.ValueAxisSet = j,
                    function (t) {
                        var e = function () {
                            function e(t, e) {
                                this.stacks = [], this.idToStack = {}, this.paddingSum = 0, this.scene = e, this.chart = t
                            }
                            return e.prototype.addSeries = function (e, i, n, r) {
                                var s;
                                if (i.stack) {
                                    var a = i.stack + "#" + i.type;
                                    s = this.idToStack[a], s || (s = this.idToStack[a] = new t.Stack(this.chart, this.scene, this, n, r), this.stacks.push(s))
                                } else s = new t.Stack(this.chart, this.scene, this, n, r), this.stacks.push(s);
                                s.addSeries(e, i)
                            }, e.prototype.afterInit = function () {
                                for (var t = 0; t < this.stacks.length; t++) {
                                    var e = this.stacks[t];
                                    e.afterInit()
                                }
                            }, e.prototype.process = function (t) {
                                for (var e = 0; e < this.stacks.length; e++) {
                                    var i = this.stacks[e];
                                    i.process(t)
                                }
                            }, e.prototype.afterProcess = function () {
                                for (var t = 0; t < this.stacks.length; t++) {
                                    var e = this.stacks[t];
                                    e.afterProcess()
                                }
                            }, e.prototype.paint = function (t, e) {
                                for (var i = 0; i < this.stacks.length; i++) {
                                    var n = this.stacks[i];
                                    n.paint(t, e)
                                }
                            }, e.prototype.hitTestStack = function (t, e) {
                                for (var i = null, n = 1 / 0, r = 0; r < this.stacks.length; r++) {
                                    var s = this.stacks[r],
                                        a = s.hitTestStack(t, e),
                                        o = a.result,
                                        l = a.distance;
                                    l < n && (n = l, i = o)
                                }
                                return {
                                    result: i,
                                    distance: n
                                }
                            }, e.prototype.hitTest = function (t, e, i) {
                                for (var n = null, r = 1 / 0, s = 0; s < this.stacks.length; s++) {
                                    var a = this.stacks[s],
                                        o = a.hitTest(t, e, i),
                                        l = o.result,
                                        h = o.distance;
                                    h < r && (r = h, n = l)
                                }
                                return {
                                    result: n,
                                    distance: r
                                }
                            }, e.prototype.exportData = function (t, e, i) {
                                for (var n = 0; n < this.stacks.length; n++) {
                                    var r = this.stacks[n];
                                    i.push(r.exportData(t, e))
                                }
                            }, e.prototype.computeStackCenterRadius = function (t, e, i, n) {
                                if (!(e.length < 2)) {
                                    for (var r = this.stacks.length, s = this.stacks.indexOf(t), a = (s + .5) / r, o = .5 / r, l = 0, h = 0, u = 0; u < this.stacks.length; u++) {
                                        var c = this.stacks[u];
                                        l += c.paddingLeft + c.paddingRight
                                    }
                                    for (var u = 0; u < this.stacks.length; u++) {
                                        var c = this.stacks[u];
                                        if (h += c.paddingLeft, c === t) break;
                                        h += c.paddingRight
                                    }
                                    var d = e[1] - e[0];
                                    l > d / 2 && (l = d / 2, h = h / d * (d - l));
                                    for (var u = 0; u < e.length - 1; u++) {
                                        var p = e[u],
                                            f = e[u + 1] - p - l;
                                        i[u] = p + f * a + h, n[u] = f * o
                                    }
                                }
                            }, e
                        }();
                        t.Cluster = e
                    }(i = t.Series || (t.Series = {}));
                var W = function () {
                    function t(t, e) {
                        this.valueAxisSet = e, this.chart = t, this.scene = this.chart.scene, this.clusters = [], this.buildSeries()
                    }
                    return t.prototype.buildSeries = function () {
                        this.clusters = [];
                        for (var t = {}, e = null, n = {}, r = new v, s = this.scene.settings, a = 0; a < s._computedSeries.length; a++) {
                            var o = s._computedSeries[a];
                            if (o.enabled) {
                                var l = void 0;
                                o.cluster ? (l = t[o.cluster], l || (l = t[o.cluster] = new i.Cluster(this.chart, this.scene), this.clusters.push(l))) : "line" === o.type ? o.stack ? n.hasOwnProperty(o.stack) ? l = n[o.stack] : (l = n[o.stack] = new i.Cluster(this.chart, this.scene), this.clusters.push(l)) : (l = new i.Cluster(this.chart, this.scene), this.clusters.push(l)) : (e || (e = new i.Cluster(this.chart, this.scene), this.clusters.push(e)), l = e);
                                var h = s._computedStacks[o.stack] || r;
                                l.addSeries(a, o, h, this.valueAxisSet.getAxis(o.valueAxis))
                            }
                        }
                        for (var u = 0; u < this.clusters.length; u++) {
                            var l = this.clusters[u];
                            l.afterInit()
                        }
                    }, t.prototype.process = function (t) {
                        for (var e = 0; e < this.clusters.length; e++) {
                            var i = this.clusters[e];
                            i.process(t)
                        }
                    }, t.prototype.afterProcess = function () {
                        for (var t = 0; t < this.clusters.length; t++) {
                            var e = this.clusters[t];
                            e.afterProcess()
                        }
                    }, t.prototype.paint = function (t) {
                        var e = t.context;
                        this.scene.seriesWithLabels = 0;
                        for (var i = 0; i < this.clusters.length; i++)
                            for (var n = this.clusters[i], r = 0; r < n.stacks.length; r++)
                                for (var s = n.stacks[r].series, a = 0; a < s.length; a++) {
                                    var o = s[a];
                                    o.valueLabels && o.valueLabels.enabled && this.scene.seriesWithLabels++
                                }
                        for (var l = 0; l < this.clusters.length; l++) {
                            var h = this.clusters[l];
                            h.paint(t, e)
                        }
                    }, t.prototype.hitTest = function (t, e, i) {
                        void 0 === i && (i = 4);
                        for (var n = null, r = 1 / 0, s = 0; s < this.clusters.length; s++) {
                            var a = this.clusters[s],
                                o = a.hitTest(t, e, i),
                                l = o.result,
                                h = o.distance;
                            h < r && (n = l, r = h)
                        }
                        if (r > i) {
                            r = 1 / 0, n = null;
                            for (var s = 0; s < this.clusters.length; s++) {
                                var a = this.clusters[s],
                                    u = a.hitTestStack(t, e),
                                    l = u.result,
                                    h = u.distance;
                                h < r && (n = l, r = h)
                            }
                        }
                        return n
                    }, t.prototype.exportData = function (t, e) {
                        for (var i = [], n = 0; n < this.clusters.length; n++) {
                            var r = this.clusters[n];
                            r.exportData(t, e, i)
                        }
                        return i
                    }, t
                }();
                t.Renderer = W
            }(l = i.LinearChart || (i.LinearChart = {})),
            function (t) {
                var e = t.Bar || (t.Bar = {}),
                    i = 864e5,
                    r = function () {
                        function e(t, i, n) {
                            this.count = i;
                            var r = e.parsingMap[t];
                            if (!r) throw new Error("Time unit `" + t + "` is not recognized.");
                            this.unit = r, this.name = void 0 === n ? i + " " + r : n
                        }
                        return e.isGoodUnit = function (t) {
                            return e.parsingMap.hasOwnProperty(t)
                        }, e.parse = function (t, i, n) {
                            if (void 0 === n && (n = !0), null == t) return null;
                            if (d.Helpers.isString(t)) {
                                var r = 1,
                                    s = void 0,
                                    a = t.split(" ");
                                if (2 === a.length) {
                                    if (r = d.Helpers.tryParseFloat(a[0], null), null === r || (0 | r) !== r) {
                                        if (n) throw new Error("Cannot parse the time unit - the correct format is `1 s`: " + t);
                                        return null
                                    }
                                    s = a[1]
                                } else {
                                    if (1 !== a.length) {
                                        if (n) throw new Error("Cannot parse the time unit - the correct format is `1 s`: " + t);
                                        return null
                                    }
                                    r = 1, s = a[0]
                                }
                                if (!this.isGoodUnit(s)) {
                                    if (n) throw new Error("Cannot parse the time unit - unrecognized time unit: " + t);
                                    return null
                                }
                                return new e(s, r, i || t)
                            }
                            if (t instanceof e) return t;
                            if (n) throw new Error("Cannot parse the unit text because it is not a string: " + t);
                            return null
                        }, e.prototype.clone = function () {
                            return new e(this.unit, this.count, this.name)
                        }, e.prototype.add = function (t, e) {
                            void 0 === e && (e = 1);
                            var n = this.unit,
                                r = this.count * e;
                            if ("ms" === n) t += r;
                            else if ("s" === n) t += 1e3 * r;
                            else if ("m" === n) t += 6e4 * r;
                            else if ("h" === n) t += 36e5 * r;
                            else if ("d" === n) t += r * i;
                            else if ("w" === n) t += r * i * 7;
                            else {
                                var s = new Date(t);
                                "y" === n ? s.setUTCFullYear(s.getUTCFullYear() + r) : "M" === n && s.setUTCMonth(s.getUTCMonth() + r), t = s.getTime()
                            }
                            return t
                        }, e.prototype.sub = function (t, e) {
                            return void 0 === e && (e = 1), this.add(t, -1 * e)
                        }, e.prototype.numberOfUnits = function (i, n) {
                            return Math.round(t.moment(n).utc().diff(t.moment(i).utc(), e.unitsTranslation[this.unit], !0) / this.count)
                        }, e.prototype.toShortString = function () {
                            return 1 === this.count ? this.unit : this.toString()
                        }, e.prototype.toString = function () {
                            return this.count + " " + this.unit
                        }, e.prototype.approxTime = function () {
                            return e.timeUnitDiffs[this.unit] * this.count
                        }, e.prototype.isSmallerOrEqual = function (t) {
                            return this.approxTime() <= t.approxTime()
                        }, e.prototype.isSmaller = function (t) {
                            return this.approxTime() < t.approxTime()
                        }, e.prototype.isBigger = function (t) {
                            return this.approxTime() > t.approxTime()
                        }, e.prototype.isEqual = function (t) {
                            return !!t && this.approxTime() === t.approxTime()
                        }, e.prototype.getBigger = function () {
                            return "y" === this.unit ? new e(this.unit, 10 * this.count) : new e(e.toBiggerUnit[this.unit], 1)
                        }, e.prototype.roundTimeDown = function (t, e) {
                            if (null == t) return null;
                            t = Math.round(t);
                            var n = this.count,
                                r = this.unit;
                            if ("ms" === r) return Math.floor(t / n) * n;
                            if ("s" === r) return Math.floor(t / 1e3 / n) * n * 1e3;
                            if ("m" === r) return Math.floor(t / 6e4 / n) * n * 6e4;
                            if ("h" === r) return Math.floor(t / 36e5 / n) * n * 36e5;
                            if ("d" === r) {
                                if (n % 7 !== 0) return Math.floor(t / i / n) * n * i;
                                r = "w", n /= 7
                            }
                            if ("w" === r) {
                                var s = e.week.dow + 3,
                                    a = t;
                                return t = (t / i - s) / 7 + 1, t = (Math.floor(t / n) * n * 7 + s) * i, t > a && (t -= 7 * i), t
                            }
                            var o = new Date(Math.floor(t / i) * i);
                            if ("y" === r) return o.setUTCFullYear(Math.floor(o.getUTCFullYear() / n) * n, 0, 1), o.getTime();
                            if ("M" === r) {
                                var l = 12 * o.getUTCFullYear() + o.getUTCMonth();
                                return o.setUTCMonth(o.getUTCMonth() + Math.floor(l / n) * n - l, 1), o.getTime()
                            }
                            throw new Error("Unrecognized unit: `" + this.unit + "`")
                        }, e.prototype.roundTimeUp = function (t, e) {
                            return null == t ? null : this.roundTimeDown(this.add(t) - 1, e)
                        }, e.prototype.roundTimeRound = function (t, e) {
                            return null == t ? null : this.roundTimeDown((this.add(t) + t - 1) / 2, e)
                        }, e.prototype.isMultipleOf = function (t) {
                            var e = this.unit,
                                i = t.unit,
                                n = this.approxTime(),
                                r = t.approxTime(),
                                s = n / r;
                            if (s < 1 || (0 | s) !== s) return !1;
                            if (e === i) return !0;
                            if (1 === t.count && "w" !== i) return !0;
                            var a = 864e5,
                                o = a / r;
                            return o >= 1 && (0 | o) === o || ("y" === e ? "M" === i : "M" !== e && "w" !== e)
                        }, e
                    }();
                r.parsingMap = {
                        milliseconds: "ms",
                        millisecond: "ms",
                        sec: "s",
                        second: "s",
                        seconds: "s",
                        min: "m",
                        minute: "m",
                        minutes: "m",
                        hour: "h",
                        hours: "h",
                        day: "d",
                        days: "d",
                        week: "w",
                        weeks: "w",
                        mon: "M",
                        month: "M",
                        months: "M",
                        year: "y",
                        years: "y",
                        ms: "ms",
                        s: "s",
                        m: "m",
                        h: "h",
                        d: "d",
                        D: "d",
                        w: "w",
                        W: "w",
                        M: "M",
                        y: "y",
                        Y: "y"
                    }, r.knownUnits = ["ms", "s", "m", "h", "d", "w", "M", "y"], r.timeUnitDiffs = {
                        ms: 1,
                        s: 1e3,
                        m: 6e4,
                        h: 36e5,
                        d: 864e5,
                        w: 6048e5,
                        M: 2592e6,
                        y: 31104e6
                    }, r.unitsTranslation = {
                        ms: "millisecond",
                        s: "second",
                        m: "minute",
                        h: "hour",
                        d: "day",
                        w: "week",
                        M: "month",
                        y: "year"
                    }, r.toBiggerUnit = {
                        ms: "s",
                        s: "m",
                        m: "h",
                        h: "d",
                        d: "w",
                        w: "M",
                        M: "y",
                        y: null
                    }, r.toSmallerUnit = {
                        ms: null,
                        s: "ms",
                        m: "s",
                        h: "m",
                        d: "h",
                        w: "d",
                        M: "d",
                        y: "M"
                    }, t.TimeStep = r,
                    function (e) {
                        var i = function (t) {
                            function e(e, i) {
                                var n;
                                return i.cssClass = i.cssClass || "DVSL-bar-btn-month", i.title = i.title || e.settings.localization.toolbar.periodDropdownTitle, n = t.call(this, e, i) || this, n._getItemsCache = null, n.custom = {
                                    displayAnchor: null,
                                    disabled: !1,
                                    displayPeriod: null,
                                    displayPeriodStr: null,
                                    displayUnit: null,
                                    displayUnitStr: null,
                                    selected: !1,
                                    name: e.settings.localization.toolbar.customPeriod
                                }, n.updateSelectedItem(), n
                            }
                            return n(e, t), e.prototype.onSelectionChange = function (t) {
                                this.chart.setDisplayPeriod(t.displayPeriodStr, t.displayAnchor, null == t.displayUnit ? null : t.displayUnit.toString(), !0, "user")
                            }, e.prototype.onSceneChange = function (t) {
                                t.settings && (this._getItemsCache = null), (t.settingsChanges && (t.settingsChanges.area || t.settingsChanges.toolbar) || t.time) && this.updateSelectedItem()
                            }, e.prototype.updateSelectedItem = function () {
                                var t = this._lastSelectedItem;
                                if (t && t !== this.custom && this.chart.isThisDisplayPeriod(t.displayPeriodStr, t.displayAnchor, t.displayUnitStr)) return void this.setSelectedItem(t);
                                for (var e = this.getItems(), i = 0; i < e.length; i++) {
                                    var n = e[i];
                                    if (n !== t && this.chart.isThisDisplayPeriod(n.displayPeriodStr, n.displayAnchor, n.displayUnitStr)) return void this.setSelectedItem(n)
                                }
                                this.setSelectedItem(this.custom)
                            }, e.prototype.setSelectedItem = function (e) {
                                this._lastSelectedItem && (this._lastSelectedItem.selected = !1), e.selected = !0, t.prototype.setSelectedItem.call(this, e), this._lastSelectedItem = e
                            }, e.prototype.getItems = function () {
                                if (this._getItemsCache) return this._getItemsCache;
                                for (var t = [], e = this.chart.settings._minUnit, i = this.custom, n = 0; n < this.chart.settings.toolbar.periods.length; n++) {
                                    var r = this.chart.settings.toolbar.periods[n],
                                        s = r.parse(),
                                        a = s.displayPeriod,
                                        o = s.displayUnit;
                                    o && o.isSmaller(e) || a && a.isSmallerOrEqual(e) || (t.push(s), this.chart.isThisDisplayPeriod(r.displayPeriod, s.displayAnchor, r.displayUnit) && (i = s))
                                }
                                return this._lastSelectedItem = i, i.selected = !0, this._getItemsCache = t, t
                            }, e
                        }(d.Bar.Combobox);
                        e.DisplayPeriodDropdown = i, d.Bar.ToolbarItemNames.displayPeriod = function (e, i) {
                            return new t.Bar.DisplayPeriodDropdown(e, i)
                        };
                        var r = function (t) {
                            function e(e, i) {
                                var n;
                                return i || (i = {}), i.cssClass = i.cssClass || "DVSL-bar-btn-bars", i.title = i.title || e.settings.localization.toolbar.unitDropdownTitle, n = t.call(this, e, i) || this, n.updateSelectedItem(), n
                            }
                            return n(e, t), e.prototype.onSelectionChange = function (t) {
                                this.chart.setDisplayUnit(t.value, !0, "user")
                            }, e.prototype.onSceneChange = function (t) {
                                t.settings && (this._getItemsCache = null), (t.settingsChanges && (t.settingsChanges.area || t.settingsChanges.toolbar) || t.time) && this.updateSelectedItem()
                            }, e.prototype.updateSelectedItem = function () {
                                var t = this.chart.displayUnit;
                                if (t) {
                                    for (var e = this.getItems(), i = 0; i < e.length; i++) {
                                        var n = e[i];
                                        if (n.value.isEqual(t)) return void this.setSelectedItem(n)
                                    }
                                    this.setSelectedItem({
                                        name: t.name,
                                        value: t,
                                        disabled: !1,
                                        selected: !0
                                    })
                                }
                            }, e.prototype.getItems = function () {
                                if (this._getItemsCache) return this._getItemsCache;
                                for (var t = this.chart.scene, e = [], i = (t.timeEnd - t.timeStart) / t.width * this.chart.settings.timeAxis.minUnitWidth, n = !1, r = 0; r < this.chart.settings._displayUnitsParsed.length; r++) {
                                    var s = this.chart.settings._displayUnitsParsed[r];
                                    s.approxTime() < i ? n || (e.push({
                                        name: this.chart.settings.localization.toolbar.unavailableUnitTitle,
                                        value: s,
                                        disabled: !0,
                                        selected: !1
                                    }), n = !0) : e.push({
                                        name: s.name,
                                        value: s,
                                        disabled: !1,
                                        selected: s.isEqual(t.displayUnit)
                                    })
                                }
                                return e
                            }, e
                        }(d.Bar.Combobox);
                        e.DisplayUnitDropdown = r, d.Bar.ToolbarItemNames.displayUnit = function (e, i) {
                            return new t.Bar.DisplayUnitDropdown(e, i)
                        }
                    }(e = t.Bar || (t.Bar = {}));
                var s = function () {
                    function t(t, e, i, n) {
                        this.name = null, this.displayAnchor = null, this.displayPeriod = null, this.displayUnit = null, void 0 === e ? this.displayPeriod = t : (this.name = t, this.displayAnchor = e, this.displayPeriod = i, this.displayUnit = n)
                    }
                    return t.prototype.parse = function () {
                        var t = this.displayPeriod,
                            e = this.displayUnit;
                        return {
                            name: this.name,
                            displayAnchor: this.displayAnchor,
                            displayPeriod: "max" === t ? null : r.parse(t),
                            displayPeriodStr: t,
                            displayUnit: "auto" === e ? null : r.parse(e),
                            displayUnitStr: e,
                            selected: !1,
                            disabled: !1
                        }
                    }, t
                }();
                t.SettingsAreaDisplayPeriod = s;
                var a = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.enabled = !0, e.zoomOut = !0, e.logScale = !0, e.displayUnit = !0, e.displayPeriod = !0, e.zoomOutFunction = null, e.periods = [new s("Last second", "now", "1 s", "25 ms"), new s("Last minute", "now", "1 m", "1 s"), new s("Last hour", "now", "1 h", "1 m"), new s("Last day", "now", "1 d", "1 h"), new s("Last week", "now", "1 w", "6 h"), new s("Last month", "now", "1 M", "1 d"), new s("Last year", "now", "1 y", "1 M"), new s("All data", "newestData", "max", "auto")], e.items = [new d.SettingsToolbarItem("fullscreen", "left"), new d.SettingsToolbarItem("back", "left"), new d.SettingsToolbarItem("zoomOut", "left"), new d.SettingsToolbarItem("logScale", "right"), new d.SettingsToolbarItem("displayPeriod", "right"), new d.SettingsToolbarItem("displayUnit", "right"), new d.SettingsToolbarItem("export", "right")], e
                    }
                    return n(e, t), e
                }(d.SettingsToolbar);
                t.SettingsToolbar = a;
                var o = function () {
                    function t(t) {
                        this.settings = t.settings, this.chart = t, this.scene = t.scene
                    }
                    return t.prototype.toBiggerDisplayUnit = function (t) {
                        for (var e = null, i = 0; i < this.settings._displayPeriodsParsed.length; i++) {
                            var n = this.settings._displayPeriodsParsed[i];
                            n.approxTime() > t.approxTime() && (null === e || n.approxTime() < e.approxTime()) && (e = n)
                        }
                        return e
                    }, t.prototype.getMinRangeForUnit = function (t, e, i, n) {
                        var r = i.approxTime(),
                            s = this.scene.settings.timeAxis.minUnitWidth,
                            a = this.scene.settings.timeAxis.maxUnitWidth,
                            o = this.verifyUnitWidth(t, e, i);
                        if (o.min || o.max) {
                            d.Helpers.warn("Could not show all data as requested by `navigation.initialDisplayPeriod`. Please adjust either `navigation.initialDisplayPeriod` or `timeAxis.minUnitWidth` and `timeAxis.maxUnitWidth`.");
                            var l = void 0;
                            o.min ? l = this.scene.width / s * r : o.max && (l = this.scene.width / a * r), "oldestData" === n ? e = t + l : t = e - l
                        }
                        return {
                            from: t,
                            to: e
                        }
                    }, t.prototype.verifyUnitWidth = function (t, e, i) {
                        var n = i.approxTime(),
                            r = this.scene.settings.timeAxis.minUnitWidth,
                            s = this.scene.settings.timeAxis.maxUnitWidth,
                            a = (e - t) / this.scene.width;
                        return {
                            min: !(r * a < n),
                            max: !(s * a > n)
                        }
                    }, t.prototype.adjustTimeRangeToUnits = function (t, e, i, n) {
                        var r, s = i - (i - e) / 2,
                            a = n.approxTime(),
                            o = this.getUnitRange(t, [n]),
                            l = i - e;
                        r = l < o.minTime ? Math.ceil(o.minTime / a) : Math.min((i - e) / a, Math.floor(o.maxTime / a));
                        var h = r * a;
                        return e = s - h / 2 + 1, i = s + h / 2 - 1, {
                            from: e,
                            to: i
                        }
                    }, t.prototype.preventUnitWidthViolation = function (t, e) {
                        var i = this.scene,
                            n = i.width,
                            r = (t - e) / n,
                            s = r * i.settings.timeAxis.minUnitWidth;
                        return s > i.displayUnit.approxTime()
                    }, t.prototype.getBiggerDisplayPeriod = function (t, e) {
                        for (var i = Math.abs(e - t), n = 0, r = null, s = 0; s < this.settings._displayPeriodsParsed.length; s++) {
                            var a = this.settings._displayPeriodsParsed[s],
                                o = a.approxTime(),
                                l = i / o;
                            l < .9 && l > n && (n = l, r = a)
                        }
                        return r
                    }, t.prototype.getBiggerDisplayUnit = function (t) {
                        for (var e = this.settings._displayUnitsParsed, i = t.approxTime(), n = 0; n < e.length; n++) {
                            var r = e[n];
                            if (r.approxTime() > i) return r
                        }
                        return t
                    }, t.prototype.getSmallerDisplayUnit = function (t) {
                        for (var e = this.settings._displayUnitsParsed, i = t.approxTime(), n = e.length - 1; n >= 0; n--) {
                            var r = e[n];
                            if (r.approxTime() < i) return r
                        }
                        return null
                    }, t.prototype.getClosestDisplayPeriod = function (t, e, i) {
                        for (var n = null, r = 0, s = null, a = 1 / 0, o = 0; o < this.settings._displayPeriodsParsed.length; o++) {
                            var l = this.settings._displayPeriodsParsed[o],
                                h = l.approxTime();
                            h <= t && (null === n || r < h) && (n = l, r = h), h >= t && (null === s || a > h) && (s = l, a = h)
                        }
                        return i ? e && e.approxTime() < .8 * t ? e : null !== s && a < 1.2 * t || null === n ? s : n : null !== n && (r > .8 * t || a > 1.2 * t) ? n : s
                    }, t.prototype.isAllowedDisplayUnit = function (t) {
                        for (var e = 0; e < this.settings._displayUnitsParsed.length; e++) {
                            var i = this.settings._displayUnitsParsed[e];
                            if (i.isEqual(t)) return !0
                        }
                        return !1
                    }, t.prototype.adjustTimeAfterScale = function (t, e, i, n) {
                        var r = this.scene,
                            s = (e - t) / r.width,
                            a = r.settings.timeAxis.minUnitWidth,
                            o = r.displayUnit.approxTime();
                        if (!(a * s <= o)) {
                            var l = i + (n - i) / 2,
                                h = r.width / a | 0;
                            t = l - h / 2 * o, e = l + h / 2 * o
                        }
                        return {
                            from: t,
                            to: e
                        }
                    }, t.prototype.computeDisplayUnit = function (t, e, i, n, r, s, a) {
                        var o = {
                            from: n,
                            to: r,
                            unit: null
                        };
                        if (null != n && null != r || d.Helpers.error("`computeDisplayUnit` called with invalid arguments."), a && !a.scale && a.scroll) return o.unit = i || this.scene.displayUnit, o;
                        if (null !== t && null !== e && i && Math.abs(e - t - (r - n)) < .001) return o.unit = i, o;
                        var l = this.scene.displayUnit,
                            h = this.scene.settings,
                            u = Math.max(s.width, 10),
                            c = h.timeAxis,
                            p = Math.max(c.minUnitWidth, Math.min(u / 3, c.maxUnitWidth)),
                            f = (r - n) / u * c.minUnitWidth,
                            g = (r - n) / u * p,
                            m = null,
                            v = 0,
                            y = h._displayUnitsParsed,
                            S = h._minUnit.approxTime(),
                            b = "min" === c.unitSizePolicy;
                        if (a && a.scale) {
                            var C = 1 / 0;
                            i && 2 !== a.scale && (a.scale === -1 ? S = i.approxTime() : C = i.approxTime());
                            for (var x = 0; x < y.length; x++) {
                                var w = y[x],
                                    L = w.approxTime();
                                if (!(L < S || L > C)) {
                                    var T = void 0;
                                    T = null === m || (b ? L >= f && L < v || v < f && L > v : L <= g && L > v || v > g && L < v), T && (m = w, v = L)
                                }
                            }
                            m || (l.approxTime() !== y[y.length - 1].approxTime() && (d.Helpers.warn("`computeDisplayUnit` could not lookup the new unit - no units available matching the `minUnitWidth` and `maxUnitWidth` for the current range.", null, !0), this.scene.disableScaleLimiter = !0), m = this.scene.displayUnit)
                        } else {
                            var k = n,
                                A = r,
                                M = h.navigation.initialDisplayAnchor,
                                I = this.chart.getDisplayLimits(),
                                P = r === I.to && ("now" === M || "newestData" === M),
                                D = n === I.from && "oldestData" === M;
                            l && l.unit === h._minUnit.unit && 1 === l.count && (m = l);
                            for (var N = 50; --N > 0;) {
                                for (var F = !1, x = 0; x < y.length; x++) {
                                    var w = y[x],
                                        L = w.approxTime();
                                    if (!(L < S))
                                        if (L < f) F = !0;
                                        else {
                                            if (!(L <= g)) break;
                                            var T = void 0;
                                            T = null == m || (b ? L < v : L > v), T && (m = w, v = L)
                                        }
                                }
                                if (!m && !F) {
                                    var O = (k + A) / 2,
                                        E = u / p * S / 2;
                                    m = h._minUnit, k = O - E, A = O + E
                                }
                                if (m) {
                                    var R = this.scene.timeStepSettings;
                                    return {
                                        from: m.roundTimeDown(k, R),
                                        to: m.roundTimeUp(A, R),
                                        unit: m
                                    }
                                }
                                var H = A - k,
                                    B = H - H / 4 >= S,
                                    z = B ? H / 4 : H - S;
                                P ? k += z : D ? A -= z : (k += z / 2, A -= z / 2), f = (A - k) / u * c.minUnitWidth, g = (A - k) / u * p
                            }
                            0 === N && d.Helpers.warn("`computeDisplayUnit` could not lookup the new unit. It is possible that the chart did not load the data properly.")
                        }
                        if (!m) throw d.Helpers.error("", t, e, i, n, r, u), new Error("Could not calculate displayUnit");
                        return o.unit = m, o
                    }, t.prototype.tryComputeDisplayPeriod = function (t, e, i, n, s, a, o) {
                        var l = "auto" === i ? null : r.parse(i),
                            h = null,
                            u = null;
                        if (t && t.indexOf(">") > -1) {
                            var c = t.split(">", 2);
                            h = parseInt(c[0], 10), u = parseInt(c[1], 10);
                            var p = r.timeUnitDiffs,
                                f = !l || p[l.unit] < p.d;
                            h = this.scene.timestampToInternal(h, f), u = this.scene.timestampToInternal(u, f)
                        } else if ("max" === t && null !== n && null !== s) h = n, u = "now" === e ? o : s;
                        else if ("max" !== t) {
                            var g = r.parse(t),
                                m = void 0;
                            m = "now" === e ? o : "newestData" === e && null !== s ? s : d.Helpers.tryParseFloat(e, null), g && null !== m && (h = g.sub(m), u = m)
                        }
                        if (null === h || null === u) return {
                            from: null,
                            to: null,
                            unit: null
                        };
                        var v = this.getUnitRange(a),
                            y = v.minTime,
                            S = v.maxTime,
                            b = v.minUnit,
                            C = v.maxUnit;
                        return u - h > S && (l = C, h = u - S), u - h < y && (l = b, h = u - y), {
                            from: h,
                            to: u,
                            unit: l
                        }
                    }, t.prototype.resolveFromTo = function (t, e, i) {
                        var n, r, s, a = this.scene,
                            o = a.timeStepSettings,
                            l = null,
                            h = a.majorTimeUnit || i;
                        return d.Helpers.isNumber(t) ? n = t : (s = "oldestDataRounded" === t) || "oldestData" === t ? (null === l && (l = this.chart.getDisplayLimits(i)), n = l.from, s && (n = h.roundTimeDown(n, o))) : (t && d.Helpers.error("Invalid `interaction.scrolling.limitFrom` value '" + t + "'."), n = null), d.Helpers.isNumber(e) ? r = e : (s = "newestDataRounded" === e) || "newestData" === e ? (null === l && (l = this.chart.getDisplayLimits(i)), r = l.to, s && (r = h.roundTimeUp(r, o))) : "now" === e ? r = a.getCurTime() : (e && d.Helpers.error("Invalid `interaction.scrolling.limitTo` value '" + e + "'."), r = null), {
                            from: i.roundTimeDown(n, o),
                            to: i.roundTimeUp(r, o)
                        }
                    }, t.prototype.getUnitRange = function (t, e) {
                        void 0 === e && (e = this.settings._displayUnitsParsed);
                        var i = e[e.length - 1],
                            n = i.approxTime(),
                            r = e[0],
                            s = r.approxTime(),
                            a = Math.max(10, t.width),
                            o = a / this.settings.timeAxis.minUnitWidth * n,
                            l = a / this.settings.timeAxis.maxUnitWidth * s;
                        return {
                            minTime: l,
                            maxTime: o,
                            minUnit: r,
                            maxUnit: i
                        }
                    }, t.prototype.getLimits = function (t, e) {
                        var i = this.settings.interaction.scrolling,
                            n = i.limitMode,
                            r = e ? null !== n : "block" === n;
                        return r && t ? this.resolveFromTo(i.limitFrom, i.limitTo, t) : {
                            from: null,
                            to: null
                        }
                    }, t.prototype.preventOverscale = function (t, e, i, n, r, s, a) {
                        var o = this.getLimits(s, a),
                            l = o.from,
                            h = o.to,
                            u = this.getUnitRange(t, e),
                            c = u.minTime,
                            p = u.maxTime;
                        if (null !== l && null !== h && r - n > h - l) {
                            var f = (l + h) / 2,
                                g = (h - l) / 2;
                            return g = Math.max(g, c / 2), this.adjustTimeRangeToUnits(t, f - g, f + g, s)
                        }
                        p *= .99, c *= 1.01;
                        var m = r - n;
                        m = Math.min(m, p), m = Math.max(m, c);
                        var v = m === c ? m / (r - n) : 1;
                        return null === i && (i = (n + r) / 2), n === r && n > 0 && d.Helpers.error("From = To, trouble", n, r), {
                            from: i + (n - i) * v,
                            to: i + (r - i) * v
                        }
                    }, t.prototype.preventOverscroll = function (t, e, i, n) {
                        var r = this.getLimits(t, n),
                            s = r.from,
                            a = r.to,
                            o = this.settings.interaction.scrolling,
                            l = i - e;
                        return null !== s && null !== a && (l = Math.min(l, a - s)), l *= o.overscrollProportion, null !== s && (s -= l), null !== a && (a += l), null !== s && null !== a && a - s < i - e ? (s < e ? l = e - s : a > i && (l = i - a), e -= l, i -= l) : null !== a && a < i ? (l = i - a, e -= l, i -= l) : null !== s && s > e && (l = s - e, e = s, i += l), {
                            from: e,
                            to: i
                        }
                    }, t.prototype.scroll = function (t, e, i, n, s, a) {
                        var o;
                        if ("displayUnit" === a) o = i.clone();
                        else if ("page" === a) o = this.getTimeRangeStep(t, e);
                        else {
                            if (!r.isGoodUnit(a)) return void d.Helpers.error("Incorrect scroll unit: " + a);
                            o = r.parse(a)
                        }
                        return o.count *= s, "<" === n ? {
                            from: o.sub(t),
                            to: o.sub(e)
                        } : {
                            from: o.add(t),
                            to: o.add(e)
                        }
                    }, t.prototype.getTimeRangeStep = function (t, e) {
                        t = Math.round(t), e = Math.round(e);
                        for (var i = null, n = this.scene.timeStepSettings, s = 0; s < r.knownUnits.length; s++) {
                            var a = r.knownUnits[s],
                                o = new r(a, 1),
                                l = o.roundTimeRound(t, n),
                                h = o.roundTimeRound(e, n);
                            t === l && e === h && (null === i || i.approxTime() < o.approxTime()) && (i = o)
                        }
                        return i.count = Math.max(1, i.numberOfUnits(t, e)), i
                    }, t
                }();
                t.TimeSetup = o;
                var h;
                h = "undefined" != typeof Float64Array ? function (t) {
                    return Array.isArray(t) || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array || t instanceof Float64Array || t instanceof Int16Array || t instanceof Uint16Array
                } : function (t) {
                    return Array.isArray(t)
                };
                var u = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.units = ["ms", "s", "m", "h", "d", "M", "y"], e.url = null, e.urlByUnit = null, e.requestMaxUnits = 1e4, e.prefetchRatio = 1, e.minimizeRequests = !1, e.cacheSize = 5e5, e.timestampInSeconds = !1, e.stringTimestampFormat = null, e.timeZoneOffset = null, e.dataFunction = null, e.preloaded = null, e.suppressWarnings = !1, e.useSmallerUnitCache = !0, e._skipRequestRangeRounding = !1, e
                    }
                    return n(e, t), e
                }(d.SettingsData);
                t.SettingsData = u;
                var c = function () {
                    function e(t, e) {
                        this.chart = null, this.scene = null, this.settings = null, this.noData = !1, this.dataLimitFrom = null, this.dataLimitTo = null, this.dataLimitFromUnit = null, this.dataLimitToUnit = null, this.dataFrom = null, this.dataTo = null, this.error = null, this.cache = {}, this.requests = {}, this._pendingAddData = [], this.dataSettings = e, this.scene = t.scene, this.settings = t.settings, this.chart = t, this.dataId = "data" + e.id, this._prepareUsableUnits(), this.updateDataLimit(null, null, null, null, new r("ms", 1))
                    }
                    return e.binSearch = function (t, e) {
                        var i = 0;
                        if (!t) throw "暂无数据";
                        for (var n = t.length - 1; i < n;) {
                            var r = (n + i) / 2 | 0;
                            if (t[r][0] < e) i = r + 1;
                            else {
                                if (!(t[r][0] > e)) {
                                    for (; r > 0 && t[r - 1][0] === e;) r -= 1;
                                    return r
                                }
                                n = r
                            }
                        }
                        return i < t.length && t[i][0] < e ? i + 1 : i
                    }, e.linSearchUp = function (t, e, i, n) {
                        if (n) {
                            for (var r = e + 1; r <= t.length - 1; r++)
                                if (null !== n(t[r])) return r
                        } else
                            for (var r = e + 1; r <= t.length - 1; r++)
                                if (null !== t[r][i]) return r;
                        return -1
                    }, e.linSearchDown = function (t, e, i, n) {
                        if (n) {
                            for (var r = e - 1; r >= 0; r--)
                                if (null !== n(t[r])) return r
                        } else
                            for (var r = e - 1; r >= 0; r--)
                                if (null !== t[r][i]) return r;
                        return -1
                    }, e.findSubrange = function (t, i, n) {
                        var r = e.binSearch(t, i),
                            s = e.binSearch(t, n);
                        return {
                            i0: r,
                            i1: s
                        }
                    }, e.prototype.notifyAssetsLoaded = function () {
                        if (t.moment && t.moment.tz) {
                            for (var e = this._pendingAddData, i = 0; i < e.length; i++) {
                                var n = e[i];
                                this.addDataInt(n.request, n.parsedData, n.append)
                            }
                            this._pendingAddData = []
                        }
                    }, e.prototype.applyPreloadedData = function () {
                        this.dataSettings.preloaded && this.addData(this.dataSettings.preloaded)
                    }, e.prototype.remove = function () {
                        this.scene.setMessage(this.dataId, null);
                        for (var t in this.requests) {
                            var e = this.requests[t];
                            e && (e.callback = null)
                        }
                    }, e.prototype._prepareUsableUnits = function () {
                        var t = this.dataSettings.units;
                        if (0 === t.length) throw new Error("The `data.units` array must contain at least one value.");
                        for (var e = this._units = new Array(t.length), i = 0; i < t.length; i++) {
                            var n = t[i],
                                s = r.parse(n, n, !0);
                            s && (e[i] = {
                                size: s.approxTime(),
                                unit: s,
                                key: s.toString()
                            })
                        }
                        e.sort(function (t, e) {
                            return e.size - t.size
                        })
                    }, e.prototype._findUsableUnit = function (t) {
                        for (var e = this._units, i = this.cache, n = 0; n < e.length; n++) {
                            var r = e[n];
                            if (null !== i[r.key] && t.isMultipleOf(r.unit)) return r.unit
                        }
                        this.chart.error("Cannot load data - no suitable data unit configured for the requested `" + t + "`.")
                    }, e.prototype.determineDataLimits = function (t, e, i, n) {
                        var r = this;
                        if (t) {
                            if (t = this._findUsableUnit(t), !t) return
                        } else t = this._units[0].unit;
                        var s = null,
                            a = null,
                            o = t.approxTime();
                        if (this.dataLimitFromUnit && this.dataLimitFromUnit.approxTime() <= o && (s = this.dataLimitFrom), this.dataLimitToUnit && this.dataLimitToUnit.approxTime() <= o && (a = this.dataLimitTo), !(e && null == s || i && null == a)) return void n(this.dataLimitFrom, this.dataLimitTo, t);
                        this.scene.setMessage(this.dataId, this.settings.localization.determiningDataBounds, 999);
                        var l = function (t, i, s, a) {
                                if (!a) return void r.scene.setMessage(r.dataId, null);
                                if (null === r.dataLimitFrom && e) {
                                    if (t !== i) return void r.scheduleDataLoading(a, null, i, !1, function (t, e, n) {
                                        return l(i, t, e, n)
                                    });
                                    r.dataLimitFrom = i
                                }
                                r.scene.setMessage(r.dataId, null), n(r.dataLimitFrom, r.dataLimitTo, a)
                            },
                            h = function (t, e, n, s, a) {
                                if (!a) return void r.scene.setMessage(r.dataId, null);
                                if (null === r.dataLimitTo && i) {
                                    if (e !== s) return void r.scheduleDataLoading(a, s, null, !1, function (e, i, n) {
                                        return h(t, s, e, i, n)
                                    });
                                    r.dataLimitTo = s
                                }
                                l(t + 1, t, s, a)
                            };
                        this.scheduleDataLoading(t, null, null, !1, function (t, e, i) {
                            return h(t, e, t, e, i)
                        })
                    }, e.prototype.getDataForRange = function (t, i, n, r) {
                        var s = this.dataSettings,
                            a = null,
                            o = t,
                            l = i;
                        null !== this.dataLimitFrom && (o = Math.max(this.dataLimitFrom, o), l = Math.max(l, this.dataLimitFrom)), null !== this.dataLimitTo && (l = Math.min(this.dataLimitTo, l), o = Math.min(o, this.dataLimitTo));
                        var h = o !== l;
                        if (h)
                            for (var u = 0; u < this._units.length; u++) {
                                var c = this._units[u],
                                    p = this.cache[c.key];
                                if (p && n.isMultipleOf(c.unit) && p.from < i && p.to > t) {
                                    (s.useSmallerUnitCache || p.unit.approxTime() === n.approxTime()) && (a = p, h = o < p.from || l > p.to);
                                    break
                                }
                            }
                        var f = !1;
                        if (h && (h = !!s.dataFunction || !!s.url || !!s.urlByUnit, h && (!s.minimizeRequests || !this.chart.scrolling.isActive()))) {
                            var g = this._findUsableUnit(n),
                                m = !1;
                            a && g.approxTime() === a.unit.approxTime() && (o >= a.from && (m = !0, o = Math.max(o, a.to)), (l <= a.to || o < a.from) && (l = Math.min(l, a.from)));
                            var v = g.numberOfUnits(t, i),
                                y = s.cacheSize;
                            v > y && (d.Helpers.warn("The chart requires " + v + " values (using data unit `" + g + "`) to display the current time range. `data.cacheSize` limit (currently " + y + ") will be automatically increased to allow this."), s.cacheSize = 1.2 * v | 0), f = this.scheduleDataLoading(g, o, l, m, r)
                        }
                        if (a) {
                            var S = e.findSubrange(a.values, t, i),
                                b = S.i0,
                                C = S.i1;
                            return {
                                unit: n.unit,
                                count: n.count,
                                from: a.from,
                                to: a.to,
                                values: a.values,
                                startIndex: b,
                                endIndex: C,
                                loading: f
                            }
                        }
                        return f ? {
                            unit: n.unit,
                            count: n.count,
                            from: o,
                            to: l,
                            values: [],
                            startIndex: 0,
                            endIndex: 0,
                            loading: !0
                        } : (o !== l && d.Helpers.warn("The datasource `" + s.id + "` cannot return data for unit " + n, null, !0), {
                            unit: null,
                            count: null,
                            from: null,
                            to: null,
                            values: [],
                            startIndex: 0,
                            endIndex: 0,
                            loading: !1
                        })
                    }, e.prototype.updateData = function (t, e, i) {
                        var n = this._findUsableUnit(t),
                            r = n.toString();
                        if (this.cache[r] && !this.requests[r]) {
                            var s = this.scene.timeStepSettings,
                                a = n.roundTimeUp(e, s),
                                o = n.roundTimeDown(this.cache[r].lastTimestamp, s);
                            o <= a && this.scheduleDataLoading(t, o, a, !1, i)
                        }
                    }, e.prototype.scheduleDataLoading = function (t, e, i, n, s) {
                        var a = this;
                        if (!t) throw "No unit";
                        if (e > i) return !1;
                        this.chart.log("Scheduling data loading " + t + "," + e + "," + i);
                        var o = d.Helpers.performanceNow(),
                            l = t.toString(),
                            h = this.requests[l];
                        if (h) {
                            if (!(h.time + this.dataSettings.requestTimeout < o)) return this.chart.log("Already loading for selected period"), !0;
                            h.callback = null, delete this.requests[l]
                        }
                        var u = e,
                            c = i,
                            p = this.scene.timeStepSettings;
                        if (this.dataSettings._skipRequestRangeRounding || (null !== u && (u = t.roundTimeDown(u, p)), null !== c && (c = t.roundTimeUp(c, p))), null !== u && null !== c) {
                            var g = (c - u) / t.approxTime();
                            g > this.dataSettings.requestMaxUnits && (n ? c = t.add(u, this.dataSettings.requestMaxUnits) : u = t.sub(c, this.dataSettings.requestMaxUnits))
                        }
                        var m = this.getDataFunction();
                        if (!m) return this.chart.log("No data function. Cannot load data?"), !1;
                        var v = r.timeUnitDiffs[t.unit] < r.timeUnitDiffs.d,
                            y = v ? null : this.settings.timeAxis.timeZone;
                        this.requests[l] = h = new f(t, u, c, s, o, y);
                        var S = function (t) {
                                return a.dataReceivedRaw(h, t)
                            },
                            b = function () {
                                return a.dataFailed(h)
                            };
                        u = this.convertTimestampFromInternal(u, v), c = this.convertTimestampFromInternal(c, v), u === c && null !== c && c++;
                        var C = m(u, c, t.toShortString(), S, b, y);
                        return this.chart.log("Data requested " + t + ", " + u + ", " + c), (d.Helpers.isObjectOrArray(C) || d.Helpers.isString(C)) && (this.dataSettings.suppressWarnings || d.Helpers.warn("Data object should not be returned directly from the `dataFunction` delegate - instead call the `success` callback."), this.dataReceivedRaw(h, C)), !0
                    }, e.prototype.dataReceivedRaw = function (t, e) {
                        if (!this.chart.removed) {
                            this.scene.setMessage(this.dataId, null), delete this.requests[t.unitStr], this.chart.log("Data arrived");
                            var i = d.Helpers.parseData(e, this.dataSettings.format);
                            d.Helpers.isObjectOrArray(e) && (i = this.cloneDataObject(i)), this.addDataInt(t, i, !1)
                        }
                    }, e.prototype.cloneDataObject = function (t) {
                        t = d.Helpers.clone(t);
                        var e = t.values;
                        if (!t.error && e)
                            if (Array.isArray(e)) {
                                t.values = e = e.slice();
                                for (var i = 0; i < e.length; i++) {
                                    var n = e[i];
                                    if (!h(n)) {
                                        t.error = "The `values` in the TimeChart data object must be an array of arrays. The value at index " + i + " is not an array.";
                                        break
                                    }
                                    e[i] = Array.prototype.slice.call(n)
                                }
                            } else t.error = "The `values` in the TimeChart data object must be an array or arrays.";
                        return t
                    }, e.prototype.addData = function (t) {
                        t = this.cloneDataObject(t), this.addDataInt(null, t, !0)
                    }, e.prototype.addDataInt = function (e, i, n) {
                        if (void 0 === n && (n = !1), null !== i) {
                            if (!t.moment || !t.moment.tz) return void this._pendingAddData.push({
                                request: e,
                                parsedData: i,
                                append: n
                            });
                            var r = this.cleanupData(i);
                            if (r.error) return "no-unit" === r.error && e && (this.cache[e.unitStr] = null), void this.chart.error(r.error);
                            var s;
                            if (s = e ? this.analyzeData(r, e) : this.analyzeDataNoRequest(r, n), e && !e.unit.isMultipleOf(s.unit)) this.chart.error("Incorrect data - requested unit `" + e.unit + "`, got `" + s.unit + "`. The requested unit must be a multiple of returned unit."), this.cache[e.unitStr] = null, e.callback && e.callback(null, null, null);
                            else {
                                var a = s.unitStr;
                                if (e && a !== e.unitStr) {
                                    this.cache[e.unitStr] = null;
                                    for (var o = !0, l = this._units, h = 0; h < l.length; h++)
                                        if (l[h].unit.isEqual(s.unit)) {
                                            o = !1;
                                            break
                                        }
                                    o && (d.Helpers.warn("The data source returned unit `" + a + "` which was not declared in `data.units`."), this.dataSettings.units.push(a), this._prepareUsableUnits())
                                }
                                if (s.unit && null != s.from && null != s.to) {
                                    var u = this.cache[s.unitStr];
                                    u ? this.cache[s.unitStr].merge(s, this.dataSettings.cacheSize, this.chart, n) : this.cache[s.unitStr] = s
                                }
                                e && e.callback && e.callback(s.from, s.to, s.unit)
                            }
                            this.chart.events.notifySceneChanges({
                                data: (c = {}, c[this.dataSettings.id] = !0, c)
                            });
                            var c
                        }
                    }, e.prototype.dataFailed = function (t) {
                        this.cache[t.unitStr] || (this.cache[t.unitStr] = null), this.scene.setMessage(this.dataId, this.settings.localization.dataRequestFailed, 1e3), this.chart.error("Failed data loading request"), t.callback && t.callback(null, null, null)
                    }, e.prototype.updateDataLimit = function (t, e, i, n, r) {
                        this.chart.invalidateDataLimits(), void 0 !== t && null !== t && (null === this.dataFrom || this.dataFrom > t) && (this.dataFrom = t), void 0 !== e && null !== e && (null === this.dataTo || this.dataTo < e) && (this.dataTo = e), null != i && (this.dataLimitFrom = i, this.dataLimitFromUnit = r, this.dataFrom = null == this.dataFrom ? i : Math.max(this.dataFrom, i)), null != n && (this.dataLimitTo = n, this.dataLimitToUnit = r, this.dataTo = null == this.dataTo ? n : Math.min(this.dataTo, n))
                    }, e.prototype.cleanupData = function (e) {
                        if (e.error) return e;
                        "local" === e.timeZone && (d.Helpers.error("The data source has to specify a timezone that is not `local` so that it works independent of the browser settings."), e.timeZone = t.moment.tz.guess()), e.error = "bad-response";
                        var i = !this.dataSettings.suppressWarnings,
                            n = "";
                        e.data && !e.values && (i && d.Helpers.warn("Use of property `data` in the TimeChart data object (returned from the URL, dataFunction or preloaded property) is deprecated. Please use `values` instead.", null, !0), e.values = e.data), null == e.unit && (n += "\nRequired field 'unit' not set in data"), null == e.values && (n += "\nRequired field 'values' not set in data");
                        var s = r.parse(e.unit, void 0, !1);
                        if (null === s && (n += "\nData error: unrecognized data unit: " + e.unit), n.length) return e.error = n.substr(1), e;
                        e.error = null;
                        var a = e.timeZone || "UTC",
                            o = r.timeUnitDiffs[s.unit] < r.timeUnitDiffs.d,
                            l = t.moment.defaultZone,
                            h = t.moment.locale();
                        t.moment.locale(this.scene.momentLocale), t.moment.tz.setDefault(a), e.from = this.convertTimestampToInternal(e.from, o), e.to = this.convertTimestampToInternal(e.to, o),
                            e.dataLimitFrom = this.convertTimestampToInternal(e.dataLimitFrom, o), e.dataLimitTo = this.convertTimestampToInternal(e.dataLimitTo, o);
                        var u, c, p = -1e30,
                            f = !1;
                        null != e.from && null != e.to && e.from >= e.to && (this.chart.error("Data logic error. from >= to: " + e.from + ", " + e.to + ". The values will be ignored."), e.from = null, e.to = null), null != e.dataLimitFrom && null != e.dataLimitTo && e.dataLimitFrom >= e.dataLimitTo && (this.chart.error("Data logic error. dataLimitFrom >= dataLimitTo: " + e.dataLimitFrom + ", " + e.dataLimitTo + ". The values will be ignored."), e.dataLimitFrom = null, e.dataLimitTo = null);
                        var g = e.dataLimitFrom,
                            m = e.dataLimitTo;
                        null == g && (g = -(1 / 0)), null == m && (m = 1 / 0);
                        var v = 0;
                        if ("UTC" === a && "UTC" === this.settings.timeAxis.timeZone && (v = this.dataSettings.timestampInSeconds ? 1e3 : 1), e.values.length > 0) {
                            for (var y = [], S = 0; S < e.values.length; S++) {
                                var b = e.values[S];
                                if (Array.isArray(b)) {
                                    for (var C = b.length, x = 1; x < C; x++) {
                                        var w = b[x];
                                        null != w ? "number" != typeof w && isNaN(b[x] = parseFloat(w)) ? (this.chart.error("Data error: the value is not a number: values[" + S + "][" + x + "] = " + w), b[x] = null) : isNaN(w) && (b[x] = null) : b[x] = null
                                    }
                                    var L = C ? b[0] : null;
                                    if (null != L) {
                                        if (b[0] = L = v && "number" == typeof L ? L * v : this.convertTimestampToInternal(L, o), null === L) continue;
                                        (L < g || L > m) && this.chart.error("Data error: value timestamp outside data limits. values[" + S + "][0] = " + b[0] + ". Limits: " + g + "..." + m), i && p === L && d.Helpers.warn("There are multiple values given for the same timestamp " + b[0] + " which might produce invalid results."), p > L && !f && (i && d.Helpers.warn("Data values are not sorted on timestamp in ascending order (timestamp " + b[0] + "). TimeChart will sort the data automatically but to achieve better performance the data source should be sorted."), f = !0), p = b[0], y.push(b)
                                    }
                                } else this.chart.error("Data error: the value at index " + S + " is not an array.")
                            }
                            e.values = y, f && y.sort(function (t, e) {
                                return t[0] - e[0]
                            }), u = y[0][0], c = y[y.length - 1][0]
                        }
                        return null != e.from && u < e.from && (d.Helpers.warn("Data logic error. Data time " + u + " outside [from, to) range: " + e.from + ", " + e.to), e.from = u), null != e.to && c >= e.to && (d.Helpers.warn("Data logic error. Data time " + c + " outside [from, to) range: " + e.from + ", " + e.to), e.to = c + 1), t.moment.defaultZone = l, t.moment.locale(h), e
                    }, e.prototype.analyzeDataNoRequest = function (t, e) {
                        var i = this.dataSettings,
                            n = t.from,
                            s = t.to,
                            a = r.parse(t.unit),
                            o = null,
                            l = null;
                        if ((null == n || null == s) && t.values.length > 0) {
                            var h = this.scene.timeStepSettings;
                            o = t.values[0][0], l = t.values[t.values.length - 1][0], o = a.roundTimeDown(o, h), l = a.roundTimeUp(l + 1, h), null == n && (n = o), null == s && (s = l)
                        }
                        null != i.dataFunction || null != i.url || null != t.dataLimitFrom || null != t.dataLimitTo || d.Helpers.hasProperties(i.urlByUnit) || (d.Helpers.warn("Using preloaded data without specifying `dataLimitFrom` and `dataLimitTo` is not recommended - these values will be implied from the data and might result in invalid behavior.", null, 1e30), null == t.dataLimitFrom && (t.dataLimitFrom = Math.min((e ? this.dataLimitFrom : 0) || 1e30, t.from || o)), null == t.dataLimitTo && (t.dataLimitTo = Math.max((e ? this.dataLimitTo : 0) || -1e30, t.to || l))), this.updateDataLimit(o, l, t.dataLimitFrom, t.dataLimitTo, a);
                        var u = new p(a, n, s, t.values);
                        return null != t.error && (u.error = t.error), u
                    }, e.prototype.analyzeData = function (t, e) {
                        null === e.from && null == t.from && null != t.dataLimitFrom && (t.from = t.dataLimitFrom, d.Helpers.warn("`from` is not set in the data response - using `dataLimitFrom` instead. This may produce unexpected results.")), null === e.to && null == t.to && null != t.dataLimitTo && (t.to = t.dataLimitTo, d.Helpers.warn("`to` is not set in the data response - using `dataLimitTo` instead. This may produce unexpected results."));
                        var i = t.from,
                            n = t.to,
                            s = null,
                            a = null;
                        null != i && null != n && i >= n && this.chart.error("Data logic error. from >= to: " + i + ", " + n);
                        var o = r.parse(t.unit),
                            l = this.scene.timeStepSettings;
                        if (t.values.length > 0 ? (s = t.values[0][0], a = t.values[t.values.length - 1][0], s = o.roundTimeDown(s, l), a = o.roundTimeUp(a + 1, l), null == i && (i = null !== e.from ? Math.min(e.from, s) : s), null == n && (n = null !== e.to ? Math.max(e.to, a) : a), e.from && a <= e.unit.add(e.from) && (this.dataSettings._skipRequestRangeRounding = !0)) : (null == i && (i = e.from), null == n && (n = e.to), null != t.from && null != t.to ? (s = t.from, a = t.to) : (s = e.from, a = e.to, null === e.from && null === e.to && null == i && null == n && null == t.dataLimitFrom && null == t.dataLimitTo && (this.noData = !0))), this.updateDataLimit(s, a, t.dataLimitFrom, t.dataLimitTo, o), null !== e.from && null != t.to) {
                            var h = o.roundTimeDown(t.to, l);
                            h <= e.from && this.updateDataLimit(null, null, null, t.to, o)
                        }
                        if (null !== e.to && null != t.from) {
                            var u = o.roundTimeUp(t.from, l);
                            u >= e.to && this.updateDataLimit(null, null, t.from, null, o)
                        }
                        null == t.from && null == t.dataLimitFrom && (null !== this.dataLimitFrom && (null === e.from || e.from <= this.dataLimitFrom && s > this.dataLimitFrom) || null === this.dataLimitFrom && (void 0 === e.from || null === e.from)) && (this.updateDataLimit(null, null, s, null, o), i = s), null == t.to && null == t.dataLimitTo && (null !== this.dataLimitTo && (null === e.to || e.to >= this.dataLimitTo && a < this.dataLimitTo) || null === this.dataLimitTo && (void 0 === e.to || null === e.to)) && (this.updateDataLimit(null, null, null, a, o), n = a);
                        var c = new p(o, i, n, t.values);
                        return t.error && (c.error = t.error), c
                    }, e.prototype.getDataFunction = function () {
                        var t = this,
                            e = this.dataSettings;
                        if (e.dataFunction) return e.dataFunction;
                        var i = d.Helpers.hasProperties(e.urlByUnit);
                        return e.url || i ? function (n, r, s, a, o, l) {
                            var h;
                            if (i) {
                                if (h = e.urlByUnit[s], !h) return '{"error":"no-unit", "errormessage":"no data url for this time unit: ' + s + '"}'
                            } else h = e.url;
                            var u = [];
                            null !== n && u.push(["from", n.toString(10)]), null !== r && u.push(["to", r.toString(10)]), u.push(["unit", s]), null !== l && u.push(["timeZone", l]), d.Data.doRequest(h, t.dataSettings, u, a, o)
                        } : null
                    }, e.prototype.hasPendingRequests = function () {
                        return d.Helpers.hasProperties(this.requests)
                    }, e.prototype.convertTimestampToInternal = function (e, i) {
                        if (null == e) return null;
                        var n = this.dataSettings,
                            r = this.settings.timeAxis,
                            s = d.Helpers.isNumber(e);
                        s && n.timestampInSeconds && (e = 1e3 * e);
                        var a = t.moment(e, s ? null : n.stringTimestampFormat);
                        if (!a.isValid()) {
                            var o = parseFloat(e);
                            return s || isNaN(o) ? (d.Helpers.error("Could not parse timestamp value `" + e + "`. The value will be ignored."), null) : (d.Helpers.warn("Numeric timestamp value `" + e + "` was passed as string. This has been deprecated starting from version 1.12."), this.convertTimestampToInternal(o, i))
                        }
                        i && (a = a.tz(r.timeZone));
                        var l = a.utcOffset ? a.utcOffset() : a.zone();
                        return e = +a + 6e4 * l, e + 6e4 * (r.timeZoneOffset - n.timeZoneOffset)
                    }, e.prototype.convertTimestampFromInternal = function (t, e) {
                        if (null == t) return null;
                        var i = this.dataSettings;
                        return t = this.scene.timestampFromInternal(t, e), t += 6e4 * i.timeZoneOffset, i.timestampInSeconds && (t /= 1e3), t
                    }, e
                }();
                t.Data = c;
                var p = function () {
                    function t(t, e, i, n) {
                        this.values = null, this.error = null, this.values = n, this.to = i, this.from = e, this.unit = t, this.unitStr = t.toString(), this.updateLastTimestamp()
                    }
                    return t.prototype.updateLastTimestamp = function () {
                        this.values.length > 0 ? this.lastTimestamp = this.values[this.values.length - 1][0] : this.lastTimestamp = 0
                    }, t.prototype.merge = function (t, e, i, n) {
                        if (t.unit.approxTime() !== this.unit.approxTime()) throw new Error("merge unit mismatch");
                        if (!n && (this.from > t.to || this.to < t.from)) return this.values = t.values, this.from = t.from, void(this.to = t.to);
                        t.values.length > 0 && t.from > t.values[0][0] && i.error("Data merge - oldest data before from"), t.values.length > 0 && t.to < t.values[t.values.length - 1][0] && i.error("Data merge - newest data after to");
                        for (var r = 0; r < this.values.length && this.values[r][0] < t.from;) r += 1;
                        for (var s = this.values.length; s > 0 && this.values[s - 1][0] >= t.to;) s -= 1;
                        var a = t.values;
                        if (this.from = Math.min(this.from, t.from), this.to = Math.max(this.to, t.to), r > 0) {
                            var o = Math.max(0, a.length + r - e);
                            a = this.values.slice(o, r - 1 + 1).concat(a), o > 0 && (this.from = this.values[o - 1][0] + 1)
                        }
                        if (s < this.values.length) {
                            var l = this.values.length - s;
                            l = Math.min(l, e - a.length), a = a.concat(this.values.slice(s, s + l + 1)), l < this.values.length - s && (this.to = this.values[s + l][0])
                        }
                        this.values = a, this.updateLastTimestamp()
                    }, t
                }();
                t.TimeData = p;
                var f = function () {
                        function t(t, e, i, n, r, s) {
                            this.time = r, this.callback = n, this.to = i, this.from = e, this.unit = t, this.unitStr = t.toString(), this.timeZone = s
                        }
                        return t
                    }(),
                    g = function (t) {
                        function e() {
                            var e = t.apply(this, arguments) || this;
                            return e.limitMode = "snapBack", e.limitFrom = "oldestData", e.limitTo = "newestData", e.overscrollProportion = 0, e
                        }
                        return n(e, t), e
                    }(l.SettingsInteractionScrolling);
                t.SettingsInteractionScrolling = g;
                var m = function (t) {
                    function e(e) {
                        var i = t.call(this, e) || this;
                        return i.animationOrder = 600, i.paintOrder = 10, i.updateOrder = 1400, i.animationUnit = null, i.targetUnit = null, i.dragStartBar0 = null, i.dragStartBar1 = null, i.dragStartUnit = null, i.timeSetup = new o(e), i
                    }
                    return n(e, t), e.prototype.onSceneChange = function (e) {
                        t.prototype.onSceneChange.call(this, e);
                        var i = this.scene,
                            n = this.scene.displayUnit;
                        !this.scalingActive && i.timeScale && i.lastUnit === n || !n || this.timeSetup.preventUnitWidthViolation(this.chart.timeEnd, this.chart.timeStart) || (i.timeScale = (i.timeEnd - i.timeStart) / i.width), i.lastUnit !== n && (i.lastUnit = n)
                    }, e.prototype.scaleViewRange = function (e, i, n) {
                        var r = t.prototype.scaleViewRange.call(this, e, i, n),
                            s = this.scene,
                            a = s.settings.timeAxis,
                            o = (r.to - r.from) / s.width * a.minUnitWidth / 1.5;
                        return s.disableScaleLimiter || o <= s.displayUnit.approxTime() ? r : {
                            from: i,
                            to: n
                        }
                    }, e.prototype.setTimeRangeSnap = function (t, e, i, n, r, s, a, o) {
                        var l = this.snap(t, e, i, n, a, o);
                        t = l.from, e = l.to;
                        var h = l.unit,
                            u = l.period,
                            c = l.anchor;
                        this.setTimeRange(t, e, h, r, s, c, u)
                    }, e.prototype.computeDisplayPeriod = function (t, e, i, n, r) {
                        var s = this.timeSetup.tryComputeDisplayPeriod(t, e, i, n, r, this.scene, this.scene.getCurTime()),
                            a = s.from,
                            o = s.to,
                            l = s.unit;
                        return null === a || null === o ? {
                            from: null,
                            to: null,
                            unit: null
                        } : this.computeTimeRangeExtend(a, o, l)
                    }, e.prototype.computeTimeRangeExtend = function (t, e, i) {
                        var n = this.scene;
                        if (!i) {
                            var r = this.timeSetup.computeDisplayUnit(n.timeStart, n.timeEnd, n.displayUnit, t, e, n);
                            t = r.from, e = r.to, i = r.unit
                        }
                        var s = n.timeStepSettings;
                        t = i.roundTimeDown(t, s), e = i.roundTimeUp(e, s), e === t && (e = i.add(e, 1));
                        var a = this._preventOverscroll(t, e, i, !0);
                        return t = a.from, e = a.to, {
                            from: t,
                            to: e,
                            unit: i
                        }
                    }, e.prototype.computeDisplayUnit = function (t, e, i) {
                        var n = null !== this.dragStartFrom ? this.dragStartFrom : this.scene.timeStart,
                            r = null !== this.dragStartTo ? this.dragStartTo : this.scene.timeEnd,
                            s = this.dragStartUnit ? this.dragStartUnit : this.scene.displayUnit,
                            a = this.chart.scrolling,
                            o = {
                                scroll: a.scrollingActive,
                                scale: a.scalingActive,
                                animate: i
                            };
                        return this.timeSetup.computeDisplayUnit(n, r, s, t, e, this.scene, o)
                    }, e.prototype.setTimeRange = function (t, e, i, n, r, s, a) {
                        if (void 0 === s && (s = null), void 0 === a && (a = null), t = Math.round(t), e = Math.round(e), !(t > e)) {
                            if (!i) {
                                var o = this.computeDisplayUnit(t, e);
                                t = o.from, e = o.to, i = o.unit
                            }
                            if ("init" === r) {
                                var o = this.timeSetup.getMinRangeForUnit(t, e, i, s);
                                t = o.from, e = o.to
                            }
                            t === this.getFrom() && e === this.getTo() && i.isEqual(this.scene.displayUnit) || (n && this.abort(), this.scene.anchor = s, this.scene.period = a, this.targetUnit = i, this.animationUnit = !i || this.scene.displayUnit && i.toString() !== this.scene.displayUnit.toString() ? null : i, this.goToPosition(t, e, n, d.Helpers.performanceNow(), !0), this.events.notifySceneChanges({
                                time: !0
                            }), r && this.chart.notifyTimeChanged(t, e, i, r))
                        }
                    }, e.prototype.zoomOut = function (t, e, i, n, r) {
                        if (this.scene.displayUnit) {
                            var s = this.computeZoomOut(e, i);
                            this.scene.displayUnit = s.unit, this.setTimeRangeSnap(s.from, s.to, s.center, s.unit, n, r, !1, !0)
                        }
                    }, e.prototype.zoomIn = function (t, e, i, n, r, s) {
                        if (this.scene.displayUnit) {
                            null === e && (e = (i + n) / 2);
                            var a = this.onZoomIn(i, n, e, .5);
                            this.setTimeRangeSnap(a.from, a.to, a.center, t, r, s, !1, !0)
                        }
                    }, e.prototype.handleZoomWheel = function (t, e, i, n, r) {
                        var s = this.onSnapWhileDragging(t, e, i, this.scrollingActive, r);
                        t = s.from, e = s.to;
                        var a = s.unit;
                        if (this.scene.displayUnit = a, null === this.pointer1) {
                            var o = this.onSnapAfterDragging(t, e, i, this.scrollingActive, r);
                            t = o.from, e = o.to, a = o.unit, this.scene.displayUnit = a
                        }
                        this.goToPosition(t, e, !0, n, !0)
                    }, e.prototype.xyInArea = function (t, e) {
                        return this.scene.xyInChart(t, e)
                    }, e.prototype.xyToPosition = function (t, e) {
                        return this.scene.xToTime(t)
                    }, e.prototype.onZoomOut = function (e, i, n, r) {
                        return void 0 === r && (r = null), r ? t.prototype.onZoomOut.call(this, e, i, n, r) : this.computeZoomOut(e, i)
                    }, e.prototype.onZoomIn = function (e, i, n, r) {
                        if (void 0 === r && (r = null), r) return t.prototype.onZoomIn.call(this, e, i, n, r);
                        if (this.dragStartBar0 && (e = this.dragStartBar0, i = this.dragStartBar1, i - e > this.scene.timeEnd - this.scene.timeStart)) {
                            var s = this.scene.getClickBar(n);
                            e = s.time0, i = s.time1
                        }
                        return {
                            from: e,
                            to: i,
                            center: (e + i) / 2
                        }
                    }, e.prototype.onScroll = function (t, e, i) {
                        return this.timeSetup.scroll(t, e, this.scene.displayUnit, i, 1, "page")
                    }, e.prototype.onGoHome = function (t, e) {
                        var i = this.chart.getDisplayLimits().to;
                        if (null === i) return {
                            from: t,
                            to: e,
                            origin: null
                        };
                        this.scene.anchor = "newestData";
                        var n = e - t;
                        return {
                            from: i - n,
                            to: i,
                            origin: i
                        }
                    }, e.prototype.onStartDragging = function (t, e, i) {
                        this.scene.anchor = null, this.animationUnit = null, this.dragStartUnit = this.scene.displayUnit;
                        var n = this.scene.getClickBar(i);
                        this.dragStartBar0 = n.time0, this.dragStartBar1 = n.time1
                    }, e.prototype.onSnapWhileDragging = function (t, e, i, n, r) {
                        if (t > e) {
                            var s = e;
                            e = t, t = s
                        }
                        var a = this._preventOverscale(t, e, null, i, !1);
                        t = a.from, e = a.to;
                        var o = this.computeDisplayUnit(t, e).unit,
                            l = this._preventOverscroll(t, e, o, !1);
                        return t = l.from, e = l.to, this.events.notifySceneChanges({
                            time: !0
                        }), {
                            from: t,
                            to: e,
                            unit: o
                        }
                    }, e.prototype.onSnapAfterDragging = function (t, e, i, n, r) {
                        if (r) {
                            var s = this.timeSetup.adjustTimeAfterScale(t, e, this.dragStartBar0, this.dragStartBar1);
                            t = s.from, e = s.to
                        }
                        var a = this.snap(t, e, i, null, n, !1),
                            o = a.unit,
                            l = a.period,
                            h = a.anchor;
                        return this.targetUnit = o, this.animationUnit = this.scene.displayUnit, this.scene.period = l, this.scene.anchor = h, this.dragStartBar0 = null, this.dragStartBar1 = null, this.dragStartFrom = null, this.dragStartTo = null, this.dragStartUnit = null, this.events.notifySceneChanges({
                            time: !0
                        }), this.chart.notifyTimeChanged(t, e, o, "user"), {
                            from: a.from,
                            to: a.to,
                            unit: o
                        }
                    }, e.prototype.onPositionChanged = function (t, e, i) {
                        if (!isNaN(t) || !isNaN(e)) {
                            var n;
                            n = this.animationUnit ? this.animationUnit : this.computeDisplayUnit(t, e).unit, this.scene.setTimeRange(t, e, n), this.chart.timeStart = t, this.chart.timeEnd = e, this.chart.displayUnit = n, this.events.notifySceneChanges({
                                position: !0,
                                time: !0
                            })
                        }
                    }, e.prototype.onAnimationDone = function (t, e) {
                        if (this.targetUnit) {
                            var i = this.targetUnit ? this.targetUnit : this.computeDisplayUnit(t, e).unit;
                            this.chart.displayUnit = i, this.scene.setTimeRange(t, e, i)
                        }
                        this.targetUnit = null, this.animationUnit = null, this.chart.notifyAnimationDone()
                    }, e.prototype.onPointerDown = function (e) {
                        null !== this.pointer1 && null === this.pointer2 && (this.dragStartUnit = this.scene.displayUnit), t.prototype.onPointerDown.call(this, e)
                    }, e.prototype.onPointerDrag = function (e) {
                        this.scene.displayUnit && t.prototype.onPointerDrag.call(this, e)
                    }, e.prototype.computeZoomOut = function (t, e) {
                        var i, n = this.scene.settings.toolbar.zoomOutFunction,
                            s = this.scene.displayUnit,
                            a = null,
                            o = null,
                            l = e - t,
                            h = e - l / 2;
                        n && (o = n(s.unit, s.count, t, e)), null != o && o.unit && (a = new r(o.unit, o.count || 1)), a || (a = this.timeSetup.getBiggerDisplayUnit(s));
                        var u = a.approxTime(),
                            c = this.timeSetup.getUnitRange(this.scene, [a]),
                            d = null != o && (null != o.from || null != o.to);
                        if (d) {
                            i = Math.min(c.maxTime, o.to - o.from);
                            var p = this.timeSetup.verifyUnitWidth(o.from, o.to, a);
                            if (p.min || p.max) {
                                var f = this.timeSetup.adjustTimeRangeToUnits(this.chart.scene, o.from, o.to, a);
                                t = f.from, e = f.to
                            }
                        } else {
                            var g = Math.min(30 * l / u, Math.floor(c.maxTime / u));
                            i = u * g
                        }
                        return (!o || o && !o.from) && (t = h - i / 2, e = h + i / 2), {
                            from: t,
                            to: e,
                            center: h,
                            unit: a
                        }
                    }, e.prototype.snap = function (t, e, i, n, r, s) {
                        if ((s || r) && this.scene.settings.interaction.scrolling.limitMode) {
                            var a = this._preventOverscale(t, e, n, i, !0);
                            t = a.from, e = a.to
                        }
                        var o, l;
                        if (n ? o = n : !s || !s && r ? o = this.scene.displayUnit : (l = this.computeDisplayUnit(t, e), o = l.unit, t = l.from, e = l.to), r || s) {
                            var h = e - t,
                                u = this._preventOverscroll(t, e, o, !1);
                            t = u.from, e = u.to, u = this._preventOverscroll(t, e, o, !0), t = u.from, e = u.to, s = s || e - t !== h
                        }
                        if (!n && s) return l = this.computeDisplayUnit(t, e), t = l.from, e = l.to, this.snap(t, e, i, o, r, s);
                        var c = s ? null : this.scene.period,
                            d = this.scene.anchor,
                            p = this.scene.settings.interaction.snapMode;
                        if (p) {
                            var f = this.scene.majorTimeUnit && "y" === this.scene.majorTimeUnit.unit,
                                g = void 0;
                            if ("displayUnit" === p) g = o;
                            else if ("multiperiod" === p || "period" === p) {
                                var m = e - t,
                                    v = this.chart.getDisplayLimits(),
                                    y = v.from,
                                    S = v.to;
                                null !== y && (m = Math.min(m, S - y));
                                var b = this.timeSetup.getClosestDisplayPeriod(m, this.scene.majorTimeUnit, "multiperiod" === p || f);
                                g = b, c = b.toString()
                            }
                            var C = this.scene.timeStepSettings;
                            if ("period" !== p || f)
                                if (s) t = g.roundTimeRound(t, C), e = g.roundTimeRound(e, C);
                                else {
                                    var x = Math.max(g.numberOfUnits(t, e), 1),
                                        w = Math.abs(g.roundTimeRound(t, C) - t),
                                        L = Math.abs(g.roundTimeRound(e, C) - e);
                                    w < L ? (t = g.roundTimeRound(t, C), e = g.add(t, x)) : (e = g.roundTimeRound(e, C), t = g.sub(e, x))
                                }
                            else t = g.roundTimeDown(i, C), e = g.add(t, 1)
                        } else t = Math.round(t), e = Math.round(e);
                        return {
                            from: t,
                            to: e,
                            unit: o,
                            period: c,
                            anchor: d
                        }
                    }, e.prototype._preventOverscroll = function (t, e, i, n) {
                        return this.timeSetup.preventOverscroll(i, t, e, n)
                    }, e.prototype._preventOverscale = function (t, e, i, n, r) {
                        var s;
                        return i ? s = [i] : (i = this.scene.displayUnit, s = this.scene.settings._displayUnitsParsed), this.timeSetup.preventOverscale(this.scene, s, n, t, e, i, r)
                    }, e
                }(l.Scrolling);
                t.Scrolling = m;
                var v = function () {
                    function t() {
                        this.enabled = !0, this.tolerance = 6, this.moveByDragging = !1, this.resizeSensitivity = 2, this.resizeTolerance = 20, this.clearOnRightClick = !0
                    }
                    return t
                }();
                t.SettingsInteractionSelection = v;
                var y = function () {
                    function t() {
                        this.lineColor = "rgba(0,0,0,0.5)", this.lineWidth = 2, this.fillColor = "rgba(30,160,220,0.15)", this.behindSeries = !1
                    }
                    return t
                }();
                t.SettingsAreaStyleSelection = y;
                var S = function (e) {
                    function i(t) {
                        var i = e.call(this) || this;
                        i.selectStart = null, i.selectingPointer = null, i.isSelecting = !1, i.isHoveringEdge = !1, i.lastX = 0, i.lastY = 0, i.roundAround = !1, i.selectionRemoved = !1, i.animationOrder = 500, i.updateOrder = 1300, i.isMoving = !1, i.moveStartX = 0, i.moveStartY = 0, i.moveSelectionStart = null, i.moveSelectionEnd = null, i.chart = t, i.scene = t.scene;
                        var n = t.settings;
                        return i.settings = n.interaction.selection, i.styleSettings = n.area.style.selection, i.labelStyle = n.area.style.selectionLabel, i.paintOrder = i.styleSettings.behindSeries ? 3 : 15, i
                    }
                    return n(i, e), i.prototype.onSceneChange = function (t) {
                        if ((t.changes.time || t.changes.bounds) && null !== this.selectStart && this.dragPointer(null, this.lastX, this.lastY, t.changes), t.changes.settings) {
                            var e = this.styleSettings.behindSeries ? 3 : 15;
                            this.paintOrder !== e && (this.paintOrder = e, this.chart.events.refreshElementOrder())
                        }
                    }, i.prototype.getLineCoordinates = function () {
                        var t = this.scene,
                            e = this.styleSettings,
                            i = Math.round(t.timeToX(t.selectionStart)),
                            n = Math.round(t.timeToX(t.selectionEnd)),
                            r = e.lineWidth,
                            s = Math.round(t.x0),
                            a = Math.round(s + t.width);
                        return i - r < s && i > s - 4 * r && (i = s + r), n + r > a && n < a + 4 * r && (n -= r), {
                            start: i,
                            end: n
                        }
                    }, i.prototype.paintScene = function (e) {
                        var i = this.scene;
                        if (null != i.minorTimeUnit && null != i.selectionStart && null != i.selectionEnd && this.chart.assetsLoaded) {
                            var n = this.styleSettings,
                                r = n.lineWidth,
                                s = Math.round(i.x0),
                                a = Math.round(s + i.width),
                                o = Math.round(i.y0),
                                l = Math.round(o + i.height + i.bottomAxisSize),
                                h = this.getLineCoordinates(),
                                u = h.start,
                                c = h.end,
                                p = i.minorTimeUnit.roundTimeRound(i.selectionStart, i.timeStepSettings),
                                f = i.minorTimeUnit.roundTimeRound(Math.max(i.selectionStart, i.selectionEnd - 1), i.timeStepSettings),
                                g = i.height + i.bottomAxisSize,
                                m = t.moment.utc(p).locale(i.momentLocale).format(i.minorTimeFormat),
                                v = t.moment.utc(f).locale(i.momentLocale).format(i.minorTimeFormat),
                                y = e.context;
                            d.Graphics.pushClip(e, s, o, i.width, g), d.Graphics.rectStyle(y, n);
                            var S = u + r % 2 / 2,
                                b = c + r % 2 / 2;
                            y.fillRect(S + r / 2, o, c - u - r, g), y.beginPath(), y.moveTo(S, o), y.lineTo(S, l), y.moveTo(b, o), y.lineTo(b, l), d.Graphics.stroke(y, n);
                            var C = e.labelRenderer,
                                x = this.labelStyle,
                                w = d.Graphics.getTextWidth(y, x, m),
                                L = d.Graphics.getTextWidth(y, x, v),
                                T = new d.Label({
                                    text: m,
                                    textStyle: x
                                }, !0),
                                k = new d.Label({
                                    text: v,
                                    textStyle: x
                                }, !0),
                                A = 10,
                                M = 5;
                            u < s && (u = s), c > a && (c = a), w + L + 20 < c - u ? (u += M, c = c - L - M) : (u = u - w - M, c += M);
                            var I = this.chart.shell.getChartInnerArea(),
                                P = I.findTopPosition(u, u + w),
                                D = I.findTopPosition(c, c + L);
                            C.paint(y, u + w / 2, P + A, 1, T), C.paint(y, c + L / 2, D + A, 1, k), d.Graphics.popClip(e)
                        }
                    }, i.prototype.onPointerMove = function (t) {
                        var e = this.scene,
                            i = this.settings;
                        if (i.enabled) {
                            e.xyInBottom(t.x, t.y) && (t.cursor = "text");
                            var n = !1;
                            if (null != e.selectionStart && null != e.selectionEnd && e.xyInChartOrBottom(t.x, t.y) && e.timeStart < e.timeEnd) {
                                var r = this.getLineCoordinates();
                                Math.abs(r.start - t.x) <= i.tolerance ? (t.cursor = "e-resize", t.consumed = !0, n = !0) : Math.abs(r.end - t.x) <= i.tolerance ? (t.cursor = "w-resize", t.consumed = !0, n = !0) : i.moveByDragging && r.start < t.x && r.end > t.x && (t.cursor = "move", t.consumed = !0)
                            }
                            this.isHoveringEdge = n
                        }
                    }, i.prototype.onPointerDown = function (t) {
                        var e = this.scene,
                            i = this.settings;
                        if (e.xyInChartOrBottom(t.x, t.y) && null === this.selectingPointer && i.enabled) {
                            this.selectionRemoved = !1, this.lastX = t.x;
                            var n = null,
                                r = null;
                            if (null !== e.selectionStart || null !== e.selectionEnd) {
                                var s = this.getLineCoordinates(),
                                    a = Math.abs(s.start - t.x),
                                    o = Math.abs(s.end - t.x),
                                    l = !1;
                                if (a < i.tolerance && a <= o ? (this.selectStart = e.selectionEnd, l = !0) : o < i.tolerance && o <= a ? (this.selectStart = e.selectionStart, l = !0) : i.moveByDragging && s.start < t.x && s.end > t.x && (this.isMoving = !0, this.moveStartX = t.x, this.moveStartY = t.y, this.moveSelectionStart = e.selectionStart, this.moveSelectionEnd = e.selectionEnd, this.selectStart = e.xToTime(t.x), l = !0), l) return this.selectingPointer = t.identifier, t.consumed = !0, this.roundAround = !0, void(this.isSelecting = !0)
                            }
                            e.xyInBottom(t.x, t.y) && (this.selectingPointer = t.identifier, this.selectStart = e.xToTime(t.x), t.capture = !0, this.roundAround = !0, this.isSelecting = !0, t.x >= n && t.x <= r || null !== e.selectionStart && (this.selectionRemoved = !0, e.selectionStart = null, e.selectionEnd = null, t.changes.selection = !0))
                        }
                    }, i.prototype.onPointerDrag = function (t) {
                        this.scene.displayUnit && this.selectingPointer === t.identifier && (this.dragPointer(t, t.x, t.y, t.changes), t.consumed = !0)
                    }, i.prototype.dragPointer = function (t, e, i, n) {
                        var r, s, a = this.scene;
                        if (this.isMoving) {
                            var o = a.dxToDtime(e - this.moveStartX);
                            r = this.moveSelectionStart + o, s = this.moveSelectionEnd + o;
                            var l = i - this.moveStartY,
                                h = this.settings.resizeTolerance;
                            if (Math.abs(l) > h) {
                                l = l < 0 ? l + h : l - h;
                                var u = this.moveSelectionEnd - this.moveSelectionStart,
                                    c = Math.min(u, a.dxToDtime(l * this.settings.resizeSensitivity)),
                                    p = 0 === u ? .5 : (this.selectStart - this.moveSelectionStart) / u;
                                r += c * p, s -= c * (1 - p)
                            }
                        } else {
                            var f = this.selectStart,
                                g = this.scene.xToTime(e),
                                m = Math.abs(f - g),
                                v = a.snapTimeRound(f),
                                o = v - f,
                                y = d.Helpers.sign(o);
                            v = f + Math.min(o * y, .9 * m) * y, v < g ? (r = v, s = g) : (r = g, s = v)
                        }
                        this.lastX = e, this.lastY = i, a.selectionStart = r, a.selectionEnd = s, n.selection = !0, a.settings.events.selectionChangeDuringInteraction && this.chart.notifySelectionChanged(this.chart.createEventArguments(t, "user"))
                    }, i.prototype.onPointerUp = function (t) {
                        if (this.selectingPointer === t.identifier) {
                            if (this.isSelecting) {
                                var e = this.snapSelection(),
                                    i = e.st,
                                    n = e.en;
                                i === n && (i = null, n = null);
                                var r = this.scene;
                                r.selectionStart = i, r.selectionEnd = n, null != i && (r.hoverFrom = i, r.hoverTo = n), this.chart.notifySelectionChanged(this.chart.createEventArguments(t, "user")), t.changes.selection = !0
                            }(this.isSelecting || this.selectionRemoved) && (t.consumed = !0), this.isSelecting = !1, this.isMoving = !1, this.selectStart = null, this.selectingPointer = null
                        }
                    }, i.prototype.onPointerCancel = function (t) {
                        this.onPointerUp(t)
                    }, i.prototype.snapSelection = function () {
                        var t, e, i = this.scene;
                        return null != i.selectionStart ? this.roundAround ? (t = i.snapTimeRound(i.selectionStart), e = i.snapTimeRound(i.selectionEnd)) : (t = i.snapTimeDown(i.selectionStart), e = i.snapTimeUp(i.selectionEnd)) : (t = null, e = null), {
                            st: t,
                            en: e
                        }
                    }, i
                }(d.ChartElement);
                t.Selection = S;
                var b = function (e) {
                    function i() {
                        var t = e.apply(this, arguments) || this;
                        return t.timeStart = 0, t.timeEnd = 0, t.anchor = null, t.period = null, t.displayUnit = null, t.data = {}, t.markers = [], t.mainData = null, t.selectionStart = null, t.selectionEnd = null, t.minorTimeFormat = null, t.minorTimeUnit = null, t.majorTimeUnit = null, t.majorTimeFormat = null, t.hoverFrom = null, t.hoverTo = null, t.timeScale = 0, t.lastUnit = null, t.disableScaleLimiter = !1, t.momentLocale = "zc" + (i._momentLocaleCounter++).toFixed(0), t
                    }
                    return n(i, e), i.prototype.setTimeRange = function (t, e, i) {
                        i || d.Helpers.error("Scene.setTimeRange: no display unit"), this.timeStart = t, this.timeEnd = e, this.displayUnit = i
                    }, i.prototype.pixelsPerTime = function () {
                        return this.width / (this.timeEnd - this.timeStart)
                    }, i.prototype.getScale = function () {
                        return (this.timeEnd - this.timeStart) / this.width
                    }, i.prototype.timeToX = function (t) {
                        return this.x0 + this.width * (t - this.timeStart) / (this.timeEnd - this.timeStart)
                    }, i.prototype.timeToXCoefs = function () {
                        return {
                            tadd: this.x0 - this.timeStart * this.width / (this.timeEnd - this.timeStart),
                            tmul: this.width / (this.timeEnd - this.timeStart)
                        }
                    }, i.prototype.xToTime = function (t) {
                        return this.timeStart + (this.timeEnd - this.timeStart) * (t - this.x0) / this.width
                    }, i.prototype.xToFraction = function (t) {
                        return (t - this.x0) / this.width
                    }, i.prototype.dTimeToDx = function (t) {
                        return this.width * t / (this.timeEnd - this.timeStart)
                    }, i.prototype.dxToDtime = function (t) {
                        return t / this.width * (this.timeEnd - this.timeStart)
                    }, i.prototype.snapTimeDown = function (t) {
                        return this.displayUnit.roundTimeDown(t, this.timeStepSettings)
                    }, i.prototype.snapTimeUp = function (t) {
                        return this.displayUnit.roundTimeUp(t, this.timeStepSettings)
                    }, i.prototype.snapTimeRound = function (t) {
                        return this.displayUnit.roundTimeRound(t, this.timeStepSettings)
                    }, i.prototype.getClickBar = function (t) {
                        var e = this.displayUnit;
                        return e ? {
                            time0: e.roundTimeDown(t, this.timeStepSettings),
                            time1: e.roundTimeUp(t + 1, this.timeStepSettings)
                        } : {
                            time0: null,
                            time1: null
                        }
                    }, i.prototype.getCurTime = function () {
                        var t, e = this.settings.currentTime;
                        return t = null != e.time ? e.time : (new Date).getTime(), this.timestampToInternal(t, !0)
                    }, i.prototype.timestampToInternal = function (e, i) {
                        if (null == e) return null;
                        e = +e;
                        var n = this.settings.timeAxis;
                        if (i) {
                            if (!t.moment || !t.moment.tz) return null;
                            var r = t.moment.utc(e).tz(n.timeZone),
                                s = r.utcOffset ? r.utcOffset() : r.zone();
                            e = +r + 6e4 * s
                        }
                        return e + 6e4 * n.timeZoneOffset
                    }, i.prototype.timestampFromInternal = function (e, i) {
                        if (null == e) return null;
                        var n = this.settings.timeAxis;
                        if (i) {
                            if (!t.moment || !t.moment.tz) return null;
                            var r = t.moment.utc(e).tz(n.timeZone),
                                s = r.utcOffset ? r.utcOffset() : r.zone();
                            e = +r - 6e4 * s
                        }
                        return e -= 6e4 * n.timeZoneOffset
                    }, i
                }(l.Scene);
                b._momentLocaleCounter = 0, t.Scene = b;
                var C = function () {
                    function e(t, e, i, n, r, s, a) {
                        void 0 === i && (i = []), void 0 === n && (n = null), void 0 === r && (r = null), void 0 === s && (s = !0), void 0 === a && (a = 2), this.scene = null, this.step = null, this.uniform = !1, this.currentFrom = 0, this.currentTo = 0, this.fromBar = null, this.toBar = null, this.fromIndex = 0, this.toIndex = 0, this.times = [], this.xes = [], this.oldMul = 0, this.oldAdd = 0, this.values = [], this.counts = [], this.arrays = [], this.extraArrays = [], this.bufExpandSize = 100, this.extraSteps = 2, this.uniformTolerance = 0, this.approxExtraTime = 0, this.extraSteps = a, this.uniform = s, this.step = e, this.scene = t, n = n || this.scene.timeStart, r = r || this.scene.timeEnd, this.extraArrays = i.slice(0), this.arrays = i.slice(0), this.arrays.push("xes"), this.arrays.push("times"), this.uniformTolerance = Math.min(1, this.step.count - 2), this.approxExtraTime = this.extraSteps * e.approxTime(), this.init(n - this.approxExtraTime, r + this.approxExtraTime)
                    }
                    return e.prototype.getArray = function (t) {
                        switch (t) {
                            case "xes":
                                return this.xes;
                            case "times":
                                return this.times;
                            case "values":
                                return this.values;
                            case "counts":
                                return this.counts;
                            default:
                                return d.Helpers.error("TimeSlicer: Invalid get array: '" + t + "'"), null
                        }
                    }, e.prototype.setArray = function (t, e) {
                        switch (t) {
                            case "xes":
                                return void(this.xes = e);
                            case "times":
                                return void(this.times = e);
                            case "values":
                                return void(this.values = e);
                            case "counts":
                                return void(this.counts = e);
                            default:
                                return void d.Helpers.error("TimeSlicer: Invalid set array: '" + t + "'")
                        }
                    }, e.prototype._getOrigin = function (t) {
                        var e = this.scene.timeStepSettings;
                        if (1 === this.step.count || this.uniform) return this.step.roundTimeDown(t, e);
                        var i = this.step.getBigger().roundTimeDown(t, e),
                            n = this.step.numberOfUnits(i, t);
                        return this.step.add(i, n)
                    }, e.prototype._add = function (t) {
                        if (this.uniform || 1 === this.step.count || "d" !== this.step.unit) return t.add(this.step.count, this.step.unit);
                        var e = t.daysInMonth(),
                            i = t.date();
                        return i + 2 * this.step.count > e + 1 + this.uniformTolerance ? t.add(e - i + 1, "d") : t.add(this.step.count, this.step.unit)
                    }, e.prototype._sub = function (t) {
                        if (this.uniform || 1 === this.step.count || "d" !== this.step.unit) return t.subtract(this.step.count, this.step.unit);
                        var e = t.date();
                        if (e <= this.step.count) {
                            t.subtract(1, "M");
                            var i = t.daysInMonth() - 1,
                                n = i + 1 - this.step.count + this.uniformTolerance;
                            return t.date(1 + n - (n % this.step.count | 0))
                        }
                        return t.subtract(this.step.count, this.step.unit)
                    }, e.prototype.init = function (e, i) {
                        for (var n = this, r = 0; r < this.arrays.length; r++) {
                            var s = this.arrays[r];
                            this.setArray(s, [])
                        }
                        if (e >= i) return this.fromIndex = 0, this.toIndex = 0, this.fromBar = null, void(this.toBar = null);
                        this.fromBar = t.moment(this._getOrigin(e)).utc(), this.fromIndex = 0;
                        var a = t.moment(this.fromBar).utc();
                        for (this.times.push(a.valueOf()); a.valueOf() < i;) this._add(a), this.times.push(a.valueOf());
                        this.toIndex = this.times.length, this.toBar = a, this.currentFrom = e, this.currentTo = i, this.xes = this.times.map(function (t) {
                            return n.scene.timeToX(t)
                        });
                        for (var o = 0; o < this.extraArrays.length; o++) {
                            var l = this.extraArrays[o],
                                h = [];
                            h.length = this.times.length, this.setArray(l, h)
                        }
                    }, e.prototype.makeMiniSlice = function (e) {
                        var i = this.scene.timeToXCoefs(),
                            n = i.tadd,
                            r = i.tmul,
                            s = t.moment(this._getOrigin(e)).utc(),
                            a = s.valueOf(),
                            o = n + a * r;
                        this._add(s);
                        var l = s.valueOf(),
                            h = n + l * r;
                        return {
                            t0: a,
                            x0: o,
                            t1: l,
                            x1: h
                        }
                    }, e.prototype.update = function (t, e) {
                        if (void 0 === t && (t = this.scene.timeStart), void 0 === e && (e = this.scene.timeEnd), null == e && (e = this.scene.timeEnd), null == t && (t = this.scene.timeStart), t -= this.approxExtraTime, e += this.approxExtraTime, t === this.currentFrom && e === this.currentTo) return this.updateXes(this.fromIndex, this.toIndex), {
                            offset: 0,
                            newBefore: this.fromIndex,
                            newAfter: this.toIndex
                        };
                        if (null === this.fromBar || t > this.toBar.valueOf() || e < this.fromBar.valueOf()) return this.init(t, e), {
                            offset: 0,
                            newBefore: this.toIndex,
                            newAfter: this.toIndex
                        };
                        var i = 0,
                            n = this.fromIndex,
                            r = this.toIndex,
                            s = this.scene.timeToXCoefs(),
                            a = s.tadd,
                            o = s.tmul,
                            l = this.fromBar.valueOf() - t;
                        if (l > 0) {
                            var h = (l / this.step.approxTime() | 0) + 2;
                            if (this.fromIndex < h) {
                                var u = [];
                                u.length = h + this.bufExpandSize;
                                for (var c = 0; c < this.arrays.length; c++) {
                                    var d = this.arrays[c];
                                    this.setArray(d, u.concat(this.getArray(d)))
                                }
                                i += u.length, n += u.length, r += u.length, this.fromIndex += u.length, this.toIndex += u.length
                            }
                            for (var p = this.fromBar.valueOf(); p > t;) this._sub(this.fromBar), this.fromIndex -= 1, p = this.fromBar.valueOf(), this.times[this.fromIndex] = p, this.xes[this.fromIndex] = a + p * o
                        }
                        var f = e - this.toBar.valueOf();
                        if (f > 0) {
                            var h = (f / this.step.approxTime() | 0) + 2;
                            if (this.times.length < this.toIndex + h)
                                for (var g = this.toIndex + h + this.bufExpandSize, c = 0; c < this.arrays.length; c++) {
                                    var d = this.arrays[c];
                                    this.getArray(d).length = g
                                }
                            for (var p = this.toBar.valueOf(); p < e;) this._add(this.toBar), p = this.toBar.valueOf(), this.times[this.toIndex] = p, this.xes[this.toIndex] = a + p * o, this.toIndex += 1
                        }
                        for (this._add(this.fromBar); this.fromBar.valueOf() < t;) this.fromIndex += 1, this._add(this.fromBar);
                        for (this._sub(this.fromBar), this._sub(this.toBar); this.toBar.valueOf() >= e;) this.toIndex -= 1, this._sub(this.toBar);
                        this._add(this.toBar);
                        var m = this.toIndex - this.fromIndex + this.bufExpandSize;
                        if (this.fromIndex > m) {
                            for (var v = this.fromIndex - this.bufExpandSize, c = 0; c < this.arrays.length; c++) {
                                var d = this.arrays[c];
                                this.getArray(d).splice(0, v)
                            }
                            i -= v, n -= v, r -= v, this.fromIndex -= v, this.toIndex -= v
                        }
                        if (this.toIndex < this.times.length - m)
                            for (var c = 0; c < this.arrays.length; c++) {
                                var d = this.arrays[c];
                                this.getArray(d).length = this.toIndex + this.bufExpandSize
                            }
                        return this.updateXes(n, r), this.currentFrom = t, this.currentTo = e, {
                            offset: i,
                            newBefore: n,
                            newAfter: r
                        }
                    }, e.prototype.updateXes = function (t, e) {
                        var i = this.scene.timeToXCoefs(),
                            n = i.tadd,
                            r = i.tmul;
                        if (this.oldAdd !== n || this.oldMul !== r) {
                            this.oldAdd = n, this.oldMul = r;
                            for (var s = t; s <= e - 1; s++) this.xes[s] = n + this.times[s] * r
                        }
                    }, e
                }();
                t.TimeSlicer = C;
                var x = function () {
                    function t() {
                        this.enabled = !0, this.vgrid = !0, this.minUnitWidth = 1, this.maxUnitWidth = 200, this.showHolidays = !0, this.miniTimeRuler = !0, this.unitSizePolicy = "auto", this.timeZoneOffset = null, this.timeZone = "UTC", this.style = {
                            showMinorTimeBalloons: !1,
                            showMajorTimeBalloons: !0,
                            minorTimeBalloonStyle: {
                                fillColor: "#FFF"
                            },
                            majorTimeBalloonStyle: {
                                fillColor: null
                            },
                            minorTimeLabel: {
                                fillColor: "#000000",
                                font: "12px Arial"
                            },
                            majorTimeLabel: {
                                fillColor: "#FFF",
                                font: "11px Arial"
                            },
                            dateLighten: {
                                fillColor: "rgba(255,255,255,0.2)"
                            },
                            dateHolidays: {
                                fillColor: "rgba(230,230,230,0.2)"
                            },
                            minorTimeRuler: {
                                lineColor: "rgba(0,0,0,0.2)"
                            },
                            vgrid: {
                                lineColor: "rgba(0,0,0,0.1)"
                            }
                        }
                    }
                    return t
                }();
                t.SettingsTimeAxis = x;
                var w = function (e) {
                    function i(t) {
                        var i = e.call(this) || this;
                        return i.curSceneScale = 0, i.minorFormat = null, i.majorFormat = null, i.minorTimeUnit = null, i.majorTimeUnit = null, i.minorLabelHeight = null, i.majorLabelHeight = null, i.minorLabelWidths = null, i.minorLabelBallonWidths = null, i.majorLabelWidths = null, i.fullLabelWidths = null, i.multiYearWidth = 0, i.majorSlices = null, i.minorSlices = null, i.animationOrder = 610, i.paintOrder = 30, i.updateOrder = 1e3, i.multiples = {
                            ms: [1, 10, 100],
                            s: [1, 2, 5, 15, 30],
                            m: [1, 2, 5, 15, 30],
                            h: [1, 3, 6, 12, 24],
                            d: [1, 2, 5, 10],
                            w: [1, 5, 10, 20],
                            M: [1, 3, 6],
                            y: [1, 10, 100, 1e3]
                        }, i.chart = t, i.scene = i.chart.scene, i.tt = new o(t), i.options = i.scene.settings.timeAxis, i.panel = new d.ChartPanel, i.panel.side = "bottom", i.panel.packingOrder = 100, i.panel.computeSize = function (t, e, n, r) {
                            return i.computeSize(t, e, n, r)
                        }, i
                    }
                    return n(i, e), i.prototype.computeSize = function (e, i, n, s) {
                        if (!this.options.enabled) return this.scene.bottomAxisSize = 0, {
                            width: e,
                            height: 0
                        };
                        var a = t.moment(0xc694d6e77ef8).utc(),
                            o = this.scene.settings.localization.timeAxisDates,
                            l = this.options.style.minorTimeLabel;
                        this.minorLabelHeight = .8 * d.Graphics.getTextHeight(n, this.options.style.minorTimeLabel.font), this.minorLabelWidths = {}, this.minorLabelBallonWidths = {};
                        var h;
                        for (h = 0; h < r.knownUnits.length; h++) {
                            var u = r.knownUnits[h],
                                c = d.Graphics.getTextWidth(n, l, a.format(o.minorLabelTimeFormats[u]));
                            this.minorLabelWidths[u] = c, this.minorLabelBallonWidths[u] = c + this.minorLabelHeight
                        }
                        for (l = this.options.style.majorTimeLabel, this.majorLabelHeight = .8 * d.Graphics.getTextHeight(n, this.options.style.majorTimeLabel.font), this.majorLabelWidths = {}, this.fullLabelWidths = {}, h = 0; h < r.knownUnits.length; h++) {
                            var u = r.knownUnits[h];
                            this.majorLabelWidths[u] = this.majorLabelHeight + d.Graphics.getTextWidth(n, l, a.format(o.majorLabelTimeFormats[u])), this.fullLabelWidths[u] = this.majorLabelHeight + d.Graphics.getTextWidth(n, l, a.format(o.majorLabelFullTimeFormats[u]))
                        }
                        this.multiYearWidth = d.Graphics.getTextWidth(n, l, "8888 - 8888") + this.majorLabelHeight;
                        var p = Math.round(Math.min(2.3913043 * (this.minorLabelHeight + this.majorLabelHeight), i));
                        return this.scene.bottomAxisSize = p, {
                            width: e,
                            height: p
                        }
                    }, i.prototype.onSceneChange = function (t) {
                        var e = t.changes.settingsChanges;
                        e && e.timeAxis && (t.changes.bounds = !0)
                    }, i.prototype.getPanels = function () {
                        return [this.panel]
                    }, i.prototype.getMajorLabelWidth = function (t, e) {
                        return "y" === t.unit && t.count > 1 ? this.multiYearWidth : e ? this.majorLabelWidths[t.unit] : null !== this.fullLabelWidths ? this.fullLabelWidths[t.unit] || null : null
                    }, i.prototype.computeLabels = function (t) {
                        var e, i, n = new o(this.chart),
                            s = this.scene.timeEnd - this.scene.timeStart,
                            a = n.toBiggerDisplayUnit(t);
                        if (a) {
                            var l = new r("s", 1);
                            for (e = a.isSmaller(l) ? l : a, i = this.computeMinorUnit(e), a = n.toBiggerDisplayUnit(e); a && (a.approxTime() <= .5 * s || e.approxTime() < this.scene.dxToDtime(this.getMajorLabelWidth(e, null != i)));) e = a, i = this.computeMinorUnit(e), a = n.toBiggerDisplayUnit(a)
                        }
                        if (!a) {
                            e = "y" === t.unit ? t : new r("y", 1);
                            for (var h = 0; h < this.multiples.y.length; h++) {
                                var u = this.multiples.y[h];
                                if (e = new r("y", u), i = this.computeMinorUnit(e), e.approxTime() > this.scene.dxToDtime(this.getMajorLabelWidth(e, null != i))) break
                            }
                        }
                        return {
                            minorUnit: i,
                            majorUnit: e
                        }
                    }, i.prototype.computeMinorUnit = function (t) {
                        var e = this.scene.displayUnit.clone(),
                            i = new r(r.toSmallerUnit[t.unit], 1);
                        i.unit && i.isBigger(e) && (e = i);
                        var n = e.approxTime(),
                            s = null;
                        if (null === this.minorLabelWidths) return null;
                        for (var a = 1.5 * this.scene.dxToDtime(this.minorLabelWidths[e.unit]), o = 0; o < this.multiples[e.unit].length; o++) {
                            var l = this.multiples[e.unit][o];
                            if (l < e.count && (l = e.count), e.count = l, n = e.approxTime(), a <= n) {
                                s = e;
                                break
                            }
                        }
                        return s && s.isEqual(t) && (s = null), s
                    }, i.prototype.doAnimations = function (t) {
                        if (this.scene.displayUnit && this.scene.timeStart < this.scene.timeEnd) {
                            var e = this.scene.getScale();
                            if (!(Math.abs(1 - this.curSceneScale / e) < .001)) {
                                this.curSceneScale = e;
                                var i = this.computeLabels(this.scene.displayUnit),
                                    n = i.minorUnit,
                                    r = i.majorUnit;
                                n ? (this.minorFormat = this.scene.settings.localization.timeAxisDates.minorLabelTimeFormats[n.unit], this.majorFormat = this.scene.settings.localization.timeAxisDates.majorLabelTimeFormats[r.unit]) : (this.minorFormat = null, this.majorFormat = this.scene.settings.localization.timeAxisDates.majorLabelFullTimeFormats[r.unit]), this.minorTimeUnit = n, this.majorTimeUnit = r, null !== this.majorSlices && r.approxTime() === this.majorSlices.step.approxTime() || (this.majorSlices = new C(this.scene, r)), !n || null !== this.minorSlices && n.approxTime() === this.minorSlices.step.approxTime() ? null === n && (this.minorSlices = null) : this.minorSlices = new C(this.scene, n, [], null, null, !1)
                            }
                            this.majorSlices.update(), this.minorSlices && this.minorSlices.update(), this.minorTimeUnit ? (this.scene.minorTimeFormat = this.minorFormat, this.scene.minorTimeUnit = this.minorTimeUnit) : this.scene.displayUnit && (this.scene.minorTimeUnit = this.scene.displayUnit, this.scene.minorTimeFormat = this.scene.settings.localization.timeAxisDates.minorLabelTimeFormats[this.scene.displayUnit.unit]), this.scene.majorTimeFormat = this.majorFormat, this.scene.majorTimeUnit = this.majorTimeUnit
                        }
                    }, i.prototype.paintScene = function (e) {
                        if (this.scene.displayUnit && this.options.enabled && this.scene.timeStart < this.scene.timeEnd) {
                            var i = this.scene.settings.timeAxis.style,
                                n = e.context,
                                r = e.labelRenderer,
                                s = this.scene.x0,
                                a = s + this.scene.width,
                                o = this.panel.top + 1,
                                l = this.panel.bottom,
                                h = l - o,
                                u = this.scene.y0,
                                c = this.scene.height,
                                p = l - 1.8 * this.majorLabelHeight;
                            d.Graphics.pushClip(e, s, u, this.scene.width, h + c);
                            var f = this.majorSlices.xes,
                                g = this.majorSlices.times,
                                m = this.majorSlices.fromIndex,
                                v = this.majorSlices.toIndex,
                                y = i.dateLighten;
                            if (y && y.fillColor) {
                                var S = this.majorSlices.step.numberOfUnits(0, g[m]);
                                n.beginPath();
                                for (var b = m + (0 | S) % 2; b <= v - 2; b += 2) {
                                    var C = (0 | Math.max(f[b], s)) + 1,
                                        x = 0 | Math.min(f[b + 1], a);
                                    n.rect(C, o - 1, x - C, h)
                                }
                                d.Graphics.fill(n, y)
                            }
                            if (this.options.showHolidays && this.minorSlices && ("w" === this.minorSlices.step.unit || "d" === this.minorSlices.step.unit || "h" === this.minorSlices.step.unit)) {
                                var w = this.scene.timeToXCoefs(),
                                    L = w.tadd,
                                    T = w.tmul,
                                    k = 864e5,
                                    A = this.scene.timeStart;
                                A = Math.round(A - A % k);
                                for (var M = t.moment(A).utc().isoWeekday(), I = this.scene.settings.localization.holidayWeekdays, P = i.dateHolidays, D = d.Graphics.beginStrokeAndFill(n, P), C = A * T + L; C <= a;) {
                                    var x = C + T * k;
                                    I.indexOf(M) > -1 && D.rect(C, u, x - C, Math.min(5, h) + c), M = M % 7 + 1, C = x
                                }
                                d.Graphics.endStrokeAndFill(n, D, P)
                            }
                            if (this.options.vgrid) {
                                for (var N = d.Graphics.beginStrokeAndFill(n, this.options.style.vgrid), b = m + 1; b <= v - 2; b++) {
                                    var F = (0 | f[b]) + .5;
                                    if (F >= a) break;
                                    N.moveTo(F, u), N.lineTo(F, l)
                                }
                                d.Graphics.endStrokeAndFill(n, N, this.options.style.vgrid)
                            }
                            var O = "y" === this.majorSlices.step.unit && this.majorSlices.step.count > 1,
                                E = this.getMajorLabelWidth(this.majorSlices.step, null != this.minorFormat),
                                R = this.scene.momentLocale;
                            if (!this.minorSlices || this.majorSlices.step.unit !== this.minorSlices.step.unit) {
                                if (i.showMajorTimeBalloons) {
                                    n.beginPath();
                                    for (var b = m; b <= v - 2; b++) {
                                        var H = f[b],
                                            B = f[b + 1];
                                        if (!(H >= a || B <= s)) {
                                            var z = (H + B) / 2;
                                            H < s && (H = s, z = Math.min((H + B) / 2, B - E)), B > a && (B = a, z = Math.max((H + B) / 2, H + E)), d.Graphics.strokeBalloon2(n, z, p + 1, E, this.majorLabelHeight)
                                        }
                                    }
                                    d.Graphics.paint(n, i.majorTimeBalloonStyle)
                                }
                                for (var b = m; b <= v - 2; b++) {
                                    var H = f[b],
                                        B = f[b + 1];
                                    if (!(H >= a || B <= s)) {
                                        var A = g[b],
                                            U = void 0;
                                        if (O) {
                                            var G = g[b + 1] - 1;
                                            U = t.moment.utc(A).locale(R).format(this.majorFormat) + " - " + t.moment(G).locale(R).utc().format(this.majorFormat)
                                        } else U = t.moment.utc(A).locale(R).format(this.majorFormat);
                                        var z = (H + B) / 2;
                                        H < s && (H = s, z = Math.min((H + B) / 2, B - E)), B > a && (B = a, z = Math.max((H + B) / 2, H + E));
                                        var j = new d.Label({
                                            text: U,
                                            textStyle: i.majorTimeLabel
                                        }, !0);
                                        r.paint(n, z, p, 1, j)
                                    }
                                }
                            }
                            var W = this.scene.settings.timeAxis,
                                V = W.style.minorTimeRuler;
                            if (this.minorSlices) {
                                g = this.minorSlices.times, f = this.minorSlices.xes, m = this.minorSlices.fromIndex, v = this.minorSlices.toIndex, E = this.minorLabelWidths[this.minorSlices.step.unit];
                                var Z = o + .4 * this.minorLabelHeight | 0,
                                    Y = o - 1,
                                    q = Z + 1.6 * this.minorLabelHeight | 0;
                                if (i.showMinorTimeBalloons) {
                                    n.beginPath();
                                    for (var b = m; b <= v - 1; b++) {
                                        var F = f[b];
                                        d.Graphics.strokeBalloon(n, F, o - 5, E, this.minorLabelHeight)
                                    }
                                    d.Graphics.paint(n, i.minorTimeBalloonStyle)
                                } else {
                                    var _ = this.majorSlices.fromIndex,
                                        X = this.majorSlices.xes;
                                    n.beginPath();
                                    for (var Q = _, b = m; b <= v - 1; b++) {
                                        for (var F = f[b]; F > X[Q];) Q += 1;
                                        if (X[Q] !== F) {
                                            if (F >= a) break;
                                            F = (0 | F) - .5, n.moveTo(F, Y), n.lineTo(F, q)
                                        }
                                    }
                                    d.Graphics.stroke(n, V)
                                }
                                for (var J = i.showMinorTimeBalloons ? "center" : "left", K = i.showMinorTimeBalloons ? 0 : 3, b = m; b <= v - 1; b++) {
                                    var F = f[b],
                                        A = g[b],
                                        U = t.moment(A).locale(R).utc().format(this.minorFormat),
                                        j = new d.Label({
                                            text: U,
                                            aspectRatio: 1e9,
                                            align: J,
                                            textStyle: i.minorTimeLabel
                                        });
                                    r.measure(n, j);
                                    var $ = F + K + j.hwidth;
                                    r.paint(n, $, Z + j.hheight, 1, j)
                                }
                            }
                            var tt = this.chart.dataWarehouse.getDisplayUnitsSlicer();
                            if (W.miniTimeRuler && V && tt && tt.xes[tt.fromIndex + 1] - tt.xes[tt.fromIndex] > 4) {
                                var et = o - 1,
                                    it = o + 3;
                                f = tt.xes;
                                var nt = this.majorSlices.fromIndex,
                                    rt = this.minorSlices ? this.minorSlices.fromIndex : nt,
                                    st = this.majorSlices.xes,
                                    at = this.minorSlices ? this.minorSlices.xes : st;
                                n.beginPath();
                                for (var ot = nt, lt = rt, ht = 0, b = tt.fromIndex; b <= tt.toIndex - 2; b++) {
                                    for (var F = f[b]; F > st[ot];) ot += 1;
                                    if (st[ot] !== F) {
                                        for (; F > at[lt];) lt += 1;
                                        if (at[lt] !== F) {
                                            if (F >= a) break;
                                            F = (0 | F) - .5, n.moveTo(F, et), n.lineTo(F, it), ht++
                                        }
                                    }
                                }
                                if (ht && d.Graphics.stroke(n, V), this.scene.settings.advanced.themeCSSClass.indexOf("gradient") !== -1) {
                                    var ut = d.Colors.colorTone(V.lineColor, 2, 2);
                                    ht = 0, n.beginPath(), ot = nt, lt = rt;
                                    for (var b = tt.fromIndex; b <= tt.toIndex - 2; b++) {
                                        for (var F = f[b]; F > st[ot];) ot += 1;
                                        if (st[ot] !== F) {
                                            for (; F > at[lt];) lt += 1;
                                            if (at[lt] !== F) {
                                                if (F >= a) break;
                                                F = (0 | F) + .5, n.moveTo(F, et), n.lineTo(F, it), ht++
                                            }
                                        }
                                    }
                                    ht && d.Graphics.stroke(n, {
                                        lineColor: ut.color
                                    })
                                }
                            }
                            d.Graphics.popClip(e)
                        }
                    }, i
                }(d.ChartElement);
                t.TimeAxis = w;
                var L = function () {
                    function t() {
                        this.enabled = !0, this.label = {
                            padding: 3,
                            margin: 3,
                            aspectRatio: 3,
                            align: "center",
                            textStyle: {
                                fillColor: "white",
                                font: "12px Arial"
                            },
                            backgroundStyle: {
                                lineColor: "#0099cc",
                                fillColor: "#0099cc"
                            }
                        }, this.align = "left", this.side = "top", this.style = {
                            lineColor: "#0099cc"
                        }, this.time = null, this.overrideLimits = !1, this.showTime = !1
                    }
                    return t
                }();
                t.SettingsMarker = L;
                var T = function () {
                    function t(t, e, i) {
                        if (this.labelCacheUnit = null, this.labelCacheTime = null, this.initialText = null, this.isMilestone = !0, this.settings = e, this.label = new d.Label(e.label), i) {
                            var n = d.Helpers.clone(i);
                            d.Helpers.extendStyleTo(this.label.style.textStyle, n), n.fillColor || (n.fillColor = e.style.lineColor), this.label.style.textStyle = n
                        }
                        null != e.time ? this.time = t.timestampToInternal(e.time, !0) : this.time = null, this.initialText = this.label.text || null
                    }
                    return t
                }();
                t.Marker = T;
                var k = function (e) {
                    function i(t) {
                        var i = e.call(this) || this;
                        return i.animationOrder = 2e3, i.paintOrder = 40, i.updateOrder = 800, i.scene = null, i._initialized = !1, i.chart = t, i.scene = i.chart.scene, i
                    }
                    return n(i, e), i.prototype.onSceneChange = function (t) {
                        if (this.chart.assetsLoaded) {
                            var e = t.changes,
                                i = e.settingsChanges,
                                n = i && i.milestones;
                            (!this._initialized || n || e.assets) && (this.createMarkers(), this._initialized = !0), (e.time || n) && this.scene.markers.sort(function (t, e) {
                                return t.time - e.time
                            })
                        }
                    }, i.prototype.paintScene = function (t) {
                        var e = this.scene,
                            i = e.markers,
                            n = t.labelRenderer,
                            r = t.context;
                        if (0 !== i.length && e.displayUnit) {
                            var s = Math.round(e.y0);
                            r.textBaseline = "middle", d.Graphics.pushClip(t, e.x0, Math.round(e.y0), e.width, e.height + e.bottomAxisSize);
                            for (var a = this.getRenderingParts(t, i), o = a.lines, l = 0; l < o.length; l++) {
                                var h = o[l],
                                    u = d.Graphics.beginStrokeAndFill(r, h.style),
                                    c = "bottom" === h.side ? this.getTopPos(h.x, 0) : s + e.height;
                                c = Math.round(c), u.moveTo(h.x, c), u.lineTo(h.x, h.y), d.Graphics.endStrokeAndFill(r, u, h.style)
                            }
                            for (var p = a.labels, f = 0; f < p.length; f++) {
                                var g = p[f];
                                n.paint(r, g.x, g.y, 1, g.label)
                            }
                            d.Graphics.popClip(t)
                        }
                    }, i.prototype.getRenderingParts = function (e, i) {
                        for (var n = e.context, r = this.scene, s = e.labelRenderer, a = r.displayUnit.unit, o = r.settings.localization.markerDates.timeFormats[a], l = r.x0, h = l + r.width, u = Math.round(r.y0), c = Math.round(u + r.height), d = [], p = [], f = [], g = [], m = [], v = [], y = [], S = [], b = this.scene.momentLocale, C = 0; C < i.length; C++) {
                            var x = i[C],
                                w = r.timeToX(x.time);
                            w = Math.floor(w) + .5, x.labelCacheUnit === a && x.labelCacheTime === x.time || (null !== x.initialText ? (x.label.text = x.initialText, x.settings.showTime && (x.label.text += " " + t.moment(x.time).locale(b).utc().format(o).replace(/ /g, "Â "))) : x.settings.showTime && (x.label.text = t.moment(x.time).locale(b).utc().format(o).replace(/ /g, "Â ")), s.measure(n, x.label), x.labelCacheUnit = a, x.labelCacheTime = x.time);
                            var L = x.label.style.margin || 0,
                                T = x.label.hwidth + L,
                                k = x.label.hheight + L,
                                A = 2 * T,
                                M = 2 * k;
                            if (w + T >= l - 1 && w - T <= h + 1) {
                                var I = x.settings.align,
                                    P = "center" === I ? T : A;
                                w + P >= h ? (I = "left", w -= 2) : w - P <= l && (I = "right", w += 2);
                                var D = w - T,
                                    N = w + T,
                                    F = w;
                                "left" === I ? (F = w - T + L, N = w, D = w - A) : "right" === I && (F = w + T - L, N = w + A, D = w);
                                var O = [],
                                    E = -1,
                                    R = D < l ? Math.max(l, D) : D > h ? Math.min(h, D) : D,
                                    H = this.getTopPos(R, P),
                                    B = "top" === x.settings.side ? H : Math.round(r.height + .5 * r.bottomAxisSize);
                                if (0 !== d.length)
                                    for (;;) {
                                        var z = E !== -1 ? f[E] + m[E] : B,
                                            U = z + M;
                                        E = -1;
                                        for (var G = 0; G < d.length; G++)
                                            if (O.indexOf(G) === -1) {
                                                var j = p[G],
                                                    W = d[G],
                                                    V = f[G],
                                                    Z = g[G],
                                                    Y = D >= W && D <= j || N >= W && N <= j || D <= W && N >= j,
                                                    q = z >= V && z <= Z || U >= V && U <= Z || z <= V && U >= Z;
                                                if (Y && q) {
                                                    O.push(G), B = f[G] + m[G], E = G;
                                                    break
                                                }
                                            }
                                        if (E === -1) break
                                    }
                                var _ = void 0;
                                "top" === x.settings.side ? _ = B + k : (c = u + r.height - k + L, _ = Math.min(B, r.height + .5 * r.bottomAxisSize)), _ = (0 | _) + .5, m.push(M), v.push(A), f.push(B), g.push(B + M), d.push(D), p.push(D + A);
                                var X = {
                                    value: c,
                                    changes: !1
                                };
                                null != x.animator && (X = x.animator.updateAndGet(_, e.timeStamp)), y.push({
                                    x: w,
                                    y: X.value + k - L,
                                    style: x.settings.style,
                                    side: x.settings.side
                                }), S.push({
                                    x: F,
                                    y: X.value,
                                    label: x.label
                                }), X.changes && (e.animating = !0)
                            }
                        }
                        return {
                            lines: y,
                            labels: S
                        }
                    }, i.prototype.getTopPos = function (t, e) {
                        var i = this.scene.x0 + this.scene.width,
                            n = this.chart.shell.getChartInnerArea();
                        return n.findTopPosition(t, Math.min(t + e, i))
                    }, i.prototype.createMarkers = function () {
                        var t = this.scene,
                            e = t.markers.filter(function (t) {
                                return !t.isMilestone
                            }),
                            i = t.settings,
                            n = i.milestones;
                        for (var r in n) {
                            var s = n[r];
                            if (s.enabled) {
                                var a = new T(t, s, i.area.style.markerText);
                                a.animator = new d.Animator(0, 0, 200), e.push(a)
                            }
                        }
                        t.markers = e
                    }, i
                }(d.ChartElement);
                t.Markers = k;
                var A = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.showTime = !0, e.align = "left", e.side = "bottom", e.label = {
                            margin: 4,
                            padding: 3,
                            textStyle: {
                                font: "12px Arial",
                                fillColor: "red"
                            }
                        }, e.style = {
                            lineColor: "red"
                        }, e
                    }
                    return n(e, t), e
                }(L);
                t.SettingsCurrentTime = A;
                var M = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.animationOrder = 100, i.paintOrder = 35, i.updateOrder = 900, i.marker = null, i.timeTimerUnit = null, i.timeTimer = null, i.timeTimerTarget = -(1 / 0), i.timeTickerEnabled = !1, i.timeTimerCheckAlways = !1, i._lastAnchor = null, i.chart = e, i.settings = i.chart.settings, i.scene = i.chart.scene, i.events = i.chart.events, i.createMarker(), i.updateTimers(), i
                    }
                    return n(e, t), e.prototype.updateTimers = function () {
                        var t = this,
                            e = this.settings.advanced;
                        this.timeTickerEnabled = e.timeUpdateInterval && (this.settings.currentTime.enabled || "now" === this.scene.anchor), this.timeTickerEnabled ? this.updateCurTime() : this.timeTimer && (clearTimeout(this.timeTimer), this.timeTimer = null), e.dataUpdateInterval ? this.dataTimer = setInterval(function () {
                            return t.dataTick()
                        }, e.dataUpdateInterval) : this.dataTimer && (clearInterval(this.dataTimer), this.dataTimer = null)
                    }, e.prototype.createMarker = function () {
                        var t = this.settings.currentTime,
                            e = this.marker,
                            i = this.scene.markers;
                        e && (i.splice(i.indexOf(e), 1), this.marker = null), t.enabled && (e = this.marker = new T(this.scene, t, null), e.isMilestone = !1, i.push(e))
                    }, e.prototype.onSceneChange = function (t) {
                        var e = !1,
                            i = t.changes.settingsChanges;
                        i && ((i.advanced || i.currentTime) && (this.updateTimers(), e = !0), i.currentTime && this.createMarker()), this._lastAnchor !== this.scene.anchor && (e || this.updateTimers(), this._lastAnchor = this.scene.anchor), this.timeTickerEnabled && (t.changes.timeMarker || t.changes.time && (this.timeTimerCheckAlways || !this.timeTimer || this.scene.getScale() < this.timeTimerUnit)) && (this.updateCurTime(), this.updateVisiblePeriod())
                    }, e.prototype.timerTick = function () {
                        this.timeTimer = null, this.chart.removed || (this.updateCurTime(), this.updateVisiblePeriod())
                    }, e.prototype.dataTick = function () {
                        var t = this;
                        if (this.dataTimer = null, !this.chart.removed && this.scene.displayUnit) {
                            var e = this.scene.getCurTime(),
                                i = function () {
                                    t.updateVisiblePeriod()
                                };
                            for (var n in this.chart.data) {
                                var r = this.chart.data[n];
                                r.updateData(this.scene.displayUnit, e, i)
                            }
                        }
                    }, e.prototype.doAnimations = function (t) {
                        t.changes.data && this.updateVisiblePeriod()
                    }, e.prototype.updateCurTime = function (t) {
                        var e = this,
                            i = this.scene;
                        this.timeTimerUnit = i.getScale();
                        var n = i.getCurTime();
                        this.marker && (this.marker.time = n);
                        var r = i.timeToX(n);
                        if (!isNaN(r)) {
                            var s = r + 200 > i.x0 && r - 200 < i.x0 + i.width,
                                a = this.settings.advanced.timeUpdateInterval,
                                o = 0;
                            if (s) this.timeTimerCheckAlways = !1, void 0 === t && this.events.notifySceneChanges({
                                requestPaint: !0
                            }), i.displayUnit.approxTime() >= 36e5 && (o = (i.xToTime(r + 1 | 0) - n) / 2, a = Math.max(a, o), o /= 4);
                            else {
                                if (r > 0) return;
                                a = Math.max(a, i.dxToDtime(-r - 200) / 2), this.timeTimerCheckAlways = !0
                            }
                            var l = +new Date;
                            if (this.timeTimer) {
                                var h = this.timeTimerTarget - l;
                                if (h < a + o) return;
                                window.clearTimeout(this.timeTimer)
                            }
                            s && i.dTimeToDx(a) > 1 ? this.events.notifySceneChanges({
                                timeMarker: !0
                            }) : (this.timeTimerTarget = l + a, this.timeTimer = setTimeout(function () {
                                return e.timerTick()
                            }, a))
                        }
                    }, e.prototype.updateVisiblePeriod = function () {
                        var t = this.scene,
                            e = t.displayUnit;
                        if (e && this.settings.navigation.followAnchor) {
                            var i = null;
                            if ("now" === t.anchor) {
                                var n = t.getCurTime();
                                i = n
                            } else if ("newestData" === t.anchor) {
                                var r = this.chart.getDataLimits().to;
                                i = r
                            }
                            if (null !== i) {
                                var s = this.chart.scrolling,
                                    a = s.getTo();
                                if (a < i) {
                                    var o = s.getFrom(),
                                        l = e.roundTimeUp(i, t.timeStepSettings) - a;
                                    this.chart.scrolling.setTimeRangeSnap(o + l, a + l, a + l, t.displayUnit, !0, "timer", !0, !1)
                                }
                            }
                        }
                    }, e
                }(d.ChartElement);
                t.TimeUpdater = M;
                var I = function (t) {
                    function e(i) {
                        var n = t.call(this, d.SettingsMapping.TimeChartSettings) || this;
                        return n._minUnit = null, n._displayUnitsParsed = [], n._displayPeriodsParsed = [], n._computedDataMap = {}, n.theme = e.FlatTheme, n.navigation = {
                            initialDisplayAnchor: "newestData",
                            initialDisplayPeriod: "max",
                            initialDisplayUnit: "auto",
                            followAnchor: !1
                        }, n.area = new W, n.chartTypes = {
                            columns: {
                                type: "columns"
                            },
                            line: {
                                type: "line"
                            },
                            candlestick: {
                                type: "candlestick"
                            }
                        }, n.currentTime = new A, n.milestones = [], n.timeAxis = new x, n.data = [], n.toolbar = new a, n.localization = new z, n.interaction = new G, n.advanced = new B, n.events = new H, n.advanced.assets.push({
                            // url: "assets://moment.js",
                            // url: "./src/dist/assets/js/moment.js",
                            url: "https://zoomcharts.com/dvsl/lib/assets/moment.js",
                            required: function () {
                                return !window.moment
                            }
                        }), n.advanced.assets.push({
                            // url: "assets://moment-tz.js",
                            // url: "./src/dist/assets/js/moment-tz.js",
                            url: "https://zoomcharts.com/dvsl/lib/assets/moment-tz.js",
                            required: function () {
                                return !window.moment || !window.moment.tz
                            }
                        }), n.apply(i), n._initializing = !1, n
                    }
                    return n(e, t), e.prototype.timeZoneCompatibility = function () {
                        var t = this.timeAxis;
                        null == t.timeZone && (t.timeZone = "UTC", d.Helpers.warn("`null` is not a valid value for `timeAxis.timeZone`, using `UTC`")), "local" === t.timeZoneOffset && (t.timeZoneOffset = -(new Date).getTimezoneOffset());
                        for (var e = this.data, i = 0; i < e.length; i++) {
                            var n = e[i];
                            null != n.timeZoneOffset && (d.Helpers.error("Setting `data.timeZoneOffset` has been deprecated. Please use `timeZone` in the data response instead."), "local" === n.timeZoneOffset && (n.timeZoneOffset = -(new Date).getTimezoneOffset()))
                        }
                    }, e.prototype.apply = function (e) {
                        this.applyCompatibility(e, [{
                            from: "toolbars",
                            to: "toolbar"
                        }, {
                            from: "toolbar.periodSelection",
                            to: "toolbar.displayPeriod"
                        }, {
                            from: "toolbar.zoomOutButton",
                            to: "toolbar.zoomOut"
                        }, {
                            from: "toolbar.backButton",
                            to: "toolbar.back"
                        }, {
                            from: "interaction.scrolling.noData",
                            to: "interaction.scrolling.limitMode"
                        }, {
                            from: "interaction.scrolling.noDataSnapBackProportion",
                            to: "interaction.scrolling.overscrollProportion",
                            transform: function (t) {
                                return 1 - t
                            }
                        }, {
                            from: "area.initialDisplayPeriod",
                            to: "navigation.initialDisplayPeriod"
                        }, {
                            from: "area.initialDisplayAnchor",
                            to: "navigation.initialDisplayAnchor"
                        }, {
                            from: "area.initialDisplayUnit",
                            to: "navigation.initialDisplayUnit"
                        }, {
                            from: "area.followAnchor",
                            to: "navigation.followAnchor"
                        }, {
                            from: "timeAxis.timeZoneOffset",
                            alternative: "timeAxis.timeZone"
                        }, {
                            from: "timeAxis.style.vgrid",
                            to: "timeAxis.style.vgrid.lineColor",
                            filter: function (t) {
                                return "string" == typeof t
                            }
                        }, {
                            from: "currentTime.overrideCurTime",
                            to: "currentTime.time"
                        }, {
                            from: "advanced.maxUnitsToDisplay",
                            alternative: "timeAxis.minUnitWidth"
                        }]);
                        var i = t.prototype.apply.call(this, e, P);
                        return this.timeZoneCompatibility(), this._calcMinUnit(), this._displayUnitsParsed = this._parseUnits(this.area.displayUnits), this._displayPeriodsParsed = this._parsePeriods(this.area.displayPeriods), i
                    }, e.prototype._parseUnits = function (t) {
                        for (var e = [], i = 0; i < t.length; i++) {
                            var n = t[i],
                                s = r.parse(n.unit, n.name);
                            this._minUnit.isSmallerOrEqual(s) && e.push(s)
                        }
                        return e.sort(function (t, e) {
                            return t.approxTime() - e.approxTime()
                        })
                    }, e.prototype._parsePeriods = function (t) {
                        for (var e = [], i = 0; i < t.length; i++) {
                            var n = r.parse(t[i].unit);
                            n && this._minUnit.isSmallerOrEqual(n) && e.push(n)
                        }
                        return e.sort(function (t, e) {
                            return t.approxTime() - e.approxTime()
                        })
                    }, e.prototype._calcMinUnit = function () {
                        for (var t = new r("y", 1e6), e = t, i = 0; i < this.area.displayUnits.length; i++) {
                            var n = this.area.displayUnits[i],
                                s = r.parse(n.unit, n.name);
                            s.isSmaller(t) && (t = s)
                        }
                        for (var i = 0; i < this._computedSeries.length; i++) {
                            var a = this._computedSeries[i],
                                o = this._computedDataMap[a.data.source];
                            if (!o) throw new Error("Data source `" + a.data.source + "` for series not found!");
                            for (var l = 0; l < o.units.length; l++) {
                                var h = o.units[l],
                                    u = r.parse(h);
                                u.isSmaller(e) && (e = u)
                            }
                        }
                        e.isBigger(t) && (t = e), this._minUnit = t
                    }, e
                }(l.Settings);
                I.StaticChart = {
                    interaction: {
                        zooming: {
                            enabled: !1,
                            click: !1
                        },
                        selection: {
                            enabled: !1
                        },
                        scrolling: {
                            enabled: !1
                        },
                        resizing: {
                            enabled: !1
                        }
                    },
                    toolbar: {
                        items: ["export"]
                    }
                }, I.DarkTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-flat DVSL-dark",
                        style: {
                            loadingArcStyle: {
                                lineColor: "#EEE"
                            },
                            messageTextStyle: {
                                fillColor: "#EEE"
                            }
                        }
                    },
                    area: {
                        style: {
                            fillColor: "rgba(28,26,28,.1)",
                            noData: {
                                fillColor: "#DDD",
                                image: "builtin://linearchart-no-data-light"
                            },
                            selection: {
                                lineColor: "#838283"
                            },
                            selectionLabel: {
                                fillColor: "#BFBBB9"
                            },
                            zoomHighlight: {
                                fillColor: "rgba(142,142,142,0.15)"
                            },
                            zoomHighlightInactive: {
                                fillColor: "rgba(142,142,142,0.15)"
                            }
                        }
                    },
                    title: {
                        margin: 15,
                        style: {
                            fillColor: "#A8A7A8"
                        }
                    },
                    chartTypes: {
                        columns: {
                            style: {
                                gradient: 1,
                                depth: 0
                            }
                        }
                    },
                    valueAxisDefault: {
                        style: {
                            valueLabel: {
                                textStyle: {
                                    fillColor: "#A8A7A8"
                                }
                            },
                            title: {
                                textStyle: {
                                    fillColor: "#A8A7A8"
                                }
                            }
                        }
                    },
                    timeAxis: {
                        style: {
                            majorTimeLabel: {
                                fillColor: "#A8A7A8",
                                shadowColor: null
                            },
                            minorTimeLabel: {
                                fillColor: "#A8A7A8",
                                shadowColor: null
                            },
                            minorTimeRuler: {
                                lineColor: "#838283"
                            },
                            dateLighten: {
                                fillColor: "rgba(142,142,142,0.15)"
                            },
                            dateHolidays: {
                                fillColor: "rgba(139,139,139,0.11)"
                            }
                        }
                    },
                    info: {
                        style: {
                            highlight: {
                                fillColor: "rgba(142,142,142,0.15)"
                            }
                        }
                    },
                    currentTime: {
                        style: {
                            lineColor: "#D12E2B"
                        }
                    },
                    legend: {
                        text: {
                            fillColor: "#A8A7A8"
                        },
                        advanced: {
                            disabledSeries: {
                                textColor: "rgba(168,167,168,0.5)",
                                lineColor: "rgba(117,117,117,0.8)"
                            }
                        }
                    }
                }, I.FlatTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-flat"
                    },
                    area: {
                        style: {
                            noData: {
                                fillColor: "#DDD",
                                image: "builtin://linearchart-no-data-light"
                            }
                        }
                    },
                    chartTypes: {
                        columns: {
                            style: {
                                gradient: 1,
                                depth: 0
                            }
                        }
                    },
                    timeAxis: {
                        style: {
                            showMajorTimeBalloons: !1,
                            showMinorTimeBalloons: !1,
                            majorTimeLabel: {
                                fillColor: "#000",
                                shadowColor: null
                            },
                            minorTimeLabel: {
                                fillColor: "#000",
                                shadowColor: null
                            },
                            dateLighten: {
                                fillColor: "rgba(0,0,0,0.05)"
                            }
                        }
                    }
                }, I.RoundTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-round"
                    },
                    valueAxisDefault: {
                        style: {
                            valueLabel: {
                                textStyle: {
                                    fillColor: "#000000",
                                    font: "11px Arial",
                                    shadowOffsetX: 0,
                                    shadowOffsetY: 1,
                                    shadowBlur: 0,
                                    shadowColor: "rgba(255,255,255,0.5)"
                                }
                            }
                        }
                    },
                    timeAxis: {
                        style: {
                            showMinorTimeBalloons: !1,
                            showMajorTimeBalloons: !0,
                            minorTimeBalloonStyle: {
                                fillColor: "#FFF",
                                shadowOffsetX: 0,
                                shadowOffsetY: 2,
                                shadowBlur: 2,
                                shadowColor: "#888"
                            },
                            majorTimeBalloonStyle: {
                                fillColor: "#AAA",
                                shadowOffsetX: 0,
                                shadowOffsetY: -1,
                                shadowBlur: 0,
                                shadowColor: "rgba(0,0,0,0.3)"
                            },
                            minorTimeLabel: {
                                fillColor: "#000000",
                                font: "12px Arial",
                                shadowOffsetX: 0,
                                shadowOffsetY: 1,
                                shadowBlur: 0,
                                shadowColor: "rgba(255,255,255,0.5)"
                            },
                            majorTimeLabel: {
                                fillColor: "#FFF",
                                font: "11px Arial",
                                shadowOffsetX: 0,
                                shadowOffsetY: 1,
                                shadowBlur: 1,
                                shadowColor: "#7c7c7c"
                            },
                            minorTimeRuler: {
                                lineColor: "rgba(0,0,0,0.2)"
                            },
                            dateLighten: {
                                fillColor: "rgba(0,0,0,0.05)"
                            }
                        }
                    },
                    chartTypes: {
                        columns: {
                            style: {
                                gradient: .8,
                                depth: 3
                            }
                        }
                    },
                    area: {
                        style: {
                            noData: {
                                image: "builtin://linearchart-no-data-dark"
                            }
                        }
                    }
                }, I.GradientTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-gradient"
                    },
                    valueAxisDefault: {
                        style: {
                            valueLabel: {
                                textStyle: {
                                    fillColor: "#000000",
                                    font: "11px Arial",
                                    shadowOffsetX: 0,
                                    shadowOffsetY: 1,
                                    shadowBlur: 0,
                                    shadowColor: "rgba(255,255,255,0.5)"
                                }
                            }
                        }
                    },
                    timeAxis: {
                        style: {
                            showMinorTimeBalloons: !1,
                            showMajorTimeBalloons: !0,
                            minorTimeBalloonStyle: {
                                fillColor: "#FFF",
                                shadowOffsetX: 0,
                                shadowOffsetY: 2,
                                shadowBlur: 2,
                                shadowColor: "#888"
                            },
                            majorTimeBalloonStyle: {
                                fillColor: "AAA",
                                shadowOffsetX: 0,
                                shadowOffsetY: -1,
                                shadowBlur: 0,
                                shadowColor: "rgba(0,0,0,0.3)"
                            },
                            minorTimeLabel: {
                                fillColor: "#000000",
                                font: "12px Arial",
                                shadowOffsetX: 0,
                                shadowOffsetY: 1,
                                shadowBlur: 0,
                                shadowColor: "rgba(255,255,255,0.5)"
                            },
                            majorTimeLabel: {
                                fillColor: "#FFF",
                                font: "11px Arial",
                                shadowOffsetX: 0,
                                shadowOffsetY: 1,
                                shadowBlur: 1,
                                shadowColor: "#7c7c7c"
                            },
                            minorTimeRuler: {
                                lineColor: "rgba(0,0,0,0.2)"
                            },
                            dateLighten: {
                                fillColor: "rgba(255,255,255,0.2)"
                            }
                        }
                    },
                    chartTypes: {
                        columns: {
                            style: {
                                gradient: .8,
                                depth: 3
                            }
                        }
                    },
                    area: {
                        style: {
                            noData: {
                                image: "builtin://linearchart-no-data-dark"
                            }
                        }
                    }
                }, t.Settings = I;
                var P = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.data = new D, e
                    }
                    return n(e, t), e.getMapping = function (t, e) {
                        if (t && e.type && t.type !== e.type) throw new Error("It is not possible to change the value of `type` property for an existing layer.");
                        switch (t ? t.type : e.type) {
                            case "columns":
                            case void 0:
                                return d.SettingsMapping.TimeChartSettingsSeriesColumns;
                            case "candlestick":
                                return d.SettingsMapping.TimeChartSettingsSeriesCandleStick;
                            case "line":
                                return d.SettingsMapping.TimeChartSettingsSeriesLines;
                            default:
                                throw new Error("The value '" + e.type + "' is not valid for the `type` property of a series. Valid values are: columns, candlestick, line.")
                        }
                    }, e.createInstance = function (t, e) {
                        switch (e || t.type) {
                            case "columns":
                            case void 0:
                                return new N;
                            case "candlestick":
                                return new R;
                            case "line":
                                return new F;
                            default:
                                throw new Error("The value '" + (e || t.type) + "' is not valid for the `type` property of a series. Valid values are: columns, candlestick, line.")
                        }
                    }, e
                }(l.SettingsSeries);
                t.SettingsSeries = P;
                var D = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.index = 1, e.countIndex = null, e
                    }
                    return n(e, t), e
                }(l.SettingsSeriesData);
                t.SettingsSeriesData = D;
                var N = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.data = new D, e
                    }
                    return n(e, t), e
                }(l.SettingsSeriesColumns);
                t.SettingsSeriesColumns = N;
                var F = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.data = new D, e.style = new O, e
                    }
                    return n(e, t), e
                }(l.SettingsSeriesLines);
                t.SettingsSeriesLines = F;
                var O = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.markerStyleFunction = null, e
                    }
                    return n(e, t), e
                }(l.SettingsSeriesLinesStyle);
                t.SettingsSeriesLinesStyle = O;
                var E = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.high = null, e.open = null, e.close = null, e.low = null, e
                    }
                    return n(e, t), e
                }(D);
                t.SettingsSeriesCandleStickData = E;
                var R = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.data = new E, e
                    }
                    return n(e, t), e
                }(l.SettingsSeriesCandleStick);
                t.SettingsSeriesCandleStick = R;
                var H = function (t) {
                    function e() {
                        var e = t.call(this) || this;
                        return e.selectionChangeDuringInteraction = !1, e.onTimeChange = null, e.chartUpdateDelay = 400, e
                    }
                    return n(e, t), e
                }(l.SettingsEvents);
                t.SettingsEvents = H;
                var B = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.timeUpdateInterval = 900, e.dataUpdateInterval = null, e.maxUnitsToDisplay = 2e4, e
                    }
                    return n(e, t), e
                }(d.SettingsAdvanced);
                t.SettingsAdvanced = B;
                var z = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.calendar = {
                            parentLocale: null
                        }, e.holidayWeekdays = [6, 7], e.toolbar = new U, e.timeUnitsNames = {
                            ms: "millisecond",
                            s: "second",
                            m: "minute",
                            h: "hour",
                            d: "day",
                            w: "week",
                            M: "month",
                            y: "year"
                        }, e.timeUnitsNamesPlural = {
                            ms: "milliseconds",
                            s: "seconds",
                            m: "minutes",
                            h: "hours",
                            d: "days",
                            w: "weeks",
                            M: "months",
                            y: "years"
                        }, e.markerDates = {
                            timeFormats: {
                                ms: "HH:mm:ss",
                                s: "HH:mm:ss",
                                m: "HH:mm:ss",
                                h: "HH:mm",
                                d: "D, HH:mm",
                                w: "MMM D",
                                M: "MMM D",
                                y: "YYYY, MMM D"
                            }
                        }, e.infoDates = {
                            majorTimeFormats: {
                                y: null,
                                M: "YYYY",
                                w: "GGGG",
                                d: "YYYY",
                                h: "MMM D, YYYY",
                                m: "MMM D, YYYY",
                                s: "MMM D, YYYY",
                                ms: "MMM D, YYYY"
                            },
                            minorTimeFormats: {
                                y: "YYYY",
                                M: "MMM",
                                w: "[Week] W",
                                d: "MMM D",
                                h: "HH:mm",
                                m: "HH:mm",
                                s: "HH:mm:ss",
                                ms: "ss.SSS"
                            },
                            fullTimeFormats: {
                                ms: "MMM D, YYYY HH:mm:ss",
                                s: "MMM D, YYYY HH:mm:ss",
                                m: "MMM D, YYYY, HH:mm",
                                h: "MMM D, YYYY HH:00",
                                d: "MMM D, YYYY",
                                w: "[Week] W, GGGG",
                                M: "MMM YYYY",
                                y: "YYYY"
                            }
                        }, e.timeAxisDates = {
                            minorLabelTimeFormats: {
                                ms: "ss.SSS",
                                s: "HH:mm:ss",
                                m: "HH:mm",
                                h: "HH:00",
                                d: "MMM D",
                                w: "MMM D",
                                M: "MMM",
                                y: "YYYY"
                            },
                            majorLabelTimeFormats: {
                                ms: "MMM D, YYYY HH:mm:ss",
                                s: "MMM D, YYYY HH:mm:ss",
                                m: "MMM D, YYYY",
                                h: "MMM D, YYYY HH:00",
                                d: "MMM D, YYYY",
                                w: "[Week] W, GGGG",
                                M: "MMM YYYY",
                                y: "YYYY"
                            },
                            majorLabelFullTimeFormats: {
                                ms: "MMM D, YYYY HH:mm:ss",
                                s: "MMM D, YYYY HH:mm:ss",
                                m: "MMM D, YYYY",
                                h: "MMM D, YYYY HH:00",
                                d: "MMM D, YYYY",
                                w: "[Week] W, GGGG",
                                M: "MMM YYYY",
                                y: "YYYY"
                            }
                        }, e.determiningDataBounds = "正在加载数据", e.loadingLabel = "加载中...", e
                    }
                    return n(e, t), e
                }(l.SettingsLocalization);
                t.SettingsLocalization = z;
                var U = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.customPeriod = "Custom", e.periodDropdownTitle = "Select units in which to show the data", e.unitDropdownTitle = "Select units in which to show the data", e.zoomoutButton = "Zoom-out", e.zoomoutTitle = "Zoom out", e.unavailableUnitTitle = "zoom in for more", e
                    }
                    return n(e, t), e
                }(l.SettingsLocalizationToolbar);
                t.SettingsLocalizationToolbar = U;
                var G = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.snapMode = "displayUnit", e.selection = new v, e.scrolling = new g, e.zooming = new j, e
                    }
                    return n(e, t), e
                }(l.SettingsInteraction);
                t.SettingsInteraction = G;
                var j = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.enabled = !0, e.click = !0, e
                    }
                    return n(e, t), e
                }(l.SettingsInteractionZooming);
                t.SettingsInteractionZooming = j;
                var W = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.displayUnits = [{
                            unit: "1 ms",
                            name: "millisecond"
                        }, {
                            unit: "1 s",
                            name: "second"
                        }, {
                            unit: "5 s",
                            name: "5 seconds"
                        }, {
                            unit: "1 m",
                            name: "minute"
                        }, {
                            unit: "5 m",
                            name: "5 minutes"
                        }, {
                            unit: "1 h",
                            name: "hour"
                        }, {
                            unit: "6 h",
                            name: "6 hours"
                        }, {
                            unit: "1 d",
                            name: "day"
                        }, {
                            unit: "1 M",
                            name: "month"
                        }, {
                            unit: "1 y",
                            name: "year"
                        }], e.displayPeriods = [{
                            unit: "10 ms"
                        }, {
                            unit: "100 ms"
                        }, {
                            unit: "s"
                        }, {
                            unit: "m"
                        }, {
                            unit: "h"
                        }, {
                            unit: "d"
                        }, {
                            unit: "M"
                        }, {
                            unit: "y"
                        }, {
                            unit: "10 y"
                        }, {
                            unit: "100 y"
                        }], e.style = new V, e
                    }
                    return n(e, t), e
                }(l.SettingsArea);
                t.SettingsArea = W;
                var V = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.markerText = {
                            font: "12px Arial"
                        }, e.selection = new y, e.selectionLabel = {
                            fillColor: "#000000",
                            font: "12px Arial"
                        }, e
                    }
                    return n(e, t), e
                }(l.SettingsAreaStyle);
                t.SettingsAreaStyle = V;
                var Z = function (e) {
                    function i(t) {
                        var i = e.call(this, t) || this;
                        return i.animationOrder = 700, i.paintOrder = 25, i.updateOrder = 1100, i
                    }
                    return n(i, e), i.prototype.doAnimations = function (t) {
                        var e = this.scene;
                        if (null != e.selectionStart && this.chart.selection.isSelecting && e.settings.info.enabled) {
                            var i = e.selectionStart,
                                n = e.selectionEnd;
                            this.showInfoPopup(i, n, null, this.buildContent(i, n, null, null), t)
                        }
                    }, i.prototype.getPopupAreaMouseMoved = function (t, e) {
                        var i = this.scene;
                        if (!i.displayUnit || !i.xyInChartOrBottom(t, e)) return null;
                        var n = i.hoverFrom,
                            r = i.hoverTo;
                        return {
                            t0: n,
                            t1: r
                        }
                    }, i.prototype.getContentsFunctionRange = function (t, e) {
                        var i = r.timeUnitDiffs,
                            n = this.scene,
                            s = !n.displayUnit || i[n.displayUnit.unit] < i.d;
                        return [n.timestampFromInternal(t, s), n.timestampFromInternal(e, s)]
                    }, i.prototype.buildContent = function (t, i, n, r) {
                        return t = this.scene.displayUnit.roundTimeRound(t, this.scene.timeStepSettings), i = this.scene.displayUnit.roundTimeRound(i, this.scene.timeStepSettings), e.prototype.buildContent.call(this, t, i, n, r)
                    }, i.prototype.buildHeader = function (e, i) {
                        var n = this.scene.displayUnit;
                        if (!n) return "";
                        var r, s = this.scene.settings.localization,
                            a = s.infoDates,
                            o = Math.max(1, Math.ceil(n.numberOfUnits(e, i))),
                            l = o * n.count | 0,
                            h = l % 10 === 1 && l % 100 !== 11 ? s.timeUnitsNames[n.unit] : s.timeUnitsNamesPlural[n.unit],
                            u = this.scene.momentLocale;
                        if (1 === o) {
                            var c = t.moment(e).locale(u).utc(),
                                d = c.format(a.fullTimeFormats[n.unit]);
                            r = "" + d
                        } else {
                            "d" !== n.unit && "M" !== n.unit && "y" !== n.unit && "ms" !== n.unit || (i -= 1);
                            var c = t.moment.utc(e).locale(u),
                                p = t.moment.utc(i).locale(u),
                                f = n.getBigger() || n;
                            "w" === f.unit && (f = f.getBigger());
                            var g = this.scene.timeStepSettings;
                            if ("y" !== n.unit && f.roundTimeDown(e, g) === f.roundTimeDown(i, g)) {
                                var m = c.format(a.majorTimeFormats[n.unit]),
                                    v = c.format(a.minorTimeFormats[n.unit]),
                                    y = p.format(a.minorTimeFormats[n.unit]);
                                r = v + " - " + y + ", " + m
                            } else {
                                var v = c.format(a.fullTimeFormats[n.unit]),
                                    y = p.format(a.fullTimeFormats[n.unit]);
                                r = v + " - " + y
                            }
                        }
                        return "<em></em><strong>" + r + ("<small>(" + l + " " + h + ")</small></strong>");
                    }, i
                }(l.InfoPopup);
                t.InfoPopup = Z;
                var Y = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.animationOrder = 600, i.paintOrder = 20, i.updateOrder = 1200, i.chart = null, i.scene = null, i.pointer = null, i.chart = e, i.scene = e.scene, i
                    }
                    return n(e, t), e.prototype.previewPointerMove = function (t) {
                        this.pointer = null, this.updateHover(t)
                    }, e.prototype.onPointerOut = function (t) {
                        var e = this.scene;
                        e.hoverFrom = null, e.hoverTo = null, e.hoverSeriesItem = null, t.changes.hover = !0, this.chart.notifyHoverChanged(t, this.chart.createEventArguments(t, "user"))
                    }, e.prototype.previewPointerDown = function (t) {
                        this.pointer = t.identifier, this.updateHover(t)
                    }, e.prototype.updateHover = function (t) {
                        var e = this.chart,
                            i = e.scene,
                            n = this.getClickRange(t.x, t.y),
                            r = null,
                            s = null,
                            a = null;
                        if (n && (r = n.t0, s = n.t1, a = e.renderer.hitTest(t.x, t.y)), e.legend)
                            if (a) e.legend.notifyHoveredSeries(i.settings._computedSeries[a.seriesIndex]);
                            else {
                                e.legend.notifyHoveredSeries(null);
                                var o = e.legend.getLastHoveredSeries();
                                o && (a = {
                                    x0: null,
                                    y0: null,
                                    x1: null,
                                    y1: null,
                                    isMarker: !1,
                                    seriesIndex: i.settings._computedSeries.indexOf(o)
                                })
                            }(r !== i.hoverFrom || s !== i.hoverTo || !a != !i.hoverSeriesItem || a && (a.seriesIndex !== i.hoverSeriesItem.seriesIndex || a.x0 !== i.hoverSeriesItem.x0)) && (i.hoverFrom = r, i.hoverTo = s, i.hoverSeriesItem = a, t.changes.hover = !0, e.notifyHoverChanged(t, e.createEventArguments(t, "user")))
                    }, e.prototype.onClick = function (t) {
                        t.identifier === this.pointer && this.chart.notifyClick(t, this.chart.createEventArguments(t, "user"))
                    }, e.prototype.defaultClick = function (t, e) {
                        var i = this.scene,
                            n = this.chart,
                            r = i.settings.interaction;
                        if (r.zooming.click) {
                            var s = i.xToTime(t.x);
                            if (null !== i.selectionStart && (i.selectionStart > s || i.selectionEnd < s)) this.clearSelection(t, "user");
                            else if (null !== i.hoverFrom && !n.selection.isHoveringEdge) {
                                var a = i.displayUnit,
                                    o = n.scrolling,
                                    l = i.hoverFrom,
                                    h = i.hoverTo,
                                    u = o.timeSetup.getLimits(a, !0);
                                null != u.from && (l = Math.max(l, u.from)), null != u.to && (h = Math.min(h, u.to)), o.setTimeRangeSnap(l, h, null, null, !0, "user", !1, !0);
                                var c = o.targetUnit || i.displayUnit;
                                a.isSmallerOrEqual(c) && (c = o.timeSetup.getSmallerDisplayUnit(c), c && o.setTimeRangeSnap(l, h, null, c, !0, "user", !1, !0)), null !== i.selectionStart && this.clearSelection(t, "user"), t.consumed = !0
                            }
                        }
                    }, e.prototype.onRightClick = function (t) {
                        var e = this.chart.settings.interaction.selection.clearOnRightClick;
                        null !== this.scene.selectionStart && e && this.clearSelection(t, "user"), null !== this.scene.hoverFrom && (this.chart.notifyRightClick(t, this.chart.createEventArguments(t, "user")), t.defaultPrevented && (t.consumed = !0))
                    }, e.prototype.onDoubleClick = function (t) {
                        null !== this.scene.hoverFrom && (this.chart.notifyDoubleClick(t, this.chart.createEventArguments(t, "user")), t.consumed = !0)
                    }, e.prototype.clearSelection = function (t, e) {
                        this.scene.selectionStart = null, this.scene.selectionEnd = null, this.chart.notifySelectionChanged(this.chart.createEventArguments(t, e)), t.changes.selection = !0, t.consumed = !0
                    }, e.prototype.onTripleClick = function (t) {
                        void 0 !== this.scene.hoverFrom && null !== this.scene.hoverFrom && (this.chart.notifyTripleClick(t, this.chart.createEventArguments(t, "user")), t.consumed = !0)
                    }, e.prototype.getClickRange = function (t, e) {
                        var i = this.scene;
                        if (!i.xyInChartOrBottom(t, e)) return null;
                        var n, r, s, a = this.scene.xToTime(t);
                        if (null !== i.selectionStart && a >= i.selectionStart && a < i.selectionEnd) n = i.selectionStart, r = i.selectionEnd, s = Math.max(2, i.displayUnit.numberOfUnits(n, r));
                        else if (i.displayUnit) {
                            var o = !0,
                                l = i.timeStepSettings;
                            if (i.majorTimeUnit) {
                                var h = i.majorTimeUnit.roundTimeDown(a, l),
                                    u = i.majorTimeUnit.roundTimeUp(a + 1, l);
                                e > i.y0 + i.height && (h > i.timeStart || u < i.timeEnd) && (n = h, r = u, n = i.displayUnit.roundTimeDown(n, l), r = i.displayUnit.roundTimeUp(r, l), s = i.displayUnit.numberOfUnits(n, r), o = !1)
                            }
                            o && (n = i.displayUnit.roundTimeDown(a, l), r = i.displayUnit.roundTimeUp(a + 1, l), s = 1)
                        } else n = null, r = null, s = null;
                        return {
                            t0: n,
                            t1: r,
                            numBars: s
                        }
                    }, e
                }(d.ChartElement);
                t.ClickNotifier = Y;
                var q = function () {
                    function t(t) {
                        this.requests = {}, this.results = {}, this.dataSlicesCache = {}, this.nextRequestId = 0, this.hasNewRequests = !1, this.lastSlicer = null, this.chart = t, this.scene = this.chart.scene
                    }
                    return t.prototype.registerDataProcessingRequest = function (t) {
                        this.requests[this.nextRequestId] = t;
                        var e = this.chart;
                        return this.results[this.nextRequestId] = {
                            leadIn: null,
                            leadOut: null,
                            times: [],
                            xes: [],
                            values: [],
                            counts: [],
                            fromIndex: 0,
                            toIndex: 0,
                            data: [],
                            from: 0,
                            to: 0,
                            slicer: null,
                            dataExistsFrom: null,
                            dataExistsTo: null,
                            externalItems: function (t, i) {
                                for (var n = r.timeUnitDiffs, s = !e.displayUnit || n[e.displayUnit.unit] < n.d, a = new Array(i - t), o = t; o < i; o++) a[o - t] = e.scene.timestampFromInternal(this.times[o], s);
                                return a
                            }
                        }, this.hasNewRequests = !0, this.nextRequestId++
                    }, t.prototype.removeDataProcessingRequest = function (t) {
                        delete this.requests[t], delete this.results[t]
                    }, t.prototype.getDisplayUnitsSlicer = function () {
                        return this.lastSlicer
                    }, t.prototype.getData = function (t) {
                        return this.results[t]
                    }, t.prototype.clear = function () {
                        this.requests = {}, this.results = {}
                    }, t.prototype.process = function (t) {
                        var e = t.changes;
                        if (e.time || e.data || e.displayUnit || e.bounds || e.settings || this.hasNewRequests)
                            if (this.scene.timeStart >= this.scene.timeEnd)
                                for (var i in this.requests) {
                                    var n = this.results[i];
                                    n.dataExistsFrom = null, n.dataExistsTo = null
                                } else {
                                    this.hasNewRequests = !1, this.loading = !1, this.hasSomeData = !1;
                                    var r = !!e.data || e.time;
                                    for (var i in this.requests) {
                                        var s = this.requests[i],
                                            n = this.results[i],
                                            a = this.updateData(r, s, n);
                                        this.updateSlices(a, i, s, n)
                                    }
                                    this.scene.loading = this.loading, this.loading ? this.scene.setMessage("noData", this.scene.settings.localization.loadingLabel, 10) : this.hasSomeData ? this.scene.setMessage("noData", null) : this.scene.setMessage("noData", this.scene.settings.localization.noDataLabel, 999)
                                }
                    }, t.prototype.exportData = function (t, e, i, n) {
                        for (var r = new C(this.scene, i, [], t, e, !0, 0), s = r.times, a = [], o = 0; o < n.length; o++) {
                            var l = n[o],
                                h = l.data,
                                u = this.chart.getData(h.source),
                                c = u.getDataForRange(t, e, i, null),
                                d = new Array(s.length - 1);
                            this.fillValues(c.values, r.times, d, r.counts, r.fromIndex, r.toIndex, h, i), a.push(d)
                        }
                        return {
                            timestamps: r.times.slice(r.fromIndex, r.toIndex - 1),
                            values: a
                        }
                    }, t.prototype.updateData = function (t, e, i) {
                        var n = this,
                            r = e.source,
                            s = this.chart.getData(r),
                            a = this.getUnitToUse(e),
                            o = (this.scene.timeEnd - this.scene.timeStart) * s.dataSettings.prefetchRatio;
                        if (t || !i.from && this.scene.timeStart || !i.to && this.scene.timeEnd || i.from >= i.to || this.scene.timeStart - o < i.from || this.scene.timeEnd + o > i.to || null !== i.dataExistsFrom && i.dataExistsFrom > this.scene.timeEnd || null !== i.dataExistsTo && i.dataExistsTo < this.scene.timeStart) {
                            t = !0;
                            var l = this.scene.timeStart - 2 * o,
                                h = this.scene.timeEnd + 2 * o,
                                u = s.getDataForRange(l, h, a, function () {
                                    return n._newDataArrived(r)
                                });
                            s.noData || (this.hasSomeData = !0), u.from > this.scene.timeEnd || u.to < this.scene.timeStart ? (i.data = [], i.from = 0, i.to = 0, i.dataExistsFrom = null, i.dataExistsTo = null, this.loading = this.loading || u.loading) : (this.loading = this.loading || u.loading && (u.from > this.scene.timeStart || u.to < this.scene.timeEnd), i.data = u.values, i.from = l, i.to = h, i.dataExistsFrom = u.from, i.dataExistsTo = u.to)
                        }
                        return t
                    }, t.prototype.updateSlices = function (t, e, i, n) {
                        var r = this.getUnitToUse(i),
                            s = i.index,
                            a = i.valueFunction,
                            o = n.data,
                            l = n.slicer = this.getSlice(e, i, r),
                            h = l.update(this.scene.timeStart, this.scene.timeEnd),
                            u = h.newBefore,
                            c = h.newAfter,
                            d = n.times = l.times,
                            p = n.counts = l.counts;
                        n.xes = l.xes;
                        var f = n.values = l.values;
                        if (o = n.data, n.fromIndex = l.fromIndex, n.toIndex = l.toIndex, o) o.length > 0 && !a && s >= o[0].length ? this.chart.error("No data for this DataIndex: " + s + ", only " + (o[0].length - 1) + " values present") : (t ? this.fillValues(o, d, f, p, l.fromIndex, l.toIndex, i, r) : (this.fillValues(o, d, f, p, l.fromIndex, u + 1, i, r), this.fillValues(o, d, f, p, c - 1, l.toIndex, i, r)), this.setLeads(i, n, r));
                        else {
                            f = n.values = new Array(d.length);
                            for (var g = 0; g < f.length; g++) f[g] = null;
                            n.leadIn = null, n.leadOut = null
                        }
                    }, t.prototype.getSlice = function (t, e, i) {
                        var n, r = t + "-" + i.toString();
                        return n = this.dataSlicesCache.hasOwnProperty(r) ? this.dataSlicesCache[r] : this.dataSlicesCache[r] = new C(this.scene, i, ["values", "counts"]), this.lastSlicer = n, n
                    }, t.prototype.getUnitToUse = function (t) {
                        return this.scene.displayUnit
                    }, t.prototype.setLeads = function (t, e, i) {
                        var n = t.noDataPolicy,
                            r = t.index,
                            s = t.valueFunction,
                            a = e.data,
                            o = e.values,
                            l = e.times,
                            h = null,
                            u = null;
                        if ("join" === n && a) {
                            var d = e.fromIndex;
                            if (null === o[d]) {
                                var p = c.binSearch(a, l[d]);
                                if (p = c.linSearchDown(a, p, r, s), p !== -1) {
                                    var f = a[p][0],
                                        g = e.slicer.makeMiniSlice(f),
                                        m = [g.t0, g.t1],
                                        v = [g.x0, g.x1],
                                        y = [null, null],
                                        S = [null, null];
                                    this.fillValues(a, m, y, S, 0, 2, t, i), h = {
                                        times: m,
                                        xes: v,
                                        values: y,
                                        counts: S,
                                        fromIndex: 0,
                                        toIndex: 2
                                    }
                                }
                            }
                            var b = e.toIndex;
                            if (null === o[b - 2]) {
                                var p = c.binSearch(a, l[b - 1]);
                                if (p = c.linSearchUp(a, p, r, s), p !== -1) {
                                    var f = a[p][0],
                                        g = e.slicer.makeMiniSlice(f),
                                        m = [g.t0, g.t1],
                                        v = [g.x0, g.x1],
                                        y = [null, null],
                                        S = [null, null];
                                    this.fillValues(a, m, y, S, 0, 2, t, i), u = {
                                        times: m,
                                        xes: v,
                                        values: y,
                                        counts: S,
                                        fromIndex: 0,
                                        toIndex: 2
                                    }
                                }
                            }
                        }
                        e.leadIn = h, e.leadOut = u
                    }, t.prototype.fillValues = function (t, e, i, n, r, s, a, o) {
                        var l = a.aggregation,
                            h = 0 | a.index,
                            u = 0 | a.countIndex,
                            c = a.valueFunction,
                            d = a.aggregatedValueFunction;
                        if (!(r + 1 >= s) && ("sum" === l ? this.fillValueSum(t, e, i, n, r, s, h, u, c) : "min" === l ? this.fillValueMin(t, e, i, n, r, s, h, u, c) : "max" === l ? this.fillValueMax(t, e, i, n, r, s, h, u, c) : "avg" === l ? this.fillValueAvg(t, e, i, n, r, s, h, u, c) : "count" === l ? this.fillValueCount(t, e, i, n, r, s, h, u, c) : "first" === l ? this.fillValueFirst(t, e, i, n, r, s, h, u, c) : "last" === l ? this.fillValueLast(t, e, i, n, r, s, h, u, c) : this.chart.error("Unrecognized aggregation function: " + l), d))
                            for (var p = r; p <= s - 2; p++) i[p] = d(i[p], e[p], o ? o.toString() : null)
                    }, t.prototype.fillValueSum = function (t, e, i, n, r, s, a, o, l) {
                        for (var h = t.length, u = c.binSearch(t, e[r]), d = r; d <= s - 2; d++) {
                            for (var p = e[d + 1], f = 0, g = 0, m = void 0; u < h && t[u][0] < p;) m = l ? l(t[u]) : t[u][a], null != m && (f += m, g += 0 === o ? 1 : t[u][o]), u += 1;
                            n[d] = g, i[d] = 0 === g ? null : f
                        }
                    }, t.prototype.fillValueMin = function (t, e, i, n, r, s, a, o, l) {
                        for (var h = t.length, u = c.binSearch(t, e[r]), d = r; d <= s - 2; d++) {
                            for (var p = e[d + 1], f = 1 / 0, g = 0, m = void 0; u < h && t[u][0] < p;) m = l ? l(t[u]) : t[u][a], null != m && (f = Math.min(f, m), g += 0 === o ? 1 : t[u][o]), u += 1;
                            n[d] = g, i[d] = 0 === g ? null : f
                        }
                    }, t.prototype.fillValueMax = function (t, e, i, n, r, s, a, o, l) {
                        for (var h = t.length, u = c.binSearch(t, e[r]), d = r; d <= s - 2; d++) {
                            for (var p = e[d + 1], f = -(1 / 0), g = 0, m = void 0; u < h && t[u][0] < p;) m = l ? l(t[u]) : t[u][a], null != m && (f = Math.max(f, m), g += 0 === o ? 1 : t[u][o]), u += 1;
                            n[d] = g, i[d] = 0 === g ? null : f
                        }
                    }, t.prototype.fillValueCount = function (t, e, i, n, r, s, a, o, l) {
                        for (var h = t.length, u = c.binSearch(t, e[r]), d = r; d <= s - 2; d++) {
                            for (var p = e[d + 1], f = 0, g = void 0; u < h && t[u][0] < p;) g = l ? l(t[u]) : t[u][a], null != g && (f += o ? t[u][o] : 1), u += 1;
                            n[d] = f, i[d] = f
                        }
                    }, t.prototype.fillValueAvg = function (t, e, i, n, r, s, a, o, l) {
                        for (var h = t.length, u = c.binSearch(t, e[r]), d = r; d <= s - 2; d++) {
                            for (var p = e[d + 1], f = 0, g = 0, m = void 0; u < h && t[u][0] < p;) m = l ? l(t[u]) : t[u][a], null != m && (f += m, g += o ? t[u][o] : 1), u += 1;
                            n[d] = g, i[d] = 0 === g ? null : f / g
                        }
                    }, t.prototype.fillValueFirst = function (t, e, i, n, r, s, a, o, l) {
                        for (var h = t.length, u = c.binSearch(t, e[r]), d = r; d <= s - 2; d++) {
                            for (var p = e[d + 1], f = null, g = 0, m = void 0; u < h && t[u][0] < p;) m = l ? l(t[u]) : t[u][a], null != m && (null === f && (f = m), g += o ? t[u][o] : 1), u += 1;
                            n[d] = g, i[d] = f
                        }
                    }, t.prototype.fillValueLast = function (t, e, i, n, r, s, a, o, l) {
                        for (var h = t.length, u = c.binSearch(t, e[r]), d = r; d <= s - 2; d++) {
                            for (var p = e[d + 1], f = null, g = 0, m = void 0; u < h && t[u][0] < p;) m = l ? l(t[u]) : t[u][a], null != m && (f = m, g += o ? t[u][o] : 1), u += 1;
                            n[d] = g, i[d] = f
                        }
                    }, t.prototype._newDataArrived = function (t) {
                        var e = {};
                        e[t] = !0, this.chart.events.notifySceneChanges({
                            data: e
                        })
                    }, t
                }();
                t.DataWarehouse = q;
                var _ = function (t) {
                    function e(e, i) {
                        var n = t.call(this) || this;
                        return n.animationOrder = 400, n.paintOrder = 5, n.updateOrder = 1500, n.dataWarehouse = i, n.chart = e, n.scene = n.chart.scene, n.events = n.chart.events, n.buildSeries(), n
                    }
                    return n(e, t), e.prototype.buildSeries = function () {
                        this.valueAxis = new l.ValueAxisSet(this.chart, this.scene.settings._computedValueAxisList), this.r = new l.Renderer(this.chart, this.valueAxis), this.dataWarehouse.clear(), this.requestIds = [];
                        for (var t = 0; t < this.scene.settings._computedSeries.length; t++) {
                            var e = this.scene.settings._computedSeries[t];
                            this.requestIds.push(this.dataWarehouse.registerDataProcessingRequest(e.data))
                        }
                    }, e.prototype.onSceneChange = function (t) {
                        var e = t.changes;
                        (e.linearChartSeries || e.linearChartValueAxis) && this.buildSeries(), e.linearChartValueAxis && (e.bounds = !0), (e.bounds || e.settings) && (e.time = !0), e.data && d.Helpers.hasProperties(e.data) && this.chart.notifyChartUpdate("data", !0)
                    }, e.prototype.getPanels = function () {
                        return this.valueAxis.getPanels(!1)
                    }, e.prototype.doAnimations = function (t) {
                        var e = t.changes;
                        if (this.dataWarehouse.process(t), this.scene.displayUnit) {
                            if (this.displayUnit !== this.scene.displayUnit && (this.displayUnit = this.scene.displayUnit, e.displayUnit = !0), e.time || e.data || e.displayUnit || e.bounds) {
                                for (var i = [], n = 0; n < this.requestIds.length; n++) i.push(this.dataWarehouse.getData(this.requestIds[n]));
                                this.r.process(i)
                            }
                            this.valueAxis.updateMinMax(t), this.r.afterProcess(), this.valueAxis.doAnimations(t)
                        }
                    }, e.prototype.paintScene = function (t) {
                        this.valueAxis.paintUnder(t), d.Graphics.pushClip(t, this.scene.x0, this.scene.y0, this.scene.width, this.scene.height), this.r.paint(t), d.Graphics.popClip(t), this.valueAxis.paint(t)
                    }, e.prototype.hitTest = function (t, e) {
                        return this.scene.xyInChart(t, e) ? this.r.hitTest(t, e, this.scene.settings.interaction.selection.tolerance) : null
                    }, e.prototype.exportData = function (t, e) {
                        return this.r.exportData(t, e)
                    }, e
                }(d.ChartElement);
                t.Renderer = _;
                var X = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.chart = e, i.scene = e.scene, i.settings = e.settings, i.reinitializePeriod = !0, i
                    }
                    return n(e, t), e.prototype.onSceneChange = function (t) {
                        var e = t.changes.settingsChanges;
                        e && e.navigation && (this.reinitializePeriod = !0), this.reinitializePeriod && this.chart.assetsLoaded && this.setupInitialDisplayPeriod()
                    }, e.prototype.onNewDataObject = function () {}, e.prototype.setupInitialDisplayPeriod = function () {
                        var t = this;
                        if (this.scene.width) {
                            this.reinitializePeriod = !1;
                            var e = this.settings.navigation.initialDisplayAnchor,
                                i = this.settings.navigation.initialDisplayPeriod,
                                n = this.settings.navigation.initialDisplayUnit;
                            this.computeDisplayPeriod(i, e, n, function (n, r, s) {
                                if (t.scene.setMessage("impl", null, 0), t.scene.loading = !1, t.scene.displayUnit && (s = t.scene.displayUnit), !t.scene.timeStart && !t.scene.timeEnd) {
                                    var a = t.chart.scrolling.timeSetup,
                                        o = a.getLimits(s, !0);
                                    null !== o.from && (n = Math.round(Math.max(n, o.from))), null !== o.to && (r = Math.round(Math.min(r, o.to))), t.chart.scrolling.setTimeRange(n, r, s, !1, "init", e, i)
                                }
                            })
                        }
                    }, e.prototype.computeDisplayPeriod = function (t, e, i, n) {
                        var r = this,
                            s = this.chart.scrolling.computeDisplayPeriod(t, e, i, this.scene.mainData.dataFrom, this.scene.mainData.dataTo),
                            a = s.from,
                            o = s.to,
                            l = s.unit;
                        if (null !== a && null !== o && l) return n(a, o, l);
                        if (!(this.scene.mainData.dataSettings.dataFunction || this.scene.mainData.dataSettings.url || this.scene.mainData.dataSettings.urlByUnit || this.scene.mainData.dataSettings.preloaded)) return void this.chart.error("Cannot compute data dependant display period, no data given. DisplayPeriod = " + t + ", DisplayAnchor = " + e);
                        var h = function (l, u, c, d, p, f) {
                            if (!r.chart.removed) {
                                if (null === l || null === u || 0 === l && 0 === u && r.scene.mainData.noData) return void n(d, p, f);
                                s = r.chart.scrolling.computeDisplayPeriod(t, e, i, l, u), a = s.from, o = s.to;
                                var g = s.unit;
                                return null === a || null === o ? void r.chart.error("Could not setup display time interval. Check your configuration.") : void(g.isMultipleOf(c) ? n(a, o, g) : r.scene.mainData.determineDataLimits(g, !0, !0, function (t, e, i) {
                                    return h(t, e, i, l, u, g)
                                }))
                            }
                        };
                        this.scene.mainData.determineDataLimits(null, !0, !0, function (t, e, i) {
                            return h(t, e, i, 0, 0, null)
                        })
                    }, e
                }(d.Navigator);
                t.Navigator = X, t.moment = null;
                var Q = !1,
                    J = function (e) {
                        function i(i, n) {
                            var r = e.call(this, new I(i), new b, n) || this;
                            return r.timeAxis = null, r.timeStart = 0, r.timeEnd = 0, r.displayUnit = null, r.selectionStart = 0, r.selectionEnd = 0, r._cachedDataLimits = null, r.dataWarehouse = new q(r), r.renderer = r.events.addElement(new _(r, r.dataWarehouse)), r.scrolling = r.events.addElement(new m(r)), r.selection = r.events.addElement(new S(r)), r.navigator = r.events.addElement(new X(r)), r.clickNotifier = r.events.addElement(new Y(r)), r.infoPopup = r.events.addElement(new Z(r)), r.events.addElement(new M(r)), r.events.addElement(new t.Markers(r)), r.events.addElement(new l.Highlights(r)), r.finalInitialize(), r
                        }
                        return n(i, e), i.prototype.notifyAssetsLoaded = function () {
                            if (!this.removed) {
                                if (!t.moment) {
                                    if (t.moment = window.moment, !t.moment) return void this.error("Unable to load moment library. Please check that the assets are configured properly.");
                                    d.Helpers.compareVersions(t.moment.version, [2, 9]) || this.error("ZoomCharts requires moment version 2.9.0 or newer. The loaded version is " + t.moment.version)
                                }!Q && t.moment.tz && (d.Helpers.compareVersions(t.moment.tz.version, [0, 5]) || this.error("ZoomCharts requires moment-timezone version 0.5.0 or newer. The loaded version is " + t.moment.tz.version), Q = !0), this.setMomentLocale();
                                var i = this.settings.timeAxis;
                                t.moment.tz && "local" === i.timeZone && (i.timeZone = t.moment.tz.guess(), d.Helpers.warn("Instead of using `local` for `timeAxis.timeZone` it is recommended to specify the exact timezone since the local timezone detection is error prone. The timezone was detected as `" + i.timeZone + "`.")), this.timeAxis || (this.timeAxis = this.events.addElement(new w(this)));
                                for (var n = Object.keys(this.data), r = 0; r < n.length; r++) this.data[n[r]].notifyAssetsLoaded();
                                e.prototype.notifyAssetsLoaded.call(this), this.api._notifyAssetsLoaded()
                            }
                        }, i.prototype.createDataObj = function (t) {
                            return new c(this, t)
                        }, i.prototype.getData = function (t) {
                            return e.prototype.getData.call(this, t)
                        }, i.prototype.setMomentLocale = function () {
                            var e = this.scene.momentLocale,
                                i = t.moment.locale(),
                                n = this.settings.localization.calendar;
                            n.parentLocale && !d.Helpers.compareVersions(t.moment.version, [2, 12]) && this.error("Using `parentLocale` requires moment.js 2.12.0 or newer. The loaded version is " + t.moment.version), t.moment.locale(e, null), t.moment.locale(e, n), this.scene.timeStepSettings = {
                                week: {
                                    dow: t.moment.localeData().firstDayOfWeek()
                                }
                            }, t.moment.locale(i)
                        }, i.prototype.remove = function () {
                            t.moment && t.moment.locale(this.scene.momentLocale, null), e.prototype.remove.call(this), this.infoPopup.remove()
                        }, i.prototype.onSettingsChanged = function (t) {
                            if (t.data && (t.toolbar = !0), t.area && t.area.displayUnits) {
                                var e = this.scene,
                                    i = new o(this);
                                if (e.displayUnit && !i.isAllowedDisplayUnit(e.displayUnit)) {
                                    var n = i.computeDisplayUnit(e.timeStart, e.timeEnd, e.displayUnit, e.timeStart, e.timeEnd, e);
                                    this.scrolling.setTimeRangeSnap(e.timeStart, e.timeEnd, null, n.unit, !0, "api", !0, !0)
                                }
                            }
                            this.assetsLoaded && t.localization && t.localization.calendar && this.setMomentLocale(), this.events.notifySceneChanges({
                                time: !0
                            })
                        }, i.prototype.save = function () {
                            var t = this.scene;
                            return JSON.stringify({
                                from: this.timeStart,
                                to: this.timeEnd,
                                unit: this.displayUnit.toString(),
                                selFrom: t.selectionStart,
                                selTo: t.selectionEnd,
                                anchor: t.anchor,
                                period: t.period
                            })
                        }, i.prototype.restore = function (t, e) {
                            if (t) {
                                var i = JSON.parse(t),
                                    n = r.parse(i.unit);
                                n && (this.scrolling.setTimeRange(i.from, i.to, n, e, "api", i.anchor, i.period), this.setSelection(i.selFrom, i.selTo))
                            }
                        }, i.prototype.warnInvisibleChart = function (t) {
                            this.scene.width || d.Helpers.warn("`" + t + "()` method has been called on a hidden chart. This might produce invalid results since the chart width impacts the calculations.")
                        }, i.prototype.setSelection = function (t, e, i) {
                            void 0 === i && (i = "api");
                            var n = this.scene;
                            n.selectionStart === t && n.selectionEnd === e || (n.selectionStart = t, n.selectionEnd = e, this.events.notifySceneChanges({
                                selection: !0
                            }), this.notifySelectionChanged(this.createEventArguments(null, i)))
                        }, i.prototype.setTimeRange = function (t, e, i, n) {
                            void 0 === n && (n = "api"), this.warnInvisibleChart("time"), this.setSelection(null, null, n);
                            var s = this.displayUnit;
                            if (!s) {
                                var a = this.settings.navigation.initialDisplayUnit;
                                a && "auto" !== a && (s = r.parse(a))
                            }
                            if (this.scene.displayUnit = s, this.scene.width) {
                                var o = this.scrolling.onSnapWhileDragging(t, e, null, !0, 2);
                                o.unit && (this.scene.displayUnit = o.unit, o = this.scrolling.onSnapAfterDragging(o.from, o.to, null, !0, 2)), t = o.from, e = o.to, s = o.unit
                            }
                            this.scrolling.setTimeRange(t, e, s, i, n)
                        }, i.prototype.setDisplayPeriod = function (t, e, i, n, r) {
                            var s = this;
                            return void 0 === e && (e = null), void 0 === i && (i = null), void 0 === n && (n = !0), void 0 === r && (r = "api"), this.warnInvisibleChart("setDisplayPeriod"), null === e && (e = this.scene.anchor), this.setSelection(null, null), "string" == typeof e && (e = e.trim()), "string" == typeof t && (t = t.trim()), this.navigator.computeDisplayPeriod(t, e, i, function (i, a, o) {
                                return s.scrolling.setTimeRange(i, a, o, n, r, e, t)
                            })
                        }, i.prototype.scroll = function (t, e, i) {
                            void 0 === i && (i = !1);
                            var n = t.trim().split(" ");
                            if (3 !== n.length) return void this.error("Incorrect scroll format: " + t);
                            var r = n[0],
                                s = parseInt(n[1], 10),
                                a = n[2];
                            if ("<" !== r && ">" !== r || "number" != typeof s) return void this.error("Scroll:Incorrect scroll format: " + t);
                            var l = new o(this),
                                h = l.scroll(this.timeStart, this.timeEnd, this.displayUnit, r, s, a),
                                u = h.from,
                                c = h.to;
                            i ? this.scrolling.setTimeRangeSnap(u, c, 0, this.displayUnit, e, "api", null, null) : this.scrolling.setTimeRange(u, c, this.displayUnit, e, "api", null, this.scene.period)
                        }, i.prototype.zoomOut = function (t, e, i) {
                            void 0 === t && (t = !0), void 0 === e && (e = "api"), void 0 === i && (i = null), this.setSelection(null, null), this.scrolling.zoomOut(i, this.scene.timeStart, this.scene.timeEnd, t, e), this.scene.period = null
                        }, i.prototype.zoomOutPossible = function () {
                            return !!this.scene.displayUnit
                        }, i.prototype.zoomIn = function (t, e, i, n) {
                            void 0 === e && (e = null), void 0 === i && (i = !0), void 0 === n && (n = "api"), this.setSelection(null, null), this.scrolling.zoomIn(t, e, this.scene.timeStart, this.scene.timeEnd, i, n), this.scene.period = null
                        }, i.prototype.setDisplayUnit = function (t, e, i, n) {
                            void 0 === i && (i = "api"), void 0 === n && (n = !1), this.warnInvisibleChart("displayUnit");
                            var s, a, o;
                            if ("auto" === t) {
                                var l = this.scrolling.timeSetup.computeDisplayUnit(null, null, null, this.timeStart, this.timeEnd, this.scene);
                                s = l.unit, a = l.from, o = l.to
                            } else {
                                if (s = r.parse(t), !s) return;
                                if (n) {
                                    for (var h = s.toString(), u = this.scene.settings._displayUnitsParsed, c = !1, p = 0; p < u.length; p++)
                                        if (u[p].toString() === h) {
                                            c = !0;
                                            break
                                        }
                                    c || d.Helpers.warn("The display unit `" + h + "` does not match a display unit configured in `area.displayUnits`.")
                                }
                                var f = this.scene.timeStepSettings;
                                a = s.roundTimeDown(this.timeStart, f), o = s.roundTimeUp(this.timeEnd, f)
                            }
                            var g = this.scrolling.snap(a, o, null, s, !1, !0);
                            this.scrolling.setTimeRange(g.from, g.to, s, e, i, g.anchor, g.period)
                        }, i.prototype.invalidateDataLimits = function () {
                            this._cachedDataLimits = null
                        }, i.prototype.getDataLimits = function (t) {
                            void 0 === t && (t = this.displayUnit);
                            var e = this._cachedDataLimits;
                            if (e && e.unit === t) return e;
                            for (var i = this.settings._computedSeries, n = Object.create(null), r = 0; r < i.length; r++) {
                                var s = i[r];
                                s.enabled && (n[s.data.source] = !0)
                            }
                            var a = 1 / 0,
                                o = -(1 / 0);
                            for (var l in n) {
                                var h = this.data[l];
                                h && (h.dataLimitFrom || h.dataLimitTo) && (a = Math.min(a, h.dataLimitFrom), o = Math.max(o, h.dataLimitTo))
                            }
                            return a > o ? (a = null, o = null) : t && (a = t.roundTimeDown(a, this.scene.timeStepSettings), o = t.roundTimeUp(o, this.scene.timeStepSettings)), this._cachedDataLimits = {
                                from: a,
                                to: o,
                                unit: t
                            }
                        }, i.prototype.getDisplayLimits = function (t) {
                            var e = this.getDataLimits(t),
                                i = e.from,
                                n = e.to;
                            if (null === i) return e;
                            for (var r = 0; r < this.scene.markers.length; r++) {
                                var s = this.scene.markers[r];
                                s.settings.overrideLimits && (i = Math.min(i, s.time), n = Math.max(n, s.time))
                            }
                            return {
                                from: i,
                                to: n
                            }
                        }, i.prototype.exportVisibleData = function () {
                            if (!this.displayUnit) return [];
                            for (var e = this.settings._computedSeries, i = this.dataWarehouse.exportData(this.timeStart, this.timeEnd, this.displayUnit, e), n = this.settings.localization.infoDates.fullTimeFormats[this.displayUnit.unit], r = i.timestamps, s = i.values, a = ["timestamp", "time"], o = 0; o < e.length; o++) {
                                var l = e[o];
                                a.push(l.name || l.id || "")
                            }
                            for (var h = [a], u = this.scene.momentLocale, c = 0; c < r.length; c++) {
                                for (var d = r[c], p = [d, t.moment.utc(d).locale(u).format(n)], f = 0; f < e.length; f++) p.push(s[f][c]);
                                h.push(p)
                            }
                            return h
                        }, i.prototype.isThisDisplayPeriod = function (t, e, i) {
                            if (!this.displayUnit) return !1;
                            var n = this.scene.mainData.dataFrom,
                                r = this.scene.mainData.dataTo,
                                s = this.scrolling.computeDisplayPeriod(t, e, i, n, r);
                            n = s.from, r = s.to;
                            var a = this.scrolling.getFrom(),
                                o = this.scrolling.getTo(),
                                l = o - a,
                                h = Math.abs(a - n) / l;
                            if (h > .1) return !1;
                            var u = Math.abs(o - r) / l;
                            return !(u > .1)
                        }, i.prototype.notifyTimeChanged = function (t, e, i, n) {
                            this.timeStart = t, this.timeEnd = e, this.displayUnit = i, this.notifyChartUpdate(n)
                        }, i.prototype.saveNavigation = function () {
                            return this.displayUnit ? {
                                timeStart: this.timeStart,
                                timeEnd: this.timeEnd,
                                displayUnit: this.displayUnit,
                                anchor: this.scene.anchor,
                                period: this.scene.period
                            } : null
                        }, i.prototype.restoreNavigation = function (t, e, i) {
                            this.timeStart = t.timeStart, this.timeEnd = t.timeEnd, this.displayUnit = t.displayUnit, this.scrolling.setTimeRange(this.timeStart, this.timeEnd, this.displayUnit, e, i, t.anchor, t.period)
                        }, i.prototype.doChartUpdateNotify = function (t) {
                            e.prototype.doChartUpdateNotify.call(this, t), this.dispatchEventParams("timeChange", this.createEventArguments(null, t), null)
                        }, i.prototype.createEventArguments = function (t, e) {
                            var i = this.scene,
                                n = i.hoverSeriesItem,
                                s = n && null != n.seriesIndex ? i.settings._computedSeries[n.seriesIndex] : null,
                                a = !!n && n.isMarker,
                                o = r.timeUnitDiffs,
                                l = !this.displayUnit || o[this.displayUnit.unit] < o.d,
                                h = i.timestampFromInternal(i.hoverFrom, l),
                                u = i.timestampFromInternal(i.hoverTo, l);
                            return {
                                chart: this.api,
                                origin: e,
                                timeStart: i.timestampFromInternal(this.timeStart, l),
                                timeEnd: i.timestampFromInternal(this.timeEnd, l),
                                displayUnit: this.displayUnit ? this.displayUnit.toString() : null,
                                selectionStart: i.timestampFromInternal(i.selectionStart, l),
                                selectionEnd: i.timestampFromInternal(i.selectionEnd, l),
                                hoverStart: h,
                                hoverEnd: u,
                                hoverSeries: s,
                                hoverMarker: a,
                                clickStart: h,
                                clickEnd: u,
                                clickSeries: s,
                                clickMarker: a
                            }
                        }, i.prototype.defaultClick = function (t, i) {
                            e.prototype.defaultClick.call(this, t, i), this.clickNotifier.defaultClick(t, i)
                        }, i.prototype.defaultRightClick = function (t) {
                            this.infoPopup.show(t), t.preventDefault()
                        }, i.prototype.getBottomHeight = function () {
                            return this.scene.height - this.scene.bottomAxisSize
                        }, i.prototype.showInfoPopup = function (t, e, i) {
                            if (null == t) return void this.infoPopup.hideInfoPopup(null);
                            if (null == e || t === e) e = t + 1;
                            else if (t > e) {
                                var n = t;
                                t = e, e = n
                            }
                            var r = this.displayUnit,
                                s = this.scene.timeStepSettings;
                            t = r.roundTimeDown(t, s), e = r.roundTimeUp(e, s), e < this.scene.timeStart || t > this.scene.timeEnd || this.infoPopup.manualShowInfoPopup(t, e, i)
                        }, i
                    }(l.Impl);
                t.Impl = J
            }(o = i.TimeChart || (i.TimeChart = {})),
            function (t) {
                var e = t.Renderers || (t.Renderers = {}),
                    i = function (t) {
                        function e() {
                            var e = t.apply(this, arguments) || this;
                            return e.itemsToLoad = 50, e.partialLoad = !0, e.autoCategories = null, e.sortField = null, e.dataFunction = null, e.preloaded = null, e
                        }
                        return n(e, t), e
                    }(d.SettingsData);
                t.SettingsData = i;
                var r = {
                        values: 1,
                        id: 1,
                        offset: 1,
                        limit: 1,
                        afterSum: 1,
                        beforeSum: 1,
                        subvalues: 1,
                        sum: 1,
                        extra: 1,
                        name: 1,
                        totalCount: 1,
                        total: 1,
                        valuesSum: 1,
                        done: 1,
                        afterFraction: 1,
                        beforeFraction: 1
                    },
                    s = function () {
                        function t() {
                            this.name = null, this.values = [], this.offset = 0, this.totalCount = null, this.total = 0, this.valuesSum = 0, this.beforeSum = 0, this.afterSum = 0, this.done = !1, this.extra = null
                        }
                        return t
                    }();
                t.PieData = s;
                var a = function (t) {
                    function e(e, i, n) {
                        var r = t.call(this, e, i) || this;
                        return r.pies = {}, r.pendingPies = {}, r.requestedPies = {}, r.nextId = 0, r._isFacetChart = n, r
                    }
                    return n(e, t), e.exportValues = function (t) {
                        var e = ["id", "name", "value"],
                            i = {
                                id: 0,
                                name: 1,
                                value: 2
                            },
                            n = 3,
                            r = t.values,
                            s = new Array(r.length + 1);
                        s[0] = e;
                        for (var a = 0; a < r.length; a++) {
                            var o = r[a],
                                l = new Array(n);
                            s[a + 1] = l;
                            for (var h = Object.keys(o), u = 0; u < h.length; u++) {
                                var c = h[u];
                                if ("_" !== c.charAt(0) && "fraction" !== c) {
                                    var p = o[c];
                                    if (Array.isArray(p)) p = p.length;
                                    else if (d.Helpers.isObjectOrArray(p)) continue;
                                    var f = i[c];
                                    void 0 === f && (i[c] = f = n++, e.push(c)), l[f] = p
                                }
                            }
                        }
                        return s
                    }, e.prototype.hasDataFunc = function () {
                        return !!this.dataSettings.dataFunction || !!this.dataSettings.url
                    }, e.prototype.applyPreloadedData = function () {
                        if (t.prototype.applyPreloadedData.call(this), !this.hasDataFunc()) {
                            for (var e = Object.keys(this.pies), i = 0; i < e.length; i++) {
                                var n = this.pies[e[i]];
                                n.done || (n.done = !0, n.afterSum = 0, n.totalCount = n.offset + n.values.length)
                            }
                            this.chart.scene.loading = !1
                        }
                    }, e.prototype.getRootId = function () {
                        return this.settings.navigation.initialDrilldown && this.settings.navigation.initialDrilldown.length > 0 ? this.settings.navigation.initialDrilldown[0] : ""
                    }, e.prototype.canExpand = function (t) {
                        return !!d.Helpers.hasProperty(this.pies, t) || !(!this.hasDataFunc() || this.dataSettings.autoCategories) && !(!t || t[0] === d.Helpers.SeparatorChar)
                    }, e.prototype.getPieData = function (t) {
                        if (!d.Helpers.hasProperty(this.pies, t)) return null;
                        var e = this.pies[t];
                        return this.needPostprocessing() && (e = this.filterAndSortData(e)), e
                    }, e.prototype.requestMorePieData = function (t, e) {
                        return void 0 === e && (e = this.dataSettings.itemsToLoad), null == e && (e = this.dataSettings.itemsToLoad), !(!d.Helpers.hasProperty(this.pies, t) || this.pies[t].done) && (this.requestPieData(t, this.pies[t].offset + this.pies[t].values.length, e), !0)
                    }, e.prototype.requestLessPieData = function (t, e) {
                        if (void 0 === e && (e = this.dataSettings.itemsToLoad), !d.Helpers.hasProperty(this.pies, t)) return !1;
                        var i = this.pies[t];
                        return (0 !== i.offset || !(i.done || i.values.length > 1)) && (this.requestPieData(t, Math.max(i.offset - this.dataSettings.itemsToLoad, 0), e), !0)
                    }, e.prototype.requestPieData = function (t, e, i) {
                        if (void 0 === i && (i = this.dataSettings.itemsToLoad), this.dataSettings.autoCategories) {
                            if (d.Helpers.hasProperties(this.pies)) throw new Error("Cannot request additional data when autoCategories is in use!");
                            t = ""
                        }
                        if (t[0] === d.Helpers.SeparatorChar) throw new Error("Invalid Id: " + t);
                        if (d.Helpers.hasProperty(this.pies, t)) {
                            var n = this.pies[t],
                                r = n.offset,
                                s = r + n.values.length;
                            if (e < r) i = r - e;
                            else {
                                if (!(e + i > s)) return;
                                i = e + i - s, e = s
                            }
                        } else(this.needPostprocessing() || !this.dataSettings.partialLoad || this.dataSettings.autoCategories) && (i = 2147483647, e = 0);
                        if (!d.Helpers.hasProperty(this.requestedPies, t))
                            if (d.Helpers.hasProperty(this.pendingPies, t)) {
                                var a = this.pendingPies[t],
                                    o = Math.min(a.offset, e),
                                    l = Math.max(a.offset + a.limit, e + i);
                                a.offset = o, a.limit = l - o
                            } else this.dataFunc && (this.pendingPies[t] = {
                                id: t,
                                offset: e,
                                limit: i
                            }, this.scheduleRequests())
                    }, e.prototype.autoCategorize = function (t, e) {
                        if (0 === e.length) return t;
                        for (var i = d.Helpers.clone(t), n = [i], r = 0; r < e.length; r++) {
                            for (var s = e[r], a = [], o = 0; o < n.length; o++) {
                                for (var l = n[o], h = [], u = {}, c = 0; c < l.subvalues.length; c++) {
                                    var p = l.subvalues[c],
                                        f = void 0;
                                    f = d.Helpers.isFunction(s) ? s(p) : p[s], f = void 0 === f || null === f ? "None" : f.toString();
                                    var g = void 0;
                                    d.Helpers.hasProperty(u, f) ? g = u[f] : (g = {
                                        id: l.id + d.Helpers.SeparatorChar + f,
                                        __id: l.id + d.Helpers.SeparatorChar + f,
                                        value: 0,
                                        subvalues: [],
                                        name: f,
                                        __category: s
                                    }, u[f] = g, h.push(g), a.push(g)), g.subvalues.push(p), g.value += d.Helpers.tryParseFloat(p.value, 0)
                                }
                                l.subvalues = h
                            }
                            n = a
                        }
                        return i
                    }, e.prototype.valueSum = function (t) {
                        if (this._isFacetChart) return 0;
                        for (var e = 0, i = 0; i < t.length; i++) e += t[i].value;
                        return e
                    }, e.prototype.addDataInt = function (t, e, i, n, a, o, l, h, u) {
                        var c;
                        c = d.Helpers.hasProperty(this.pies, t) ? this.pies[t] : this.pies[t] = new s;
                        var p = c.offset + c.values.length,
                            f = i + e.length;
                        if (0 === c.values.length || f < c.offset || p < i) c.offset = i, c.done = n > e.length, c.values = e.slice(), c.valuesSum = this.valueSum(e), c.totalCount = c.done ? c.values.length + c.offset : null, c.afterSum = c.done ? 0 : a, c.beforeSum = 0 === c.offset ? 0 : o, c.total = c.done && 0 === c.offset ? c.valuesSum : l;
                        else {
                            var g = null,
                                m = null,
                                v = 0,
                                y = 0;
                            c.offset < i && (i === p ? (g = c.values, v = c.valuesSum) : (g = c.values.slice(0, i - c.offset), v = this.valueSum(g))), p > f && e.length >= n && (c.offset === f ? (m = c.values, y = c.valuesSum) : (m = c.values.slice(f - c.offset), y = this.valueSum(m))), m ? c.values = g ? g.concat(e, m) : e.concat(m) : c.values = g ? g.concat(e) : e.slice(), c.offset = Math.min(c.offset, i), c.valuesSum = this.valueSum(e) + v + y, e.length < n && (c.done = !0), g || (c.beforeSum = o), m || (c.afterSum = a), c.total = l, c.done && (c.afterSum = 0), 0 === c.offset && (c.beforeSum = 0), c.done && 0 === c.offset && (c.total = c.valuesSum)
                        }
                        if (c.extra = h.extra, c.name = h.name, h)
                            for (var S in h) d.Helpers.hasProperty(r, S) || (c[S] = h[S]);
                        for (var b = 0; b < e.length; b++) {
                            var C = e[b];
                            C.subvalues && (u[C.__id] = !0, this.addDataInt(C.__id, C.subvalues, 0, 1 / 0, null, null, null, C, u))
                        }
                    }, e.prototype.needPostprocessing = function () {
                        var t = this.chart.settings.filters;
                        return !!t.sliceFilter || !t.allowZeroValues || !!this.dataSettings.sortField
                    }, e.prototype.filterAndSortData = function (t) {
                        var e = this.chart.settings.filters,
                            i = e.allowZeroValues,
                            n = e.sliceFilter;
                        if (!i || n) {
                            for (var r = t.total || 0, a = [], o = 0; o < t.values.length; o++) {
                                var l = t.values[o];
                                n && !n(l) || !i && 0 === l.value ? r -= l.value : a.push(l)
                            }
                            var h = new s;
                            h.values = a, h.done = t.done, h.beforeSum = t.beforeSum, h.afterSum = t.afterSum, h.total = t.total || null, h.totalCount = t.totalCount || null, h.extra = t.extra, t = h
                        }
                        return this.dataSettings.sortField && this.sortData(t), t
                    }, e.prototype.sortData = function (t) {
                        var e = this.dataSettings.sortField;
                        if (d.Helpers.isFunction(e)) return void t.values.sort(e);
                        var i;
                        i = Array.isArray(e) ? e.slice() : [e];
                        for (var n = new Array(i.length), r = 0; r < i.length; r++) {
                            var s = i[r];
                            "-" === s.charAt(0) ? (i[r] = s.substr(1), n[r] = -1) : n[r] = 1
                        }
                        var a = function (t, e) {
                            for (var r = 0; r < i.length; r++) {
                                var s = t[i[r]],
                                    a = e[i[r]],
                                    o = void 0;
                                if (null == s ? o = null == a ? 0 : a < 0 ? -1 : 1 : null == a ? o = s < 0 ? 1 : -1 : (o = a - s, isNaN(o) && (o = ("" + a).localeCompare(s))), 0 !== o) return n[r] * o
                            }
                            return 0
                        };
                        t.values.sort(a)
                    }, e.prototype.buildRequest = function () {
                        if (!d.Helpers.hasProperties(this.pendingPies)) return null;
                        var t = d.Helpers.removePropertyValue(this.pendingPies),
                            e = t.key,
                            i = t.value;
                        return this.requestedPies[e] = i, i
                    }, e.prototype.dataFunc = function (t, e, i) {
                        var n = this.dataSettings;
                        if (n.dataFunction) n.dataFunction(t.id, t.limit, t.offset, e, i);
                        else if (n.url) {
                            var r = [];
                            t.id && r.push(["id", t.id]), r.push(["limit", t.limit.toString(10)]), r.push(["offset", t.offset.toString(10)]), d.Data.doRequest(n.url, n, r, e, i)
                        } else i({
                            error: "Chart configuration does not define data retrieval function"
                        })
                    }, e.prototype.verifySlices = function (t, e, i) {
                        for (var n = !0, r = 0; r < t.length; r++) {
                            var s = t[r],
                                a = s.id ? " Slice id: `" + s.id + "`" : "";
                            if (d.Helpers.isObjectOrArray(s)) {
                                if (!this._isFacetChart)
                                    if (s.value = d.Helpers.tryParseFloat(s.value, null), null === s.value) {
                                        if (!i) {
                                            d.Helpers.warn("Slices must have a numeric `value` property!" + a), t.splice(r, 1), r--;
                                            continue
                                        }
                                        this.chart.error("Slices must have a numeric `value` property!" + a), n = !1
                                    } else if (s.value < 0) {
                                    if (!i) {
                                        d.Helpers.warn("Slice values cannot be negative." + a), t.splice(r, 1), r--;
                                        continue
                                    }
                                    this.chart.error("Slice values cannot be negative." + a), n = !1
                                }
                                d.Helpers.hasProperty(s, "id") ? (s.__id = "" + s.id, d.Helpers.hasProperty(e, s.__id) && (this.chart.error("Multiple slices with the same ID." + a), n = !1), e[s.__id] = !0) : (s.__id = d.Helpers.SeparatorChar + this.nextId, this.nextId++), d.Helpers.hasProperty(s, "subvalues") && (Array.isArray(s.subvalues) ? this.verifySlices(s.subvalues, e, i) || (n = !1) : (this.chart.error("Field `subvalues` is not an array!" + a), n = !1))
                            } else this.chart.error("Slices must be objects!"), n = !1
                        }
                        return n
                    }, e.prototype.verifyData = function (t, e) {
                        if (d.Helpers.hasProperty(e, "id") || (e.id = t ? t.id : this.getRootId()), t && e.id && e.id !== t.id) return this.chart.error("Requested data for ID `" + t.id + "` but got data with ID `" + e.id + "`. Consider specifying `navigation.initialDrilldown`."), !1;
                        if (delete this.requestedPies[e.id], e.limit = d.Helpers.tryParseInt(e.limit, 1 / 0), e.offset = d.Helpers.tryParseInt(e.offset, 0), e.beforeSum = d.Helpers.tryParseFloat(e.beforeSum, null), e.afterSum = d.Helpers.tryParseFloat(e.afterSum, null), e.sum = d.Helpers.tryParseFloat(e.sum, null), !d.Helpers.hasProperty(e, "subvalues")) {
                            if (!d.Helpers.hasProperty(e, "values")) return this.chart.error("Field `subvalues` not set in root data object"), !1;
                            d.Helpers.warn("Use of property `values` within PieChart data object is being deprecated. Please use `subvalues` instead.", null, !0), e.subvalues = e.values
                        }
                        if (!Array.isArray(e.subvalues)) return this.chart.error("Field `subvalues` is not an array!"), !1;
                        var i = !0;
                        e.offset < 0 && (this.chart.error("Data `offset` must be greater or equal to 0."), i = !1), e.limit < 1 && (this.chart.error("Data `limit` must be greater than 0."), i = !1);
                        var n = e.offset > 0 || e.limit <= e.subvalues.length;
                        if (!this.verifySlices(e.subvalues, {}, n)) return !1;
                        var r = e.limit > e.subvalues.length,
                            s = e.offset + e.subvalues.length;
                        if (t && (e.offset >= t.offset + t.limit || t.offset >= s && !r) && (this.chart.error("Response and request do not overlap. Requested " + t.limit + " items starting at " + t.offset + ". Received " + e.subvalues.length + " items starting at " + e.offset), i = !1), d.Helpers.hasProperty(this.pies, e.id)) {
                            var a = this.pies[e.id];
                            if (a.values.length > 0) {
                                var o = a.offset + a.values.length;
                                (o < e.offset || s < a.offset && !r) && (this.chart.error("Data cannot be merged - there is a gap between old data and new data! Old data spans slices from " + a.offset + " to " + (o - 1) + "; new data spans slices from " + e.offset + " to " + (s - 1) + "."), i = !1)
                            }
                        }
                        if (n && this.dataSettings.autoCategories && (this.chart.error("Cannot auto categorize partial data"), i = !1), !this._isFacetChart && n) {
                            var l = (null == e.beforeSum ? 0 : 1) + (null == e.afterSum ? 0 : 1) + (null == e.sum ? 0 : 1);
                            l < 2 ? (this.chart.error("For partial loading, at least 2 of the following need to be set: beforeSum, afterSum, sum."), i = !1) : (e.__valuesSum = this.valueSum(e.subvalues), null == e.beforeSum ? e.beforeSum = e.sum - e.afterSum - e.__valuesSum : null == e.afterSum ? e.afterSum = e.sum - e.beforeSum - e.__valuesSum : null == e.sum && (e.sum = e.beforeSum + e.afterSum + e.__valuesSum), e.sum !== e.beforeSum + e.afterSum + e.__valuesSum && (this.chart.error("For partial loading, beforeSum + (sum of subvalues) + afterSum must equal sum!"), i = !1), this._isFacetChart || (e.beforeSum < 0 && (this.chart.error("beforeSum cannot be negative!"), i = !1), e.afterSum < 0 && (this.chart.error("afterSum cannot be negative!"), i = !1), e.sum < 0 && (this.chart.error("sum cannot be negative!"), i = !1)))
                        }
                        return i
                    }, e.prototype.addVerifiedData = function (t, e) {
                        this.chart.scene.loading = this.hasPendingRequests();
                        var i = e.id,
                            n = {};
                        return n[i] = !0, t ? this.chart.log("Data arrived, id=" + i + ", offset=" + t.offset + ", len=" + e.subvalues.length + " of " + (t.limit || "unset")) : this.chart.log("Data arrived, id=" + i + ", offset=" + e.offset + ", len=" + e.subvalues.length + " of " + (e.limit || "unset")), this.dataSettings.autoCategories && (e = this.autoCategorize(e, this.dataSettings.autoCategories)), this.addDataInt(i, e.subvalues, e.offset, e.limit, e.afterSum, e.beforeSum, e.sum, e, n), {
                            pieChartPieIds: n
                        }
                    }, e.prototype.requestFailedPermanently = function (t) {
                        if (this.chart.scene.loading = this.hasPendingRequests(), t) {
                            var e = new s;
                            e.done = !0, this.pies[t.id] = e, this.chart.error("Data request failed for pie with ID `" + t.id + "`."), delete this.requestedPies[t.id]
                        } else this.chart.error("Data request failed.")
                    }, e
                }(d.Data);
                t.Data = a;
                var o = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.marker = new l, e.showOthers = !1, e
                    }
                    return n(e, t), e
                }(d.SettingsLegend);
                t.SettingsLegend = o;
                var l = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.shape = "square", e
                    }
                    return n(e, t), e
                }(d.SettingsLegendMarker);
                t.SettingsLegendMarker = l;
                var h = function (t) {
                        function e(e, i, n) {
                            var r = t.call(this, e, i, null, null) || this;
                            return r.sliceHovered = !1, r.data = n, r
                        }
                        return n(e, t), e.prototype.isHovered = function () {
                            return this.hoverCount > 0 || this.sliceHovered
                        }, e
                    }(d.LegendEntry),
                    u = function (t) {
                        function e(e) {
                            var i = t.call(this, e) || this;
                            return i.paintOrder = 20, i.updateOrder = 1e3, i
                        }
                        return n(e, t), e.prototype.onSceneChange = function (e) {
                            t.prototype.onSceneChange.call(this, e);
                            var i = e.changes;
                            i.pie && (this.rebuildItems(), i.bounds = !0)
                        }, e.prototype.getLastHoveredSlice = function () {
                            var t = this.getLastHoveredEntry();
                            return t ? t.data : null
                        }, e.prototype.doAnimations = function () {
                            for (var t = this.chart.scene.hoverSlice, e = 0; e < this.entries.length; e++) this.entries[e].sliceHovered = this.entries[e].data === t;
                            for (var i = this.chart.scene.selection, e = 0; e < i.length; e++) {
                                var n = this.entryIndex[i[e].id];
                                n && (n.sliceHovered = !0)
                            }
                        }, e.prototype.paintMarker = function (t, e, i, n, r) {
                            var s = r.data,
                                a = {
                                    fillColor: s.currentFillColor,
                                    lineColor: this.settings.marker.lineColor
                                },
                                o = t.context;
                            o.beginPath();
                            var l = this.settings.marker.shape;
                            l || (l = "circle"), d.Graphics.strokeMarker(o, l, e, i, n), d.Graphics.paint(o, a)
                        }, e.prototype.rebuildItems = function () {
                            var t = [],
                                e = this.chart.scene.peek();
                            if (e) {
                                var i = this.settings.text.fillColor,
                                    n = function (t) {
                                        return new h(t.data.nameLegend || t.label.text || t.data.name, i, t)
                                    },
                                    r = this.settings.showOthers,
                                    s = e.slices,
                                    a = e.previousSlice,
                                    o = e.othersSlice;
                                r && a && !a.removed && t.push(n(a)), t.push.apply(t, s.map(n)), r && o && !o.removed && t.push(n(o))
                            }
                            this.entryIndex = {};
                            for (var l = 0; l < t.length; l++) this.entryIndex[t[l].data.id] = t[l];
                            this.resetEntries(t)
                        }, e.prototype.itemClicked = function (t, e) {}, e
                    }(d.Legend);
                t.Legend = u;
                var p = function () {
                    function t() {
                        this.hwidth = 0, this.hheight = 0, this.x = null, this.y = null, this.userPlaced = !1, this.inside = !0
                    }
                    return t
                }();
                t.Icon = p;
                var f = function () {
                    function t(t, e) {
                        this.id = null, this.pie = null, this.data = null, this.index = 0, this.value = 0, this.percent = null, this.fraction = 0, this.cutoutDistance = 0, this.selectDistance = 15, this.selection = 0, this.brightness = 1, this.expandable = !0, this.selected = !1, this.active = !1, this.removed = !1, this.icon = null, this.iconOffset = null, this.url = null, this.urlTarget = null, this.userPlaced = !1, this.inside = !0, this.x = 0, this.y = 0, this.originalId = null, this.currentCutoutDistance = null, this.currentFraction = null, this.currentInsideLabel = null, this.currentLabel = null, this.currentIcon = null, this.currentLineColor = null, this.currentFillColor = null, this.targetFillColor = null, this.targetLineColor = null, this._resetLabelText = !1, this._label = {
                            textStyle: {}
                        }, this._insideLabel = {
                            textStyle: {}
                        }, this.lineColor = null, this.fillColor = null, this.fillColor2 = null, this.lineWidth = 1, this.lineDash = null, this.lineBrightness = 0, this._animatorF = null, this._animatorLineColor = null, this._animatorFillColor = null, this._animatorCutout = null, this._renderParams = null, this.index = e, this.pie = t
                    }
                    return Object.defineProperty(t.prototype, "label", {
                        get: function () {
                            return this._label
                        },
                        set: function (t) {
                            d.Helpers.isObjectOrArray(t) ? this._label = t : (d.Helpers.warn("Slice.label should no longer be set to the text value - instead use Slice.label.text."), this._label.text = t ? "" + t : null, this._resetLabelText = !1)
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "insideLabel", {
                        get: function () {
                            return this._insideLabel
                        },
                        set: function (t) {
                            d.Helpers.isObjectOrArray(t) ? this._insideLabel = t : (d.Helpers.warn("Slice.insideLabel should no longer be set to the text value - instead use Slice.insideLabel.text."), this._insideLabel.text = t ? "" + t : null, this._resetLabelText && (this._resetLabelText = !1, this._label.text = null))
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "labelStyle", {
                        get: function () {
                            return d.Helpers.warn("Slice.labelStyle is deprecated - use Slice.label instead."), this._label
                        },
                        set: function (t) {
                            d.Helpers.warn("Slice.labelStyle is deprecated - use Slice.label instead."), t && (t.text || (t.text = this._label.text), d.Helpers.extendDeep(this._label, t))
                        },
                        enumerable: !0,
                        configurable: !0
                    }), Object.defineProperty(t.prototype, "insideLabelStyle", {
                        get: function () {
                            return d.Helpers.warn("Slice.insideLabelStyle is deprecated - use Slice.insideLabel instead."), this._insideLabel
                        },
                        set: function (t) {
                            d.Helpers.warn("Slice.insideLabelStyle is deprecated - use Slice.insideLabel instead."), t && (t.text || (t.text = this._insideLabel.text), d.Helpers.extendDeep(this._insideLabel, t))
                        },
                        enumerable: !0,
                        configurable: !0
                    }), t
                }();
                t.Slice = f;
                var g = function () {
                    function t() {
                        this.id = null, this.data = null, this.total = 1, this.parentSlice = null, this.othersSlice = null, this.previousSlice = null, this.slices = [], this.allSlices = [], this.offset = 0, this.count = 0, this.background = !1, this.activeSliceId = null, this.brightness = 1, this.loading = !1, this.scrollOffset = 0, this.fillColor = null, this.x = 0, this.y = 0, this.startAngle = 0, this.endAngle = 0, this.rotationSpeed = 0, this.currentlyRotating = !1, this.currentStartAngle = null, this.currentEndAngle = null, this.currentRadius = 0, this.innerRadius = 0, this.radius = 0, this.currentInnerRadius = 0, this.colorDistribution = null, this.sliceColors = null, this.removed = !1, this.visibleFraction = 1, this.removeTime = null, this._animatorA0 = null, this._animatorA1 = null, this._animatorR0 = null, this._animatorR1 = null
                    }
                    return t.prototype.getActiveSlice = function () {
                        if (!this.activeSliceId) return null;
                        for (var t = 0; t < this.slices.length; t++) {
                            var e = this.slices[t];
                            if (e.id === this.activeSliceId) return e
                        }
                        return null
                    }, t
                }();
                t.Pie = g;
                var m = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.radius = 100, e.innerRadius = 0, e.currentRadius = null, e.currentInnerRadius = null, e.pies = [], e.stack = [], e.selectionIds = [], e.hoverBack = !1, e.hoverSlice = null, e.hoverLabel = null, e.hoverPie = null, e.view = null, e.selection = [], e.pendingAction = null, e.pendingOffset = null, e
                    }
                    return n(e, t), e.prototype.addPie = function (t) {
                        return this.pies.push(t), this.stack.push(t), t
                    }, e.prototype.removePie = function (t) {
                        if (null !== t) {
                            t.removed = !0, t.removeTime = null, d.Helpers.removeFromArray(this.stack, t);
                            for (var e = 0; e < this.selection.length;) {
                                var i = this.selection[e];
                                i.pie === t ? d.Helpers.removeFromArray(this.selection, i) : e++
                            }
                        }
                    }, e.prototype.deletePie = function (t) {
                        return d.Helpers.removeFromArray(this.pies, t), d.Helpers.removeFromArray(this.stack, t)
                    }, e.prototype.length = function () {
                        return this.stack.length
                    }, e.prototype.peek = function () {
                        return 0 === this.stack.length ? null : this.stack[this.stack.length - 1]
                    }, e.prototype.push = function (t, e) {
                        void 0 === e && (e = null);
                        var i = this.peek();
                        if (i && !e)
                            for (var n = 0; n < i.slices.length; n++) {
                                var r = i.slices[n];
                                if (r.id === t.id) {
                                    e = r;
                                    break
                                }
                            }
                        if (e) {
                            t.parentSlice = e;
                            var s = e.pie,
                                a = this.getSliceAngles(e);
                            t.currentStartAngle = a.a0, t.currentEndAngle = a.a1, t.currentRadius = s.currentRadius, t.currentInnerRadius = s.currentInnerRadius, i.activeSliceId = e.id;
                            for (var n = 0; n < t.allSlices.length; n++) {
                                var r = t.allSlices[n];
                                r.currentFillColor = e.currentFillColor, r.currentLineColor = e.currentLineColor
                            }
                        } else i && (i.activeSliceId = null);
                        return i && (i.background = !0), this.addPie(t)
                    }, e.prototype.pop = function () {
                        if (0 !== this.stack.length) {
                            this.removePie(this.peek());
                            var t = this.peek();
                            t && (t.background = !1, t.brightness = 1)
                        }
                    }, e.prototype.getParent = function (t) {
                        for (var e = null, i = 0; i < this.stack.length; i++) {
                            var n = this.stack[i];
                            if (n === t) return e;
                            e = n
                        }
                        return null
                    }, e.prototype.getChild = function (t) {
                        for (var e = null, i = 0; i < this.stack.length; i++) {
                            var n = this.stack[i];
                            if (e === t) return n;
                            e = n
                        }
                        return null
                    }, e.prototype.updateOnPieChanged = function (t) {
                        var e = this.getParent(t),
                            i = this.getChild(t);
                        if (e && !t.parentSlice)
                            for (var n = 0; n < e.slices.length; n++) {
                                var r = e.slices[n];
                                if (r.id === t.id) {
                                    t.parentSlice = r, e.activeSliceId = r.id;
                                    break
                                }
                            }
                        if (i && !i.parentSlice)
                            for (var n = 0; n < t.slices.length; n++) {
                                var r = t.slices[n];
                                if (r.id === i.id) {
                                    i.parentSlice = r, t.activeSliceId = r.id;
                                    break
                                }
                            }
                    }, e.prototype.findPieAt = function (t, e, i) {
                        return this.view.findPieAt(t, e, i)
                    }, e.prototype.findSliceAt = function (t, e, i, n) {
                        return this.view.findSliceAt(t, e, i, n)
                    }, e.prototype.findLabelAt = function (t, e, i) {
                        return this.view.findLabelAt(t, e, i)
                    }, e.prototype.getSliceAngles = function (t) {
                        for (var e = 0, i = t.pie, n = 0, r = 0; r < i.allSlices.length; r++) {
                            var s = i.allSlices[r];
                            if (n = e, e += s.currentFraction, s.id === t.id) break
                        }
                        var a = i.currentEndAngle - i.currentStartAngle,
                            o = i.currentStartAngle;
                        return {
                            a0: o + a * n,
                            a1: o + a * e
                        }
                    }, e.prototype.getSliceTargetAngles = function (t) {
                        for (var e = 0, i = t.pie, n = 0, r = 0; r < i.allSlices.length; r++) {
                            var s = i.allSlices[r];
                            if (n = e, e += s.currentFraction, s.id === t.id) break
                        }
                        var a = i.currentEndAngle - i.currentStartAngle,
                            o = i.currentStartAngle;
                        return {
                            a0: o + a * n,
                            a1: o + a * e
                        }
                    }, e
                }(d.Scene);
                t.Scene = m;
                var v = function (t) {
                    function e(i) {
                        var n = t.call(this, d.SettingsMapping.PieChartSettings) || this;
                        return n.theme = e.FlatTheme, n.data = [], n.legend = new o, n.navigation = {
                            initialDrilldown: [""],
                            initialOffset: 0
                        }, n.pie = {
                            radius: null,
                            adaptiveRadius: !0,
                            outerMargin: 1,
                            margin: 2,
                            centerMargin: 5,
                            showInnerPiesExport: !0,
                            showInnerPies: !0,
                            innerRadius: .3,
                            innerRadiusWhenDrilldown: .2,
                            startAngle: -Math.PI / 2,
                            endAngle: 1.5 * Math.PI,
                            rotationSpeed: 0,
                            theme: "flat",
                            depth: 0,
                            x: null,
                            y: null,
                            style: {
                                fillColor: "transparent",
                                sliceColors: ["#2fc32f", "#b0dc0b", "#eab404", "#de672c", "#ec2e2e", "#d5429b", "#6f52b8", "#1c7cd5", "#56b9f7", "#0ae8eb"],
                                colorDistribution: "list",
                                brightness: 1
                            },
                            noDataStyle: {
                                fillColor: "#ddd"
                            },
                            backgroundStyle: {},
                            backgroundHoveredStyle: {
                                brightness: .7
                            },
                            styleFunction: null
                        }, n.slice = {
                            margin: 2,
                            minFraction: 0,
                            style: {
                                lineBrightness: 0,
                                brightness: 1,
                                lineWidth: 1,
                                label: {
                                    backgroundStyle: null,
                                    textStyle: {
                                        fillColor: "#000",
                                        font: "12px Arial"
                                    },
                                    lineSpacing: .2,
                                    margin: 4,
                                    padding: 0,
                                    borderRadius: 999,
                                    text: null
                                },
                                insideLabel: {
                                    textStyle: {
                                        fillColor: "#fff",
                                        font: "12px Arial"
                                    },
                                    lineSpacing: .2,
                                    margin: 4,
                                    padding: 0,
                                    borderRadius: 0,
                                    text: null
                                }
                            },
                            hoverStyle: {
                                brightness: 1.2,
                                lineBrightness: 2,
                                lineWidth: .35
                            },
                            selectedStyle: null,
                            backgroundStyle: {
                                fillColor: "#e2e2e2",
                                fillColor2: "#e0e0e0"
                            },
                            backgroundActiveStyle: {
                                brightness: 1.3
                            },
                            othersStyle: {
                                fillColor: "#ccc",
                                lineDecoration: "zigzag"
                            },
                            previousStyle: {
                                fillColor: "#ccc",
                                lineDecoration: "zigzag"
                            },
                            connectorStyle: {
                                lineColor: "#333",
                                lineWidth: 1
                            },
                            expandableMarkStyle: {
                                lineWidth: 1,
                                lineColor: "rgba(255,255,255,0.8)",
                                distance: 4,
                                lineDash: null
                            },
                            styleFunction: null
                        }, n.filters = {
                            sliceFilter: null,
                            allowZeroValues: !1
                        }, n.labels = new y, n.icons = {
                            sizeExtent: [16, 64],
                            placement: "auto",
                            autohideWhenTooSmall: !0
                        }, n.advanced = new x, n.interaction = new C, n.info = {
                            enabled: !0,
                            contentsFunction: null
                        }, n.events = new S, n.toolbar = new d.SettingsToolbar(!1, [new d.SettingsToolbarItem("back"), new d.SettingsToolbarItem("export"), new d.SettingsToolbarItem("zoomOut"), new d.SettingsToolbarItem("fullscreen")]), n.localization = new b, n.toolbar.zoomOut = !1, n.apply(i), n._initializing = !1, n
                    }
                    return n(e, t), e.prototype.apply = function (e) {
                        this.applyCompatibility(e, [{
                            from: "slice.labelStyle",
                            to: "slice.style.label"
                        }, {
                            from: "slice.insideLabelStyle",
                            to: "slice.style.insideLabel"
                        }, {
                            from: "labels.connectorStyle",
                            to: "slice.connectorStyle"
                        }, {
                            from: "labels.textStyle",
                            to: "slice.style.label.textStyle"
                        }, {
                            from: "labels.backgroundStyle",
                            to: "slice.style.label.backgroundStyle"
                        }, {
                            from: "labels.insideTextStyle",
                            to: "slice.style.insideLabel.textStyle"
                        }, {
                            from: "labels.padding",
                            to: "slice.style.label.padding"
                        }, {
                            from: "labels.borderRadius",
                            to: "slice.style.label.borderRadius"
                        }, {
                            from: "area.initialPieId",
                            to: "navigation.initialDrilldown"
                        }, {
                            from: "area.initialPieOffset",
                            to: "navigation.initialOffset"
                        }, {
                            from: "area.initialAnimation",
                            to: "advanced.initialAnimation"
                        }, {
                            from: "advanced.iconMinSize",
                            alternative: "icons.sizeExtent[0]"
                        }, {
                            from: "advanced.pointer.dragSensitivity",
                            to: "interaction.selection.swipeSensitivity"
                        }]);
                        var i = t.prototype.apply.call(this, e);
                        return i
                    }, e
                }(d.Settings);
                v.FlatTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-flat",
                        assets: []
                    },
                    pie: {
                        theme: "flat",
                        depth: 0
                    }
                }, v.DarkTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-dark",
                        assets: []
                    },
                    area: {
                        style: {
                            fillColor: "rgba(28,26,28,.1)"
                        }
                    },
                    title: {
                        margin: 15,
                        style: {
                            fillColor: "#A8A7A8"
                        }
                    },
                    pie: {
                        theme: "flat",
                        depth: 0,
                        style: {
                            sliceColors: ["#32CD32", "#36BEFF", "#FBBD30", "#EE3431", "#894BBC", "#0EC9AC", "#524BBC", "#0b83ea", "#3ca20d", "#BC438F"]
                        }
                    },
                    slice: {
                        connectorStyle: {
                            lineColor: "#4C4C4C"
                        },
                        style: {
                            label: {
                                textStyle: {
                                    fillColor: "#A8A7A8"
                                }
                            }
                        }
                    },
                    legend: {
                        text: {
                            fillColor: "#A8A7A8"
                        },
                        marker: {
                            lineColor: null
                        }
                    }
                }, v.BevelTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-flat",
                        assets: []
                    },
                    pie: {
                        theme: "bevel",
                        depth: 0
                    }
                }, v.GradientTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-flat",
                        assets: []
                    },
                    pie: {
                        theme: "smoothy",
                        depth: 0
                    }
                }, v.CanTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-flat",
                        assets: []
                    },
                    pie: {
                        theme: "can",
                        depth: 10
                    }
                }, t.Settings = v;
                var y = function () {
                    function t() {
                        this.enabled = !0, this.connectors = !0, this.connectorLength = 20, this.angle = 0, this.insideLabel = "append", this.insideLabelVisibilityFraction = .8, this.interLabelSpacing = .6, this.placement = "aligned"
                    }
                    return t
                }();
                t.SettingsLabels = y;
                var S = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.onPieChange = null, e.onPieReadyStateChanged = null, e
                    }
                    return n(e, t), e
                }(d.SettingsEvents);
                t.SettingsEvents = S;
                var b = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.othersLabel = "Others", e.previousLabel = "Previous", e
                    }
                    return n(e, t), e
                }(d.SettingsLocalization);
                t.SettingsLocalization = b;
                var C = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.mode = "drilldown", e.coverCenter = !1, e.selection = {
                            enabled: !0,
                            tolerance: 2,
                            swipe: !1,
                            swipeSensitivity: 10,
                            partialSwipe: !1,
                            maxSwipeDistance: 45
                        }, e.animation = {
                            scrollDuration: 500,
                            hoverDuration: 200
                        }, e.others = {
                            enabled: !0,
                            centerGoesToPrevious: !1,
                            navigationFraction: .15,
                            maxSlicesVisible: 15,
                            minSlices: 1,
                            maxOthersFraction: .6,
                            minSliceFraction: .01
                        }, e.scrolling = {
                            enabled: !1
                        }, e
                    }
                    return n(e, t), e
                }(d.SettingsInteraction);
                t.SettingsInteraction = C;
                var x = function (t) {
                    function e() {
                        var e = t.call(this) || this;
                        return e.iconMinSize = null, e.initialAnimation = !0, e.renderQuality = 1, e.backImage = "builtin://piechart-back", e.backImageBackground = null, e.backAlwaysVisible = !1, e.labelInsideTreshold = 1, e.builtinAssets["piechart-back"] = c.PiechartBack, e.pointer.noClickOnDoubleClick = !1, e
                    }
                    return n(e, t), e
                }(d.SettingsAdvanced);
                t.SettingsAdvanced = x;
                var w = function (e) {
                    function i(i) {
                        var n = e.call(this) || this;
                        return n.animationOrder = 1100, n.paintOrder = 10, n.updateOrder = 1200, n.currentSlice = null, n.currentLabel = null, n.currentPie = null, n.hoveringLegend = !1, n.draggedLabelSlice = null, n.draggedLabel = null, n.hoverEvent = null, n.dragStartConditions = {
                            angle: 1 / 0,
                            distance: 1 / 0,
                            slice: null,
                            pie: null
                        }, n.isScrolling = !1, n.px = 0, n.py = 0, n.chart = i, n.scene = i.scene, n.events = i.events, n.scrolling = new t.Scrolling(i), n
                    }
                    return n(i, e), i.prototype.doAnimations = function (t) {
                        this.hoverEvent && this.onPointerMove(this.hoverEvent)
                    }, i.prototype.previewPointerDrag = function (t) {
                        this.hoverEvent = t
                    }, i.prototype.onPointerMove = function (t) {
                        this.hoverEvent = t, this.updateCurrentObject(t)
                    }, i.prototype.onPointerOut = function (t) {
                        this.updateCurrentObject(t), this.switchCurrentSlice(null, null, !1, t), this.hoverEvent = null
                    }, i.prototype.onPointerDown = function (t) {
                        this.handlePointerDown(t), this.scrolling.handlePointerDown(t)
                    }, i.prototype.handlePointerDown = function (t) {
                        this.updateCurrentObject(t);
                        var e = this.currentSlice;
                        (e || this.currentPie) && (t.consumed = !0), this.px = t.x, this.py = t.y;
                        var i = this.scene.settings.interaction.selection;
                        if (i.swipe || i.partialSwipe) {
                            var n = this.scene.settings.interaction,
                                r = this.scene.pies[0],
                                s = r && n.others.centerGoesToPrevious && r.previousSlice,
                                a = n.coverCenter && !s && (!r || !r.background),
                                o = this.scene.findSliceAt(t.x, t.y, n.selection.tolerance, a);
                            if (this.dragStartConditions.slice = null, this.dragStartConditions.pie = null, this.dragStartConditions.distance = 1 / 0, this.dragStartConditions.angle = 0, o && null !== o.id) {
                                this.dragStartConditions.slice = e, this.dragStartConditions.pie = r;
                                var l = t.x - r.x,
                                    h = t.y - r.y,
                                    u = Math.sqrt(l * l + h * h);
                                this.dragStartConditions.distance = u - e.currentCutoutDistance, this.dragStartConditions.angle = 180 * Math.atan2(h, l) / Math.PI
                            }
                        }
                        var c = this.scene.findLabelAt(t.x, t.y, this.scene.settings.interaction.selection.tolerance);
                        this.draggedLabelSlice = c.slice, this.draggedLabel = c.label, this.draggedLabel = null, this.draggedLabelSlice = null
                    }, i.prototype.onPointerDrag = function (t) {
                        this.handlePointerDrag(t), this.scrolling.handlePointerDrag(t)
                    }, i.prototype.handlePointerDrag = function (t) {
                        var e = this.scene.settings.interaction.selection;
                        if (!this.isScrolling) {
                            if (t.distance({
                                    x: this.px,
                                    y: this.py
                                }) < e.swipeSensitivity) return;
                            this.isScrolling = !0
                        }
                        if ((e.swipe || e.partialSwipe) && (this.currentSlice || this.dragStartConditions.slice)) {
                            var i = this.dragStartConditions.slice;
                            if (null !== i) {
                                var n = this.dragStartConditions.pie,
                                    r = this.dragStartConditions.distance,
                                    s = this.dragStartConditions.angle;
                                s === 1 / 0 && (s = 180 * Math.atan2(t.y - n.y, t.x - n.x) / Math.PI);
                                var a = t.x - n.x,
                                    o = t.y - n.y,
                                    l = 180 * Math.atan2(o, a) / Math.PI,
                                    h = Math.abs(s - l);
                                if (h <= 90) {
                                    var u = Math.sqrt(a * a + o * o);
                                    this.dragStartConditions.distance === 1 / 0 && (r = u - i.currentCutoutDistance);
                                    var c = this.scene.innerRadius >= i.selectDistance / 2 ? -i.selectDistance / 2 : 0,
                                        d = u * Math.cos(h * Math.PI / 180),
                                        p = d - r > e.maxSwipeDistance,
                                        f = d - r > c;
                                    i.userPlaced = !0, p ? i.currentCutoutDistance = e.maxSwipeDistance : f && (i.currentCutoutDistance = d - r > c ? d - r | 0 : 0), i.selection = i.currentCutoutDistance > 0 ? i.currentCutoutDistance / e.maxSwipeDistance * 100 : 0, t.changes.pie = !0
                                }
                            }
                        }
                        if (this.draggedLabel) {
                            var g = this.draggedLabel;
                            g.userPlaced = !0, g.x += t.dx, g.y += t.dy, t.consumed = !0, t.changes.pie = !0
                        }
                    }, i.prototype.onPointerUp = function (t) {
                        this.handlePointerUp(t), this.scrolling.handlePointerUp(t)
                    }, i.prototype.handlePointerUp = function (t) {
                        this.isScrolling = !1;
                        var e = this.scene.settings.interaction.selection;
                        if (e.swipe || e.partialSwipe) {
                            var i = this.dragStartConditions.slice;
                            if (i) {
                                var n = i.currentCutoutDistance >= i.selectDistance / 2 && !i.selected,
                                    r = i.currentCutoutDistance < i.selectDistance / 2 && i.selected;
                                e.swipe || i.currentCutoutDistance <= 0 && e.partialSwipe ? i.userPlaced = !1 : e.partialSwipe && (i.userPlaced = !0), r || n ? this.updateSelection(t, i, !1) : i.currentCutoutDistance >= i.selectDistance / 2 && i.selected && this.setSelection([i], [], !0)
                            }
                        }
                        this.draggedLabel && (this.draggedLabel = null, t.consumed = !0)
                    }, i.prototype.onPointerCancel = function (t) {
                        this.onPointerUp(t)
                    }, i.prototype.defaultClick = function (t, e) {
                        var i = this.chart,
                            n = e.clickSlice,
                            r = e.clickPie,
                            s = "drilldown" === i.settings.interaction.mode;
                        if (s || n && (n === n.pie.othersSlice || n === n.pie.previousSlice))
                            if (n)
                                if (n.url) d.Helpers.openUrl(n.url, n.urlTarget), t.preventDefault();
                                else {
                                    var a = i.settings.interaction.selection.enabled;
                                    a && t.ctrlKey || !this.chart.navigator.expandSlice(n, "user") || t.preventDefault()
                                }
                        else r && "back" === e.clickOrigin && (this.setSelection([], [], !1, "user"), this.chart.navigator.goCenter("user"), t.preventDefault())
                    }, i.prototype.onClick = function (t) {
                        this.onPointerMove(t);
                        var e = this.createClickArgs(t);
                        if ("legend" !== e.clickOrigin || this.chart.settings.legend.interaction.click ? (this.chart.notifyClick(t, e), (this.currentSlice || this.currentPie) && (t.consumed = !0), t.defaultPrevented || this.updateSelection(t, this.currentSlice, !1)) : "legend" === e.clickOrigin && (e.clickSlice = null, e.clickPie = null, this.chart.notifyClick(t, e)), t.touch) {
                            var i = t.x;
                            t.x = 1e9, this.onPointerOut(t), t.x = i
                        }
                    }, i.prototype.onLongPress = function (t) {
                        this.updateSelection(t, this.currentSlice, !1)
                    }, i.prototype.onRightClick = function (t) {
                        this.onPointerMove(t), (this.currentSlice || this.currentPie) && (t.consumed = !0), this.chart.notifyRightClick(t, this.createClickArgs(t)), t.defaultPrevented && (t.consumed = !0)
                    }, i.prototype.onDoubleClick = function (t) {
                        this.onPointerMove(t), this.chart.notifyDoubleClick(t, this.createClickArgs(t)), t.consumed = !0
                    }, i.prototype.onTripleClick = function (t) {
                        this.onPointerMove(t), this.chart.notifyTripleClick(t, this.createClickArgs(t)), t.consumed = !0
                    }, i.prototype.createClickArgs = function (t) {
                        var e = this.chart.createEventArguments(t, "user"),
                            i = e.hoverSlice;
                        if (e.clickSlice = i, e.clickPie = i ? i.pie : e.hoverPie, e.clickLabel = e.hoverLabel, i) {
                            var n = e.clickLabel;
                            this.hoveringLegend ? e.clickOrigin = "legend" : n ? n === i.currentInsideLabel ? e.clickOrigin = "insideLabel" : e.clickOrigin = "label" : e.clickOrigin = "slice"
                        } else this.scene.hoverBack && (e.clickOrigin = "back");
                        return e
                    }, i.prototype.updateSelection = function (t, e, i) {
                        var n = this.scene,
                            r = n.settings.interaction;
                        if (r.selection.enabled) {
                            var s = t.shiftKey,
                                a = "toggle" === r.mode || t.ctrlKey;
                            e ? s || i && e.selected || a && !e.selected ? e.selected || (this.scene.selection.push(e), e.selected = !0, this.setSelection(n.selection, n.selectionIds, !0)) : a && e.selected ? (d.Helpers.removeFromArray(n.selection, e), e.selected = !1, this.setSelection(n.selection, n.selectionIds, !0)) : !e.selected || n.selection.length > 1 ? this.setSelection([e]) : this.setSelection([]) : s || a || this.setSelection([])
                        }
                    }, i.prototype.switchCurrentSlice = function (t, e, i, n) {
                        t === this.currentSlice && e === this.currentLabel && this.hoveringLegend === i || (n.changes.current = !0, this.scene.hoverSlice && (this.scene.hoverSlice.active = !1), this.scene.hoverPie && (this.scene.hoverPie.active = !1), this.scene.hoverSlice = t, this.scene.hoverPie = null, this.scene.hoverLabel = e, this.currentSlice = t, this.currentLabel = e, this.currentPie = null, this.hoveringLegend = i, t && (t.active = !0), this.events.notifySceneChanges({
                            pie: !0
                        }), this.chart.notifyHoverChanged(n, this.chart.createEventArguments(n, "user")))
                    }, i.prototype.switchCurrentPie = function (t, e) {
                        t !== this.currentPie && (e.changes.current = !0, this.scene.hoverSlice && (this.scene.hoverSlice.active = !1), this.scene.hoverPie && (this.scene.hoverPie.active = !1), this.scene.hoverPie = t, this.scene.hoverSlice = null, this.currentSlice = null, this.currentPie = t, this.hoveringLegend = !1, t && (t.active = !0), this.events.notifySceneChanges({
                            pie: !0
                        }), this.chart.notifyHoverChanged(e, this.chart.createEventArguments(e, "user")))
                    }, i.prototype.onSceneChange = function (t) {
                        t.changes.pie && this.updateSelectionIds() && (this.events.notifySceneChanges({
                            selection: !0
                        }), this.chart.notifySelectionChanged(this.chart.createEventArguments(null, "api")))
                    }, i.prototype.updateSelectionIds = function () {
                        for (var t = [], e = 0; e < this.scene.selectionIds.length; e++)
                            for (var i = this.scene.selectionIds[e], n = 0; n < this.scene.pies.length; n++) {
                                var r = this.scene.pies[n];
                                if (!r.background)
                                    for (var s = 0; s < r.slices.length; s++) {
                                        var a = r.slices[s];
                                        if (a.id === i) {
                                            t.push(a);
                                            break
                                        }
                                    }
                            }
                        if (t.length > 0)
                            for (var s = 0; s < t.length; s++) {
                                var a = t[s];
                                a.selected || (a.selected = !0, this.scene.selection.push(a)), d.Helpers.removeFromArray(this.scene.selectionIds, a.id)
                            }
                        return t.length > 0
                    }, i.prototype.setSelection = function (t, e, i, n) {
                        void 0 === e && (e = []), void 0 === i && (i = !1), void 0 === n && (n = "user"), this.scene.selectionIds = e;
                        var r;
                        if (i) r = !0;
                        else {
                            for (var s = 0; s < this.scene.selection.length; s++) {
                                var a = this.scene.selection[s];
                                t.indexOf(a) < 0 && (a.selected = !1, r = !0)
                            }
                            for (var s = 0; s < t.length; s++) {
                                var a = t[s];
                                a.selected || (a.selected = !0, r = !0)
                            }
                            this.scene.selection = t
                        }
                        var o = this.updateSelectionIds();
                        r = r || o, r && (this.events.notifySceneChanges({
                            selection: !0
                        }), this.chart.notifySelectionChanged(this.chart.createEventArguments(null, n)))
                    }, i.prototype.updateCurrentObject = function (t) {
                        var e, i = this.scene,
                            n = i.settings.interaction,
                            r = i.findPieAt(t.x, t.y, n.selection.tolerance),
                            s = r && n.others.centerGoesToPrevious && r.previousSlice,
                            a = n.coverCenter && !s && (!r || !r.background),
                            o = i.findLabelAt(t.x, t.y, n.selection.tolerance),
                            l = !1;
                        e = o.slice ? o.slice : i.findSliceAt(t.x, t.y, n.selection.tolerance, a);
                        var h = this.chart.legend;
                        !e && h && (e = h.getLastHoveredSlice(), e && (l = !0)), e && (this.chart.settings.legend.interaction.click && (t.cursor = "pointer"), t.hovered = !0), this.switchCurrentSlice(e, o.label, l, t), r && (r.background || s) && !e ? (t.cursor = "pointer", t.hovered = !0, r.background ? this.switchCurrentPie(r, t) : (this.switchCurrentSlice(r.previousSlice, null, !1, t), this.switchCurrentPie(null, t)), i.hoverBack = !0) : (this.switchCurrentPie(null, t), i.hoverBack = !1)
                    }, i
                }(d.ChartElement);
                t.Selection = w;
                var L = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.animationOrder = 100, i.paintOrder = 25, i.updateOrder = 900, i.chart = e, i.scene = e.scene, i
                    }
                    return n(e, t), e.needStyleUpdate = function (t) {
                        return t.settings || t.pie || t.selection || t.style
                    }, e.prototype.onSceneChange = function (t) {
                        if (e.needStyleUpdate(t.changes))
                            for (var i = 0; i < this.scene.pies.length; i++) {
                                var n = this.scene.pies[i];
                                this.updatePie(n), this.computePieColors(n);
                                for (var r = 0; r < n.allSlices.length; r++) {
                                    var s = n.allSlices[r];
                                    this.updateSlice(s, r)
                                }
                            }
                    }, e.prototype.updatePie = function (t) {
                        d.Helpers.extendStyleTo(this.scene.settings.pie.style, t), 0 === t.slices.length && d.Helpers.extendStyleTo(this.scene.settings.pie.noDataStyle, t), t.background && d.Helpers.extendStyleTo(this.scene.settings.pie.backgroundStyle, t), this.scene.hoverPie === t && d.Helpers.extendStyleTo(this.scene.settings.pie.backgroundHoveredStyle, t), this.scene.settings.pie.styleFunction && this.scene.settings.pie.styleFunction.call(this.chart.api, t, t.data)
                    }, e.prototype.computePieColors = function (t) {
                        for (var e = t.sliceColors, i = t.colorDistribution, n = 0, r = 0; r < t.slices.length; r++) {
                            var s = t.slices[r];
                            s.removed || (n += 1)
                        }
                        if (1 === n) return void(t.slices[0].fillColor = e[0]);
                        if (1 === e.length) {
                            var a = e[0];
                            e = [a, d.Colors.blend(a, "#fff", .8)]
                        }
                        var o = e.length;
                        if ("gradient" === i)
                            for (var l = 0, r = 0; r < t.slices.length; r++) {
                                var s = t.slices[r];
                                if (!s.removed) {
                                    var h = e[l * (o - 1) | 0],
                                        u = e[l * (o - 1) + 1 | 0],
                                        c = l * (o - 1);
                                    c -= Math.floor(c);
                                    var a = d.Colors.blend(h, u, c, !1);
                                    s.fillColor = a, l += 1 / (n - .9)
                                }
                            } else if ("gradientProportional" === i)
                                for (var l = 0, r = 0; r < t.slices.length; r++) {
                                    var s = t.slices[r];
                                    if (!s.removed) {
                                        var h = e[l * (o - 1) | 0],
                                            u = e[l * (o - 1) + 1 | 0],
                                            c = l * (o - 1);
                                        c -= Math.floor(c);
                                        var a = d.Colors.blend(h, u, c, !1);
                                        s.fillColor = a, l += s.fraction
                                    }
                                } else
                                    for (var p = 0; p < t.slices.length; p++) {
                                        var s = t.slices[p];
                                        if (!s.removed) {
                                            var a = e[(t.offset + p) % o],
                                                f = p / o | 0;
                                            1 === f ? a = d.Colors.derive(a, 1.5, 1) : f >= 2 && (a = d.Colors.derive(a, .5, 1)), s.fillColor = a
                                        }
                                    }
                    }, e.prototype.updateSlice = function (t, e) {
                        if (!t.removed) {
                            var i = t.pie,
                                n = this.scene.settings.slice,
                                r = n.styleFunction;
                            t.expandable = this.scene.mainData.canExpand(t.id), d.Helpers.extendDeep(t, n.style), t === i.othersSlice ? d.Helpers.extendDeep(t, n.othersStyle) : t === i.previousSlice && d.Helpers.extendDeep(t, n.previousStyle), i.total > 0 ? t.percent = t.value / i.total * 100 : t.percent = 0;
                            var s = t.label;
                            s.text ? s.text += " " : s.text = "", t.data.name && (s.text += t.data.name + " "), s.text += t.percent.toFixed(1) + "%", t.cutoutDistance = t.selected ? t.selectDistance : 0, this.scene.hoverSlice === t && d.Helpers.extendDeep(t, n.hoverStyle), t.data.style && d.SettingsHelper.updateRecursive(t, t.data.style, d.SettingsMapping.PieChartSettingsSliceStyle, {}), r && (t._resetLabelText = !0, r.call(this.chart.api, t, t.data)), i.background && (i.activeSliceId !== t.id ? (d.Helpers.extendDeep(t, n.backgroundStyle), e % 2 === 1 && (t.fillColor = t.fillColor2)) : d.Helpers.extendDeep(t, n.backgroundActiveStyle));
                            var a = "rgba(255,255,255,0)";
                            t.fillColor && (a = t.fillColor);
                            var o = "rgba(255,255,255,0)";
                            t.lineColor ? o = t.lineColor : t.lineBrightness && (o = d.Colors.derive(a, t.lineBrightness, 1));
                            var l = t.brightness * i.brightness;
                            1 !== l && (a = d.Colors.derive(a, l, 1), o = d.Colors.derive(o, l, 1), a.indexOf("255,255,255") !== -1 && o.indexOf("255,255,255") !== -1 && (o = "rgb(200,200,200)")),
                                i.removed && i.parentSlice ? (t.targetFillColor = i.parentSlice.targetFillColor, t.targetLineColor = i.parentSlice.targetLineColor) : (t.targetFillColor = d.Colors.normalize(a), t.targetLineColor = d.Colors.normalize(o))
                        }
                    }, e
                }(d.ChartElement);
                t.Styles = L;
                var T = function (t) {
                    function e(e) {
                        return t.call(this, e) || this
                    }
                    return n(e, t), e.prototype.createDom = function (e) {
                        t.prototype.createDom.call(this, e), this.backgroundImage.className += " DVSL-PC-background-image", this.backgroundImage.style.display = "none"
                    }, e.prototype.doAnimations = function (e) {
                        if (t.prototype.doAnimations.call(this, e), this.scene.settings.area.style.image && this.scene.pies.length > 0) {
                            var i = this.scene.currentInnerRadius - this.scene.settings.pie.margin,
                                n = this.scene.pies[0].x,
                                r = this.scene.pies[0].y;
                            (0 !== n || 0 !== r) && i > 0 ? (this.backgroundImage.style.left = Math.round(n - i) + "px", this.backgroundImage.style.top = Math.round(r - i) + "px", this.backgroundImage.style.width = Math.round(2 * i) + "px", this.backgroundImage.style.height = Math.round(2 * i) + "px", this.backgroundImage.style.display = "") : this.backgroundImage.style.display = "none"
                        }
                    }, e
                }(d.DomLayer);
                t.DomLayer = T;
                var k = function () {
                    function t(t) {
                        this.pie = null, this.chart = t, this.scene = t.scene, this.events = t.events
                    }
                    return t.prototype.handlePointerDown = function (t) {
                        this.scene.settings.interaction.scrolling.enabled && (this.pointer || (this.pointer = t.identifier, this.pie = this.scene.peek()))
                    }, t.prototype.handlePointerDrag = function (t) {
                        this.pie && this.scene.settings.interaction.scrolling.enabled && (t.consumed = !0, t.identifier === this.pointer && (this.pie.scrollOffset += this.scene.view.getMovement(this.pie, t).dfraction, this.updatePieScrolling(this.pie), t.changes.pie = !0))
                    }, t.prototype.handlePointerUp = function (t) {
                        this.scene.settings.interaction.scrolling.enabled && t.identifier === this.pointer && (this.updatePieAfterScroll(this.pie), this.pie = null, this.pointer = null)
                    }, t.prototype.updatePieScrolling = function (t) {
                        if (t.scrollOffset > 0 && 0 === t.offset && (t.scrollOffset = 0), 0 !== t.scrollOffset) return this.scene.view.updatePie(this.pie, !1)
                    }, t.prototype.updatePieAfterScroll = function (t) {
                        return t.scrollOffset = 0, this.scene.view.updatePie(t, !0)
                    }, t
                }();
                t.Scrolling = k;
                var A = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.animationOrder = 250, i.paintOrder = 30, i.updateOrder = 650, i.chart = e, i.scene = e.scene, i.events = e.events, i
                    }
                    return n(e, t), e.prototype.onNewDataObject = function () {}, e.prototype.setPie = function (t, e, i) {
                        Array.isArray(t) || (t = [t]), this.scene.pendingAction = null;
                        for (var n = 0; this.scene.length() > t.length;) this.scene.pop(), n++;
                        for (; this.scene.length() > 0 && this.scene.peek().id !== t[this.scene.length() - 1];) this.scene.pop(), n++;
                        for (; this.scene.length() < t.length;) {
                            var r = new g;
                            r.id = t[this.scene.length()], r.offset = this.scene.length() + 1 === t.length ? e : 0, this.scene.push(r), this.scene.view.updatePie(r), n++
                        }
                        var s = this.scene.peek();
                        s && s.offset !== e ? (this.scroll(s, e), n++) : n && s && this.scene.view.updatePie(s), n && (this.chart.notifyChartUpdate(i), this.events.notifySceneChanges({
                            pie: !0
                        }))
                    }, e.prototype.getPie = function () {
                        return this.scene.stack.map(function (t) {
                            return t.id
                        })
                    }, e.prototype.getPieOffset = function () {
                        return this.scene.peek().offset
                    }, e.prototype.goBack = function (t) {
                        var e = this.scene.length();
                        1 === e ? this.goPrevious(this.scene.peek(), t, 0) : e > 1 && (this.scene.pop(), this.scene.pendingAction = null, this.updateAndNotifyCurrent(t))
                    }, e.prototype.goCenter = function (t) {
                        var e = this.scene.peek();
                        e.offset > 0 && this.scene.settings.interaction.others.centerGoesToPrevious ? this.goPrevious(e, t) : this.scene.length() > 1 && (this.scene.pop(), this.scene.pendingAction = null, this.updateAndNotifyCurrent(t))
                    }, e.prototype.drillDown = function (t, e) {
                        this.scene.pendingAction = null;
                        var i = new g;
                        i.id = t, i.offset = 0, this.scene.push(i), this.updateAndNotifyCurrent(e)
                    }, e.prototype.goOthers = function (t, e) {
                        var i = this.scene.view.scrollForward(t, t.offset + t.count);
                        i || (this.scene.pendingAction = "forward", this.scene.pendingOffset = null), this.events.notifySceneChanges({
                            pie: !0
                        }), this.chart.notifyChartUpdate(e)
                    }, e.prototype.goPrevious = function (t, e, i) {
                        if (void 0 === i && (i = null), !(t.offset <= 0)) {
                            var n = this.scene.view.scrollBackward(t, i);
                            n || (this.scene.pendingAction = "back", this.scene.pendingOffset = null), this.chart.notifyChartUpdate(e), this.events.notifySceneChanges({
                                pie: !0
                            })
                        }
                    }, e.prototype.scroll = function (t, e) {
                        var i = !0;
                        t.offset > e ? (i = this.scene.view.scrollBackward(t, e), i || (this.scene.pendingAction = "back", this.scene.pendingOffset = e)) : t.offset < e && (i = this.scene.view.scrollForward(t, e), i || (this.scene.pendingAction = "forward", this.scene.pendingOffset = e))
                    }, e.prototype.updateAndNotifyCurrent = function (t) {
                        var e = this.scene.peek();
                        this.scene.view.updatePie(e), this.chart.notifyChartUpdate(t), this.events.notifySceneChanges({
                            pie: !0
                        })
                    }, e.prototype.expandSlice = function (t, e) {
                        var i = t.pie;
                        if (i !== this.scene.peek()) return this.chart.setSelection([]), this.goBack(e), !0;
                        if (t === i.othersSlice) return this.chart.setSelection([]), this.goOthers(i, e), !0;
                        if (t === i.previousSlice) return this.chart.setSelection([]), this.goPrevious(i, e), !0;
                        var n = t.id;
                        return !(!t.expandable || !this.scene.mainData.canExpand(n)) && (this.chart.setSelection([]), this.drillDown(n, e), !0)
                    }, e.prototype.onSceneChange = function (t) {
                        var e = !1,
                            i = this.scene.peek();
                        if (t.changes.data || t.changes.pieChartPieIds || t.changes.dataArrived)
                            for (var n = t.changes.pieChartPieIds || Object.create(null), r = 0; r < this.scene.stack.length; r++) {
                                var s = this.scene.stack[r];
                                if (n[s.id] || !s.data || s === i || t.changes.dataDeep) {
                                    if (s === i) {
                                        var a = void 0;
                                        a = "forward" === this.scene.pendingAction ? this.scene.view.scrollForward(s, this.scene.pendingOffset) : "back" === this.scene.pendingAction ? this.scene.view.scrollBackward(s, this.scene.pendingOffset) : this.scene.view.updatePie(s), a && (this.scene.pendingAction = null, this.scene.pendingOffset = null), e = a
                                    } else this.scene.view.updatePie(s);
                                    t.changes.pie = !0
                                }
                            }
                        e && this.chart.notifyChartUpdate("data", !0)
                    }, e
                }(d.Navigator);
                t.Navigator = A;
                var M = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.currentSlice = null, i.animationOrder = 500, i.paintOrder = 15, i.updateOrder = 1100, i.activePointer = null, i.chart = e, i.scene = e.scene, i.options = i.scene.settings, i.events = e.events, i.popup = new d.InfoPopup(e), i
                    }
                    return n(e, t), e.prototype.previewPointerMove = function (t) {
                        if (null === this.activePointer || this.activePointer === t.identifier) {
                            var e = t.y,
                                i = t.x;
                            if (this.options.info.enabled && (!this.chart.legend || !this.chart.legend.containsCoordinate(i, e))) {
                                var n = this.scene.hoverSlice,
                                    r = this.scene.hoverPie;
                                r && !n && (n = r.getActiveSlice()), this.setCurrentObject(i, e, n)
                            }
                        }
                    }, e.prototype.previewRightClick = function (t) {
                        t.touch && (this.activePointer = t.identifier, this.previewPointerMove(t))
                    }, e.prototype.previewPointerCancel = function (t) {
                        null !== this.activePointer && this.activePointer === t.identifier && (this.activePointer = null)
                    }, e.prototype.previewPointerUp = function (t) {
                        null !== this.activePointer && this.activePointer === t.identifier && (this.activePointer = null)
                    }, e.prototype.previewPointerDown = function (t) {
                        null === this.activePointer && (this.activePointer = t.identifier, this.hide())
                    }, e.prototype.previewPointerDrag = function (t) {
                        null !== this.activePointer && this.activePointer !== t.identifier || this.hide()
                    }, e.prototype.previewPointerOut = function (t) {
                        null !== this.activePointer && this.activePointer !== t.identifier || t.touch || this.hide()
                    }, e.prototype.hide = function () {
                        this.activePointer = null, this.setCurrentObject(0, 0, null)
                    }, e.prototype.setCurrentObject = function (t, e, i) {
                        if (i) {
                            if (i !== this.currentSlice) {
                                var n = this.buildContents(i);
                                this.popup.show(t, t, e, n)
                            } else this.popup.updateXY(t, t, e);
                            this.currentSlice = i
                        } else this.currentSlice = null, this.popup.hide()
                    }, e.prototype.buildContents = function (t) {
                        var e = this;
                        if (this.options.info.contentsFunction) {
                            var i = function (i) {
                                if (t === e.currentSlice) return e.popup.updateContents(i)
                            };
                            return this.options.info.contentsFunction.call(this.chart.api, t.data, t, i)
                        }
                        return t.label.text
                    }, e.prototype.remove = function () {
                        this.popup.remove()
                    }, e
                }(d.ChartElement);
                t.InfoPopup = M;
                var I = function () {
                    function t(t) {
                        this.prevTime = 0, this.radiusAnimator = null, this.innerRadiusAnimator = null, this.chart = t, this.scene = t.scene, this.events = t.events
                    }
                    return t.prototype.doAnimations = function (t) {
                        var e = 0;
                        this.prevTime && (e = Math.min(30, t.timeStamp - this.prevTime));
                        var i = this.scene.settings.interaction.animation.scrollDuration,
                            n = this.scene.settings.interaction.animation.hoverDuration,
                            r = t.timeStamp,
                            s = [],
                            a = [],
                            o = !1;
                        if (this.scene.settings.pie.adaptiveRadius) {
                            this.innerRadiusAnimator || (this.innerRadiusAnimator = new d.Animator(0, this.scene.innerRadius, i, "<>", r), this.radiusAnimator = new d.Animator(0, this.scene.radius, i, "<>", r));
                            var l = this.radiusAnimator.updateAndGet(this.scene.radius, r);
                            this.scene.currentRadius = l.value;
                            var h = l.changes;
                            l = this.innerRadiusAnimator.updateAndGet(this.scene.innerRadius, r), this.scene.currentInnerRadius = l.value;
                            var u = l.changes;
                            o = o || h || u, t.animating = t.animating || o
                        } else this.scene.currentRadius === this.scene.radius && this.scene.currentInnerRadius === this.scene.innerRadius || (o = !0, this.scene.currentRadius = this.scene.radius, this.scene.currentInnerRadius = this.scene.innerRadius);
                        for (var c = 0; c < this.scene.pies.length; c++) {
                            var p = this.scene.pies[c],
                                f = t.changes.bounds || L.needStyleUpdate(t.changes),
                                g = !1;
                            if (p.removed === !0 && null === p.removeTime && (p.removeTime = r + i), p.removed && (t.animating = !0, g = p.removeTime < r), g) s.push(p);
                            else {
                                if (p._animatorA0 || (f = !0, p._animatorA0 = new d.Animator(p.currentStartAngle, p.startAngle, i, "<>", r), p._animatorA1 = new d.Animator(p.currentEndAngle, p.endAngle, i, "<>", r), p._animatorR0 = new d.Animator(p.currentInnerRadius, p.innerRadius, i, "<>", r), p._animatorR1 = new d.Animator(p.currentRadius, p.radius, i, "<>", r), this.scene.settings.advanced.initialAnimation || (p._animatorA0.jump(p.startAngle), p._animatorA1.jump(p.endAngle), p._animatorR0.jump(p.innerRadius), p._animatorR1.jump(p.radius))), p.rotationSpeed) {
                                    if (null === p.currentStartAngle) p.currentStartAngle = p.startAngle, p.currentEndAngle = p.endAngle;
                                    else {
                                        var m = t.dtime * p.rotationSpeed / 1e3;
                                        p.currentStartAngle += m, p.currentEndAngle += m
                                    }
                                    p.currentlyRotating = !0, f = !0
                                } else if (p.currentlyRotating) {
                                    var v = 2 * Math.PI;
                                    p._animatorA0.reset(p.currentStartAngle % v - v, p.startAngle, t.timeStamp), p._animatorA1.reset(p.currentEndAngle % v, p.endAngle, t.timeStamp), p.currentlyRotating = !1, f = !0
                                } else {
                                    var y = p._animatorA0.updateAndGet(p.startAngle, r);
                                    p.currentStartAngle = y.value, f = f || y.changes;
                                    var S = p._animatorA1.updateAndGet(p.endAngle, r);
                                    p.currentEndAngle = S.value, f = f || S.changes
                                }
                                var b = p._animatorR1.updateAndGet(p.radius, r);
                                p.currentRadius = b.value, f = f || b.changes, b = p._animatorR0.updateAndGet(p.innerRadius, r), p.currentInnerRadius = b.value, f = f || b.changes, p.currentInnerRadius = Math.min(p.currentInnerRadius, p.currentRadius);
                                for (var C = [], x = 0, w = 0; w < p.allSlices.length; w++) {
                                    var T = p.allSlices[w];
                                    T._animatorF || (f = !0, T._animatorF = new d.Animator(T.currentFraction, T.fraction, i, "<>", r));
                                    var k = T._animatorF.updateAndGetFixed(T.fraction, r);
                                    T.currentFraction = k.value, f = f || k.changes, T.removed && 0 === T.currentFraction && C.push(T), x += T.currentFraction
                                }
                                if (Math.abs(x - 1) > .001) {
                                    x = 1 / x;
                                    for (var w = 0; w < p.allSlices.length; w++) {
                                        var T = p.allSlices[w];
                                        T.currentFraction *= x
                                    }
                                }
                                if (C.length > 0) {
                                    f = !0;
                                    for (var w = 0; w < C.length; w++) {
                                        var T = C[w];
                                        d.Helpers.removeFromArray(p.slices, T), d.Helpers.removeFromArray(p.allSlices, T), T === p.othersSlice && (p.othersSlice = null), T === p.previousSlice && (p.previousSlice = null)
                                    }
                                }
                                for (var w = 0; w < p.allSlices.length; w++) {
                                    var T = p.allSlices[w];
                                    T._animatorLineColor || (f = !0, T._animatorLineColor = new d.ColorAnimator(T.currentLineColor, T.targetLineColor, n, "<>", r), T._animatorFillColor = new d.ColorAnimator(T.currentFillColor, T.targetFillColor, n, "<>", r), T._animatorCutout = new d.Animator(T.currentCutoutDistance, T.cutoutDistance, n, "<>", r));
                                    var A = T._animatorLineColor,
                                        M = T._animatorFillColor,
                                        I = T._animatorCutout,
                                        P = A.updateAndGet(T.targetLineColor, r);
                                    if (T.currentLineColor = P.value, f = f || P.changes, P = M.updateAndGet(T.targetFillColor, r), T.currentFillColor = P.value, f = f || P.changes, T.userPlaced) I.jump(T.currentCutoutDistance);
                                    else {
                                        var l = I.updateAndGet(T.cutoutDistance, r);
                                        T.currentCutoutDistance = l.value, f = f || l.changes
                                    }
                                }(f || o) && a.push(p), t.animating = t.animating || f
                            }
                        }
                        for (var c = 0; c < s.length; c++) {
                            var p = s[c];
                            this.scene.deletePie(p)
                        }
                        return this.prevTime = r, a
                    }, t
                }();
                t.Animations = I;
                var P = function () {
                    function t(t, e) {
                        this.view = e, this.chart = t, this.scene = t.scene, this.events = t.events
                    }
                    return t.prototype.placeStack = function (t, e) {
                        var i = this.scene,
                            n = i.settings,
                            r = n.pie,
                            s = i.stack,
                            a = r.depth,
                            o = !1,
                            l = i.height - 2 * a;
                        l = Math.max(2, l);
                        var h = r.x,
                            u = r.y;
                        null === h ? h = i.x0 + i.width / 2 : h >= 0 && h <= 1 && (h = i.x0 + i.width * h), null === u ? u = i.y0 + l / 2 : u >= 0 && u <= 1 && (u = i.y0 + i.height * u);
                        var c = n.pie.startAngle,
                            d = n.pie.endAngle,
                            p = n.pie.rotationSpeed;
                        t.x === h && t.y === u && c === t.startAngle && d === t.endAngle && p === t.rotationSpeed || (o = !0, t.x = h, t.y = u, t.startAngle = c, t.endAngle = d, t.rotationSpeed = p);
                        var f = Math.min(l / 2, i.width / 2);
                        f -= n.pie.outerMargin;
                        var g = n.pie.radius;
                        if (g) g <= 1 && (g = f * g);
                        else if (n.labels.enabled && n.pie.adaptiveRadius) {
                            var m = this.computeDesiredRadiusFromLabels(t, e);
                            m = Math.min(f, m), m -= n.labels.connectorLength, m = Math.max(m, f / 3), g = m
                        } else g = f;
                        var v = n.pie.innerRadius;
                        if (v < 1 && (v = g * v), s.length > 1) {
                            var y = n.pie.innerRadiusWhenDrilldown;
                            y < 1 && (y = g * y), v = Math.max(v, y)
                        }
                        var S = 0,
                            b = 0;
                        g !== v && (S = 1 / (g - v), b = -v * S), i.radius === g && i.innerRadius === v || (o = !0, i.radius = g, i.innerRadius = v), t.radius = 1, t.innerRadius = v * S + b;
                        var C = s.length - 1;
                        if (C > 0) {
                            v -= n.pie.margin;
                            for (var x = C, w = Math.max(0, Math.min(g - v, (v - n.pie.centerMargin) / x)), L = C - 1; L >= 0; L--) g = v, v -= w, t = s[L], u += a, t.x = h, t.y = u, t.radius = g * S + b, t.innerRadius = (v + n.pie.margin) * S + b, t.brightness = .8 - .8 * (x - L - 1) / x, t.startAngle = n.pie.startAngle, t.endAngle = n.pie.endAngle
                        }
                        for (C = 0; C < i.pies.length; C++)
                            if (t = i.pies[C], t.removed && t.parentSlice) {
                                var T = i.getSliceTargetAngles(t.parentSlice);
                                t.startAngle = T.a0, t.endAngle = T.a1
                            }
                        return o
                    }, t.prototype.computeDesiredRadiusFromLabels = function (t, e) {
                        for (var i = this.scene.settings.slice.style.label, n = new D(e, 1, 0, 100, 0, 100, i, this.scene.settings.labels), r = 2 * i.padding, s = n.lineHeight + r, a = 0, o = 0, l = 0, h = 0, u = 0, c = t.startAngle, p = t.endAngle, f = p - c, g = t.startAngle, m = g, v = 0; v < t.slices.length; v++) {
                            var y = t.slices[v],
                                S = m;
                            u = Math.min(1, u + y.fraction), m = g + u * f;
                            var b = Math.max(S, c),
                                C = Math.min(m, p);
                            if (!(b >= p || C <= c) && y.label.text) {
                                for (var x = "", w = 0, L = y.label.text.split(" "); w < L.length; w++) {
                                    var T = L[w];
                                    T.length > x.length && (x = T)
                                }
                                var k = d.Graphics.getTextWidth(e, y.label.textStyle, x) + r,
                                    A = d.Graphics.getTextWidth(e, y.label.textStyle, y.label.text) + r,
                                    M = s * A * 1.2,
                                    I = ((b + C) / 2 + Math.PI / 2) % (2 * Math.PI) <= Math.PI;
                                I ? (h += M, o = Math.max(o, k)) : (l += M, a = Math.max(a, k))
                            }
                        }
                        d.Graphics.clearShadow(e);
                        var P = Math.min(this.scene.width, this.scene.height),
                            N = this.scene.width * P,
                            F = Math.max(1, N - 2 * Math.max(l, h) * 1.2),
                            O = Math.sqrt(F / Math.PI),
                            E = Math.max(a, o),
                            R = this.scene.width / 2 - 1.1 * E;
                        return Math.min(O, R)
                    }, t.prototype.placeLabels = function (t, e) {
                        if (this.chart.assetsLoaded) {
                            var i = this.scene.settings.icons,
                                n = this.scene.settings.labels,
                                r = this.scene.settings.slice,
                                s = n.enabled,
                                a = i.sizeExtent[0],
                                o = i.sizeExtent[1],
                                l = i.placement,
                                h = i.autohideWhenTooSmall;
                            this.scene.settings.advanced.iconMinSize && (a = this.scene.settings.advanced.iconMinSize);
                            for (var u = r.margin, c = t.x, f = t.y, g = this.scene.currentInnerRadius, m = this.scene.currentRadius - g, v = t.currentInnerRadius * m + g, y = t.currentRadius * m + g, S = 0, b = t.currentStartAngle, C = t.currentEndAngle, x = C - b, w = t.currentStartAngle, L = this.scene.x0 - c, T = L + this.scene.width, k = this.scene.y0 - f, A = k + this.scene.height, M = new D(e, y, L, T, k, A, r.style.insideLabel, this.scene.settings.labels), I = new D(e, y, L, T, k, A, r.style.label, this.scene.settings.labels), P = [], N = [], F = w, O = 0; O < t.allSlices.length; O++) {
                                var E = t.allSlices[O],
                                    R = F;
                                S = Math.min(1, S + E.currentFraction), F = w + S * x;
                                var H = Math.max(R, b),
                                    B = Math.min(F, C),
                                    z = v + E.currentCutoutDistance,
                                    U = y + E.currentCutoutDistance,
                                    G = (H + B) / 2;
                                if (E.removed || t.background) E.currentLabel = null, E.currentInsideLabel = null;
                                else {
                                    if (E.insideLabel.text && s) {
                                        var j = E.insideLabel.text,
                                            W = void 0;
                                        W = E.currentInsideLabel ? E.currentInsideLabel : E.currentInsideLabel = new d.Label(E.insideLabel, !0), E.currentInsideLabel.text !== j && (W.text = j);
                                        var V = M.fitLabelInSlice(e, W, z, U, H, B);
                                        W.shouldBeVisible = W.visible = "always" === n.insideLabel || V >= n.insideLabelVisibilityFraction
                                    } else E.currentInsideLabel = null;
                                    var Z = E.label.text && s ? E.label.text : "";
                                    if ("append" === n.insideLabel && E.insideLabel.text && s && !E.currentInsideLabel.userPlaced && !E.currentInsideLabel.shouldBeVisible && (Z ? (c = Math.cos(G), Z = c > 0 ? E.insideLabel.text + ", " + Z : Z + ", " + E.insideLabel.text) : Z = E.insideLabel.text), Z) {
                                        var W = null;
                                        W = E.currentLabel ? E.currentLabel : E.currentLabel = new d.Label(E.label, !0), E.currentLabel.text !== Z && (W.text = Z), W.userPlaced || I.placeOutsideLabelInitial(W, G), W.x > 0 ? (W.style.align = "left", N.push(W)) : (W.style.align = "right", P.push(W))
                                    } else E.currentLabel = null
                                }
                                var Y = null;
                                if (E.icon && (!t.background || E.id === t.activeSliceId)) {
                                    var q = M.fitBoxInSlice(1, 1, z, U, H, B);
                                    c = q.x, f = q.y;
                                    var _ = q.prop;
                                    _ -= u, (!h || 2 * _ >= a) && (_ = Math.max(Math.min(_, o / 2), a / 2), Y = new p, Y.hwidth = _, Y.hheight = _, Y.inside = !0, E.iconOffset ? (Y.x = 0, Y.y = 0, this.applyOffset(Y, E.iconOffset, z, U, H, B)) : "center" === l ? (Y.x = 0, Y.y = 0, this.applyOffset(Y, [0, 0, 0, 0], z, U, H, B)) : (Y.x = c, Y.y = f))
                                }
                                E.currentIcon = Y
                            }
                            I.computeOutsideLabelLocations(e, P, N)
                        }
                    }, t.prototype.applyOffset = function (t, e, i, n, r, s) {
                        var a = 0,
                            o = 0;
                        e.length >= 2 && (a = e[0], o = e[1]);
                        var l = 0,
                            h = 0;
                        e.length >= 4 && (l = e[2], h = e[3]);
                        var u = i + (n - i) * (l + 1) / 2,
                            c = r + (s - r) * (h + 1) / 2;
                        a += Math.cos(c) * u, o += Math.sin(c) * u, t.x += a, t.y += o
                    }, t
                }();
                t.PieLayout = P;
                var D = function (t) {
                    function e(e, i, n, r, s, a, o, l) {
                        var h = t.call(this) || this;
                        return h.config = l, h.bottom = a, h.top = s, h.right = r, h.left = n, h.margin = o.margin || 0, h.rr = i + l.connectorLength, h.lineHeight = d.Graphics.getTextHeight(e, o.textStyle.font), h.interLabelSpacing = Math.max(l.interLabelSpacing * h.lineHeight, h.margin), h
                    }
                    return n(e, t), e.prototype.placeOutsideLabelInitial = function (t, e) {
                        var i = this.rr * Math.cos(e),
                            n = this.rr * Math.sin(e),
                            r = 1;
                        n < this.top && (r = Math.min(r, this.top / n)), n > this.bottom && (r = Math.min(r, this.bottom / n)), i < this.left && (r = Math.min(r, this.left / i)), i > this.right && (r = Math.min(r, this.right / i)), t.x = i * r, t.y = n * r
                    }, e.prototype.computeOutsideLabelLocations = function (t, e, i) {
                        var n = this.bottom - this.margin,
                            r = this.top + this.margin,
                            s = this.interLabelSpacing;
                        e.sort(function (t, e) {
                            return e.y - t.y
                        }), i.sort(function (t, e) {
                            return t.y - e.y
                        });
                        for (var a = 0; a < e.length; a++) {
                            var o = e[a];
                            o.originX = o.x
                        }
                        for (var a = 0; a < i.length; a++) {
                            var o = i[a];
                            o.originX = o.x
                        }
                        for (var l = "wrap" === this.config.placement ? [!1] : [!0, !1], h = 0; h < l.length; h++) {
                            for (var u = l[h], c = 100, d = !1, p = 0; p < 2; p++) {
                                for (var f = 0 === p ? e : i, a = 0; a < f.length; a++) {
                                    var o = f[a];
                                    o.prop = this.fitLabelOutside(t, o, u)
                                }
                                for (var g = n - r, m = [], v = 0, a = 0; a < f.length; a++) {
                                    var o = f[a];
                                    if (o.visible) {
                                        var y = 2 * o.hheight + s;
                                        v + y < g ? (m.push(o), v += y) : (o.visible = o.userPlaced, c = .5)
                                    }
                                }
                                var S = n,
                                    b = r;
                                f === e ? b += v : S -= v;
                                for (var a = 0; a < m.length; a++) {
                                    var o = m[a];
                                    if (f === e ? b -= 2 * o.hheight + s : S += 2 * o.hheight + s, !o.userPlaced && (o.y + o.hheight > S || o.y - o.hheight < b)) {
                                        o.y = Math.min(Math.max(o.y, b + o.hheight), S - o.hheight);
                                        var C = this.fitLabelOutside(t, o, u);
                                        c = Math.min(C, c), d = d || o.rows && o.rows.subLines[o.rows.subLines.length - 1].row > 0
                                    } else c = Math.min(c, o.prop);
                                    f === e ? S = o.y - o.hheight - s : b = o.y + o.hheight + s
                                }
                            }
                            if (c >= 1 || !d) break
                        }
                    }, e.prototype.fitLabelOutside = function (t, e, i) {
                        var n = this;
                        void 0 === i && (i = !1), null == i && (i = !1);
                        var r = function (t) {
                            return e.userPlaced ? n.getOutsideMaxWidth(e.x, e.y, t, !1) : n.placeOutsideMaxWidth(e.originX, e.y, t, i)
                        };
                        return this.fitLabelInRect(t, e, r)
                    }, e.prototype.fitLabelInSlice = function (t, e, i, n, r, s) {
                        var a, o = this,
                            l = Math.cos(r),
                            h = Math.cos(s),
                            u = Math.min(l, h),
                            c = Math.max(l, h);
                        a = u < 0 && c < 0 || -u > 2 * c ? "right" : u > 0 && c > 0 || 2 * -u < c ? "left" : "center";
                        var d, p;
                        if (e.userPlaced) d = e.x, p = e.y;
                        else {
                            var f = void 0;
                            f = 2 * i >= n ? .5 : .5 + (n - 2 * i) / n / 4;
                            var g = i + (n - i) * f,
                                m = (r + s) / 2,
                                v = Math.cos(m),
                                y = Math.sin(m);
                            d = g * v, p = g * y
                        }
                        var S = p - this.rayIntersectsSlice(d, p, 0, -1, i, n, r, s),
                            b = p + this.rayIntersectsSlice(d, p, 0, 1, i, n, r, s),
                            C = function (t, e) {
                                if (!(n > 0) || e <= S || e >= b) return [1e-5, 1e-5];
                                var a = o.rayIntersectsSlice(t, e, -1, 0, i, n, r, s),
                                    l = o.rayIntersectsSlice(t, e, 1, 0, i, n, r, s);
                                return [a, l]
                            };
                        return this.fitLabelInLines(t, e, d, p, "center", a, C)
                    }, e.prototype.placeOutsideMaxWidth = function (t, e, i, n) {
                        var r = this.rr,
                            s = e - i / 2,
                            a = s + i;
                        if (s < this.top) {
                            var o = this.top - s;
                            s += o, a += o
                        }
                        if (a > this.bottom) {
                            var o = this.bottom - a;
                            s += o, a += o
                        }
                        var l, h = this.left,
                            u = this.right;
                        return l = n ? r : s > r || a < -r ? 0 : s > 0 ? Math.sqrt(r * r - s * s) : a < 0 ? Math.sqrt(r * r - a * a) : r, t > 0 ? h = Math.max(l, t) : u = Math.min(t, -l), {
                            x: (h + u) / 2,
                            y: (s + a) / 2,
                            dx: 1,
                            dy: 0,
                            width: u - h
                        }
                    }, e.prototype.getOutsideMaxWidth = function (t, e, i, n) {
                        var r, s = e - i / 2,
                            a = s + i,
                            o = this.left,
                            l = this.right,
                            h = this.rr;
                        r = n ? h : s > h || a < -h ? 0 : s > 0 ? Math.sqrt(h * h - s * s) : a < 0 ? Math.sqrt(h * h - a * a) : h, t > 0 ? o = r : l = -r;
                        var u = Math.min(Math.abs(t - o), Math.abs(t - l));
                        return {
                            x: t,
                            y: e,
                            dx: 1,
                            dy: 0,
                            width: 2 * u
                        }
                    }, e.prototype.fitBoxInSlice = function (t, e, i, n, r, s) {
                        var a = .5 + (n - i) / n / 4,
                            o = i + (n - i) * a,
                            l = (r + s) / 2,
                            h = Math.cos(l),
                            u = Math.sin(l),
                            c = o * h,
                            d = o * u,
                            p = t,
                            f = e,
                            g = this.rayIntersectsSlice(c, d, p, f, i, n, r, s),
                            m = this.rayIntersectsSlice(c, d, -p, f, i, n, r, s),
                            v = this.rayIntersectsSlice(c, d, -p, -f, i, n, r, s),
                            y = this.rayIntersectsSlice(c, d, p, -f, i, n, r, s),
                            S = Math.min(g, m, v, y);
                        return {
                            x: c,
                            y: d,
                            prop: S
                        }
                    }, e.prototype.rayIntersectsSlice = function (t, e, i, n, r, s, a, o) {
                        var l = d.Geometry.rayIntersectsCircle(t, e, i, n, r);
                        l = Math.min(l, d.Geometry.rayIntersectsCircle(t, e, i, n, s));
                        var h = Math.cos(a),
                            u = Math.sin(a);
                        return l = Math.min(l, d.Geometry.rayIntersectsSegment(t, e, i, n, r * h, r * u, s * h, s * u)), h = Math.cos(o), u = Math.sin(o), l = Math.min(l, d.Geometry.rayIntersectsSegment(t, e, i, n, r * h, r * u, s * h, s * u))
                    }, e
                }(d.LabelLayoutBase);
                t.LabelLayout = D,
                    function (t) {
                        var e = function () {
                            function t(t) {
                                this.renderer = t, this.settings = this.renderer.settings
                            }
                            return t.prototype.paintPie = function (t, e, i, n, r, s, a, o) {
                                o.fillColor && (t.beginPath(), t.arc(e, i, r, s, a, !1), t.arc(e, i, n, a, s, !0), t.closePath(), d.Graphics.fill(t, o))
                            }, t.prototype.paintExpandableHilights = function (t, e, i, n) {
                                var r = this.settings.slice.expandableMarkStyle.distance,
                                    s = this.settings.slice.expandableMarkStyle;
                                if (!(s.lineWidth <= 0))
                                    for (var a = 0; a < n.length; a++) {
                                        var o = n[a];
                                        if (o.expandable) {
                                            var l = o._renderParams,
                                                h = e + o.x,
                                                u = i + o.y,
                                                c = l[0],
                                                p = l[1],
                                                f = Math.max((c + p) / 2, p - r),
                                                g = l[2],
                                                m = l[3];
                                            t.beginPath(), t.arc(h, u, f, g, m), d.Graphics.paint(t, s)
                                        }
                                    }
                            }, t.prototype.strokeSlice = function (t, e, i, n) {
                                var r = n._renderParams;
                                e += n.x, i += n.y;
                                var s = r[0],
                                    a = r[1],
                                    o = r[2],
                                    l = r[3],
                                    h = r[4],
                                    u = r[5],
                                    c = a * Math.abs(l - o),
                                    d = a - s,
                                    p = Math.min(.1 * Math.min(c, d), 3);
                                s + a === -2 && (s = 0, a = 0), t.beginPath(), "zigzag" === n.lineDecoration ? this.strokeZigZag(t, e, i, a, p, o, l) : t.arc(e, i, a, o, l, !1), h === u ? t.lineTo(e + Math.cos(u) * s, i + Math.sin(h) * s) : t.arc(e, i, s, u, h, !0), t.closePath()
                            }, t.prototype.strokeZigZag = function (t, e, i, n, r, s, a) {
                                var o = 5 / n,
                                    l = s;
                                for (t.moveTo(e + n * Math.cos(s), i + n * Math.sin(s)); l + o < a;) l += o, t.lineTo(e + (n + r) * Math.cos(l), i + (n + r) * Math.sin(l)), r = -r;
                                t.lineTo(e + n * Math.cos(a), i + n * Math.sin(a))
                            }, t.prototype.strokeAndPaint = function (t, e, i, n) {
                                var r = d.Graphics.beginStrokeAndFill(t, n);
                                if (this.strokeSlice(r, e, i, n), n.fillGradient) {
                                    for (var s = t.createRadialGradient(e, i, n._renderParams[0], e, i, n._renderParams[1]), a = 0; a < n.fillGradient.length; a++) {
                                        var o = n.fillGradient[a];
                                        s.addColorStop(o[0], o[1])
                                    }
                                    n.fillColor = s
                                }
                                d.Graphics.endStrokeAndFill(t, r, n)
                            }, t
                        }();
                        t.CommonBase = e;
                        var i = function (t) {
                            function e() {
                                return t.apply(this, arguments) || this
                            }
                            return n(e, t), e.prototype.paintSlices = function (t, e, i, n) {
                                for (var r = 0; r < n.length; r++) {
                                    var s = n[r];
                                    this.strokeAndPaint(t, e, i, s)
                                }
                            }, e
                        }(e);
                        t.Flat = i;
                        var r = function (t) {
                            function e() {
                                return t.apply(this, arguments) || this
                            }
                            return n(e, t), e.prototype.paintPie = function (e, i, n, r, s, a, o, l) {
                                t.prototype.paintPie.call(this, e, i, n, r, s, a, o, l);
                                var h = this.settings.pie.depth;
                                if (h > 0 && l.allSlices.length > 0) {
                                    e.fillStyle = "rgba(0,0,0,0.05)";
                                    for (var u = 0; u < [5, 10, 18].length; u++) {
                                        var c = [5, 10, 18][u];
                                        e.beginPath(), e.arc(i, n + c + h, s, a, o, !1), e.arc(i, n + c + h, r, o, a, !0), e.closePath(), e.fill()
                                    }
                                }
                            }, e.prototype.paintSlices = function (t, e, i, n) {
                                var r = this.settings.pie.depth,
                                    s = 2 * this.settings.advanced.renderQuality,
                                    a = 1 / s,
                                    o = r * s;
                                t.shadowOffsetX = 0, t.shadowOffsetY = 0, t.shadowBlur = 1.5 * r, t.shadowColor = "black", t.fillStyle = "black";
                                for (var l = 0; l < n.length; l++) {
                                    var h = n[l];
                                    this.strokeSlice(t, e, i + r, h), t.fill()
                                }
                                t.shadowColor = null, t.shadowBlur = 0, t.lineWidth = 1;
                                for (var u = 0; u <= o; u++)
                                    for (var l = 0; l < n.length; l++) {
                                        var h = n[l];
                                        h.fillColor instanceof CanvasGradient ? d.Helpers.error("slice.fillColor cannot be gradient if `can` renderer is used") : (this.strokeSlice(t, e, i + r - u * a, h), u >= o - 1 ? t.strokeStyle = d.Colors.derive(h.fillColor, 1.35, 1) : t.strokeStyle = d.Colors.derive(h.fillColor, .5 + u / o * .2, 1), t.stroke())
                                    }
                                var c = Math.PI;
                                t.shadowBlur = r, t.shadowColor = "rgba(0,0,0,0.1)", t.fillStyle = "black";
                                for (var l = 0; l < n.length; l++) {
                                    var h = n[l],
                                        p = h._renderParams,
                                        f = p[4],
                                        g = p[5];
                                    if (f !== g) {
                                        for (; f > c;) f -= 2 * c, g -= 2 * c;
                                        f < 0 ? g > 0 && (g = Math.min(g, c), this.strokeInnerShadowSlice(t, e, i, h, 0, g) && t.fill()) : g < c ? this.strokeInnerShadowSlice(t, e, i, h, f, g) && t.fill() : (f < c && this.strokeInnerShadowSlice(t, e, i, h, f, c) && t.fill(), g > 2 * c && this.strokeInnerShadowSlice(t, e, i, h, 2 * c, g) && t.fill())
                                    }
                                }
                                for (var l = 0; l < n.length; l++) {
                                    var h = n[l];
                                    this.strokeAndPaint(t, e, i, h)
                                }
                            }, e.prototype.strokeInnerShadowSlice = function (t, e, i, n, r, s) {
                                var a = n._renderParams,
                                    o = a[0] + 1,
                                    l = Math.min(a[1] - 1, o + 10);
                                return !(o >= a[1] || l <= a[0]) && (r += 1 / o, s -= 1 / o, r >= s ? void 0 : (t.beginPath(), t.arc(e, i, l, r, s, !1), t.arc(e, i, o, s, r, !0), t.closePath(), !0))
                            }, e
                        }(e);
                        t.Can = r;
                        var s = function (t) {
                            function e() {
                                return t.apply(this, arguments) || this
                            }
                            return n(e, t), e.prototype.paintSlices = function (t, e, i, n) {
                                this.g = t;
                                for (var r = 0; r < n.length; r++) {
                                    var s = n[r];
                                    this.strokeAndPaint(t, e, i, s), this.elegantGradient(e, i, s)
                                }
                            }, e.prototype.getRadialGradient = function (t, e, i, n, r, s, a) {
                                var o = Math.abs(Math.sin(a)),
                                    l = this.g.createRadialGradient(t, e, i, n, r, s);
                                return this.addColorStops(l, o, a), l
                            }, e.prototype.getLinearGradient = function (t, e, i, n, r, s, a, o) {
                                var l = a - n,
                                    h = Math.sin(o),
                                    u = Math.cos(o),
                                    c = e + u * n,
                                    d = i + h * n,
                                    p = c + u * l,
                                    f = d + h * l,
                                    g = Math.abs(h),
                                    m = this.g.createLinearGradient(c, d, p, f);
                                return this.addColorStops(m, g, o), m
                            }, e.prototype.addColorStops = function (t, e, i) {
                                var n = "0,0,0",
                                    r = "255,255,255",
                                    s = r,
                                    a = n;
                                (i <= 0 || i > Math.PI) && (s = n, a = r);
                                var o = .4 * e,
                                    l = .2 * e,
                                    h = .1 * e,
                                    u = .3 * e,
                                    c = .5 * e;
                                t.addColorStop(0, "rgba(" + s + "," + o.toFixed(3) + ")"), t.addColorStop(.1, "rgba(" + s + "," + l.toFixed(3) + ")"), t.addColorStop(.1, "rgba(" + s + "," + h.toFixed(3) + ")"), t.addColorStop(.4, "rgba(" + n + ",0.1)"), t.addColorStop(.9, "rgba(" + a + "," + h.toFixed(3) + ")"), t.addColorStop(.95, "rgba(" + a + "," + u.toFixed(3) + ")"), t.addColorStop(1, "rgba(" + a + "," + c.toFixed(3) + ")")
                            }, e.prototype.elegantGradient = function (t, e, i) {
                                for (var n = i._renderParams[0], r = i._renderParams[1], s = i._renderParams[2], a = i._renderParams[3], o = this.settings.advanced.renderQuality, l = Math.PI / Math.max(1, 180 * o), h = s; h < a;) {
                                    var u = Math.min(h + l, a);
                                    this.g.beginPath(), this.g.arc(t, e, r, h, u), this.g.arc(t, e, n, u, h, !0), this.g.closePath(), d.Graphics.paint(this.g, {
                                        fillColor: this.getRadialGradient(t, e, n, t, e, r, h)
                                    }), h = u
                                }
                            }, e
                        }(e);
                        t.Smoothy = s;
                        var a = function (t) {
                            function e() {
                                return t.apply(this, arguments) || this
                            }
                            return n(e, t), e.prototype.paintSlices = function (t, e, i, n) {
                                this.g = t;
                                for (var r = 0; r < n.length; r++) {
                                    var s = n[r];
                                    this.strokeAndPaint(t, e, i, s), this.smartGradient(e, i, s)
                                }
                            }, e.prototype.getSmartGradient = function (t, e, i, n, r, s) {
                                var a, o, l = 0,
                                    h = 0,
                                    u = 0,
                                    c = 0;
                                "inside" === r ? "top" === s ? (u = n - i, c = e, a = "rgba(0,0,0,0.3)", o = "rgba(0,0,0,0)") : (u = e, c = e + i, a = "rgba(255,255,255,0)", o = "rgba(255,255,255,0.3)") : "top" === s ? (c = e, a = "rgba(255,255,255,0.3)", o = "rgba(255,255,255,0)") : (u = e, c = e + n, a = "rgba(0,0,0,0)", o = "rgba(0,0,0,0.3)");
                                try {
                                    var d = this.g.createLinearGradient(l, u, h, c);
                                    return d.addColorStop(0, a), d.addColorStop(1, o), d
                                } catch (t) {
                                    throw "Could not create linear gradient: " + t
                                }
                            }, e.prototype.smartOuterShineTop = function (t, e, i, n, r, s, a, o) {
                                if (!(r > 0 && s < Math.PI)) {
                                    s > 0 && r < 0 && (s = 0, o = 0), r > 0 && r < Math.PI && (r = Math.PI, a = Math.PI);
                                    var l = {
                                        _renderParams: [n - .1 * (n - i), n, r, s, a, o, null, null],
                                        x: 0,
                                        y: 0,
                                        fillColor: this.getSmartGradient(t, e, i, n, "outside", "top")
                                    };
                                    this.strokeAndPaint(this.g, t, e, l)
                                }
                            }, e.prototype.smartOuterShineBottom = function (t, e, i, n, r, s, a, o) {
                                if (!(s < 0 || r > Math.PI)) {
                                    r < 0 && (r = 0, a = 0), s > Math.PI && (s = Math.PI, o = Math.PI);
                                    var l = {
                                        _renderParams: [n - .1 * (n - i), n, r, s, a, o, null, null],
                                        x: 0,
                                        y: 0,
                                        fillColor: this.getSmartGradient(t, e, i, n, "outside", "bottom")
                                    };
                                    this.strokeAndPaint(this.g, t, e, l)
                                }
                            }, e.prototype.smartInnerShineTop = function (t, e, i, n, r, s, a, o) {
                                if (!(r > 0 && s < Math.PI)) {
                                    s > 0 && r < 0 && (s = 0, o = 0), r > 0 && r < Math.PI && (r = Math.PI, a = Math.PI);
                                    var l = {
                                        _renderParams: [i, i + .1 * (n - i), r, s, a, o, null, null],
                                        x: 0,
                                        y: 0,
                                        fillColor: this.getSmartGradient(t, e, i, n, "inside", "top")
                                    };
                                    this.strokeAndPaint(this.g, t, e, l)
                                }
                            }, e.prototype.smartInnerShineBottom = function (t, e, i, n, r, s, a, o) {
                                if (!(s < 0 || r > Math.PI)) {
                                    r < 0 && (r = 0, a = 0), s > Math.PI && (s = Math.PI, o = Math.PI);
                                    var l = {
                                        _renderParams: [i, i + .1 * (n - i), r, s, a, o, null, null],
                                        x: 0,
                                        y: 0,
                                        fillColor: this.getSmartGradient(t, e, i, n, "inside", "bottom")
                                    };
                                    this.strokeAndPaint(this.g, t, e, l)
                                }
                            }, e.prototype.smartGradient = function (t, e, i) {
                                t += i.x, e += i.y;
                                var n = i._renderParams[0],
                                    r = i._renderParams[1],
                                    s = i._renderParams[2],
                                    a = i._renderParams[3],
                                    o = i._renderParams[4],
                                    l = i._renderParams[5];
                                this.smartOuterShineTop(t, e, n, r, s, a, o, l), this.smartOuterShineBottom(t, e, n, r, s, a, o, l), this.smartInnerShineTop(t, e, n, r, s, a, o, l), this.smartInnerShineBottom(t, e, n, r, s, a, o, l)
                            }, e
                        }(e);
                        t.Bevel = a
                    }(e = t.Renderers || (t.Renderers = {}));
                var N = function () {
                    function t(t) {
                        this.renderer = null, this.chart = t, this.settings = t.settings, this.scene = t.scene
                    }
                    return t.prototype.onSceneChange = function (t) {
                        t.changes.settings && this.buildSeries()
                    }, t.prototype.buildSeries = function () {
                        var t = this.settings.pie.theme,
                            i = t.charAt(0).toUpperCase() + t.slice(1);
                        try {
                            this.renderer = new e[i](this)
                        } catch (e) {
                            throw "Renderer " + t + " is not available: " + e
                        }
                    }, t.prototype.paintScene = function (t) {
                        for (var e = t.context, i = t.labelRenderer, n = t.isExport ? this.settings.pie.showInnerPiesExport : this.settings.pie.showInnerPies, r = !1, s = 0; s < this.scene.pies.length; s++) {
                            var a = this.scene.pies[s];
                            !n && a.background || this.paintPie(e, i, a), r = r || a.background
                        }!t.isExport && (this.scene.hoverBack || this.scene.settings.advanced.backAlwaysVisible && r) && this.paintBackArrow(t)
                    }, t.prototype.paintBackArrow = function (t) {
                        var e = this.scene.assetsLoader.getAssetImage(this.scene.settings.advanced.backImage);
                        if (e) {
                            var i = this.scene.pies[this.scene.pies.length - 1],
                                n = .707106781186547,
                                r = i.x,
                                s = i.y,
                                a = this.settings.pie.depth;
                            s += (this.scene.pies.length - 1) * a;
                            var o = e.width / 2,
                                l = e.height / 2,
                                h = i.innerRadius * n,
                                u = Math.min(o, Math.max(h, o / 2)) / o,
                                c = Math.min(l, Math.max(h, l / 2)) / l,
                                p = Math.min(u, c),
                                f = t.context;
                            if (this.settings.advanced.backImageBackground) {
                                var g = this.settings.slice.margin,
                                    m = this.scene.currentInnerRadius,
                                    v = this.scene.currentRadius - m,
                                    y = Math.max(this.scene.pies[0].currentInnerRadius * v + m, g / 2);
                                f.beginPath(), f.arc(r, s, y, 0, 2 * Math.PI), f.closePath(), f.fillStyle = this.settings.advanced.backImageBackground, f.fill()
                            }
                            f.globalAlpha = .5, d.Graphics.drawImageHighQuality(f, e, r - o * p, s - l * p, 2 * o * p, 2 * l * p), f.globalAlpha = 1
                        }
                    }, t.prototype.paintPie = function (t, e, i) {
                        var n = this.settings.slice.margin;
                        i.allSlices.length < 2 && (n = 0);
                        var r = this.scene.currentInnerRadius,
                            s = this.scene.currentRadius - r,
                            a = Math.max(i.currentInnerRadius * s + r, n / 2),
                            o = i.currentRadius * s + r,
                            l = i.currentStartAngle,
                            h = i.currentEndAngle,
                            u = h - l,
                            c = l;
                        if (o > 0 && u > 0) {
                            for (var p = a > 0 ? 1 / a : 0, f = 1 / o, g = n / 2 * p, m = n / 2 * f, v = [], y = 0; y < i.allSlices.length; y++) {
                                var S = i.allSlices[y],
                                    b = S.currentFraction * u;
                                if (!(S.currentFraction <= 0)) {
                                    var C = c;
                                    c += b;
                                    var x = a + S.currentCutoutDistance,
                                        w = o + S.currentCutoutDistance,
                                        L = void 0,
                                        T = void 0;
                                    if (b <= 4 * m) {
                                        var k = (C + c) / 2,
                                            A = b / 4;
                                        L = k - A, T = k + A
                                    } else L = C + m, T = c - m;
                                    var M = C + g,
                                        I = c - g;
                                    M > I && (M = I = (M + I) / 2), T < l || L > h || (L = Math.max(L, l), T = Math.min(T, h), M = Math.max(M, l), I = Math.min(I, h), M > I && (M = I = (M + I) / 2), S._renderParams = [x, w, L, T, M, I, S.fillColor, S.lineColor], S.fillColor = S.currentFillColor, S.lineColor = S.currentLineColor, v.push(S))
                                }
                            }
                            var P = i.x,
                                D = i.y;
                            this.renderer.paintPie(t, P, D, a, o, i.currentStartAngle, i.currentEndAngle, i), this.renderer.paintSlices(t, P, D, v), i === this.scene.peek() && this.renderer.paintExpandableHilights(t, P, D, v);
                            for (var N = 0; N < v.length; N++) {
                                var F = v[N];
                                F.fillColor = F._renderParams[6], F.lineColor = F._renderParams[7]
                            }
                            if (!i.removed) {
                                d.Graphics.clearShadow(t);
                                for (var y = 0; y < i.allSlices.length; y++) {
                                    var S = i.allSlices[y];
                                    if (S.currentIcon) {
                                        var O = this.scene.assetsLoader.getAssetImage(S.icon);
                                        if (O) {
                                            var E = S.currentIcon,
                                                R = P + E.x,
                                                H = D + E.y,
                                                B = Math.min(O.width / 2, E.hwidth),
                                                z = Math.min(O.height / 2, E.hheight);
                                            d.Graphics.drawImageHighQuality(t, O, R - B, H - z, 2 * B, 2 * z)
                                        }
                                    }
                                }
                                c = l;
                                for (var y = 0; y < i.allSlices.length; y++) {
                                    var S = i.allSlices[y],
                                        b = S.currentFraction * u,
                                        C = c;
                                    c = C + b;
                                    var U = Math.max(C, l),
                                        G = Math.min(c, h),
                                        j = (U + G) / 2,
                                        W = S === this.scene.hoverSlice,
                                        V = o + S.currentCutoutDistance;
                                    S.currentInsideLabel && S.currentInsideLabel.visible && this.paintLabel(t, e, P, D, V, j, S.currentInsideLabel, W), S.currentLabel && S.currentLabel.visible && this.paintLabel(t, e, P, D, V, j, S.currentLabel, W)
                                }
                            }
                        }
                    }, t.prototype.paintLabel = function (t, e, i, n, r, s, a, o) {
                        var l, h, u = this.scene.y0 + 3,
                            c = u + this.scene.height - 6,
                            p = this.settings.labels,
                            f = a.x,
                            g = a.y,
                            m = a.hwidth,
                            v = r + p.connectorLength;
                        if (f < 0 ? (l = f + m, h = g) : f >= 0 && (l = f - m, h = g), p.connectors && l * l + h * h > r * r) {
                            var y = Math.sin(s),
                                S = Math.cos(s);
                            t.beginPath();
                            var b = i + r * S,
                                C = n + r * y;
                            t.moveTo(b, C);
                            var x = i + v * S,
                                w = n + v * y;
                            w = Math.min(Math.max(w, u), c), l += i, h += n, h = Math.min(Math.max(h, u), c);
                            var L = (r + v) / 2,
                                T = d.Geometry.rayIntersectsCircle(l - i, h - n, b - l, C - h, r),
                                k = d.Geometry.lineTouchingCircle(l - i, h - n, x - i, w - n, v);
                            if (T < .9 && k) {
                                for (var A = k.x, M = k.y, I = Math.atan2(M, A); I - s > Math.PI;) I -= 2 * Math.PI;
                                for (; I - s < -Math.PI;) I += 2 * Math.PI;
                                var P = I - s;
                                A += i, M += n, x = i + L * S, w = n + L * y, w = Math.min(Math.max(w, u), c);
                                var D = i + L * Math.cos(s + .2 * P),
                                    N = n + L * Math.sin(s + .2 * P);
                                N = Math.min(Math.max(N, u), c), t.quadraticCurveTo(x, w, D, N);
                                var F = i + v * Math.cos(I),
                                    O = n + v * Math.sin(I);
                                O = Math.min(Math.max(O, u), c), d.Graphics.arcBetweenTwoPoints(t, i, n, L, D, N, F, O), t.lineTo(l, h)
                            } else t.quadraticCurveTo(x, w, l, h);
                            var E = this.settings.slice.connectorStyle,
                                R = E.lineWidth;
                            o && (E.lineWidth += 2), d.Graphics.stroke(t, E), E.lineWidth = R
                        }
                        e.paint(t, i + a.x, n + a.y, 1, a), d.Graphics.clearShadow(t)
                    }, t
                }();
                t.PieRenderer = N;
                var F = function () {
                    function t(t) {
                        this.chart = t, this.scene = t.scene
                    }
                    return t.prototype.updatePie = function (t, e) {
                        var i = this.getPieData(t);
                        this.rectifyScrollOffsets(t, i);
                        var n = this.getForwardCount(t.id, i, t.offset),
                            r = n.numberOfSlices,
                            s = n.isReady;
                        if (t.data = i, t.loading = !s, s) {
                            var a = this.buildSlices(t, t.offset, r),
                                o = a.slices,
                                l = a.othersSlice,
                                h = a.previousSlice;
                            this.applyNewSlices(t, o, l, h, e)
                        }
                        return s
                    }, t.prototype.scrollForward = function (t, e) {
                        var i = this.getPieData(t);
                        t.data = i;
                        var n, r = !0;
                        if (null === e || void 0 === e) {
                            var s = this.getForwardCount(t.id, i, t.offset);
                            n = s.numberOfSlices, r = s.isReady, e = t.offset + n
                        }
                        if (r) {
                            var s = this.getForwardCount(t.id, i, e);
                            n = s.numberOfSlices, r = s.isReady
                        }
                        if (r) {
                            var a = this.buildSlices(t, e, n),
                                o = a.slices,
                                l = a.othersSlice,
                                h = a.previousSlice;
                            if (t.othersSlice) {
                                var u = Math.min(o.length, Math.max(0, t.offset + t.count - e));
                                this.fitSlicesInOrigin(t.othersSlice, o.slice(u), l), l || (l = t.othersSlice, l.fraction = 0, l.currentFraction = 0, l.removed = !0)
                            }
                            return t.offset = e, this.applyNewSlices(t, o, l, h), t.loading = !1, !0
                        }
                        return t.loading = !0, !1
                    }, t.prototype.scrollBackward = function (t, e) {
                        var i = this.getPieData(t);
                        t.data = i;
                        var n = !0,
                            r = 0;
                        if (i && i.done && t.offset > i.offset + i.values.length && (t.offset = i.offset + i.values.length), null == e) {
                            var s = this.getBackOffset(t.id, i, t.offset);
                            if (e = s.newOffset, n = s.isReady)
                                do {
                                    e += r;
                                    var a = this.getForwardCount(t.id, i, e);
                                    r = a.numberOfSlices, n = a.isReady
                                } while (n && e + r < t.offset)
                        } else {
                            var a = this.getForwardCount(t.id, i, e);
                            r = a.numberOfSlices, n = a.isReady
                        }
                        if (n) {
                            var o = this.buildSlices(t, e, r),
                                l = o.slices,
                                h = o.othersSlice,
                                u = o.previousSlice;
                            if (t.previousSlice) {
                                var c = Math.min(l.length, Math.max(0, t.offset - e));
                                this.fitSlicesInOrigin(t.previousSlice, l.slice(0, c), u), u || (u = t.previousSlice, u.fraction = 0, u.currentFraction = 0, u.removed = !0)
                            }
                            return t.offset = e, this.applyNewSlices(t, l, h, u), t.loading = !1, !0
                        }
                        return t.loading = !0, !1
                    }, t.prototype.fitSlicesInOrigin = function (t, e, i) {
                        for (var n = Math.max(1e-6, t.currentFraction), r = 0, s = 0; s < e.length; s++) {
                            var a = e[s];
                            r += a.fraction
                        }
                        i && (r += i.fraction);
                        for (var o = n / r, s = 0; s < e.length; s++) {
                            var a = e[s];
                            a.currentFraction = a.fraction * o, a.currentFillColor = t.currentFillColor, a.currentLineColor = t.currentLineColor
                        }
                        i && (i.currentFraction = i.fraction * o, i.currentFillColor = t.currentFillColor, i.currentLineColor = t.currentLineColor)
                    }, t.prototype.rectifyScrollOffsets = function (t, e) {
                        if (null == e) return void(t.scrollOffset = 0);
                        var i, n = t.offset;
                        if (t.scrollOffset < 0) {
                            for (0 === n && (t.scrollOffset -= this.scene.settings.interaction.others.navigationFraction); t.scrollOffset < 0 && n - e.offset < e.values.length;) i = e.values[n - e.offset], t.scrollOffset += i.fraction / t.visibleFraction, n++;
                            var r = this.scene.settings.interaction.others.maxSlicesVisible + 1;
                            n + r > e.values.length && (t.scrollOffset = 0, n = Math.max(e.values.length - r, 0))
                        } else if (t.scrollOffset > 0) {
                            var s = 0;
                            for (1 === n && (s = this.scene.settings.interaction.others.navigationFraction); n > 0 && t.scrollOffset + s > e.values[n - e.offset - 1].fraction / t.visibleFraction;) i = e.values[n - e.offset - 1], t.scrollOffset -= i.fraction / t.visibleFraction, n--;
                            0 === n && (t.scrollOffset = 0)
                        }
                        t.offset = n
                    }, t.prototype.getForwardCount = function (t, e, i) {
                        if (!e || e.offset > i || e.offset + e.values.length <= i) return !e || !e.done || e.offset > i ? (this.scene.mainData.requestPieData(t, i), {
                            numberOfSlices: 0,
                            isReady: !1
                        }) : {
                            numberOfSlices: 0,
                            isReady: !0
                        };
                        var n = e.offset,
                            r = n + e.values.length,
                            s = this.scene.settings.interaction.others,
                            a = s.minSliceFraction,
                            o = s.maxOthersFraction,
                            l = s.maxSlicesVisible;
                        if (!s.enabled || r - i <= s.minSlices) return e.done || this.scene.mainData.requestMorePieData(t), {
                            numberOfSlices: Math.max(r - i, 0),
                            isReady: e.done
                        };
                        for (var h = e.afterFraction, u = i; u <= r - 1; u++) h += e.values[u - n].fraction;
                        for (var c = 0, d = 0, p = e.done; c + i < r;) {
                            c++;
                            var f = e.values[i + c - n - 1].fraction;
                            d += f, h -= f;
                            var g = h / (h + d),
                                m = Math.min(g, o),
                                v = f / d * (1 - m);
                            if (c > l || v < a) {
                                e.done && c + i !== r && c--, p = !0;
                                break
                            }
                        }
                        return p || this.scene.mainData.requestMorePieData(t), {
                            numberOfSlices: c,
                            isReady: p
                        }
                    }, t.prototype.getBackOffset = function (t, e, i) {
                        if (0 === i) return {
                            newOffset: 0,
                            isReady: !0
                        };
                        if (!e || e.offset >= i || !e.done && e.offset + e.values.length < i) return this.scene.mainData.requestPieData(t, Math.max(0, i - this.scene.mainData.dataSettings.itemsToLoad)), {
                            newOffset: 0,
                            isReady: !1
                        };
                        if (0 === i) return {
                            newOffset: 0,
                            isReady: !0
                        };
                        for (var n = e.offset, r = n + e.values.length, s = this.scene.settings.interaction.others.minSliceFraction, a = this.scene.settings.interaction.others.maxOthersFraction, o = this.scene.settings.interaction.others.maxSlicesVisible, l = e.afterFraction, h = i; h < r; h++) l += e.values[h - n].fraction;
                        for (var u = i, c = e.values[i - n - 1].fraction, d = 0, p = 0 === e.offset; u > e.offset;) {
                            u--, d += e.values[u - n].fraction;
                            var f = i - u,
                                g = Math.min(l / (l + d), a),
                                m = c / d * (1 - g);
                            if (0 === u || f > o || m < s) {
                                0 !== u && u++, p = !0;
                                break
                            }
                        }
                        return p || this.scene.mainData.requestLessPieData(t), {
                            newOffset: u,
                            isReady: p
                        }
                    }, t.prototype.buildSlices = function (t, e, i) {
                        var n = this.scene.settings,
                            r = t.data;
                        if (!r) throw new Error("Internal error - buildSlices");
                        for (var s = 0, a = [], o = e; o < e + i; o++) {
                            var l = new f(t, o);
                            l.data = r.values[o - r.offset], l.id = l.data.__id, s += l.data.fraction, a.push(l)
                        }
                        for (var h = n.interaction.others, u = r.afterFraction, c = r.afterSum, o = e + i; o < r.offset + r.values.length; o++) {
                            var d = r.values[o - r.offset];
                            c += d.value, u += d.fraction
                        }
                        var p;
                        u > 0 && (e > 0 || r.values.length > h.minSlices) ? (p = new f(t, 1 / 0), p.data = {
                            value: c,
                            fraction: u,
                            name: n.localization.othersLabel
                        }) : p = null;
                        var g = null,
                            m = 0;
                        if (e > 0) {
                            for (var v = r.beforeSum, o = r.offset; o <= Math.min(e, r.offset + r.values.length) - 1; o++) v += Math.abs(r.values[o - r.offset].value);
                            g = new f(t, -1), m = h.navigationFraction, m += t.scrollOffset, g.data = {
                                value: v,
                                name: n.localization.previousLabel
                            }, g.fraction = m
                        }
                        t.visibleFraction = (s + u) * (1 + m / (1 - m)), p && (u = Math.max(h.navigationFraction, u), u = Math.min(h.maxOthersFraction, u), p.fraction = u);
                        var y = (1 - m - u) / s;
                        s = 1 - m - u;
                        for (var S = 0; S < a.length; S++) {
                            var b = a[S];
                            b.fraction = b.data.fraction * y
                        }
                        var C = n.slice.minFraction;
                        if (C > 0)
                            for (var x = 0;;) {
                                for (var w = 0, L = 0, S = 0; S < a.length; S++) {
                                    var b = a[S];
                                    b.fraction <= C && (w += 1, L += b.fraction)
                                }
                                if (w === a.length) {
                                    for (var T = s / a.length, S = 0; S < a.length; S++) {
                                        var b = a[S];
                                        b.fraction = T
                                    }
                                    break
                                }
                                y = (s - w * C) / (s - L);
                                for (var S = 0; S < a.length; S++) {
                                    var b = a[S];
                                    b.fraction <= C ? b.fraction = C : b.fraction = b.fraction * y
                                }
                                if (w === x) break;
                                x = w
                            }
                        return {
                            slices: a,
                            othersSlice: p,
                            previousSlice: g
                        }
                    }, t.prototype.applyNewSlices = function (t, e, i, n, r) {
                        void 0 === r && (r = !0);
                        var s = t.allSlices,
                            a = 0 === s.length,
                            o = [],
                            l = [],
                            h = 0,
                            u = 0,
                            c = s.length,
                            p = e.length + (i ? 1 : 0) + (n ? 1 : 0);
                        for (n ? (t.previousSlice ? (t.previousSlice.removed = n.removed, t.previousSlice.data = n.data, t.previousSlice.fraction = n.fraction, t.previousSlice.value = n.value, r || this.jumpSliceToAnimationEnd(t.previousSlice)) : (a || (n.currentFraction = 0), t.previousSlice = n), l.push(t.previousSlice)) : t.previousSlice && (t.previousSlice.removed = !0, t.previousSlice.fraction = 0, l.push(t.previousSlice)); h < s.length || u < e.length;) {
                            var f = s[h],
                                g = e[u];
                            !f || f.index !== 1 / 0 && f.index !== -1 ? f && g && (f.originalId || f.id) === g.id ? (f.removed = !1, f.fraction = g.fraction, f.data = g.data, g.currentFraction && r && (f.currentFraction = g.currentFraction, f._animatorF = null), r || this.jumpSliceToAnimationEnd(f), o.push(f), l.push(f), h++, u++) : !g || f && (f.index < g.index || c > p) ? (f.removed = !0, f.fraction = 0, f.originalId || (f.originalId = f.id), f.id = d.Helpers.getIdentifierStr(), r && l.push(f), h++) : (g.currentFraction || a || (g.currentFraction = 0), r || this.jumpSliceToAnimationEnd(g), o.push(g), l.push(g), u++) : h++
                        }
                        i ? (t.othersSlice ? (t.othersSlice.removed = i.removed, t.othersSlice.data = i.data, t.othersSlice.fraction = i.fraction, t.othersSlice.value = i.value, r || this.jumpSliceToAnimationEnd(t.othersSlice)) : (a || (i.currentFraction = 0), t.othersSlice = i), l.push(t.othersSlice)) : t.othersSlice && (l.push(t.othersSlice), t.othersSlice.removed = !0, t.othersSlice.fraction = 0), !r && t.othersSlice && this.jumpSliceToAnimationEnd(t.othersSlice), t.total = t.data ? t.data.total : 0, t.count = e.length, t.slices = o, t.allSlices = l;
                        for (var m = 0; m < l.length; m++) {
                            var v = l[m];
                            v.value = v.data.value, r || this.jumpSliceToAnimationEnd(v)
                        }
                        this.scene.updateOnPieChanged(t), this.resetSelection()
                    }, t.prototype.resetSelection = function () {
                        for (var t = this.scene, e = 0, i = t.selection; e < i.length; e++) {
                            var n = i[e];
                            t.selectionIds.push(n.id), n.selected = !1
                        }
                        return t.selection = [], t.selectionIds.length > 0
                    }, t.prototype.jumpSliceToAnimationEnd = function (t) {
                        t._animatorF ? t._animatorF.jump(t.fraction) : t._animatorF = new d.Animator(t.fraction, t.fraction, this.scene.settings.interaction.animation.scrollDuration, "<>", 0), t.currentFraction = t.fraction
                    }, t.prototype.getPieData = function (t) {
                        var e = this.scene.mainData.getPieData(t.id);
                        if (!e) return null;
                        var i = e.total;
                        if (i > 0)
                            for (var n = 0; n < e.values.length; n++) {
                                var r = e.values[n];
                                r.fraction = Math.max(1e-9, r.value / i)
                            } else {
                                i = e.values.length;
                                for (var n = 0; n < e.values.length; n++) {
                                    var r = e.values[n];
                                    r.fraction = 1 / i
                                }
                            }
                        return e.afterSum > 0 ? e.afterFraction = e.afterSum / i : e.afterFraction = 0, e.beforeSum > 0 ? e.beforeFraction = e.beforeSum / i : e.beforeFraction = 0, e
                    }, t
                }();
                t.PieBuilder = F;
                var O = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.animationOrder = 500, i.paintOrder = 30, i.updateOrder = 700, i.chart = e, i.scene = e.scene, i.renderer = new N(e), i.animator = new I(e), i.layout = new P(e, i), i.builder = new F(e), i
                    }
                    return n(e, t), e.prototype.updatePie = function (t, e) {
                        return void 0 === e && (e = !0), this.builder.updatePie(t, e)
                    }, e.prototype.scrollForward = function (t, e) {
                        return this.builder.scrollForward(t, e)
                    }, e.prototype.scrollBackward = function (t, e) {
                        return this.builder.scrollBackward(t, e)
                    }, e.prototype.onSceneChange = function (t) {
                        this.renderer.onSceneChange(t)
                    }, e.prototype.doAnimations = function (t) {
                        var e = !1;
                        if (t.changes.settings || t.changes.pie || t.changes.bounds || t.changes.assets) {
                            var i = this.scene.peek();
                            i && this.chart.assetsLoaded && (e = this.layout.placeStack(i, t.context))
                        }
                        for (var n = this.animator.doAnimations(t), r = 0; r < n.length; r++) {
                            var i = n[r];
                            this.layout.placeLabels(i, t.context)
                        }(e || n) && (t.changes.position = !0)
                    }, e.prototype.paintScene = function (t) {
                        this.renderer.paintScene(t)
                    }, e.prototype.getMovement = function (t, e) {
                        var i = e.x - e.dx - t.x,
                            n = e.y - e.dy - t.y,
                            r = e.x - t.x,
                            s = e.y - t.y,
                            a = d.Geometry.normalizeAngle(Math.atan2(n, i)),
                            o = d.Geometry.normalizeAngle(Math.atan2(s, r)),
                            l = d.Geometry.subtractAngle(o, a) / (t.currentEndAngle - t.currentStartAngle),
                            h = Math.sqrt(i * i + n * n),
                            u = Math.sqrt(r * r + s * s),
                            c = u - h;
                        return {
                            dfraction: l,
                            doffset: c
                        }
                    }, e.prototype.findPieAt = function (t, e, i) {
                        for (var n = this.scene.currentInnerRadius, r = this.scene.currentRadius - n, s = this.scene.pies.length - 1; s >= 0; s--) {
                            var a = this.scene.pies[s],
                                o = a.x,
                                l = a.y,
                                h = a.currentInnerRadius * r + n,
                                u = a.currentRadius * r + n,
                                c = Math.max(0, h - i);
                            c = u + i;
                            var d = c * c,
                                p = t - o,
                                f = e - l,
                                g = p * p + f * f;
                            if ((a.background || 1 === this.scene.pies.length) && g <= d) return a
                        }
                        return null
                    }, e.prototype.findSliceAt = function (t, e, i, n) {
                        for (var r = this.scene.currentInnerRadius, s = this.scene.currentRadius - r, a = this.scene.pies.length - 1; a >= 0; a--) {
                            var o = this.scene.pies[a];
                            if (!o.background) {
                                var l = o.x,
                                    h = o.y,
                                    u = n ? 0 : o.currentInnerRadius * s + r,
                                    c = o.currentRadius * s + r,
                                    d = Math.max(0, u - i);
                                d = c + i;
                                var p = t - l,
                                    f = e - h,
                                    g = p * p + f * f,
                                    m = Math.sqrt(g);
                                p /= m, f /= m;
                                for (var v = o.currentStartAngle, y = o.currentEndAngle - v, S = Math.cos(v), b = Math.sin(v), C = 0; C < o.allSlices.length; C++) {
                                    var x = o.allSlices[C],
                                        w = S,
                                        L = b;
                                    if (v += y * x.currentFraction, S = Math.cos(v), b = Math.sin(v), m >= u + x.currentCutoutDistance && m <= c + x.currentCutoutDistance) {
                                        var T = L * p - w * f,
                                            k = b * p - S * f;
                                        if (T < 0 && k > 0) return x;
                                        if (Math.abs(y * x.currentFraction) > Math.PI && (T < 0 && k < 0 || T > 0 && k > 0)) return x
                                    }
                                }
                            }
                        }
                        return null
                    }, e.prototype.findLabelAt = function (t, e, i) {
                        for (var n = this.scene.pies.length - 1; n >= 0; n--)
                            for (var r = this.scene.pies[n], s = t - r.x, a = e - r.y, o = 0; o < r.allSlices.length; o++) {
                                var l = r.allSlices[o];
                                if (l.currentLabel) {
                                    var h = l.currentLabel;
                                    if (h.visible && h.x - h.hwidth <= s && h.x + h.hwidth >= s && h.y - h.hheight <= a && h.y + h.hheight >= a) return {
                                        slice: l,
                                        label: h
                                    }
                                }
                                if (l.currentInsideLabel) {
                                    var h = l.currentInsideLabel;
                                    if (h.visible && h.x - h.hwidth <= s && h.x + h.hwidth >= s && h.y - h.hheight <= a && h.y + h.hheight >= a) return {
                                        slice: l,
                                        label: h
                                    }
                                }
                            }
                        return {
                            slice: null,
                            label: null
                        }
                    }, e
                }(d.ChartElement);
                t.PieView = O;
                var E = function (t) {
                    function e(e, i) {
                        var n = t.call(this, new v(e), new m, i) || this;
                        return n.scene.loading = !1, n.selection = n.events.addElement(new w(n)), n.scene.view = new O(n), n.popup = n.events.addElement(new M(n)), n.legend = n.events.addElement(new u(n)), n.events.addElement(new L(n)), n.navigator = n.events.addElement(new A(n)), n.events.addElement(n.scene.view), n.finalInitialize(), n.navigator.setPie(n.settings.navigation.initialDrilldown, n.settings.navigation.initialOffset, "init"), n
                    }
                    return n(e, t), e.prototype.createDataObj = function (t) {
                        return new a(this, t, !1)
                    }, e.prototype.getData = function (e) {
                        return t.prototype.getData.call(this, e)
                    }, e.prototype.createDomLayer = function () {
                        return new T(this)
                    }, e.prototype.onSettingsChanged = function (t) {
                        t.navigation && (t.navigation.initialDrilldown || t.navigation.initialOffset) && this.navigator.setPie(this.settings.navigation.initialDrilldown, this.settings.navigation.initialOffset), (t.labels || t.icons || t.pie || t.slice || t.interaction) && this.events.notifySceneChanges({
                            pie: !0
                        })
                    }, e.prototype.save = function () {
                        var t = this.saveSelection();
                        return JSON.stringify({
                            pie: this.navigator.getPie(),
                            offset: this.navigator.getPieOffset(),
                            selection: t
                        })
                    }, e.prototype.zoomOut = function (t, e) {
                        void 0 === t && (t = !0), void 0 === e && (e = "api"), this.setSelection([]), this.navigator.goBack(e)
                    }, e.prototype.zoomOutPossible = function () {
                        var t = this.scene;
                        return t.length() > 1 || t.peek().offset > 0
                    }, e.prototype.restore = function (t, e) {
                        if (t) {
                            var i = JSON.parse(t);
                            this.setPie(i.pie, i.offset, e), this.setSelection(i.selection)
                        }
                    }, e.prototype.updateFilters = function () {
                        this.updateFilter(!0)
                    }, e.prototype.updateFilter = function (t) {
                        void 0 === t && (t = !1), this.log("Update filter");
                        var e = {};
                        for (var i in this.settings._computedDataMap) e[i] = !0;
                        this.events.notifySceneChanges({
                            data: e,
                            dataDeep: t
                        })
                    }, e.prototype.setSelection = function (t, e) {
                        void 0 === e && (e = "api"), this.log("Set selection");
                        for (var i = [], n = [], r = 0; r < t.length; r++) {
                            var s = t[r];
                            s instanceof f ? i.push(s) : d.Helpers.isString(s) ? n.push(s) : this.error("SetSelection: Selection contents must be Piechart_Slice object or string, got " + s)
                        }
                        this.selection.setSelection(i, n, !1, e)
                    }, e.prototype.saveSelection = function () {
                        for (var t = this.scene.selectionIds.splice(0), e = 0; e < this.scene.selection.length; e++) {
                            var i = this.scene.selection[e];
                            t.push(i.id)
                        }
                        return t
                    }, e.prototype.exportVisibleData = function () {
                        var t = this.scene.peek();
                        return t ? a.exportValues(t.data) : []
                    }, e.prototype.setPie = function (t, e, i, n) {
                        void 0 === i && (i = !0), void 0 === n && (n = "api"), this.log("Set pie"), this.navigator.setPie(t, e, n)
                    }, e.prototype.setPieOffset = function (t, e, i) {
                        void 0 === e && (e = !0), void 0 === i && (i = "api"), this.log("Set pie offset"), this.navigator.setPie(this.getPie(), t, i)
                    }, e.prototype.getPie = function () {
                        return this.navigator.getPie()
                    }, e.prototype.getActiveSlices = function () {
                        for (var t = [], e = 0; e < this.scene.stack.length; e++) {
                            var i = this.scene.stack[e];
                            i.parentSlice && t.push(i.parentSlice)
                        }
                        return t
                    }, e.prototype.getActivePies = function () {
                        return this.scene.stack
                    }, e.prototype.expandSlice = function (t, e) {
                        return void 0 === e && (e = "api"), this.navigator.expandSlice(t, e)
                    }, e.prototype.getSliceDimensions = function (t, e) {
                        if (!Array.isArray(t)) return this.error("getSliceDimensions: slice Id must be an array"), null;
                        if (t.length < 2) return null;
                        if (!e && this.scene.stack.length + 1 < t.length) return null;
                        for (var i, n = 0, r = 0; r < this.scene.stack.length; r++) {
                            if (i = this.scene.stack[r], i.id !== t[n]) return null;
                            if (n += 1, n === t.length - 1) break
                        }
                        for (var s = t[n], a = 0; a < i.slices.length; a++) {
                            var o = i.slices[a];
                            if (o.id === s) {
                                var l = o._renderParams;
                                return l ? {
                                    centerX: i.x,
                                    centerY: i.y,
                                    r0: l[0],
                                    r1: l[1],
                                    a0: l[2],
                                    a1: l[3]
                                } : null
                            }
                        }
                        return null
                    }, e.prototype.saveNavigation = function () {
                        var t = this.scene.peek();
                        return !t || t.loading ? null : {
                            pie: this.navigator.getPie(),
                            offset: this.navigator.getPieOffset()
                        }
                    }, e.prototype.restoreNavigation = function (t, e, i) {
                        this.navigator.setPie(t.pie, t.offset, i)
                    }, e.prototype.doChartUpdateNotify = function (e) {
                        t.prototype.doChartUpdateNotify.call(this, e);
                        var i = this.createEventArguments(null, e);
                        this.dispatchEventParams("pieChange", i, null), this.dispatchEventParams("pieReadyStateChanged", i, null)
                    }, e.prototype.createEventArguments = function (t, e) {
                        var i = this.scene;
                        if (!i) return {
                            chart: this.api,
                            origin: e
                        };
                        var n = i.peek();
                        return {
                            chart: this.api,
                            origin: e,
                            pie: n,
                            offset: n && n.offset,
                            count: n && n.count,
                            selection: i.selection.slice(),
                            slice: i.hoverSlice,
                            hoverSlice: i.hoverSlice,
                            hoverPie: i.hoverPie,
                            label: i.hoverLabel,
                            hoverLabel: i.hoverLabel
                        }
                    }, e.prototype.defaultClick = function (t, e) {
                        this.selection.defaultClick(t, e)
                    }, e.prototype.remove = function () {
                        t.prototype.remove.call(this), this.popup.remove()
                    }, e
                }(d.Impl);
                t.Impl = E
            }(a = i.PieChart || (i.PieChart = {})),
            function (t) {
                var e = function () {
                    function t() {
                        this.enabled = !0, this.size = 40, this.defaultUnitWidth = 50, this.maxUnitWidth = 400, this.zoomOutUnitWidth = 20, this.labels = {
                            enabled: !0,
                            angle: 0,
                            lineSpacing: .2,
                            interLabelSpacing: .6,
                            textStyle: {
                                fillColor: "#000",
                                font: "12px Arial"
                            },
                            margin: 4,
                            padding: 0,
                            aspectRatio: 3,
                            allowOverflow: !1
                        }, this.title = {
                            enabled: !1,
                            aspectRatio: 0,
                            align: "center",
                            useFacetName: !0,
                            textStyle: {
                                font: "13px Arial",
                                fillColor: "#000"
                            }
                        }
                    }
                    return t
                }();
                t.SettingsFacetAxis = e;
                var i = function () {
                    function t(t, e) {
                        this.title = null, this.titleHeight = null, this.facet = e, this.chart = t, this.scene = this.chart.scene, this.options = this.scene.settings.facetAxis, this.currentItemWidth = 1, this.currentItemHeight = 1, this.panel = new d.ChartPanel, this.panel.side = "bottom", this.createTitle(), this.panel.packingOrder = 100
                    }
                    return t.prototype.getPanel = function () {
                        var t = this.options,
                            e = this.panel;
                        return t.enabled && t.size > 0 ? (e.desiredHeight = t.size, e.visible = !0, this.scene.bottomAxisSize = t.size) : (e.desiredHeight = 0, e.visible = !1, this.scene.bottomAxisSize = 0), e.enableClipping = !t.labels.allowOverflow, e
                    }, t.prototype.createTitle = function () {
                        this.options.title.enabled ? this.title = new d.Label(this.options.title) : (this.title = null, this.titleHeight = 0)
                    }, t.prototype.updateTitle = function (t, e) {
                        var i = this.title,
                            n = this.options.title,
                            r = this.facet.data ? this.facet.data.name : "",
                            s = (n.useFacetName ? r || n.text : n.text) || "";
                        i && (i.text = s, e.measure(t, i), s ? this.titleHeight = 2 * ((i.style.margin || 0) + i.hheight) : this.titleHeight = 0)
                    }, t.prototype.paintTitle = function (t, e) {
                        var i = this.title;
                        if (i) {
                            this.updateTitle(t, e);
                            var n = this.titleHeight;
                            if (n) {
                                var r = this.panel.left,
                                    s = this.panel.right,
                                    a = this.scene.y0,
                                    o = this.scene.height,
                                    l = a + o + this.scene.bottomAxisSize - n / 2,
                                    h = void 0,
                                    u = i.style.align;
                                h = (r + s) / 2, "left" === u && (h = r + i.hwidth), "right" === u && (h = s - i.hwidth), e.paint(t, h, l, 1, i)
                            }
                        }
                    }, t.prototype.paint = function (t, e, i, n) {
                        var r = this.options.labels;
                        if (n.length > 1 && this.panel.visible && r.enabled && this.chart.assetsLoaded) {
                            var s = t.context,
                                a = t.labelRenderer,
                                o = n[1] - n[0],
                                l = this.panel.top,
                                h = n[0];
                            this.paintTitle(s, a);
                            var u = this.panel.bottom - this.panel.top - this.titleHeight,
                                c = !1;
                            (Math.abs(1 - this.currentItemWidth / o) > .01 || Math.abs(1 - this.currentItemHeight / u) > .01) && (this.currentItemWidth = o, this.currentItemHeight = u, c = !0), t.changes && t.changes.settings && (c = !0), this.layout = new d.LabelLayoutBase;
                            var p = this.facet.items,
                                f = (r.angle || 0) * Math.PI / 180,
                                g = Math.abs(Math.sin(f));
                            this.panel.pushClip(t);
                            for (var m = 0; m < p.length; m++) {
                                var v = n[m];
                                if (!(h > v)) {
                                    var y = p[m],
                                        S = y.currentLabel,
                                        b = this.htmlDecodeLabel(y.label || y.data.name || r.text, this.layout, s);
                                    if (y.currentLabel = null, b) {
                                        (null === y.currentLabel || c || y.currentLabel.text !== b) && (S = this.buildLabel(s, b, o, u), y.currentLabel = S);
                                        var C = Math.max.apply(Math, S.rows.rowWidths);
                                        if (h = v + S.x + C / 2, 0 !== f) {
                                            for (var x = 1, w = g * (n[m + 1] - n[m]); w < S.lineHeight + (r.margin || 0) + (r.padding || 0);) x++, w = g * (n[m + x] - n[m]);
                                            h = n[m + x], void 0 === n[m + x] && (h = 1 / 0)
                                        }
                                        a.paint(s, v + S.x, l + S.y, 1, S)
                                    }
                                }
                            }
                            this.panel.popClip(t)
                        }
                    }, t.prototype.htmlDecodeLabel = function (t, e, i) {
                        if (null == t || 0 === t.length) return "";
                        for (var n = e.styleTagParser2(i, t, {}), r = "", s = 0, a = n.words, o = 0; o < a.length; o++) {
                            var l = a[o];
                            if (r += l.word, o === a.length - 1) break;
                            n.breaks[s] === o + 1 ? (r += " ", s++) : l.spaceWidth && (r += " ")
                        }
                        return r
                    }, t.prototype.buildLabel = function (t, e, i, n) {
                        var r = new d.Label(this.options.labels),
                            s = r.style;
                        r.text = e;
                        var a = (s.angle || 0) * Math.PI / 180,
                            o = s.align;
                        o || (o = a > 0 ? "left" : a < 0 ? "right" : "center", s.align = o);
                        var l = function (t, e, r) {
                            var s, o, l = 0,
                                h = 1;
                            0 !== a ? (l = Math.sin(a), h = Math.cos(a), o = r / Math.abs(l), s = i / 2) : (s = e / 2, o = 2 * t <= n ? e : 0);
                            var u, c;
                            return a > 0 ? (u = s + o / 2 * h - 2 * t * h, c = e / 2 * l) : a < 0 ? (u = s - o / 2 * h + 2 * t * h, c = -e / 2 * l) : (u = s, c = t), {
                                x: u,
                                y: c,
                                dx: h,
                                dy: l,
                                width: o
                            }
                        };
                        return this.layout.getFormatedText(t, r, i, n, l), r
                    }, t
                }();
                t.FacetAxis = i;
                var r = function () {
                    function t() {
                        this.enabled = !0, this.tolerance = 4
                    }
                    return t
                }();
                t.SettingsInteractionSelection = r;
                var s = function () {
                    function t() {
                        this.lineColor = "rgba(0,0,0,0.5)", this.lineWidth = 2, this.fillColor = "rgba(30,160,220,0.15)", this.behindSeries = !1
                    }
                    return t
                }();
                t.SettingsAreaStyleSelection = s;
                var o = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.animationOrder = 2e3, i.paintOrder = 15, i.updateOrder = 1e3, i.scene = null, i.events = null, i.currentItem = null, i.currentFacet = null, i.hoverEvent = null, i.chart = e, i.scene = e.scene, i.events = e.events, i.settings = e.settings.interaction.selection, i.styleSettings = e.settings.area.style.selection, i.paintOrder = i.styleSettings.behindSeries ? 3 : 15, i
                    }
                    return n(e, t), e.prototype.paintScene = function (t) {
                        var e = this.scene,
                            i = e.selection,
                            n = !this.settings.enabled;
                        if (n || i && i.length) {
                            var r = e.width,
                                s = this.styleSettings,
                                a = s.lineWidth,
                                o = Math.round(e.x0),
                                l = Math.round(e.y0),
                                h = Math.round(l + e.height + e.bottomAxisSize),
                                u = e.height + e.bottomAxisSize,
                                c = [],
                                p = e.activeFacet;
                            if (n)
                                for (var f = 0, g = p.items; f < g.length; f++) {
                                    var m = g[f];
                                    m.selected && c.push(m.index)
                                } else
                                    for (var v = 0; v < i.length; v++) {
                                        var y = i[v];
                                        y.facet === p && c.push(y.index)
                                    }
                            c.sort(function (t, e) {
                                return t - e
                            });
                            for (var S, v = 0; v < c.length;) {
                                for (var b = c[v], C = b; ++v < c.length && (S = c[v]) === C + 1;) C = S;
                                var x = e.getItemPlacement(p, b, C),
                                    w = Math.round(o + r * x.left),
                                    L = Math.round(o + r * x.right),
                                    T = t.context;
                                d.Graphics.pushClip(t, o, l, r, u), d.Graphics.rectStyle(T, s);
                                var k = w + a % 2 / 2,
                                    A = L + a % 2 / 2;
                                T.fillRect(k + a / 2, l, L - w - a, u), T.beginPath(), T.moveTo(k, l), T.lineTo(k, h), T.moveTo(A, l), T.lineTo(A, h), d.Graphics.stroke(T, s), d.Graphics.popClip(t)
                            }
                        }
                    }, e.prototype.doAnimations = function (t) {
                        this.hoverEvent && this.onPointerMove(this.hoverEvent)
                    }, e.prototype.previewPointerDrag = function (t) {
                        this.hoverEvent = t
                    }, e.prototype.onPointerMove = function (t) {
                        var e = this.chart,
                            i = e.scene;
                        this.hoverEvent = t;
                        var n = i.findItemAt(t.x, t.y);
                        n && (t.cursor = "pointer");
                        var r = e.renderer.hitTest(t.x, t.y);
                        if (e.legend)
                            if (r) e.legend.notifyHoveredSeries(i.settings._computedSeries[r.seriesIndex]);
                            else {
                                e.legend.notifyHoveredSeries(null);
                                var s = e.legend.getLastHoveredSeries();
                                s && (r = {
                                    x0: null,
                                    y0: null,
                                    x1: null,
                                    y1: null,
                                    isMarker: !1,
                                    seriesIndex: i.settings._computedSeries.indexOf(s)
                                })
                            }(!r != !i.hoverSeriesItem || r && (r.seriesIndex !== i.hoverSeriesItem.seriesIndex || r.x0 !== i.hoverSeriesItem.x0)) && (i.hoverSeriesItem = r, t.changes.hover = !0), this.switchCurrentItem(n, t)
                    }, e.prototype.onPointerOut = function (t) {
                        this.hoverEvent = this.scene.hoverSeriesItem = null, this.events.notifySceneChanges({
                            selection: !0
                        }), this.switchCurrentItem(null, t)
                    }, e.prototype.defaultClick = function (t, e) {
                        var i = e.clickItem;
                        i && (i.url ? (d.Helpers.openUrl(i.url, i.urlTarget), t.preventDefault()) : this.settings.enabled && t.ctrlKey || "drilldown" !== this.chart.settings.interaction.mode || !this.chart.expandItem(i, "user") || t.preventDefault())
                    }, e.prototype.getClickArgs = function (t) {
                        var e = this.scene.findItemAt(t.x, t.y, !0),
                            i = this.chart.createEventArguments(t, "user", e);
                        return e && (t.cursor = "pointer", i.clickOrigin = this.scene.xyInBottom(t.x, t.y) ? "label" : "item"), i
                    }, e.prototype.onClick = function (t) {
                        var e = this.getClickArgs(t);
                        t.consumed = !0, this.chart.notifyClick(t, e), t.defaultPrevented || this.updateSelection(t, e.clickItem)
                    }, e.prototype.onLongPress = function (t) {
                        var e = this.scene.findItemAt(t.x, t.y);
                        this.updateSelection(t, e)
                    }, e.prototype.onRightClick = function (t) {
                        var e = this.getClickArgs(t);
                        this.chart.notifyRightClick(t, e), t.defaultPrevented && (t.consumed = !0)
                    }, e.prototype.onDoubleClick = function (t) {
                        var e = this.getClickArgs(t);
                        this.chart.notifyDoubleClick(t, e), t.consumed = !0
                    }, e.prototype.onTripleClick = function (t) {
                        var e = this.getClickArgs(t);
                        this.chart.notifyTripleClick(t, e), t.consumed = !0
                    }, e.prototype.updateSelection = function (t, e) {
                        if (this.settings.enabled) {
                            var i = this.scene,
                                n = i.selection;
                            if (t.ctrlKey || "toggle" === this.chart.settings.interaction.mode) e && (e.selected = !e.selected, e.selected ? n.push(e) : d.Helpers.removeFromArray(n, e), this.setSelection(n, i.selectionIds, !0));
                            else if (t.shiftKey) {
                                var r = i.activeFacet;
                                if (e && e.facet === r) {
                                    for (var s = 0, a = 0; a < n.length; a++) {
                                        var o = n[a];
                                        if (o.facet === r) {
                                            s = o.index;
                                            break
                                        }
                                    }
                                    var l = Math.min(e.index, s),
                                        h = Math.max(e.index, s);
                                    n = new Array(h - l + 1);
                                    for (var a = l; a <= h; a++) n[a - l] = r.items[a];
                                    this.setSelection(n)
                                }
                            } else !e || e.selected && 1 === n.length ? this.setSelection([]) : this.setSelection([e])
                        }
                    }, e.prototype.switchCurrentItem = function (t, e) {
                        if (t !== this.currentItem) {
                            var i = this.chart.createEventArguments(e, "user");
                            e.changes.current = !0, this.scene.hoverItem && (this.scene.hoverItem.active = !1), this.scene.hoverItem = t, this.currentItem = t, this.currentFacet = null, this.currentItem && (this.scene.hoverItem.active = !0, i.hoverItem = this.currentItem), this.events.notifySceneChanges({
                                items: !0
                            }), this.chart.notifyHoverChanged(e, i)
                        }
                    }, e.prototype.onSceneChange = function (t) {
                        if (t.changes.items) {
                            var e = this.chart;
                            this.updateSelectionIds() && (this.events.notifySceneChanges({
                                selection: !0
                            }), e.notifySelectionChanged(e.createEventArguments(null, "api")))
                        }
                    }, e.prototype.updateSelectionIds = function () {
                        for (var t = this.scene, e = [], i = 0, n = t.selectionIds; i < n.length; i++)
                            for (var r = n[i], s = 0, a = t.stack; s < a.length; s++)
                                for (var o = a[s], l = 0, h = o.items; l < h.length; l++) {
                                    var u = h[l];
                                    if (u.id === r) {
                                        e.push(u);
                                        break
                                    }
                                }
                        if (0 === e.length) return !1;
                        for (var c = 0, p = e; c < p.length; c++) {
                            var f = p[c];
                            f.selected || (f.selected = !0, t.selection.push(f)), d.Helpers.removeFromArrayHasty(t.selectionIds, f.id)
                        }
                        return !0
                    }, e.prototype.setSelection = function (t, e, i, n) {
                        void 0 === e && (e = []), void 0 === i && (i = !1), void 0 === n && (n = "user"), this.scene.selectionIds = e;
                        var r = !1;
                        if (i) r = !0;
                        else {
                            for (var s = 0; s < this.scene.selection.length; s++) {
                                var a = this.scene.selection[s];
                                t.indexOf(a) < 0 && (a.selected = !1, r = !0)
                            }
                            for (var s = 0; s < t.length; s++) {
                                var a = t[s];
                                a.selected || (a.selected = !0, r = !0)
                            }
                            this.scene.selection = t
                        }
                        var o = this.updateSelectionIds();
                        r = r || o, r && (this.events.notifySceneChanges({
                            selection: !0
                        }), this.chart.notifySelectionChanged(this.chart.createEventArguments(null, n)))
                    }, e
                }(d.ChartElement);
                t.Selection = o;
                var h = function (t) {
                    function e(e) {
                        var i = t.call(this, e) || this;
                        return i.animationOrder = 500, i.paintOrder = 25, i.updateOrder = 800, i
                    }
                    return n(e, t), e.prototype.doAnimations = function (t) {
                        (t.changes.position || t.changes.navigation) && this.updatePopup(t)
                    }, e.prototype.getPopupAreaMouseMoved = function (t, e) {
                        if (!this.scene.xyInChartOrBottom(t, e) || !this.scene.activeFacet) return null;
                        var i = this.scene.activeFacet,
                            n = this.scene.xToPosition(t);
                        if (isNaN(n)) return null;
                        var r = Math.floor(n),
                            s = Math.ceil(n);
                        return r === s && (s = r + 1), r < i.offset || r >= i.items.length + i.offset ? null : {
                            t0: r,
                            t1: s
                        }
                    }, e.prototype.buildHeader = function (t, e) {
                        var i = this.scene.activeFacet,
                            n = i.items[t - i.offset],
                            r = n.label || n.data.name || "";
                        return "<em></em><strong>" + r + "</strong>"
                    }, e
                }(l.InfoPopup);
                t.InfoPopup = h;
                var u = function () {
                    function t() {
                        this.enabled = !0, this.enabledOnExport = !1, this.size = 28, this.style = {
                            fillColor: "rgba(255,255,255,0.5)",
                            lineColor: "rgba(0,0,0,0.5)",
                            hoverFillColor: "rgba(255,255,255,0.9)",
                            hoverLineColor: "rgba(0,0,0,0.9)"
                        }
                    }
                    return t
                }();
                t.SettingsScrollButtons = u;
                var c = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        i.paintOrder = 75, i.chart = e, i.scene = e.scene, i.settings = e.settings.scrollButtons, i.panels = [];
                        for (var n = 0; n < 2; n++) {
                            var r = new d.ChartPanel;
                            r.packingOrder = 115, r.side = 1 === n ? "left" : "right", r.location = "inside", r.align = "center", i.panels.push(r)
                        }
                        return i
                    }
                    return n(e, t), e.prototype.onSceneChange = function (t) {
                        this.settings.enabled && (this.activeFacet = this.chart.scene.activeFacet, this.showLeft = Math.floor(this.activeFacet.from) > 0, this.showRight = Math.ceil(this.activeFacet.to) < this.activeFacet.totalCount)
                    }, e.prototype.getPanels = function (t) {
                        for (var e = 0; e < 2; e++) {
                            var i = this.panels[e];
                            i.visible = t ? this.settings.enabledOnExport : this.settings.enabled, i.desiredWidth = i.desiredHeight = this.settings.size
                        }
                        return this.panels
                    }, e.prototype.paintScene = function (t) {
                        if (this.panels[0].visible) {
                            var e = this.settings.style,
                                i = t.context;
                            i.fillStyle = e.fillColor, i.strokeStyle = e.lineColor;
                            for (var n = this.settings.size, r = n / 2, s = n / 4, a = this.scene.y0 + this.scene.height / 2 - n / 2, o = 0; o < this.panels.length; o++) {
                                var l = this.panels[o],
                                    h = l.left;
                                this.showRight && "right" === l.side && (this.rightActive && (i.fillStyle = e.hoverFillColor, i.strokeStyle = e.hoverLineColor), i.beginPath(), i.fillRect(h, a, n, n), i.moveTo(h + r - s / 2 + 2, a + s), i.lineTo(h + r + s - 3, a + r), i.lineTo(h + r - s / 2 + 2, a + n - s), i.stroke()), this.showLeft && "left" === l.side && (this.leftActive && (i.fillStyle = e.hoverFillColor, i.strokeStyle = e.hoverLineColor), i.beginPath(), i.fillRect(h, a, n, n), i.moveTo(h + r + s / 2 - 2, a + s), i.lineTo(h + r - s + 3, a + r), i.lineTo(h + r + s / 2 - 2, a + n - s), i.stroke()), i.fillStyle = e.fillColor, i.strokeStyle = e.lineColor
                            }
                        }
                    }, e.prototype.findItemAt = function (t, e, i) {
                        if (!this.panels[0].visible) return null;
                        for (var n = i.touch ? 10 : 0, r = 0; r < 2; r++) {
                            var s = this.panels[r];
                            if (t >= s.left - n && t <= s.right + n && e >= s.top - n && e <= s.bottom + n && ("left" === s.side && this.showLeft || "right" === s.side && this.showRight)) return s.side
                        }
                        return null
                    }, e.prototype.onClick = function (t) {
                        if (this.panels[0].visible) {
                            var e = d.Helpers.performanceNow(),
                                i = this.findItemAt(t.x, t.y, t);
                            if (null !== i) {
                                var n = this.chart.scrolling,
                                    r = this.activeFacet,
                                    s = r.from,
                                    a = r.to,
                                    o = r.totalCount,
                                    l = a - s;
                                "right" === i && (a + l > o ? (a = a - l + (o - a), n.goToPosition(a, o, !0, e, !0)) : n.goToPosition(a, a + l, !0, e, !0)), "left" === i && (s - l < 0 ? n.goToPosition(0, l, !0, e, !0) : n.goToPosition(s - l, s, !0, e, !0)), t.consumed = !0
                            }
                        }
                    }, e.prototype.onPointerMove = function (t) {
                        var e = this.findItemAt(t.x, t.y, t);
                        null !== e ? ("left" === e && (this.leftActive = !0), "right" === e && (this.rightActive = !0), t.changes.hover = !0, t.consumed = !0) : (this.leftActive = !1, this.rightActive = !1)
                    }, e
                }(d.ChartElement);
                t.ScrollButtons = c;
                var p = "#A8A7A8",
                    f = function (t) {
                        function i(i) {
                            var n = t.call(this, d.SettingsMapping.FacetChartSettings) || this;
                            return n.area = new g, n.data = [], n.filters = {
                                sliceFilter: null,
                                allowZeroValues: !0
                            }, n.navigation = {
                                initialDrilldown: [""],
                                initialOffset: 0
                            }, n.items = {
                                style: {
                                    label: null,
                                    expandable: !0
                                },
                                styleFunction: null
                            }, n.chartTypes = {
                                columns: {
                                    type: "columns"
                                },
                                line: {
                                    type: "line"
                                },
                                candlestick: null
                            }, n.facetAxis = new e, n.interaction = new y, n.toolbar = new v, n.legend = new l.SettingsLegend, n.scrollButtons = new u, n.localization.toolbar.zoomoutTitle = "Zoom-out to previous level", n.apply(i), n._initializing = !1, n
                        }
                        return n(i, t), i.prototype.apply = function (e) {
                            if (this.applyCompatibility(e, [{
                                    from: "area.initialPieId",
                                    to: "navigation.initialDrilldown"
                                }, {
                                    from: "area.initialPieOffset",
                                    to: "navigation.initialOffset"
                                }]), e.series)
                                for (var i = 0; i < e.series.length; i++) {
                                    var n = e.series[i];
                                    n && void 0 !== n.styleFunction && d.Helpers.error("Setting `series[" + i + "].styleFunction` is no longer supported. Consider using `items.styleFunction` instead. See the example: https://zoomcharts.com/developers/en/facet-chart/examples/series/stacked-colored.html")
                                }
                            return t.prototype.apply.call(this, e, S)
                        }, i
                    }(l.Settings);
                f.DarkTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-dark"
                    },
                    area: {
                        style: {
                            fillColor: "rgba(28,26,28,.1)",
                            selection: {
                                lineColor: "#838283"
                            }
                        }
                    },
                    title: {
                        margin: 15,
                        style: {
                            fillColor: p
                        }
                    },
                    valueAxisDefault: {
                        style: {
                            valueLabel: {
                                textStyle: {
                                    fillColor: p
                                }
                            },
                            title: {
                                textStyle: {
                                    fillColor: p
                                }
                            }
                        }
                    },
                    facetAxis: {
                        labels: {
                            textStyle: {
                                fillColor: p
                            }
                        },
                        title: {
                            textStyle: {
                                fillColor: p
                            }
                        }
                    },
                    legend: {
                        text: {
                            fillColor: p
                        },
                        advanced: {
                            disabledSeries: {
                                textColor: "rgba(168,167,168,0.5)",
                                lineColor: "rgba(117,117,117,0.3)"
                            }
                        }
                    }
                }, t.Settings = f;
                var g = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.style = new m, e
                    }
                    return n(e, t), e
                }(l.SettingsArea);
                t.SettingsArea = g;
                var m = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.selection = new s, e
                    }
                    return n(e, t), e
                }(l.SettingsAreaStyle);
                t.SettingsAreaStyle = m;
                var v = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.logScale = !0, e.zoomOut = !0, e.enabled = !0, e.items = [new d.SettingsToolbarItem("fullscreen", "left"), new d.SettingsToolbarItem("back", "left"), new d.SettingsToolbarItem("zoomOut", "left"), new d.SettingsToolbarItem("logScale", "right"), new d.SettingsToolbarItem("export", "right")], e
                    }
                    return n(e, t), e
                }(d.SettingsToolbar);
                t.SettingsToolbar = v;
                var y = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.selection = new r, e.mode = "drilldown", e.animation = {
                            scrollDuration: 500
                        }, e
                    }
                    return n(e, t), e
                }(l.SettingsInteraction);
                t.SettingsInteraction = y;
                var S = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.type = "columns", e.data = new b, e
                    }
                    return n(e, t), e.getMapping = function (t, e) {
                        if (t && e.type && t.type !== e.type) throw new Error("It is not possible to change the value of `type` property for an existing layer.");
                        switch (t ? t.type : e.type) {
                            case "columns":
                            case void 0:
                                return d.SettingsMapping.FacetChartSettingsSeriesColumns;
                            case "line":
                                return d.SettingsMapping.FacetChartSettingsSeriesLines;
                            default:
                                throw new Error("The value '" + e.type + "' is not valid for the `type` property of a series. Valid values are: columns, line.")
                        }
                    }, e.createInstance = function (t, e) {
                        switch (e || t.type) {
                            case "columns":
                            case void 0:
                                return new C;
                            case "line":
                                return new x;
                            default:
                                throw new Error("The value '" + (e || t.type) + "' is not valid for the `type` property of a series. Valid values are: columns, line.")
                        }
                    }, e
                }(l.SettingsSeries);
                t.SettingsSeries = S;
                var b = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.field = null, e.valueFunction = null, e
                    }
                    return n(e, t), e
                }(l.SettingsSeriesData);
                t.SettingsSeriesData = b;
                var C = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.style = new L, e.data = new b, e
                    }
                    return n(e, t), e
                }(l.SettingsSeriesColumns);
                t.SettingsSeriesColumns = C;
                var x = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.data = new b, e.style = new w, e
                    }
                    return n(e, t), e
                }(l.SettingsSeriesLines);
                t.SettingsSeriesLines = x;
                var w = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.markerStyleFunction = null, e
                    }
                    return n(e, t), e
                }(l.SettingsSeriesLinesStyle);
                t.SettingsSeriesLinesStyle = w;
                var L = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.previewContents = !1, e.previewLineColor = "rgba(255,255,255,.5)", e
                    }
                    return n(e, t), e
                }(l.SettingsSeriesColumnsStyle);
                t.SettingsSeriesColumnsStyle = L;
                var T = function (t) {
                    function e() {
                        return t.apply(this, arguments) || this
                    }
                    return n(e, t), e
                }(L);
                t.SettingsFacetStyle = T;
                var k = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.sortField = null, e.dataFunction = null, e.preloaded = null, e
                    }
                    return n(e, t), e
                }(a.SettingsData);
                t.SettingsData = k;
                var A = function () {
                    function t() {
                        this.id = null, this.data = null, this.items = [], this.parentItem = null, this.activeItemId = null, this.offset = 0, this.count = 0, this.totalCount = 0, this.from = 0, this.to = 0, this.left = 0, this.right = 1, this.opacity = 1, this.loading = null, this.rebuild = !0
                    }
                    return t.prototype.getActiveItem = function () {
                        if (!this.activeItemId) return null;
                        for (var t = 0; t < this.items.length; t++) {
                            var e = this.items[t];
                            if (e.id === this.activeItemId) return e
                        }
                        return null
                    }, t
                }();
                t.Facet = A;
                var M = function () {
                    function t(t, e, i, n) {
                        this.expandable = !0, this.selected = !1, this.active = !1, this.url = null, this.urlTarget = null, this.values = [], this.innerFacet = null, this.label = null, this.currentLabel = null, this.facet = t, this.id = e, this.index = i, this.data = n
                    }
                    return t
                }();
                t.Item = M;
                var I = function () {
                    function t(t, e, i, n, r) {
                        this.value = 0, this.label = null, this.currentLabel = null, this.style = new T, this.previewData = null, this.data = n, this.index = i, this.id = e, this.facet = t, this.seriesId = r
                    }
                    return t
                }();
                t.ItemValue = I;
                var P = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.data = null, e.stack = [], e.activeFacet = null, e.hoverItem = null, e.selection = [], e.selectionIds = [], e
                    }
                    return n(e, t), e.prototype.xToPosition = function (t) {
                        var e = this.activeFacet,
                            i = this.x0 + e.left * this.width,
                            n = this.x0 + e.right * this.width,
                            r = e.from + (t - i) / (n - i) * (e.to - e.from);
                        return r
                    }, e.prototype.positionToX = function (t) {
                        var e = this.activeFacet,
                            i = this.x0 + e.left * this.width,
                            n = this.x0 + e.right * this.width;
                        return i + (t - e.from) * (n - i) / (e.to - e.from)
                    }, e.prototype.timeToX = function (t) {
                        return this.positionToX(t)
                    }, e.prototype.xToTime = function (t) {
                        return this.xToPosition(t)
                    }, e.prototype.length = function () {
                        return this.stack.length
                    }, e.prototype.peek = function () {
                        return 0 === this.stack.length ? null : this.stack[this.stack.length - 1]
                    }, e.prototype.push = function (t, e) {
                        var i = this.peek();
                        if (i && !e)
                            for (var n = 0; n < i.items.length; n++) {
                                var r = i.items[n];
                                if (r.data.__id === t.id) {
                                    e = r;
                                    break
                                }
                            }
                        if (e) {
                            t.parentItem = e, e.innerFacet = t;
                            var s = this.getItemPlacement(e.facet, e.index);
                            t.left = s.left, t.right = s.right, i.activeItemId = e.id
                        } else i && (i.activeItemId = null);
                        this.stack.push(t), this.activeFacet = t
                    }, e.prototype.pop = function () {
                        if (this.stack.length > 0) {
                            var t = this.stack.pop();
                            t.parentItem && (t.parentItem.facet.activeItemId = null)
                        }
                        return this.stack.length > 0 ? this.activeFacet = this.peek() : this.activeFacet = null, this.activeFacet
                    }, e.prototype.getParent = function (t) {
                        for (var e = null, i = 0; i < this.stack.length; i++) {
                            var n = this.stack[i];
                            if (n === t) return e;
                            e = n
                        }
                        return null
                    }, e.prototype.getChild = function (t) {
                        for (var e = null, i = 0; i < this.stack.length; i++) {
                            var n = this.stack[i];
                            if (e === t) return n;
                            e = n
                        }
                        return null
                    }, e.prototype.updateLinks = function (t) {
                        var e = this.getParent(t),
                            i = this.getChild(t);
                        if (e && !t.parentItem)
                            for (var n = 0; n < e.items.length; n++) {
                                var r = e.items[n];
                                if (r.id === t.id) {
                                    t.parentItem = r, e.activeItemId = r.id;
                                    break
                                }
                            }
                        if (i && !i.parentItem)
                            for (var n = 0; n < t.items.length; n++) {
                                var r = t.items[n];
                                if (r.id === i.id) {
                                    i.parentItem = r, t.activeItemId = r.id;
                                    break
                                }
                            }
                    }, e.prototype.getItemPlacement = function (t, e, i) {
                        void 0 === i && (i = e);
                        var n = t.to - t.from,
                            r = t.from,
                            s = (e - r) / n,
                            a = (i - r + 1) / n;
                        return {
                            left: t.left + s * (t.right - t.left),
                            right: t.left + a * (t.right - t.left)
                        }
                    }, e.prototype.getFacetPlacementFromItem = function (t, e, i) {
                        var n = t.facet,
                            r = t.index,
                            s = r + 1,
                            a = (r - n.from) / (n.to - n.from),
                            o = (s - n.from) / (n.to - n.from),
                            l = e - a * (e - i) / (a - o),
                            h = l + (e - i) / (a - o);
                        return {
                            left: l,
                            right: h
                        }
                    }, e.prototype.findItemAt = function (t, e, i) {
                        var n = this.activeFacet;
                        if (n) {
                            if (!i && !this.xyInChart(t, e)) return null;
                            if (i && !this.xyInChartOrBottom(t, e)) return null;
                            var r = Math.floor(this.xToPosition(t));
                            if (r >= n.offset && r < n.offset + n.count) return n.items[r - n.offset]
                        }
                        return null
                    }, e
                }(l.Scene);
                t.Scene = P;
                var D = function (t) {
                    function e(e) {
                        var i = t.call(this, e) || this;
                        return i.animationOrder = 100, i.paintOrder = 10, i.updateOrder = 1100, i.animatingFacet = null, i.leftAnimator = null, i.rightAnimator = null, i.activePieReady = !1, i._shouldZoomOut = !1, i
                    }
                    return n(e, t), e.prototype.setState = function (t, e, i, n) {
                        if (0 === t.length) return void this.chart.error("setPie - array needs at least one item.");
                        for (var r = 0; this.scene.length() > t.length;) this.scene.pop(), r++;
                        for (; this.scene.length() > 0 && this.scene.peek().id !== t[this.scene.length() - 1];) this.scene.pop(), r++;
                        for (; this.scene.length() < t.length;) {
                            var s = t[this.scene.length()];
                            this.drillDown(s, null), r++
                        }
                        var a = this.scene.peek();
                        if (this.facet = a, r && this.goToPositionDragging(a.from, a.to), a.offset !== e || i && a.count !== i) {
                            var o = e,
                                l = void 0;
                            l = i > 0 ? o + i : e + a.count, r ? (this.goToPositionDragging(o, l), this.animateFillChart()) : this.goToPosition(o, l, !0, d.Helpers.performanceNow(), !0)
                        } else r && this.animateFillChart();
                        this.chart.notifyChartUpdate(n), r && this.events.notifySceneChanges({
                            navigation: !0
                        })
                    }, e.prototype.getState = function () {
                        for (var t = [], e = 0; e < this.scene.stack.length; e++) {
                            var i = this.scene.stack[e];
                            t.push(i.id)
                        }
                        var n = this.scene.peek();
                        return {
                            idArray: t,
                            offset: n.offset,
                            count: n.count
                        }
                    }, e.prototype.goUp = function (t) {
                        if (this.scene.length() > 1) {
                            this.scene.pop();
                            var e = this.facet = this.scene.peek();
                            this.goToPositionDragging(e.from, e.to), this.animateFillChart(), this.events.notifySceneChanges({
                                navigation: !0
                            }), this.updateAndNotifyCurrent(t)
                        } else this.goToPosition(0, this.getMaxItems(), !0, d.Helpers.performanceNow(), !0)
                    }, e.prototype.getMaxItems = function () {
                        var t = this.scene.width / this.scene.settings.facetAxis.defaultUnitWidth;
                        return this.facet.data.totalCount && (t = Math.min(t, this.facet.data.totalCount)), t
                    }, e.prototype.drillDown = function (t, e) {
                        this.stopAnimations();
                        var i = new A;
                        i.id = t, this.scene.push(i, null), this.chart.builder.updateFacet(i), this.facet = i, this.setFrom(i.from), this.setTo(i.to), this.animateFillChart(), this.events.notifySceneChanges({
                            navigation: !0
                        }), this.updateAndNotifyCurrent(e)
                    }, e.prototype.updateAndNotifyCurrent = function (t) {
                        this.chart.builder.updateFacet(this.facet), this.chart.notifyChartUpdate(t)
                    }, e.prototype.onSceneChange = function (t) {
                        var e = this.facet,
                            i = t.timeStamp,
                            n = t.changes.settingsChanges;
                        if (n && n.series) {
                            t.changes.items = !0;
                            for (var r = 0; r < this.scene.stack.length; r++) {
                                var s = this.scene.stack[r];
                                this.chart.builder.rebuildValues(s)
                            }
                        }
                        if ((t.changes.pieChartPieIds || t.changes.dataArrived || t.changes.data) && (this.activePieReady = !1, t.changes.data || t.changes.dataArrived))
                            for (var a = t.changes.pieChartPieIds || Object.create(null), o = 0; o < this.scene.stack.length; o++) {
                                var s = this.scene.stack[o],
                                    l = !s.data || s === e || a[s.id] || t.changes.dataDeep;
                                l && (s.rebuild = !0, this.chart.builder.updateFacet(s, t), t.changes.items = !0, this.activePieReady = this.activePieReady || s === e && !s.loading)
                            }
                        this.activePieReady && this.scene.width > 0 && (this.activePieReady = !1, this.inertiaT.finished(i) && e.from < e.to && (this.setFrom(e.from), this.setTo(e.to), this.animateFillChart()), this.chart.notifyChartUpdate(null))
                    }, e.prototype.doAnimations = function (e) {
                        var i = this.facet;
                        if (this.animatingFacet) {
                            i.left = this.leftAnimator.get(e.timeStamp), i.right = this.rightAnimator.get(e.timeStamp);
                            var n = this.leftAnimator.finished(e.timeStamp) || this.rightAnimator.finished(e.timeStamp);
                            n && (this.animatingFacet = null, this.leftAnimator = null, this.rightAnimator = null), this.events.notifySceneChanges({
                                position: !0
                            }), e.animating = !0
                        } else i.opacity = 1;
                        this.layoutFacets();
                        for (var r = 0; r < this.scene.stack.length; r++) i = this.scene.stack[r], this.chart.builder.updateFacet(i, e);
                        t.prototype.doAnimations.call(this, e)
                    }, e.prototype.xyInArea = function (t, e) {
                        return this.scene.xyInChartOrBottom(t, e)
                    }, e.prototype.xyToPosition = function (t, e) {
                        return this.scene.xToPosition(t)
                    }, e.prototype.onGoHome = function (t, e) {
                        return {
                            from: 0,
                            to: e - t,
                            origin: 0
                        }
                    }, e.prototype.handleZoomWheel = function (t, e, i, n, r) {
                        t < 0 && (e -= t, t = 0);
                        var s = this.onSnapWhileDragging(t, e, i, this.scrollingActive, r);
                        t = s.from, e = s.to;
                        var a = this.onSnapAfterDragging(t, e, i, this.scrollingActive, r);
                        return a ? void this.goToPosition(a.from, a.to, !0, n, !0) : void(this.wheelOrigin = null)
                    }, e.prototype.onStartDragging = function (t, e, i) {
                        this.stopAnim()
                    }, e.prototype.onSnapWhileDragging = function (t, e, i, n, r) {
                        var s = e - t,
                            a = this.facet,
                            o = a.totalCount,
                            l = 0,
                            h = 1,
                            u = !1;
                        return this.scene.stack.length > 1 && (s > 2 * o || this.scene.width / s < this.scene.settings.facetAxis.zoomOutUnitWidth) && (u = !0), this._shouldZoomOut = u, a.left = l, a.right = h, {
                            from: t,
                            to: e
                        }
                    }, e.prototype.onSnapAfterDragging = function (t, e, i, n, r) {
                        if (this._shouldZoomOut) return this._shouldZoomOut = !1, this.goUp("user"), null;
                        var s = this.snap(t, e, i, n, r);
                        return t = s.from, e = s.to, this.animateFillChart(), this.chart.notifyChartUpdate("user"), {
                            from: t,
                            to: e
                        }
                    }, e.prototype.onPositionChanged = function (t, e) {
                        var i = this.facet;
                        i.from = t, i.to = e, this.chart.builder.updateFacet(i), this.events.notifySceneChanges({
                            position: !0
                        })
                    }, e.prototype.onAnimationDone = function (t, e) {
                        this.chart.notifyChartUpdate(null), this.chart.notifyAnimationDone()
                    }, e.prototype.snap = function (t, e, i, n, r) {
                        var s = this.facet,
                            a = s.totalCount;
                        s.right < 1 && (0 === s.right && (s.right = 1e-10), e = t + (e - t) / s.right), s.left > 0 && (1 === s.left && (s.left = 1 - 1e-10), t = e - (e - t) / (1 - s.left));
                        var o = this.scene.width / (e - t),
                            l = o;
                        a > 0 && (l = Math.max(l, this.scene.width / a)), l = Math.min(this.scene.settings.facetAxis.maxUnitWidth, l);
                        var h = o / l;
                        if (t = i + (t - i) * h, e = i + (e - i) * h, t = Math.round(t), e = Math.round(e), t < 0) e -= t, t = 0;
                        else if (e > a) {
                            var u = Math.max(0, a - (e - t));
                            e = e - t + u, t = u
                        }
                        return {
                            from: t,
                            to: e
                        }
                    }, e.prototype.animateFillChart = function () {
                        0 === this.facet.left && 1 === this.facet.right && this.animatingFacet === this.facet || (this.animatingFacet = this.facet, this.leftAnimator = new d.Animator(this.facet.left, 0, this.scene.settings.interaction.animation.scrollDuration, "<>"), this.rightAnimator = new d.Animator(this.facet.right, 1, this.scene.settings.interaction.animation.scrollDuration, "<>"), this.events.notifySceneChanges({
                            requestPaint: !0
                        }))
                    }, e.prototype.stopAnim = function () {
                        var t = this.facet;
                        this.animatingFacet && (t.opacity = 1, this.animatingFacet = null), this.leftAnimator && (t.left = this.leftAnimator.get(1 / 0), this.leftAnimator = null), this.rightAnimator && (t.right = this.rightAnimator.get(1 / 0), this.rightAnimator = null), this.layoutFacets()
                    }, e.prototype.layoutFacets = function () {
                        for (var t = this.scene.stack.length - 2; t >= 0; t--) {
                            var e = this.scene.stack[t + 1],
                                i = this.scene.stack[t];
                            if (e.parentItem) {
                                var n = this.scene.getFacetPlacementFromItem(e.parentItem, e.left, e.right);
                                i.left = n.left, i.right = n.right
                            }
                            i.opacity = e.left > 0 || e.right < 1 ? .5 : 0
                        }
                        this._shouldZoomOut ? (this.facet.opacity = .65, this.facet.parentItem && this.facet.parentItem.facet && (this.facet.parentItem.facet.opacity = 1)) : this.facet.opacity = 1
                    }, e
                }(l.Scrolling);
                t.Scrolling = D;
                var N = function () {
                    function t(t, e, n) {
                        this.bounds = {
                            x0: 0,
                            y0: 0,
                            width: 0,
                            height: 0
                        }, this.facet = n, this.chart = e, this.scene = this.chart.scene, this.valueAxis = new l.ValueAxisSet(this.chart, this.scene.settings._computedValueAxisList), this.xes = [], this.facetAxis = new i(e, n), this.r = new l.Renderer(this.chart, this.valueAxis)
                    }
                    return t.prototype.getPanels = function () {
                        var t = this.valueAxis.getPanels(!0);
                        return t.push(this.facetAxis.getPanel()), t
                    }, t.prototype.setPanels = function (t) {
                        this.valueAxis.setPanels(t), this.facetAxis.panel = t[t.length - 1]
                    }, t.prototype.doAnimations = function (t, e) {
                        var i = e.x0,
                            n = e.y0,
                            r = e.width,
                            s = e.height,
                            a = this.facet,
                            o = a.offset,
                            l = a.left,
                            h = a.right;
                        l = i + r * l, h = i + r * h;
                        var u = Math.max(i, l),
                            c = Math.min(i + r, h);
                        this.bounds = {
                            x0: u,
                            y0: n,
                            width: c - u,
                            height: s
                        };
                        var d = t.changes;
                        if (d.position || d.data || d.bounds || d.items) {
                            for (var p = (h - l) / (a.to - a.from), f = l - a.from * p, g = a.count, m = o, v = o + g, y = new Array(g + 1), S = new Array(g + 1), b = m; b < v + 1; b++) y[b - m] = b, S[b - m] = b * p + f;
                            this.xes = S;
                            for (var C = new Array(this.scene.settings._computedSeries.length), x = 0; x < C.length; x++) {
                                for (var w = new Array(g), L = new Array(g), T = new Array(g), b = m; b < v; b++) {
                                    var k = this.facet.items[b - o],
                                        A = k.values[x];
                                    w[b - m] = A.value, T[b - m] = 1, L[b - m] = A
                                }
                                C[x] = {
                                    xes: S,
                                    times: y,
                                    counts: T,
                                    fromIndex: 0,
                                    toIndex: g + 1,
                                    values: w,
                                    config: L,
                                    externalItems: function (t, e) {
                                        return this.config.slice(t, e)
                                    }
                                }
                            }
                            this.r.process(C)
                        }
                        this.valueAxis.updateMinMax(t), this.r.afterProcess(), this.valueAxis.doAnimations(t)
                    }, t.prototype.paintScene = function (t) {
                        var e = t.context,
                            i = this.bounds,
                            n = this.facet.opacity,
                            r = 1 === n ? n : .2;
                        0 !== n && (e.globalAlpha = r, this.valueAxis.paintUnder(t), e.globalAlpha = n, d.Graphics.pushClip(t, i.x0, i.y0, i.width, i.height), this.r.paint(t), d.Graphics.popClip(t), e.globalAlpha = r, this.facetAxis.paint(t, i.x0, i.width, this.xes), this.valueAxis.paint(t), e.globalAlpha = 1)
                    }, t
                }();
                t.Layer = N;
                var F = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.animationOrder = 400, i.paintOrder = 5, i.updateOrder = 1200, i.chart = e, i.scene = i.chart.scene, i.events = i.chart.events, i.layers = [], i.panels = [], i
                    }
                    return n(e, t), e.prototype.onSceneChange = function (t) {
                        var e = t.changes;
                        if (e.settings || e.navigation || e.linearChartSeries || e.linearChartValueAxis) {
                            var i = e.settingsChanges;
                            e.linearChartValueAxis || i && i.facetAxis ? (e.bounds = !0, this.layers = []) : e.linearChartSeries && (this.layers = []);
                            for (var n = 0; n < this.layers.length; n++) {
                                var r = this.layers[n];
                                r.facet !== this.scene.stack[n] && (this.layers = this.layers.slice(0, n))
                            }
                            for (; this.layers.length < this.scene.stack.length;) {
                                var s = this.scene.stack[this.layers.length],
                                    a = new N(t, this.chart, s);
                                this.layers.push(a)
                            }
                            0 === this.layers.length && this.layers.push(new N(t, this.chart, new A));
                            var o = this.layers[0].getPanels();
                            this.panels = o.filter(function (t) {
                                return null != t
                            });
                            for (var l = 0; l < this.layers.length; l++) this.layers[l].setPanels(o)
                        }
                    }, e.prototype.getPanels = function () {
                        return this.panels
                    }, e.prototype.doAnimations = function (t) {
                        for (var e = 0; e < this.layers.length; e++) {
                            var i = this.layers[e];
                            i.doAnimations(t, this.scene)
                        }
                    }, e.prototype.paintScene = function (t) {
                        for (var e = 0; e < this.layers.length; e++) {
                            var i = this.layers[e];
                            i.paintScene(t)
                        }
                    }, e.prototype.exportData = function (t, e) {
                        return this.layers[this.layers.length - 1].r.exportData(t, e)
                    }, e.prototype.hitTest = function (t, e) {
                        var i = this.scene,
                            n = this.layers;
                        return i.xyInChart(t, e) && n.length > 0 ? n[n.length - 1].r.hitTest(t, e, i.settings.interaction.selection.tolerance) : null
                    }, e
                }(d.ChartElement);
                t.Renderer = F;
                var O = function () {
                    function t(t) {
                        this.chart = t, this.scene = t.scene, this.loading = !1
                    }
                    return t.prototype.updateFacet = function (t, e) {
                        void 0 === e && (e = null);
                        var i = this.chart.getData("default"),
                            n = t.data;
                        if ((!n || e && (e.changes.data || e.changes.dataArrived || e.changes.filters)) && (n = t.data = i.getPieData(t.id), !n)) return t.loading = !0, void i.requestPieData(t.id, Math.floor(t.from));
                        var r = !1;
                        if (this.scene.width && (!(t.from < t.to) || t.rebuild)) {
                            t.rebuild = !1;
                            var s = Math.max(1, Math.floor(this.scene.width / this.scene.settings.facetAxis.maxUnitWidth)),
                                a = Math.max(1, Math.floor(this.scene.width / this.scene.settings.facetAxis.defaultUnitWidth));
                            n.totalCount && (a = Math.min(n.totalCount, a)), a = Math.max(s, a), t.offset = Math.floor(t.from), t.count = 0, t.to = t.from + (0 | a), t.items = []
                        }
                        var o = Math.max(0, (0 | t.from) - 2),
                            l = Math.ceil(t.to + 2),
                            h = n.values.length + n.offset,
                            u = n.offset;
                        t.loading = !1, u > o && (o = u, i.requestLessPieData(t.id), t.loading = !0), h < l && (l = h, n.done || (i.requestMorePieData(t.id), t.loading = !0));
                        var c = t.offset + t.items.length;
                        if ((l < t.offset || o > c) && (t.offset = o, t.items = [], c = o), o > t.offset) t.items = t.items.slice(o - t.offset);
                        else if (o < t.offset) {
                            for (var d = [], p = o; p <= t.offset - 1; p++) d.push(this.buildItem(t, n, p));
                            t.items = d.concat(t.items), r = !0
                        }
                        if (t.offset = o, l < c) t.items = t.items.slice(0, l - t.offset);
                        else if (l > c) {
                            for (var p = c; p < l; p++) t.items.push(this.buildItem(t, n, p));
                            r = !0
                        }
                        if (t.count = t.items.length, t.totalCount = Math.max(t.offset + t.count, n.totalCount || 0), r) {
                            if (e) e.changes.items = !0, e.changes.changedItems || (e.changes.changedItems = {}), e.changes.changedItems[t.id] = !0;
                            else {
                                var f = {};
                                f[t.id] = !0, this.chart.events.notifySceneChanges({
                                    items: !0,
                                    changedItems: f
                                })
                            }
                            this.resetSelection() && this.chart.events.notifySceneChanges({
                                items: !0
                            })
                        }
                        this.scene.updateLinks(t)
                    }, t.prototype.resetSelection = function () {
                        for (var t = this.scene, e = 0, i = t.selection; e < i.length; e++) {
                            var n = i[e];
                            t.selectionIds.push(n.id), n.selected = !1
                        }
                        return t.selection = [], t.selectionIds.length > 0
                    }, t.prototype.rebuildValues = function (t) {
                        for (var e = 0; e < t.items.length; e++) {
                            var i = t.items[e];
                            this.updateItem(i)
                        }
                    }, t.prototype.buildItem = function (t, e, i) {
                        var n = e.values[i - e.offset],
                            r = new M(t, n.__id, i, n);
                        return this.updateItem(r), r
                    }, t.prototype.updateItem = function (t) {
                        for (var e = [], i = 0; i < this.scene.settings._computedSeries.length; i++) {
                            var n = this.scene.settings._computedSeries[i],
                                r = new I(t.facet, t.id, t.index, t.data, n.id);
                            t.data ? r.value = this.getSeriesValue(t.data, n) : r.value = null, e.push(r)
                        }
                        t.values = e
                    }, t.prototype.getSeriesValue = function (t, e) {
                        var i = e.data.valueFunction,
                            n = null;
                        if (i) n = i(t);
                        else {
                            var r = e.data.field || "value";
                            n = t[r]
                        }
                        return d.Helpers.tryParseFloat(n, null)
                    }, t.prototype.buildPreviewData = function (t, e) {
                        var i = t.id,
                            n = this.scene.mainData,
                            r = n.getPieData(i),
                            s = null;
                        if (r)
                            if (r.offset > 0) n.requestLessPieData(t.id);
                            else {
                                s = [];
                                for (var a = 0, o = 0; o < r.values.length; o++) {
                                    var l = r.values[o],
                                        h = this.getSeriesValue(l, e);
                                    s.push(h), a += h
                                }
                                if (a > 0) {
                                    a = 1 / a;
                                    for (var u = 0; u < s.length; u++) s[u] = s[u] * a
                                } else s = null
                            }
                        else t.expandable && n.canExpand(i) && n.requestPieData(t.id, 0);
                        return s
                    }, t
                }();
                t.Builder = O;
                var E = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.animationOrder = 200, i.paintOrder = 20, i.updateOrder = 900, i.chart = e, i.scene = e.scene, i
                    }
                    return n(e, t), e.prototype.doAnimations = function (t) {
                        var e = t.changes;
                        if (e.settings || e.items || e.selection || e.navigation || e.style) {
                            var i = this.scene.activeFacet;
                            if (i)
                                for (this.computeFacetStyleRec(i); i && i.parentItem;) i = i.parentItem.facet, this.computeFacetStyleRec(i)
                        }
                    }, e.prototype.computeFacetStyleRec = function (t) {
                        this.computeFacetStyle(t);
                        for (var e = 0; e < t.items.length; e++) {
                            var i = t.items[e];
                            this.computeItemStyle(t, i), i.innerFacet && this.computeFacetStyleRec(i.innerFacet)
                        }
                    }, e.prototype.computeFacetStyle = function (t) {}, e.prototype.computeItemStyle = function (t, e) {
                        var i = this.scene.settings._computedSeries;
                        if (d.Helpers.extendStyleTo(this.scene.settings.items.style, e), e.data.style && d.SettingsHelper.updateRecursive(e, e.data.style, d.SettingsMapping.FacetChartSettingsFacetStyle, {}), e.id === e.facet.activeItemId)
                            for (var n = 0; n < e.values.length; n++) {
                                var r = e.values[n];
                                r.style.fillColor = null, r.style.lineColor = null
                            } else
                                for (var n = 0; n < e.values.length; n++) {
                                    var r = e.values[n];
                                    d.Helpers.extendStyleTo(i[n].style, r.style)
                                }
                        if (this.scene.settings.items.styleFunction ? (this.scene.settings.items.styleFunction(e, e.data), e.label && !d.Helpers.isString(e.label) && (e.label = "" + e.label)) : e.data.name && (e.label = e.data.name), e.id !== e.facet.activeItemId)
                            for (var n = 0; n < e.values.length; n++) {
                                var r = e.values[n],
                                    s = i[n];
                                r.style.previewContents ? r.previewData = this.chart.builder.buildPreviewData(e, s) : r.previewData = null
                            } else e.values[e.values.length - 1].previewData = null
                    }, e
                }(d.ChartElement);
                t.Styles = E;
                var R = function (t) {
                    function e(e, i) {
                        var n = t.call(this, new f(e), new P, i) || this;
                        return n.builder = new O(n), n.renderer = n.events.addElement(new F(n)), n.scrolling = n.events.addElement(new D(n)), n.selection = n.events.addElement(new o(n)), n.events.addElement(new E(n)), n.infoPopup = new h(n), n.events.addElement(n.infoPopup), n.events.addElement(new l.Highlights(n)), n.scrollButtons = n.events.addElement(new c(n)), n.finalInitialize(), n.scrolling.setState(n.settings.navigation.initialDrilldown, n.settings.navigation.initialOffset, 0, "init"), n
                    }
                    return n(e, t), e.prototype.createDataObj = function (t) {
                        return new a.Data(this, t, !0)
                    }, e.prototype.getData = function (e) {
                        return t.prototype.getData.call(this, e)
                    }, e.prototype.onSettingsChanged = function (t) {
                        var e = {
                            settings: !0,
                            settingsChanges: t,
                            items: !1
                        };
                        t.navigation && this.scrolling.setState(this.settings.navigation.initialDrilldown, this.settings.navigation.initialOffset, null, "api"), (t.series || t.interaction) && (e.items = !0), this.events.notifySceneChanges(e), (t.data || t.facetAxis) && this.updateSize(!0)
                    }, e.prototype.updateFilters = function () {
                        return this.updateFilter(!0)
                    }, e.prototype.updateFilter = function (t) {
                        void 0 === t && (t = !1), this.log("Update filter");
                        var e = {};
                        for (var i in this.settings._computedDataMap) e[i] = !0;
                        this.events.notifySceneChanges({
                            data: e,
                            dataDeep: t
                        })
                    }, e.prototype.setSelection = function (t, e) {
                        void 0 === e && (e = "api"), this.log("Set selection");
                        for (var i = [], n = [], r = 0; r < t.length; r++) {
                            var s = t[r];
                            s instanceof M ? i.push(s) : d.Helpers.isString(s) ? n.push(s) : this.error("SetSelection: Selection contents must be FacetChart.Item object or string, got " + typeof s)
                        }
                        this.selection.setSelection(i, n, !1, e)
                    }, e.prototype.exportVisibleData = function () {
                        var t = this.scene.peek();
                        return t ? a.Data.exportValues(t.data) : []
                    }, e.prototype.setPie = function (t, e, i, n) {
                        void 0 === i && (i = null), void 0 === n && (n = !0), this.log("Set pie"), this.scrolling.setState(t, e, i, "api")
                    }, e.prototype.getPie = function () {
                        return this.scrolling.getState().idArray
                    }, e.prototype.getPieOffset = function () {
                        return this.scrolling.getState().offset
                    }, e.prototype.getActiveItems = function () {
                        for (var t = [], e = 0; e < this.scene.stack.length; e++) {
                            var i = this.scene.stack[e];
                            i.parentItem && t.push(i.parentItem)
                        }
                        return t
                    }, e.prototype.getActiveFacets = function () {
                        return this.scene.stack
                    }, e.prototype.zoomOut = function (t, e) {
                        void 0 === t && (t = !0), void 0 === e && (e = "api"), this.setSelection([]), this.scrolling.goUp(e)
                    }, e.prototype.zoomOutPossible = function () {
                        var t = this.scene;
                        return t.length() > 1 || t.peek() && t.peek().offset > 0
                    }, e.prototype.getBottomHeight = function () {
                        return this.scene.chartHeight - this.settings.facetAxis.size
                    }, e.prototype.expandItem = function (t, e) {
                        var i = t.facet;
                        if (i === this.scene.peek()) {
                            var n = t.id;
                            if (t.expandable && this.scene.mainData.canExpand(n)) return this.setSelection([]), this.scrolling.drillDown(n, e), !0
                        }
                        return !1
                    }, e.prototype.saveNavigation = function () {
                        var t = this.scene.peek();
                        return !t || this.scrolling.isActive() ? null : this.scrolling.getState()
                    }, e.prototype.restoreNavigation = function (t, e, i) {
                        return this.scrolling.setState(t.idArray, t.offset, t.count, i)
                    }, e.prototype.save = function () {
                        for (var t = this.scene.selectionIds.splice(0), e = 0; e < this.scene.selection.length; e++) {
                            var i = this.scene.selection[e];
                            t.push(i.id)
                        }
                        var n = this.scrolling.getState();
                        return JSON.stringify({
                            pie: n.idArray,
                            offset: n.offset,
                            count: n.count,
                            selection: t
                        })
                    }, e.prototype.restore = function (t, e) {
                        if (t) {
                            var i = JSON.parse(t);
                            this.setPie(i.pie, i.offset, i.count, e), this.setSelection(i.selection)
                        }
                    }, e.prototype.createEventArguments = function (t, e, i) {
                        var n = this.scene;
                        if (!n) return {
                            chart: this.api,
                            origin: e
                        };
                        var r = n.peek(),
                            s = i && i.facet,
                            a = n.hoverSeriesItem,
                            o = a && null != a.seriesIndex ? n.settings._computedSeries[a.seriesIndex] : null;
                        return {
                            chart: this.api,
                            origin: e,
                            facet: r,
                            offset: r && r.offset,
                            count: r && r.count,
                            hoverItem: n.hoverItem,
                            hoverSeries: o,
                            hoverMarker: !!a && a.isMarker,
                            selection: n.selection.slice(),
                            clickItem: i,
                            clickFacet: s,
                            clickOrigin: null
                        }
                    }, e.prototype.defaultClick = function (t, e) {
                        this.selection.defaultClick(t, e)
                    }, e.prototype.remove = function () {
                        t.prototype.remove.call(this), this.infoPopup.remove()
                    }, e
                }(l.Impl);
                t.Impl = R
            }(s = i.FacetChart || (i.FacetChart = {})),
            function (e) {
                function r(t) {
                    return t ? t.properties && t.properties.id && d.Helpers.isString(t.properties.id) ? t.properties.id : t.id : null
                }

                function s(t) {
                    if (!Array.isArray(t)) return "GeoJSON LineString data contained invalid coordinate collection.";
                    if (t.length < 2) return "GeoJSON LineString data must contain at least 2 points.";
                    for (var e = new Array(2 * t.length), i = 0; i < t.length; i++) {
                        var n = t[i];
                        if (!n || !d.Helpers.isNumber(n[0]) || !d.Helpers.isNumber(n[1])) return "GeoJSON LineString data contained invalid coordinates.";
                        e[2 * i] = n[0], e[2 * i + 1] = n[1]
                    }
                    return e
                }

                function a(t, e) {
                    if (!Array.isArray(t)) return "GeoJSON Polygon data contained invalid coordinate collection.";
                    if (t.length < 1) return "GeoJSON Polygon data doesn't contain any LinearRings.";
                    for (var i = 0; i < t.length; i++) {
                        var n = s(t[i]);
                        if (d.Helpers.isString(n)) return n;
                        e.push(n)
                    }
                    return null
                }

                function o(t) {
                    return d.Helpers.isNumber(t[0]) && d.Helpers.isNumber(t[1]) ? [t[0], t[1]] : "GeoJSON data contained invalid coordinates."
                }

                function l(t) {
                    var e = [],
                        i = a(t.coordinates, e);
                    return i ? i : e
                }

                function h(t) {
                    var e = t.coordinates;
                    if (!Array.isArray(e)) return "GeoJSON MultiPolygon data contained invalid coordinates";
                    if (e.length < 1) return "GeoJSON MultiPolygon data doesn't contain any Polygons.";
                    for (var i = [], n = 0; n < e.length; n++) {
                        var r = a(e[n], i);
                        if (r) return r
                    }
                    return i
                }

                function c(t) {
                    var e = s(t.coordinates);
                    return d.Helpers.isString(e) ? e : [e]
                }

                function p(t) {
                    var e = t.coordinates;
                    if (!Array.isArray(e)) return "GeoJSON MultiLineString data contained invalid coordinates";
                    if (e.length < 1) return "GeoJSON MultiLineString data doesn't contain any lines.";
                    for (var i = new Array(e.length), n = 0; n < e.length; n++) {
                        var r = s(e[n]);
                        if (d.Helpers.isString(r)) return r;
                        i[n] = r
                    }
                    return i
                }

                function f(t, e, i, n, s, a) {
                    d.Helpers.isString(e) ? a(e, n) : t.push({
                        _x: 0,
                        _y: 0,
                        id: r(n),
                        loaded: !0,
                        coordinates: e,
                        type: i,
                        shapeFeature: n,
                        shapeGeometry: s
                    })
                }

                function g(t, e, i, n) {
                    if (!Array.isArray(e.coordinates)) return void n("GeoJSON data contained invalid object.", i);
                    switch (e.type) {
                        case "Point":
                            f(t, o(e.coordinates), "point", i, e, n);
                            break;
                        case "MultiPoint":
                            var r = e;
                            if (Array.isArray(r.coordinates))
                                for (var s = 0; s < r.coordinates.length; s++) f(t, o(r.coordinates[s]), "point", i, e, n);
                            else n("GeoJSON data contained invalid MultiPoint object.", i);
                            break;
                        case "LineString":
                            f(t, c(e), "line", i, e, n);
                            break;
                        case "MultiLineString":
                            f(t, p(e), "line", i, e, n);
                            break;
                        case "Polygon":
                            f(t, l(e), "polygon", i, e, n);
                            break;
                        case "MultiPolygon":
                            f(t, h(e), "polygon", i, e, n);
                            break;
                        default:
                            return void n('GeoJSON data contained unknown object with type "' + e.type + '" .', i)
                    }
                }

                function m(t, e, i, n) {
                    if ("GeometryCollection" === e.type) {
                        var r = e;
                        if (Array.isArray(r.geometries))
                            for (var s = 0; s < r.geometries.length; s++) m(t, r.geometries[s], i, n);
                        else n("GeoJSON data contained invalid GeometryCollection object.", i)
                    } else g(t, e, i, n)
                }

                function v(t, e, i) {
                    return e.geometry && "Feature" === e.type ? void m(t, e.geometry, e, i) : void i("GeoJSON data contained invalid feature object.", e)
                }

                function y(t, e, i) {
                    if (!Array.isArray(e.features) || "FeatureCollection" !== e.type) return void i("GeoJSON data contained invalid FeatureCollection object.", null);
                    for (var n = 0; n < e.features.length; n++) v(t, e.features[n], i)
                }

                function S(t, e) {
                    function i(t, i) {
                        e.error("Error: " + t + " Feature id: '" + r(i) + "'")
                    }
                    if (!t) return [];
                    var n = [];
                    switch (t.type) {
                        case "FeatureCollection":
                            y(n, t, i);
                            break;
                        case "Feature":
                            v(n, t, i);
                            break;
                        case "GeometryCollection":
                            m(n, t, null, i);
                            break;
                        case "Point":
                        case "MultiPoint":
                        case "LineString":
                        case "MultiLineString":
                        case "Polygon":
                        case "MultiPolygon":
                            g(n, t, null, i);
                            break;
                        default:
                            return void i('GeoJSON data contained unknown object with type "' + t.type + '" .', null)
                    }
                    for (var s = {
                            "##default": 0
                        }, a = 0; a < n.length; a++) {
                        var o = n[a];
                        null == o.id ? o.id = "##default" + d.Helpers.SeparatorChar + s["##default"]++ : d.Helpers.hasProperty(s, o.id) ? o.id += d.Helpers.SeparatorChar + s[o.id]++ : s[o.id] = 0
                    }
                    return n
                }
                e.convertFromGeoJson = S;
                var b = function () {
                    function t(t, e, i) {
                        this.nodes = {}, this.links = {}, this.area = new d.AreaCollection, this.requestedArea = new d.AreaCollection, this.pendingArea = null, this.cacheId = i, this.id = e, this.level = t
                    }
                    return t
                }();
                e.DataLayer = b;
                var C = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.dataFunction = null, e.preloaded = null, e.prefetchRatio = 1, e.bounds = [-180, -85.0511287798, 180, 85.0511287798], e.wrapLng = !0, e.maxRequestRect = [256, 256], e.perBoundsData = !0, e.perZoomData = !1, e.perDrilldownData = !1, e.useGridBasedAggregation = !1, e.aggregationGridSize = 100, e.aggregationMinCount = 5, e
                    }
                    return n(e, t), e
                }(u.SettingsData);
                e.SettingsData = C;
                var x = function (t) {
                    function e(e, i) {
                        var n = t.call(this, e, i) || this;
                        n.layers = {}, n.pendingLayers = [], n.nextId = 0, n.aggregationGridSize = 1, n.zoomLevel = null, n.projectFun = function (t, e) {
                            return n.chart.scene.project(t, e)
                        }, n.unprojectFun = function (t, e) {
                            return n.chart.scene.unproject(t, e)
                        };
                        var r = n.projectFun(n.dataSettings.bounds[0], n.dataSettings.bounds[1]),
                            s = n.projectFun(n.dataSettings.bounds[2], n.dataSettings.bounds[3]);
                        return n.projectedBounds = new d.Rect(Math.min(r.x, s.x), Math.min(r.y, s.y), Math.max(r.x, s.x), Math.max(r.y, s.y)), n
                    }
                    return n(e, t), e.prototype.getProjectedBounds = function () {
                        return this.projectedBounds
                    }, e.prototype.setViewParams = function (t, e, i, n, r) {
                        this.dataSettings.perZoomData ? this.zoomLevel = e : this.zoomLevel = null, this.aggregationGridSize = t, this.loadDataArea = this.buildRectArea(r), this.returnDataArea = this.buildRectArea(n), this.visibleArea = this.buildRectArea(i), this.pendingLayers = []
                    }, e.prototype.getLayer = function (t) {
                        var e = "",
                            i = null;
                        t && (e += "" + t), null !== this.zoomLevel && (e += "#z" + this.zoomLevel, i = this.zoomLevel);
                        var n;
                        return n = this.layers.hasOwnProperty(e) ? this.layers[e] : this.layers[e] = new b(i, t, e), this.lastLayer = n, n
                    }, e.prototype.getData = function (t) {
                        var e, i = this.getLayer(t);
                        i.area.coversArea(this.loadDataArea) ? (i.pendingArea = new d.AreaCollection, e = !1) : i.requestedArea.coversArea(this.loadDataArea) ? e = this.hasPendingRequests() : (i.pendingArea = this.loadDataArea.makeCopy().subtractArea(i.requestedArea), i.pendingArea.isEmpty() || (this.pendingLayers.indexOf(i) < 0 && this.pendingLayers.push(i), this.scheduleRequests(!0)), e = this.hasPendingRequests());
                        var n = this.applyFilters(i, this.returnDataArea);
                        return this.chart.log("Data: returned " + n.nodes.length + " nodes and " + n.links.length + " links for ID: " + t + ", loading=" + e), {
                            nodes: n.nodes,
                            links: n.links,
                            hasData: i.area.intersectsArea(this.visibleArea),
                            loading: e
                        }
                    }, e.prototype.applyFilters = function (t, e) {
                        var i, n, r = e.toRects(),
                            s = this.settings.filters.nodeFilter,
                            a = [],
                            o = [],
                            l = {};
                        for (var h in t.nodes) {
                            var u = t.nodes[h],
                                c = u._bounds,
                                d = !s || s(u);
                            if (d)
                                for (i = 0; i < r.length; i++)
                                    if (n = r[i], n.overlapsRect(c.x0, c.y0, c.x1, c.y1)) {
                                        a.push(u), l[h] = !0;
                                        break
                                    }
                        }
                        for (var h in t.links) {
                            var p = t.links[h],
                                f = l[p.from],
                                g = l[p.to];
                            if (f || g) o.push(p), f || (l[p.from] = !0, a.push(t.nodes[p.from])), g || (l[p.to] = !0, a.push(t.nodes[p.to]));
                            else {
                                var m = t.nodes[p.from],
                                    v = t.nodes[p.to];
                                if (m._x && v._x) {
                                    var y = m._x,
                                        S = m._y,
                                        b = v._x,
                                        C = v._y;
                                    for (i = 0; i < r.length; i++)
                                        if (n = r[i], n.intersectsSegment(y, S, b, C)) {
                                            a.push(m), a.push(v), l[p.from] = !0, l[p.to] = !0;
                                            break
                                        }
                                }
                            }
                        }
                        return {
                            nodes: a,
                            links: o
                        }
                    }, e.prototype.unprojectRect = function (t) {
                        var e = this.unprojectFun(t.x0, t.y0),
                            i = this.unprojectFun(t.x1, t.y1);
                        return new d.Rect(Math.min(e.lng, i.lng), Math.min(e.lat, i.lat), Math.max(e.lng, i.lng), Math.max(e.lat, i.lat))
                    }, e.prototype.projectRect = function (t) {
                        var e = this.projectFun(t.x0, t.y0),
                            i = this.projectFun(t.x1, t.y1);
                        return new d.Rect(Math.min(e.x, i.x), Math.min(e.y, i.y), Math.max(e.x, i.x), Math.max(e.y, i.y));
                    }, e.prototype.buildRectArea = function (t) {
                        var e = this.projectedBounds,
                            i = t.x0,
                            n = t.y0,
                            r = t.x1,
                            s = t.y1,
                            a = new d.AreaCollection;
                        if (n = Math.max(n, e.y0), s = Math.min(s, e.y1), this.dataSettings.wrapLng) {
                            var o = e.x1 - e.x0;
                            if (r - i > o) i = e.x0, r = e.x1;
                            else {
                                for (; i < e.x0;) i += o, r += o;
                                for (; i > e.x1;) i -= o, r -= o
                            }
                            r <= e.x1 ? a.addRect(new d.Rect(i, n, r, s)) : (a.addRect(new d.Rect(i, n, e.x1, s)), a.addRect(new d.Rect(e.x0, n, r - o, s)))
                        } else a.addRect(t.clone().clip(e));
                        return a
                    }, e.prototype.buildRequest = function () {
                        if (this.pendingLayers.length > 0) {
                            var t = this.pendingLayers[0],
                                e = t.pendingArea.findOverlappingRect(this.dataSettings.maxRequestRect[0], this.dataSettings.maxRequestRect[1]);
                            t.pendingArea.subtractRect(e), t.pendingArea.isEmpty() && d.Helpers.removeFromArray(this.pendingLayers, t);
                            var i = e,
                                n = [],
                                r = [];
                            if (this.dataSettings.useGridBasedAggregation) {
                                var s = this.buildAggregationRequest(e);
                                i = s.rectangle, n = s.xcuts, r = s.ycuts
                            }
                            t.requestedArea.addRect(i);
                            var a = this.unprojectRect(i);
                            return {
                                id: t.id,
                                layerId: t.cacheId,
                                west: a.x0,
                                north: a.y1,
                                east: a.x1,
                                south: a.y0,
                                zoom: this.zoomLevel,
                                aggregateLat: r,
                                aggregateLng: n,
                                aggregateMinItems: this.dataSettings.aggregationMinCount
                            }
                        }
                        return null
                    }, e.prototype.buildAggregationRequest = function (t) {
                        for (var e = this.aggregationGridSize, i = Math.floor(t.x0 / e) * e, n = Math.ceil(t.x1 / e) * e, r = Math.floor(t.y0 / e) * e, s = Math.ceil(t.y1 / e) * e, a = this.dataSettings.bounds[0], o = this.dataSettings.bounds[1], l = this.dataSettings.bounds[2], h = this.dataSettings.bounds[3], u = [], c = [], p = i; p <= n; p += e) u.push(Math.min(Math.max(this.unprojectFun(p, r).lng, a), l));
                        for (var f = r; f <= s; f += e) c.push(Math.min(Math.max(this.unprojectFun(i, f).lat, o), h));
                        return {
                            rectangle: new d.Rect(i, r, n, s),
                            xcuts: u,
                            ycuts: c
                        }
                    }, e.prototype.dataFunc = function (t, e, i) {
                        var n = this.dataSettings;
                        if (n.dataFunction) n.dataFunction(t, e, i);
                        else if (n.url) {
                            var r = [
                                ["id", t.id],
                                ["south", t.south.toString(10)],
                                ["west", t.west.toString(10)],
                                ["north", t.north.toString(10)],
                                ["east", t.east.toString(10)]
                            ];
                            (t.aggregateLat.length || t.aggregateLng.length) && (r.push(["aggregateLat", t.aggregateLat.join(",")]), r.push(["aggregateLng", t.aggregateLng.join(",")]), r.push(["aggregateMinItems", t.aggregateMinItems.toString(10)])), null !== t.zoom && r.push(["zoom", t.zoom.toString(10)]), d.Data.doRequest(n.url, n, r, e, i)
                        } else i({
                            error: "Chart configuration does not define data retrieval function"
                        })
                    }, e.prototype.verifyData = function (t, e) {
                        "geojson" === this.dataSettings.format.toLowerCase() && (e.nodes = S(e, this.chart));
                        var i = !0;
                        e.hasOwnProperty("nodes") || (e.nodes = []), e.hasOwnProperty("links") || (e.links = []);
                        var n = d.Helpers.tryParseFloat(e.west, t ? t.west : 1 / 0),
                            r = d.Helpers.tryParseFloat(e.east, t ? t.east : -(1 / 0)),
                            s = d.Helpers.tryParseFloat(e.north, t ? t.north : 1 / 0),
                            a = d.Helpers.tryParseFloat(e.south, t ? t.south : -(1 / 0));
                        e._bounds = new d.Rect(n, a, r, s);
                        for (var o = {}, l = 0; l < e.nodes.length; l++) {
                            var h = e.nodes[l];
                            if (Array.isArray(h.coordinates) || (this.chart.error("Data response: Node has no coordinates, or not an array"), i = !1), h.aggregate) d.Helpers.isNumber(h.count) || (this.chart.error("Aggregated node needs `count` field that contains a number."), i = !1);
                            else if (h.hasOwnProperty("id")) {
                                var u = h.id.toString();
                                o.hasOwnProperty(u) && this.chart.error("Data response: Multiple nodes with same id: " + u), o[u] = !0
                            } else this.chart.error("Data response: Node without ID"), i = !1
                        }
                        for (var c = {}, p = 0; p < e.links.length; p++) {
                            var f = e.links[p];
                            f.hasOwnProperty("id") ? c.hasOwnProperty(f.id) && this.chart.error("Data response: Multiple links with the same ID: " + f.id) : f.id = d.Helpers.SeparatorChar + (this.nextId++).toString(10), o[f.from] || o[f.to] || this.chart.error("Data response: Returned link that does not match any node: " + f.id), c[f.id] = !0
                        }
                        return i
                    }, e.prototype.addVerifiedData = function (t, e) {
                        var i, n;
                        t ? (n = t.id, i = t.layerId) : (i = "", n = "");
                        var r, s, a = this.layers[i];
                        if (a || (a = this.getLayer(n)), e.clearCache) a.nodes = {}, a.links = {}, a.area = new d.AreaCollection, a.area.addRect(this.projectedBounds);
                        else if (e._bounds.x0 !== 1 / 0) {
                            var o = this.projectRect(e._bounds);
                            for (var l in a.nodes) r = a.nodes[l], o.overlaps(r._bounds) && delete a.nodes[l];
                            for (var l in a.links) s = a.links[l], a.nodes[s.from] && a.nodes[s.to] || delete a.links[l];
                            a.area.addRect(o)
                        } else a.area.addRect(this.projectedBounds);
                        for (var h = {}, u = 0; u < e.nodes.length; u++) r = e.nodes[u], r.loaded = !0, r.aggregate ? (r.id = d.Helpers.SeparatorChar + this.nextId, this.nextId++, a.nodes[r.id] = r) : (h[r.id] = !0, a.nodes.hasOwnProperty(r.id) ? d.Helpers.extendDeep(a.nodes[r.id], r) : a.nodes[r.id] = r), r.coordinates && (Array.isArray(r.coordinates[0]) ? this.prepareShape(r) : this.preparePoint(r));
                        for (var c = {}, p = 0; p < e.links.length; p++) s = e.links[p], c[s.id] = !0, a.links[s.id] = s;
                        var f = {};
                        f[n || ""] = {
                            nodes: h,
                            links: c
                        };
                        var g = {};
                        return g[this.dataSettings.id] = f, {
                            geoChartDataNodesIds: g
                        }
                    }, e.prototype.prepareShape = function (t) {
                        for (var e = [], i = d.Rect.createEmpty(), n = 0; n < t.coordinates.length; n++) {
                            var r = t.coordinates[n],
                                s = this.projectLineString(r, i);
                            e.push(s)
                        }
                        t._bounds = i, t._coordinates = e
                    }, e.prototype.preparePoint = function (t) {
                        if (2 !== t.coordinates.length) return void this.chart.error("Point coordinates must be an array of two numbers.");
                        var e = t.coordinates,
                            i = e[0],
                            n = e[1],
                            r = this.projectFun(i, n);
                        t._x = r.x, t._y = r.y, t._bounds = new d.Rect(r.x, r.y, r.x, r.y)
                    }, e.prototype.projectLineString = function (t, e) {
                        for (var i = [], n = 0; n < t.length - 1; n += 2) {
                            var r = this.projectFun(t[n], t[n + 1]);
                            i.push(r.x), i.push(r.y), e.addPoint(r.x, r.y)
                        }
                        return i
                    }, e.prototype.exportAreas = function () {
                        var t = this.lastLayer.area.toRects(),
                            e = this.lastLayer.requestedArea.toRects(),
                            i = this.lastLayer.pendingArea.toRects();
                        return this.projectRects(t), this.projectRects(e), this.projectRects(i), {
                            areasRects: t,
                            reqAreasRects: e,
                            pendingAreasRects: i
                        }
                    }, e.prototype.projectRects = function (t) {
                        for (var e = 0; e < t.length; e++) {
                            var i = t[e],
                                n = this.projectFun(i.x0, i.y0);
                            if (i.x0 = n.x, i.y0 = n.y, n = this.projectFun(i.x1, i.y1), i.x1 = n.x, i.y1 = n.y, i.y1 < i.y0) {
                                var r = i.y0;
                                i.y0 = i.y1, i.y1 = r
                            }
                        }
                    }, e
                }(d.Data);
                e.Data = x, e.Leaflet = null, "undefined" != typeof L && (e.Leaflet = L);
                var w = function () {
                        function t(t, e, i) {
                            var n = this;
                            this.layers = i, this.chartContainer = e, this.chart = t, this.wasDragged = null, this.wasZoomed = !1, this.translate = null, this.updatePosDelegate = function () {
                                return n.updatePos()
                            }, this.onZoomDelegate = function (t) {
                                return n.onZoom(t)
                            }, this.viewResetDelegate = function () {
                                return n.viewReset()
                            }, this.userActionEndDelegate = function () {
                                return n.userActionEnd()
                            }, this.userActionStartDelegate = function () {
                                return n.userActionStart()
                            }
                        }
                        return t.prototype.extendLayer = function (t) {
                            var e = this,
                                i = t.onAdd,
                                n = t.onRemove;
                            t.onAdd = function (n) {
                                return e.onAdd(n), i ? i.call(t, n) : t
                            }, t.onRemove = function (i) {
                                return e.onRemove(i), n ? n.call(t, i) : t
                            }
                        }, t.prototype.onAdd = function (t) {
                            return this.map = t, t.getPanes().overlayPane.appendChild(this.chartContainer), t.on("move", this.updatePosDelegate, this), t.on("zoomanim", this.onZoomDelegate, this), t.on("viewreset", this.viewResetDelegate, this), t.on("moveend", this.userActionEndDelegate, this), t.on("movestart", this.userActionStartDelegate, this), this.updatePos(), this
                        }, t.prototype.onRemove = function (t) {
                            return t.getPanes().overlayPane.removeChild(this.chartContainer), t.off("move", this.updatePosDelegate, this), t.off("zoomanim", this.onZoomDelegate, this), t.off("viewreset", this.viewResetDelegate, this), t.off("moveend", this.userActionEndDelegate, this), t.off("movestart", this.userActionStartDelegate, this), this
                        }, t.prototype.userActionStart = function () {
                            this.wasDragged = !0
                        }, t.prototype.userActionEnd = function () {
                            var t;
                            t = this.wasDragged === !0 ? "user" : null === this.wasDragged ? "init" : "api", this.chart.notifyChartUpdate(t), this.wasDragged = !1
                        }, t.prototype.viewReset = function () {
                            this.updatePos(), this.userActionEnd()
                        }, t.prototype.setTranslate = function () {
                            null !== this.translate && (this.chartContainer.style[e.Leaflet.DomUtil.TRANSFORM] = this.translate, this.chartContainer.style[e.Leaflet.DomUtil.TRANSFORM + "Origin"] = "50% 50%", this.translate = null)
                        }, t.prototype.getTranslateString = function (t) {
                            var e = L.Browser.webkit3d,
                                i = "translate" + (e ? "3d" : "") + "(",
                                n = (e ? ",0" : "") + ")";
                            return i + t.x + "px," + t.y + "px" + n
                        }, t.prototype.updatePos = function () {
                            if (this.map) {
                                var t = this.map.options.crs,
                                    i = this.chart.scene;
                                this.offset = this.map.containerPointToLayerPoint(e.Leaflet.point(0, 0)), this.chartContainer.setAttribute("class", " "), this.translate = this.getTranslateString(this.offset);
                                var n = this.map.getPixelBounds(),
                                    r = t.transformation.untransform(n.min, t.scale(this.map.getZoom()));
                                r = t.transformation.transform(r, t.scale(0));
                                var s = t.transformation.untransform(n.max, t.scale(this.map.getZoom()));
                                s = t.transformation.transform(s, t.scale(0));
                                var a = this.map.getZoom();
                                a !== i.zoomLevel && (i.zoom = Math.pow(2, a), i.zoomLevel = a, this.wasZoomed = !0), i.centerX = (s.x + r.x) / 2, i.centerY = (s.y + r.y) / 2, this.chart.events && !this.layers.resizing && (this.wasZoomed ? (this.chart.events.notifySceneChanges({
                                    zoom: !0,
                                    position: !0
                                }), this.wasZoomed = !1) : this.chart.events.notifySceneChanges({
                                    position: !0
                                }))
                            }
                        }, t.prototype.onZoom = function (t) {
                            var i = this.map.getZoomScale(t.zoom),
                                n = this.map.latLngToLayerPoint(t.center).subtract(this.map.containerPointToLayerPoint(this.map.getSize().divideBy(2))),
                                r = n.multiplyBy(-i).add(this.map.containerPointToLayerPoint(e.Leaflet.point(0, 0)));
                            this.chartContainer.setAttribute("class", " leaflet-zoom-animated"), this.translate = this.getTranslateString(r) + " scale(" + i + ") ", this.setTranslate(), this.wasZoomed = !0
                        }, t
                    }(),
                    T = function () {
                        function t() {
                            this.enabled = !0, this.type = "tile", this.url = "https://cartodb-basemaps-{s}.global.ssl.fastly.net/light_all/{z}/{x}/{y}.png", this.params = {
                                subdomains: "abcd",
                                attribution: '&copy; <a target="_blank" href="https://www.openstreetmap.org/copyright">OpenStreetMap</a>, &copy; <a href="https://cartodb.com/attributions" target="_blank">CartoDB</a>'
                            }
                        }
                        return t
                    }();
                e.SettingsBackground = T;
                var k = function (t) {
                    function i(e) {
                        var i = t.call(this, e) || this;
                        return i.animationOrder = 100, i.resizing = !1, i._focusHandler = function () {
                            return i.containerOnFocusChange()
                        }, i
                    }
                    return n(i, t), i.prototype.createDom = function (n) {
                        var r = this;
                        t.prototype.createDom.call(this, n), this.leafletContainer = d.Helpers.createDom("div", "DVSL-leaflet", null, null), this.container.insertBefore(this.leafletContainer, this.canvas), this.container.removeChild(this.canvas), this.container.removeChild(this.outerBorder), this.container.removeChild(this.interactionContainer), this.interactionContainer.appendChild(this.canvas), this.canvas.style.position = "static", this.outerBorder = null, this.menuContainer.className = "DVSL-menu-container", this.itemLayer = new w(this.chart, this.interactionContainer, this), i.setContainerStyle(this.leafletContainer), this.chart.scene.project = function (t, e) {
                            return r.projectFunc(t, e)
                        }, this.chart.scene.unproject = function (t, e) {
                            return r.unprojectFunc(t, e)
                        }, null != e.Leaflet ? this.createMap() : this.chart.assetsLoader.ensureAssetsList(["./src/dist/assets/js/leaflet.js"], function (t) {
                        // }, null != e.Leaflet ? this.createMap() : this.chart.assetsLoader.ensureAssetsList(["assets://leaflet.js"], function (t) {
                            return r.leafletLoaded(t)
                        }), d.Helpers.listen(this.interactionContainer, "focus", this._focusHandler), d.Helpers.listen(this.interactionContainer, "blur", this._focusHandler), d.Helpers.listen(this.leafletContainer, "focus", this._focusHandler), d.Helpers.listen(this.leafletContainer, "blur", this._focusHandler)
                    }, i.prototype.containerOnFocusChange = function () {
                        if (this.map) {
                            var t = d.Helpers.isParentOf(this.container, document.activeElement),
                                e = this.map.scrollWheelZoom;
                            t || !this.chart.settings.advanced.pointer.mouseWheelRequiresFocus ? e.enable() : e.disable()
                        }
                    }, i.prototype.leafletLoaded = function (t) {
                        if (!this.removed) {
                            if ("undefined" == typeof L) throw new Error("`leaflet.js` was loaded but the global variable `L` was not found. Please make sure that `L.noConflict()` is not called.");
                            e.Leaflet = L, this.createMap(), t && this.chart.notifyChartUpdate("api")
                        }
                    }, i.prototype.ensureMap = function () {
                        if (!this.map) throw new Error("This method is only available after leaflet.js has been loaded.")
                    }, i.prototype.createMap = function () {
                        var t = this.chart.settings.navigation,
                            i = {
                                maxZoom: t.maxZoom,
                                minZoom: t.minZoom,
                                worldCopyJump: !1
                            };
                        this.map = e.Leaflet.map(this.leafletContainer, i), this.map.attributionControl.setPrefix("");
                        var n = t.maxBounds;
                        if (this.map.setMaxBounds(new e.Leaflet.LatLngBounds(new e.Leaflet.LatLng(n.south, n.west), new e.Leaflet.LatLng(n.north, n.east))), this.createMapBackground(), L.Layer) {
                            var r = new L.Layer;
                            this.itemLayer.extendLayer(r), this.map.addLayer(r)
                        } else this.map.addLayer(this.itemLayer);
                        this.crs = this.map.options.crs, this.containerOnFocusChange(), this.chart.domLayerCreated()
                    }, i.prototype.createMapBackground = function () {
                        var t = this.map,
                            i = this.tileLayer;
                        i && (t.removeLayer(i), i = null);
                        var n = this.scene.settings.background;
                        n.enabled && ("tile" === n.type ? (i = e.Leaflet.tileLayer(n.url, n.params), t.addLayer(i)) : "wms" === n.type && (i = e.Leaflet.tileLayer.wms(n.url, n.params), t.addLayer(i))), this.tileLayer = i
                    }, i.prototype.onSceneChange = function (t) {
                        this.itemLayer.setTranslate()
                    }, i.prototype.remove = function () {
                        this.removed = !0, d.Helpers.unlisten(this.interactionContainer, "focus", this._focusHandler), d.Helpers.unlisten(this.interactionContainer, "blur", this._focusHandler), d.Helpers.unlisten(this.leafletContainer, "focus", this._focusHandler), d.Helpers.unlisten(this.leafletContainer, "blur", this._focusHandler), this.map && this.map.remove(), this.map = null
                    }, i.prototype.updateSettings = function (i) {
                        if (t.prototype.updateSettings.call(this, i), !this.removed && this.leafletContainer && (this.map && i.background && this.createMapBackground(), i.navigation && ((i.navigation.minZoom || i.navigation.maxZoom) && d.Helpers.warn("Changing of navigation.minZoom or navigation.maxZoom with updateSettings() is not yet supported."), this.map && i.navigation.maxBounds))) {
                            var n = i.navigation.maxBounds;
                            this.map.setMaxBounds(new e.Leaflet.LatLngBounds(new e.Leaflet.LatLng(n.south, n.west), new e.Leaflet.LatLng(n.north, n.east)))
                        }
                    }, i.prototype.projectFunc = function (t, i) {
                        return this.ensureMap(), this.crs.latLngToPoint(new e.Leaflet.LatLng(i, t), 0)
                    }, i.prototype.unprojectFunc = function (t, i) {
                        return this.ensureMap(), this.crs.pointToLatLng(new e.Leaflet.Point(t, i), 0)
                    }, i.prototype.doAnimations = function (e) {
                        if (t.prototype.doAnimations.call(this, e), e.changes.bounds) {
                            var i = this.scene;
                            i.x0 = i.chartLeft, i.y0 = i.chartTop, i.width = i.chartWidth, i.height = i.chartHeight, i.leftMargin = 0, i.rightMargin = 0, i.topMargin = 0, i.bottomMargin = 0, this.map && (this.resizing = !0, this.map.invalidateSize(null), this.resizing = !1), this.interactionContainer.style.width = i.chartWidth + "px", this.interactionContainer.style.height = i.chartHeight + "px"
                        }
                    }, i
                }(d.DomLayer);
                e.DomLayer = k;
                var A = function () {
                    function t() {
                        this.enabled = !1, this.distance = 60, this.maxZoom = 18, this.weightFunction = null, this.ignoreZeroWeight = !1
                    }
                    return t
                }();
                e.SettingsAggregation = A;
                var M = function () {
                    function t(t, e, i) {
                        this.zoom = e.zoom, this.scene = e, this.settings = t, this.chart = i
                    }
                    return t.orientation = function (t, e, i) {
                        var n = (e.x - t.x) * (i.y - t.y) - (e.y - t.y) * (i.x - t.x);
                        return 0 === n ? 0 : n > 0 ? 1 : -1
                    }, t.distanceLineToPoint = function (t, e, i) {
                        var n = Math.sqrt((e.x - t.x) * (e.x - t.x) + (e.y - t.y) * (e.y - t.y));
                        return Math.abs((i.x - t.x) * (e.y - t.y) - (i.y - t.y) * (e.x - t.x)) / n
                    }, t.prototype.findMainNodes = function (t, e) {
                        var i = this.settings;
                        i.ignoreZeroWeight && (t = t.slice());
                        var n = {},
                            r = {},
                            s = {},
                            a = d.Helpers.isFunction(i.weightFunction);
                        if (a) {
                            for (var o = t.length - 1; o >= 0; o--) {
                                var l = t[o],
                                    h = i.weightFunction(l);
                                if (i.ignoreZeroWeight && 0 === h) {
                                    var u = t.pop();
                                    o < t.length && (t[o] = u)
                                } else s[l.id] = h
                            }
                            t.sort(function (t, e) {
                                return s[e.id] - s[t.id]
                            })
                        }
                        for (var c, p, f, g = this.zoom / (i.distance / 2), m = [], v = {}, o = 0; o < t.length; o++) {
                            var l = t[o],
                                y = Math.floor(l._x * g),
                                S = Math.floor(l._y * g);
                            if (c = r[y] || (r[y] = {}), void 0 === c[S] && void 0 === c[S - 1] && void 0 === c[S + 1] && (p = r[y - 1] || (r[y - 1] = {}), void 0 === p[S] && void 0 === p[S - 1] && void 0 === p[S + 1] && (f = r[y + 1] || (r[y + 1] = {}), void 0 === f[S] && void 0 === f[S - 1] && void 0 === f[S + 1]))) {
                                c[S] = m.length, c[S + 1] = m.length, c[S - 1] = m.length, p[S] = m.length, p[S + 1] = m.length, p[S - 1] = m.length, f[S] = m.length, f[S + 1] = m.length, f[S - 1] = m.length;
                                var b = a ? s[l.id] || 0 : 1,
                                    C = {
                                        id: "__aggr_" + l.id,
                                        aggregatedWeight: b,
                                        _originalWeight: b,
                                        _x: l._x,
                                        _y: l._y,
                                        _bounds: l._bounds,
                                        aggregatedNodes: [l],
                                        loaded: !0
                                    };
                                m.push(C), n[l.id] = C, v[o] = !0
                            }
                        }
                        for (var x = [], o = 0; o < t.length; o++)
                            if (!v[o]) {
                                var l = t[o],
                                    y = Math.floor(l._x * g),
                                    S = Math.floor(l._y * g),
                                    w = m[r[y][S]];
                                if (!w) {
                                    c = r[y] || (r[y] = {}), p = r[y - 1] || (r[y - 1] = {}), f = r[y + 1] || (r[y + 1] = {}), x.push(c[S]), x.push(c[S - 1]), x.push(c[S + 1]), x.push(p[S]), x.push(p[S - 1]), x.push(p[S + 1]), x.push(f[S]), x.push(f[S - 1]), x.push(f[S + 1]);
                                    for (var L = 1 / 0; x.length > 0;) {
                                        var T = x.pop();
                                        if (void 0 !== T) {
                                            var k = m[T],
                                                A = (k._x - l._x) * (k._x - l._x) + (k._y - l._y) * (k._y - l._y);
                                            A < L && (L = A, w = k)
                                        }
                                    }
                                }
                                var h = a ? s[l.id] || 0 : 1;
                                (w.aggregatedWeight > 0 || h > 0) && (w._x = (w._x * w.aggregatedWeight + l._x * h) / (w.aggregatedWeight + h), w._y = (w._y * w.aggregatedWeight + l._y * h) / (w.aggregatedWeight + h)), w._originalWeight < h && (w._originalWeight = h, w.id = "__aggr_" + l.id), n[l.id] = w, w.aggregatedNodes.push(l), w.aggregatedWeight += h
                            }
                        for (var o = 0; o < m.length; o++) {
                            var l = m[o],
                                M = this.scene.unproject(l._x, l._y);
                            l.coordinates = [M.lng, M.lat]
                        }
                        if (i.postProcessAggregatedNodes) {
                            var I = [];
                            i.postProcessAggregatedNodes(m, n, I);
                            for (var o = 0; o < I.length; o++) {
                                var l = I[o],
                                    P = this.scene.project(l.coordinates[0], l.coordinates[1]);
                                l._x = P.x, l._y = P.y
                            }
                        }
                        var D = this.aggregateLinks(e, n);
                        return this.findConvexShapes(m), {
                            nodes: m,
                            links: D
                        }
                    }, t.prototype.aggregateLinks = function (t, e) {
                        for (var i = [], n = {}, r = 0; r < t.length; r++) {
                            var s = t[r],
                                a = e[s.from],
                                o = e[s.to];
                            if (a && o) {
                                var l = void 0,
                                    h = a.id + "-" + o.id;
                                d.Helpers.hasProperty(n, h) ? n[h].aggregatedLinks.push(s) : (l = {
                                    id: h,
                                    from: a.id,
                                    to: o.id,
                                    aggregatedLinks: [s]
                                }, i.push(l), n[h] = l)
                            }
                        }
                        return i
                    }, t.prototype.findConvexShapes = function (e) {
                        for (var i = 0; i < e.length; i++) {
                            for (var n = [], r = e[i].aggregatedNodes, s = r[0], a = r[0], o = 1; o < r.length; o++) {
                                var l = r[o];
                                l._x <= s._x && (s = r[o]), l._x >= a._x && (a = r[o])
                            }
                            for (var h = [], u = [], o = 0; o < r.length; o++) {
                                var l = r[o];
                                if (null != l) {
                                    var c = t.orientation({
                                        x: s._x,
                                        y: s._y
                                    }, {
                                        x: a._x,
                                        y: a._y
                                    }, {
                                        x: l._x,
                                        y: l._y
                                    });
                                    c > 0 ? h.push(l) : c < 0 && u.push(l)
                                }
                            }
                            var d = [s],
                                p = {};
                            n = [], this.separateOuterPoints(s, a, u, n, p), d = d.concat(n.sort(function (t, e) {
                                return t._x - e._x
                            })), d.push(a), n = [], this.separateOuterPoints(a, s, h, n, p), d = d.concat(n.sort(function (t, e) {
                                return e._x - t._x
                            })), e[i].convexShape = d
                        }
                    }, t.prototype.separateOuterPoints = function (e, i, n, r, s) {
                        if (0 !== n.length) {
                            if (1 === n.length) return s[n[0].id] = 1, void r.push(n[0]);
                            for (var a = 0, o = null, l = 0; l < n.length; l++) {
                                var h = n[l],
                                    u = t.distanceLineToPoint({
                                        x: e._x,
                                        y: e._y
                                    }, {
                                        x: i._x,
                                        y: i._y
                                    }, {
                                        x: h._x,
                                        y: h._y
                                    });
                                u > a && (a = u, o = h)
                            }
                            s[o.id] || (r.push(o), s[o.id] = 1);
                            for (var c = [], d = [], l = 0; l < n.length; l++) {
                                var h = n[l];
                                if (!s[h.id]) {
                                    var p = t.orientation({
                                        x: e._x,
                                        y: e._y
                                    }, {
                                        x: o._x,
                                        y: o._y
                                    }, {
                                        x: h._x,
                                        y: h._y
                                    });
                                    0 !== p && p < 0 && d.push(h);
                                    var f = t.orientation({
                                        x: o._x,
                                        y: o._y
                                    }, {
                                        x: i._x,
                                        y: i._y
                                    }, {
                                        x: h._x,
                                        y: h._y
                                    });
                                    0 !== f && f < 0 && c.push(h)
                                }
                            }
                            this.separateOuterPoints(e, o, d, r, s), this.separateOuterPoints(o, i, c, r, s)
                        }
                    }, t.prototype.aggregate = function (t, e) {
                        if (this.zoom > Math.pow(2, this.settings.maxZoom)) {
                            var i = [],
                                n = [],
                                r = this.settings.weightFunction,
                                s = this.settings.ignoreZeroWeight,
                                a = d.Helpers.isFunction(r),
                                o = void 0,
                                l = Object.create(null);
                            for (o = 0; o < t.length; o++) {
                                var h = t[o],
                                    u = a ? r(h) : 1;
                                0 === u && s ? l[h.id] = !0 : i.push({
                                    id: "__aggr_" + h.id,
                                    aggregatedWeight: u,
                                    _x: h._x,
                                    _y: h._y,
                                    _bounds: h._bounds,
                                    coordinates: h.coordinates,
                                    aggregatedNodes: [h],
                                    loaded: !0
                                })
                            }
                            for (o = 0; o < e.length; o++) {
                                var c = e[o];
                                s && l[c.from] || l[c.to] || n.push({
                                    from: "__aggr_" + c.from,
                                    to: "__aggr_" + c.to,
                                    id: "__aggr_" + c.from + "-__aggr_" + c.to,
                                    aggregatedLinks: [c]
                                })
                            }
                            return {
                                nodes: i,
                                links: n
                            }
                        }
                        return this.findMainNodes(t, e)
                    }, t
                }();
                e.Aggregation = M;
                var I = function (t) {
                    function e(i) {
                        var n = t.call(this, d.SettingsMapping.GeoChartSettings) || this;
                        return n._computedLayers = [], n.theme = e.FlatTheme, n.area = new P, n.background = new T, n.data = [], n.style = {
                            fadeTime: 200,
                            selection: {
                                fillColor: "rgba(200, 200, 255 ,0.7)",
                                sizeConstant: 5,
                                sizeProportional: .2
                            }
                        }, n.layerTypes = {
                            shapes: {
                                type: "shapes"
                            },
                            items: {
                                type: "items",
                                style: {
                                    item: {
                                        hoverEffect: !1,
                                        zIndex: 0
                                    }
                                }
                            },
                            aggregateOnShapes: {
                                type: "aggregateOnShapes"
                            },
                            charts: {
                                type: "charts"
                            }
                        }, n.layersDefault = null, n.layers = [], n.navigation = {
                            initialLat: 40,
                            initialLng: 25,
                            initialZoom: 3,
                            minZoom: 0,
                            maxZoom: 18,
                            maxBounds: {
                                west: -200,
                                north: -85,
                                east: 200,
                                south: 85
                            },
                            initialDrilldown: [""],
                            drilldownLayer: "default"
                        }, n.filters = {
                            nodeFilter: null
                        }, n.interaction = new z, n.toolbar = new d.SettingsToolbar(!1, [new d.SettingsToolbarItem("fullscreen")], "bottom", "left"), n.advanced.assets.push({
                            // url: "assets://leaflet.css",
                            url: "./src/dist/assets/styles/leaflet.css",
                            
                            required: function () {
                                return !d.Helpers.isStyleSheetDefined("leaflet-tile", "visibility")
                            }
                        }), n.area.defaultHeight = 500, n.advanced.style.loadingArcStyle.r = 15, n.advanced.style.loadingArcStyle.lineColor = "red", n.advanced.style.loadingArcStyle.lineWidth = 7, n.apply(i), n._initializing = !1, n
                    }
                    return n(e, t), e.prototype.apply = function (e) {
                        this.applyCompatibility(e, [{
                            from: "layersDefault",
                            alternative: "layerTypes"
                        }]), e.toolbar && d.Helpers.error("`toolbar` is not supported on GeoChart");
                        var i = t.prototype.apply.call(this, e);
                        return (this._initializing || i.layers || i.layerTypes) && (this._computedLayers = d.SettingsHelper.mergeDefaultValues(this.layers, this.layersDefault, this.layerTypes, F.createInstance, F.getMapping, "layers")), i
                    }, e
                }(u.Settings);
                I.FlatTheme = {
                    advanced: {
                        themeCSSClass: "DVSL-flat"
                    }
                }, e.Settings = I;
                var P = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.style = new D, e
                    }
                    return n(e, t), e
                }(d.SettingsArea);
                e.SettingsArea = P;
                var D = function (t) {
                    function e() {
                        return t.apply(this, arguments) || this
                    }
                    return n(e, t), e
                }(d.SettingsAreaStyle);
                e.SettingsAreaStyle = D;
                var N = function (t) {
                    function e() {
                        var e = t.call(this) || this;
                        return e.aggregatedShape = {
                            mode: 1,
                            lineColor: "rgba(0,0,128,0.5)",
                            lineWidth: 1,
                            fillColor: "rgba(0,0,128,0.3)"
                        }, e.scaleObjectsWithZoom = !1, e.node.radius = 10, e.node.fillColor = "orange", e.node.lineColor = "red", e.linkLabel.scaleWithSize = !1, e.linkLabel.scaleWithZoom = !1, e.linkLabel.backgroundStyle.fillColor = "white", e.linkLabel.backgroundStyle.lineColor = "black", e.nodeLabel.scaleWithSize = !1, e.nodeLabel.scaleWithZoom = !1, e.nodeLabel.backgroundStyle.fillColor = "white", e.nodeLabel.backgroundStyle.lineColor = "black", e
                    }
                    return n(e, t), e
                }(u.SettingsNodesLayerStyle);
                e.SettingsNodesLayerStyle = N;
                var F = function () {
                    function t() {
                        this.enabled = !0, this.id = "default", this.name = "", this.type = "shapes", this.minZoom = 0, this.maxZoom = 20, this.perZoomStyle = !1, this.data = {
                            id: "default"
                        }
                    }
                    return t.getMapping = function (t, e) {
                        if (t && e.type && t.type !== e.type) throw new Error("It is not possible to change the value of `type` property for an existing layer.");
                        switch (t ? t.type : e.type) {
                            case "shapes":
                                return d.SettingsMapping.GeoChartSettingsLayerShapes;
                            case "items":
                                return d.SettingsMapping.GeoChartSettingsLayerItems;
                            case "charts":
                                return d.SettingsMapping.GeoChartSettingsLayerCharts;
                            case "aggregateOnShapes":
                                return d.SettingsMapping.GeoChartSettingsLayerAggregated;
                            default:
                                throw new Error("The value '" + e.type + "' is not valid for the `type` property of a layer. Valid values are: shapes, items, charts, aggregateOnShapes.")
                        }
                    }, t.createInstance = function (t, e) {
                        switch (e || t.type) {
                            case "shapes":
                                return new O;
                            case "items":
                                return new E;
                            case "charts":
                                return new B;
                            case "aggregateOnShapes":
                                return new H;
                            default:
                                throw new Error("The value '" + (e || t.type) + "' is not valid for the `type` property of a layer. Valid values are: shapes, items, charts, aggregateOnShapes.")
                        }
                    }, t
                }();
                e.SettingsLayerBase = F;
                var O = function (t) {
                    function i() {
                        var i = t.call(this) || this;
                        return i.style = new e.SettingsShapesLayerStyle, i.type = "shapes", i
                    }
                    return n(i, t), i
                }(F);
                e.SettingsLayerShapes = O;
                var E = function (t) {
                    function e() {
                        var e = t.call(this) || this;
                        return e.style = new N, e.aggregation = new A, e.layout = new j, e.auras = new u.SettingsNodesLayerAuras, e.type = "items", e
                    }
                    return n(e, t), e
                }(F);
                e.SettingsLayerItems = E;
                var R = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.shapesLayer = null, e
                    }
                    return n(e, t), e
                }(F);
                e.SettingsLayerOverlay = R;
                var H = function (t) {
                    function e() {
                        var e = t.call(this) || this;
                        return e.aggregationField = null, e.aggregation = "count", e.aggregationFunction = null, e.styleFunction = null, e.type = "aggregateOnShapes", e
                    }
                    return n(e, t), e
                }(R);
                e.SettingsLayerAggregated = H;
                var B = function (t) {
                    function e() {
                        var e = t.call(this) || this;
                        return e.chartType = "piechart", e.settings = null, e.settingsFunction = null, e.autoSize = !1, e.data = {
                            id: null
                        }, e.type = "charts", e
                    }
                    return n(e, t), e
                }(R);
                e.SettingsLayerCharts = B;
                var z = function (t) {
                    function e() {
                        var e = t.call(this) || this;
                        return e.mode = "drilldown", e.zooming = new U, e.nodesMovable = !1, e.selection.enabled = !1, e
                    }
                    return n(e, t), e
                }(u.SettingsInteraction);
                e.SettingsInteraction = z;
                var U = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.zoomInOnDoubleClick = !0, e
                    }
                    return n(e, t), e
                }(u.SettingsInteractionZooming);
                e.SettingsInteractionZooming = U;
                var G = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.animationOrder = 2e3, i.updateOrder = 1100, i.scene = null, i.events = null, i.currentObject = null, i.chart = e, i.scene = e.scene, i.events = e.events, i.dragPointers = {}, i
                    }
                    return n(e, t), e.prototype.onPointerMove = function (t) {
                        this.updateCurrentObject(t), this.currentObject && (this.updateCursor(t), t.hovered = !0)
                    }, e.prototype.onPointerOut = function (t) {
                        this.switchCurrentObject(null, null, t)
                    }, e.prototype.onPointerDown = function (t) {
                        this.updateCurrentObject(t);
                        var e = this.currentObject;
                        e instanceof u.Node && (this.updateSelection(t, e, !0), this.updateCursor(t), this.scene.settings.interaction.nodesMovable && (this.setPointerNode(t, e), t.consumed = !0))
                    }, e.prototype.onPointerUp = function (t) {
                        this.dragPointers[t.identifier] && (this.dragPointers[t.identifier].dragging && (t.consumed = !0, this.updateLastNode(t, this.dragPointers[t.identifier].node)), this.updateCursor(t), this.setPointerNode(t, null))
                    }, e.prototype.onPointerCancel = function (t) {
                        this.onPointerUp(t)
                    }, e.prototype.onPointerDrag = function (t) {
                        var e = this.dragPointers[t.identifier];
                        if (e) {
                            var i = this.scene.fromDisplay(t.x, t.y),
                                n = i.x,
                                r = i.y;
                            e.mouseX = t.x, e.mouseY = t.y, e.dragging = !0, this.dragNodes(e, n, r, this.scene.settings.interaction.selection.lockNodesOnMove), this.updateCursor(t), t.consumed = !0
                        }
                    }, e.prototype.onClick = function (t) {
                        this.scene.xyInChart(t.x, t.y) && ((!this.currentObject || !this.scene.settings.interaction.selection.nodesSelectable && this.currentObject.isNode || !this.scene.settings.interaction.selection.linksSelectable && this.currentObject.isLink) && this.updateSelection(t, null, !1), this.chart.notifyClick(t, this.buildEventArgs(t)), t.defaultPrevented && (t.consumed = !0))
                    }, e.prototype.onRightClick = function (t) {
                        if (this.scene.xyInChart(t.x, t.y)) {
                            var e = this.buildEventArgs(t);
                            this.updateSelection(t, this.currentObject, !1), this.chart.notifyRightClick(t, e), t.defaultPrevented && (t.consumed = !0)
                        }
                    }, e.prototype.onDoubleClick = function (t) {
                        this.scene.xyInChart(t.x, t.y) && (this.chart.notifyDoubleClick(t, this.buildEventArgs(t)), t.defaultPrevented && (t.consumed = !0))
                    }, e.prototype.onTripleClick = function (t) {
                        this.scene.xyInChart(t.x, t.y) && (this.chart.notifyTripleClick(t, this.buildEventArgs(t)), t.defaultPrevented && (t.consumed = !0))
                    }, e.prototype.doAnimations = function (t) {
                        for (var e in this.dragPointers) {
                            var i = this.dragPointers[e],
                                n = this.scene.fromDisplay(i.mouseX, i.mouseY),
                                r = n.x,
                                s = n.y;
                            this.dragNodes(i, r, s, !1), t.changes.coordinates = !0
                        }
                    }, e.prototype.updateSelection = function (t, e, i) {
                        this.scene.settings.interaction.selection.enabled && (t.shiftKey || t.ctrlKey || !(!e || !this.scene.settings.interaction.selection.nodesSelectable && e.isNode || !this.scene.settings.interaction.selection.linksSelectable && e.isLink) ? e && t.ctrlKey ? (e.selected ? this.scene.removeFromSelection(e) : this.scene.addToSelection(e), this.notifySelectionChanged("user")) : e && t.shiftKey || i && e.selected ? this.scene.addToSelection(e) && this.notifySelectionChanged("user") : e && this.setSelection([e], "user") : this.setSelection([], "user"))
                    }, e.prototype.dragNodes = function (t, e, i, n) {
                        var r = e + t.x - t.node.x,
                            s = i + t.y - t.node.y;
                        if (0 !== r || 0 !== s) {
                            if (this.moveNode(t.node, r, s, n), t.extraNodes && t.extraNodes.length > 0)
                                for (var a = 0; a < t.extraNodes.length; a++) this.moveNode(t.extraNodes[a], r, s, n);
                            this.events.notifySceneChanges({
                                coordinates: !0
                            })
                        }
                    }, e.prototype.moveNode = function (t, e, i, n) {
                        if (t.x += e, t.y += i, n && (t.userLock = !0), !this.scene.settings.interaction.selection.allowMoveNodesOffscreen) {
                            var r = this.scene.getVisibleBounds(),
                                s = 1.2 * t.renderHwidth / this.scene.zoom,
                                a = 1.2 * t.renderHheight / this.scene.zoom;
                            t.x = Math.min(Math.max(t.x, r.x0 + s), r.x1 - s), t.y = Math.min(Math.max(t.y, r.y0 + a), r.y1 - a)
                        }
                    }, e.prototype.setPointerNode = function (t, e) {
                        var i = t.identifier,
                            n = this.dragPointers[i];
                        if (n) {
                            if (n.node.locks--, n.extraNodes && n.extraNodes.length > 0)
                                for (var r = 0; r < n.extraNodes.length; r++) n.extraNodes[r].locks--;
                            delete this.dragPointers[i]
                        }
                        if (e) {
                            var s = this.scene.fromDisplay(t.x, t.y),
                                a = s.x,
                                o = s.y,
                                l = null;
                            if (!d.Helpers.hasProperties(this.dragPointers) && this.scene.selection.length > 0) {
                                l = [];
                                for (var r = 0; r < this.scene.selection.length; r++) {
                                    var h = this.scene.selection[r];
                                    h !== e && h instanceof u.Node && (h.locks++, l.push(h))
                                }
                            }
                            this.dragPointers[t.identifier] = {
                                x: e.x - a,
                                y: e.y - o,
                                node: e,
                                extraNodes: l,
                                mouseX: t.x,
                                mouseY: t.y,
                                dragging: !1
                            }, e.locks++
                        }
                    }, e.prototype.updateCurrentObject = function (t) {
                        if (this.chart.renderer && this.scene.xyInChart(t.x, t.y)) {
                            var e = this.chart.renderer.findObjectAt(t.x, t.y, this.scene.settings.interaction.selection.tolerance);
                            this.switchCurrentObject(e ? e.object : null, e ? e.details : null, t)
                        }
                    }, e.prototype.updateCursor = function (t) {
                        this.currentObject && this.currentObject.cursor ? t.cursor = this.currentObject.cursor : t.cursor = "move"
                    }, e.prototype.switchCurrentObject = function (t, e, i) {
                        t === this.currentObject && e === this.currentItem || (i.changes.current = !0, this.scene.setActiveObject(t, e), this.currentObject = t, this.currentItem = e, this.chart.notifyHoverChanged(i, this.chart.createEventArguments(null, "api")))
                    }, e.prototype.buildEventArgs = function (t) {
                        var e = this.chart.createEventArguments(t, "user");
                        e.clickItem = this.currentItem;
                        var i = this.currentObject;
                        return i instanceof u.Node ? (e.clickNode = i, this.updateLastNode(t, i)) : e.clickLink = i, e
                    }, e.prototype.updateLastNode = function (t, e) {
                        this.scene.lastClickedNode = e, this.scene.settings.interaction.zooming.autoZoomAfterClick && (this.scene.autoZoomMode = !0, t.changes.zoom = !0)
                    }, e.prototype.setSelection = function (t, e) {
                        var i = this.scene.setSelection(t);
                        i && this.notifySelectionChanged(e)
                    }, e.prototype.notifySelectionChanged = function (t) {
                        this.events.notifySceneChanges({
                            selection: !0
                        }), this.chart.notifySelectionChanged(this.chart.createEventArguments(null, t))
                    }, e
                }(d.ChartElement);
                e.Selection = G;
                var j = function () {
                    function t() {
                        this.mode = "static", this.nodeSpacing = 3, this.anchorStrength = 1
                    }
                    return t
                }();
                e.SettingsNodesLayout = j;
                var W = function () {
                        function t() {}
                        return t
                    }(),
                    V = function () {
                        function t(t, e, i) {
                            this.initialLoad = !0, this.scene = t, this.settings = i, this.layer = e, this.random = new d.Random(1)
                        }
                        return t.isNodeLocked = function (t) {
                            return t.userLock || t.locks > 0 || t.anchorMode === u.NodeAnchorMode.Fixed
                        }, t.prototype.doAnimations = function (e, n) {
                            var r = this,
                                s = !1,
                                a = this.layer.hasTopologyChanges(),
                                o = "dynamic" === this.settings.mode;
                            if (o && "undefined" == typeof i.Chipmunk) {
                                if (t.cpRequestInitiated) return;
                                if (this.scene.assetsLoader.loadAssetsList([{
                                        url: "./src/dist/assets/js/cp.js",
                                        required: function () {
                                            return "undefined" == typeof i.Chipmunk
                                        }
                                    }], function () {
                                        r.layer.events.notifySceneChanges({
                                            requestPaint: !0
                                        })
                                    })) return void(t.cpRequestInitiated = !0)
                            }
                            for (var l = this.layer.nodes(), h = this.layer.getGeometry(), u = 0; u < l.length; u += 1) {
                                var c = l[u];
                                c.shape.adaptToViewport(h.txm, h.txa, h.tym, h.tya, h.zoom)
                            }
                            if (this.initialLoad && (a = !0, n = !0), a && (this.random = new d.Random(1), this.placeNewNodes(o), s = !0), o) {
                                this.placeModifiedNodes();
                                var p = this.updateLayout(e.dtime, a, n, e.changes.zoom);
                                p && (e.animating = !0, s = !0)
                            } else this.placeModifiedNodes(), this.computeNodeAnchorCoordinates();
                            s && (e.changes.position = !0), this.initialLoad = !1
                        }, t.prototype.computeNodeAnchorCoordinates = function () {
                            for (var t = this.layer.getNodesSceneZoom(), e = 0, i = this.layer.nodes(); e < i.length; e++) {
                                var n = i[e],
                                    r = n.shape.getAnchor();
                                n.x = n.anchorX - r.x * t, n.y = n.anchorY - r.y * t
                            }
                        }, t.prototype.placeNewNodes = function (t) {
                            for (var e = this.layer.getNodesSceneZoom(), i = 0, n = this.layer.nodes(); i < n.length; i++) {
                                var r = n[i],
                                    s = r.shape.getAnchor();
                                r.anchorX = r.data._x, r.anchorY = r.data._y, null !== r.x && null !== r.y || (r.x = r.anchorX - s.x * e, r.y = r.anchorY - s.y * e, t && (r.x += this.random.get() * e))
                            }
                        }, t.prototype.placeModifiedNodes = function () {
                            for (var t in this.layer.modifiedNodes) {
                                var e = this.layer.modifiedNodes[t];
                                e.anchorX = e.data._x, e.anchorY = e.data._y
                            }
                        }, t.prototype.removeNode = function (t) {
                            var e = this.idToState[t.id],
                                i = this.cpSpace;
                            i.removeShape(e.shape), e.locked || (i.removeBody(e.body), i.removeShape(e.anchorShape)), delete this.idToState[t.id]
                        }, t.prototype.addNode = function (t, e) {
                            var n = new W,
                                r = this.cpSpace,
                                s = this.layer.getNodesSceneZoom(),
                                a = t.shape.getAnchor();
                            if (n.locked = e, this.idToState[t.id] = n, !e) {
                                var o = r.addBody(new i.Chipmunk.Body(1, 1 / 0));
                                n.body = o, o.setPos(i.Chipmunk.v(t.x + a.x * s, t.y + a.y * s))
                            }
                            return n
                        }, t.prototype.updateLayout = function (e, n, r, s) {
                            this.cpSpace || (this.cpSpace = new i.Chipmunk.Space, this.cpSpace.sleepTimeThreshold = 1,
                                this.cpSpace.damping = .2, this.idToState = {}, n = !0);
                            var a = this.cpSpace,
                                o = this.idToState,
                                l = this.settings.nodeSpacing,
                                h = this.settings.anchorStrength,
                                u = this.layer.getNodesSceneZoom();
                            this.zoom = u, this.cpSpace.collisionSlop = 2 * u, this.cpSpace.idleSpeedThreshold = 5 * u;
                            var c = this.layer.nodes();
                            if (n) {
                                for (var p in this.layer.deletedNodes) this.removeNode(this.layer.deletedNodes[p]);
                                for (var p in this.layer.newNodes) {
                                    var f = this.layer.newNodes[p];
                                    this.addNode(f, t.isNodeLocked(f))
                                }
                            }
                            if (r || n)
                                for (var g = 0; g < c.length; g += 1) {
                                    var f = c[g],
                                        m = o[f.id],
                                        v = t.isNodeLocked(f),
                                        y = null;
                                    m && v === m.locked || (m && (m.body && (y = m.body.p), this.removeNode(f)), m = this.addNode(f, v));
                                    var S = (Math.max(f.bounds.w(), f.bounds.h()) + l) / 2 * u,
                                        b = f.shape.getAnchor(),
                                        C = f.anchorX,
                                        x = f.anchorY;
                                    if (s || m.prevAX !== C || m.prevAY !== x || m.prevR !== S) {
                                        if (m.locked) {
                                            var w = m.shape;
                                            w && a.removeShape(w), y || (y = i.Chipmunk.v(C - b.x * u, x - b.y * u)), y.x -= b.x * u, y.y -= b.y * u, w = a.addShape(new i.Chipmunk.CircleShape(a.staticBody, S, y)), m.p = y, w.setElasticity(0), w.setFriction(0), m.shape = w
                                        } else {
                                            if (m.prevR !== S) {
                                                var w = m.shape;
                                                w && a.removeShape(w), w = a.addShape(new i.Chipmunk.CircleShape(m.body, S, i.Chipmunk.v(-b.x * u, -b.y * u))), w.setElasticity(0), w.setFriction(0), m.shape = w
                                            }
                                            if (s || m.prevAX !== C || m.prevAY !== x) {
                                                var L = m.anchorShape;
                                                L && a.removeShape(L), L = a.addShape(new i.Chipmunk.CircleShape(a.staticBody, 2 * u, i.Chipmunk.v(C, x))), L.setElasticity(0), L.setFriction(0), m.anchorShape = L
                                            }
                                        }
                                        m.prevAX = C, m.prevAY = x, m.prevR = S
                                    }
                                }
                            for (var g = 0; g < c.length; g += 1) {
                                var f = c[g],
                                    m = o[f.id];
                                if (!m.locked) {
                                    var T = f.anchorX,
                                        k = f.anchorY,
                                        A = m.body.p.x,
                                        M = m.body.p.y,
                                        I = m.body,
                                        P = A - T,
                                        D = M - k,
                                        N = I.vx,
                                        F = I.vy;
                                    P += .5 * N, D += .5 * F;
                                    var O = -Math.abs(3 * P) * d.Helpers.sign(P),
                                        E = 0;
                                    E = D < 0 ? -2 * D : -5 * D, I.f = i.Chipmunk.v(O * h, E * h)
                                }
                            }
                            a.step(1 / 60);
                            for (var R = !0, g = 0; g < c.length; g += 1) {
                                var f = c[g],
                                    m = o[f.id],
                                    b = f.shape.getAnchor();
                                m.locked ? m.p ? (f.x = m.p.x, f.y = m.p.y) : (f.x = f.data._x - b.x * u, f.y = f.data._y - b.y * u) : (f.x = m.body.p.x - b.x * u, f.y = m.body.p.y - b.y * u, R = R && m.body.isSleeping())
                            }
                            return !R
                        }, t
                    }();
                V.cpRequestInitiated = !1, e.NodesLayout = V;
                var Z = function (t) {
                    function e(e, i, n) {
                        var r = t.call(this, e, i, n) || this;
                        return r.layout = null, r.hoveredNode = null, r.layout = new V(e.scene, r, i.layout), r
                    }
                    return n(e, t), e.prototype.postprocessStyle = function (e) {
                        t.prototype.postprocessStyle.call(this, e);
                        var i = e.changes.zoom || this.hasStyleChanges();
                        this.layout.doAnimations(e, i)
                    }, e.prototype.paintHoverShape = function (t) {
                        var e = this.style.aggregatedShape;
                        switch (e.mode) {
                            case 0:
                                break;
                            default:
                            case 1:
                                if (null === this.hoveredNode || !this.hoveredNode.hovered || this.hoveredNode.removed) {
                                    var i = this.modifiedNodes;
                                    this.hoveredNode = null;
                                    for (var n in i)
                                        if (i[n].hovered) {
                                            this.hoveredNode = i[n];
                                            break
                                        }
                                }
                                this.hoveredNode && this.paintConvex(this.hoveredNode, t, e);
                                break;
                            case 2:
                                for (var r = this.nodes(), s = 0; s < r.length; s++) {
                                    var a = r[s];
                                    a.removed || this.paintConvex(a, t, e)
                                }
                                break;
                            case 3:
                                for (var o = this.nodes(), s = 0; s < o.length; s++) {
                                    var a = o[s];
                                    !a.removed && a.selected && this.paintConvex(a, t, e)
                                }
                        }
                    }, e.prototype.paintConvex = function (t, e, i) {
                        var n = t.data,
                            r = n.convexShape;
                        if (r && !(r.length < 2)) {
                            var s = this.getGeometry(),
                                a = {},
                                o = d.Graphics.beginStrokeAndFill(e, i);
                            a[r[0].id] = 1, o.moveTo(r[0]._x * s.txm + s.txa, r[0]._y * s.tym + s.tya);
                            for (var l = 1; l < r.length; l++) a[r[l].id] = 1, o.lineTo(r[l]._x * s.txm + s.txa, r[l]._y * s.tym + s.tya);
                            o.closePath(), d.Graphics.endStrokeAndFill(e, o, i);
                            for (var l = 0; l < n.aggregatedNodes.length; l++) {
                                var h = n.aggregatedNodes[l];
                                a[h.id] || (o = d.Graphics.beginStroke(e, i), o.arc(h._x * s.txm + s.txa, h._y * s.tym + s.tya, 1, 0, 2 * Math.PI, !1), d.Graphics.endStroke(e, o, i))
                            }
                        }
                    }, e.prototype.paint = function (e) {
                        this.paintHoverShape(e.context), t.prototype.paint.call(this, e)
                    }, e
                }(u.NodesLayer);
                e.NodesLayer = Z;
                var Y = function (t) {
                    function e() {
                        var e = t.call(this) || this;
                        return e.stack = [], e.zoomLevel = 0, e.mainDataEnabled = !1, e.project = null, e.unproject = null, e
                    }
                    return n(e, t), e.prototype.push = function (t) {
                        return this.stack.push(t)
                    }, e.prototype.peek = function () {
                        return 0 === this.stack.length ? null : this.stack[this.stack.length - 1]
                    }, e.prototype.pop = function () {
                        return 0 === this.stack.length ? null : this.stack.pop()
                    }, e.prototype.getVisibleBoundsLatLon = function () {
                        var t = this.fromDisplay(this.x0, this.y0),
                            e = t.x,
                            i = t.y;
                        t = this.fromDisplay(this.x0 + this.width, this.y0 + this.height);
                        var n = t.x,
                            r = t.y;
                        return this.unprojectRect(new d.Rect(e, i, n, r))
                    }, e.prototype.unprojectRect = function (t) {
                        var e = this.unproject(t.x0, t.y0),
                            i = this.unproject(t.x1, t.y1);
                        return new d.Rect(Math.min(e.lng, i.lng), Math.min(e.lat, i.lat), Math.max(e.lng, i.lng), Math.max(e.lat, i.lat))
                    }, e
                }(u.Scene);
                e.Scene = Y;
                var q = function (t) {
                    function e() {
                        var e = t.apply(this, arguments) || this;
                        return e.shapeSimplificationPrecision = 1.5, e.node = {
                            fillColor: "#c7dae0",
                            lineColor: null,
                            lineWidth: null,
                            radius: 30,
                            shadowColor: null,
                            lineDash: null,
                            expandable: !1
                        }, e
                    }
                    return n(e, t), e
                }(N);
                e.SettingsShapesLayerStyle = q;
                var _ = function (t) {
                    function e(e, i) {
                        return t.call(this, e, i) || this
                    }
                    return n(e, t), e.prototype.postprocessNode = function (t) {
                        t.currentItems = [], t.label, this.postprocessItems(t)
                    }, e.prototype.postprocessLink = function (t) {
                        var e = [];
                        if (t.label) {
                            var i = new d.Label(t.labelStyle);
                            i.text = t.label.toString(), i.style.px = 0, i.style.py = 0, e.push(i)
                        }
                        t.currentItems = e, this.postprocessItems(t)
                    }, e
                }(u.ItemsStyle);
                e.ShapesStyle = _;
                var X = function (t) {
                    function e(e, i) {
                        var n = t.call(this, e, i) || this;
                        return n.style = i.style, n
                    }
                    return n(e, t), e.prototype.createStyleUpdater = function (t) {
                        return new _(t, this)
                    }, e.prototype.paintSelection = function (t, e, i) {
                        var n = this.getGeometry(),
                            r = n.txm,
                            s = n.txa,
                            a = n.tym,
                            o = n.tya,
                            l = 1 / r,
                            h = t.context,
                            u = this.style.selection;
                        h.beginPath();
                        for (var c = 0; c < e.length; c++)
                            for (var d = e[c], p = 0, f = this.getNodeCoords(d, l); p < f.length; p++) {
                                var g = f[p],
                                    m = g[0] * r + s,
                                    v = g[1] * a + o;
                                h.moveTo(m, v);
                                for (var y = 2; y <= g.length - 2; y += 2) h.lineTo(g[y] * r + s, g[y + 1] * a + o);
                                h.closePath()
                            }
                        h.fillStyle = u.fillColor, h.strokeStyle = u.fillColor, h.lineWidth = 2 * u.sizeConstant, h.fill(), h.stroke()
                    }, e.prototype.paintLinks = function (t, e) {}, e.prototype.paintNodes = function (t, e) {
                        for (var i = t.context, n = this.getGeometry(), r = n.txm, s = n.txa, a = n.tym, o = n.tya, l = n.zoom, h = n.x0w, u = n.y0w, c = n.x1w, p = n.y1w, f = 1 / r, g = l > this.style.nodeDetailMinZoom, m = this.style.nodeDetailMinSize * this.style.nodeDetailMinSize * f * f, v = this.style.nodeLabelScaleBase, y = 0; y < e.length; y++) {
                            var S = e[y];
                            if (S.removed) this.deleteNode(S);
                            else if (S.data) {
                                var b = S.bounds;
                                if (!(b.x1 < h || b.x0 > c || b.y1 < u || b.y0 > p)) {
                                    var C = S.opacity,
                                        x = g && b.area() > m || S.hovered;
                                    if (C < 1 && (i.globalAlpha = C), x) {
                                        S.items.sort(function (t, e) {
                                            return t.zIndex - e.zIndex
                                        });
                                        var w = (b.x1 + b.x0) / 2 * r + s,
                                            L = (b.y1 + b.y0) / 2 * a + o,
                                            T = (b.x1 - b.x0) / 2 * r,
                                            k = (b.y1 - b.y0) / 2 * a;
                                        this.paintNodeDetails(S, w, L, T, k, l, v, t, !0)
                                    }
                                    if (S.fillColor || S.lineColor) {
                                        for (var A = d.Graphics.beginStrokeAndFill(i, S), M = 0, I = this.getNodeCoords(S, f); M < I.length; M++) {
                                            var P = I[M],
                                                D = P[0] * r + s,
                                                N = P[1] * a + o;
                                            A.moveTo(D, N);
                                            for (var F = 2; F <= P.length - 2; F += 2) A.lineTo(P[F] * r + s, P[F + 1] * a + o);
                                            A.closePath()
                                        }
                                        d.Graphics.endStrokeAndFill(i, A, S)
                                    }
                                    if (x) {
                                        var w = (b.x1 + b.x0) / 2 * r + s,
                                            L = (b.y1 + b.y0) / 2 * a + o,
                                            T = (b.x1 - b.x0) / 2 * r,
                                            k = (b.y1 - b.y0) / 2 * a;
                                        this.paintNodeDetails(S, w, L, T, k, l, v, t, !1)
                                    }
                                    C < 1 && (i.globalAlpha = 1)
                                }
                            }
                        }
                        return !1
                    }, e.prototype.findObjectAt = function (t, e, i) {
                        for (var n = this.scene.fromDisplay(t, e), r = n.x, s = n.y, a = 1 / this.scene.zoom, o = i * a, l = null, h = this.nodes(), u = h.length - 1; u >= 0; u--) {
                            var c = h[u];
                            if (!c.removed) {
                                var p = this.getNodeCoords(c, a),
                                    f = d.Geometry.distanceToPolygonSq(r, s, p),
                                    g = o * o;
                                if (f <= 0) return {
                                    object: c,
                                    details: null
                                };
                                if (f < g) {
                                    var m = Math.sqrt(f);
                                    m < o && (o = m, l = c)
                                }
                            }
                        }
                        return {
                            object: l,
                            details: null
                        }
                    }, e.prototype.getNodeCoords = function (t, e) {
                        var i = this.style.shapeSimplificationPrecision;
                        if (!(i > 0)) return t.coordinates;
                        i *= e;
                        var n = t.coordinatesCachePrecision;
                        if (n <= i && 2 * n > i) return t.coordinatesCache;
                        var r, s = [];
                        r = n < i ? t.coordinatesCache : t.coordinates;
                        for (var a = 0; a < r.length; a++) {
                            var o = r[a],
                                l = d.Geometry.computeBoundsSize(o);
                            l > 4 * i && (o.length > 10 && (o = d.Geometry.simplify(o, i)), s.push(o))
                        }
                        return t.coordinatesCachePrecision = i, t.coordinatesCache = s, s
                    }, e
                }(u.ItemsLayer);
                e.ShapesLayer = X;
                var Q = function (t) {
                    function e(e, i, n) {
                        var r = t.call(this, e) || this;
                        return r.layerSettings = n, r.parentId = null, r.baseLayer = i, r
                    }
                    return n(e, t), e.prototype.findObjectAt = function (t, e, i) {
                        return null
                    }, e.prototype.nodes = function () {
                        return this.baseLayer.nodes()
                    }, e.prototype.links = function () {
                        return this.baseLayer.links()
                    }, e.prototype.getModified = function () {
                        return this.baseLayer.getModified()
                    }, e.prototype.hasTopologyChanges = function () {
                        return this.baseLayer.hasTopologyChanges()
                    }, e.prototype.hasStyleChanges = function () {
                        return this.baseLayer.hasStyleChanges()
                    }, e.prototype.getGeometry = function () {
                        return this.baseLayer.getGeometry()
                    }, e
                }(d.Layer);
                e.OverlayLayerBase = Q;
                var J = function (e) {
                    function i(t, i, n, r) {
                        var s = e.call(this, t, i, n) || this;
                        return s.idToChart = {}, s.chart = r, s
                    }
                    return n(i, e), i.prototype.updateStyle = function (t) {}, i.prototype.postprocessStyle = function (t) {
                        for (var e in this.baseLayer.newNodes) {
                            var i = this.baseLayer.newNodes[e];
                            this.idToChart[e] = this.createChart(i)
                        }
                        var n;
                        for (var e in this.baseLayer.modifiedNodes) {
                            var i = this.baseLayer.modifiedNodes[e];
                            this.baseLayer.newNodes.hasOwnProperty(e) || (n = this.idToChart[e], n ? this.updateChart(n, i) : this.idToChart[e] = this.createChart(i))
                        }
                        for (var e in this.baseLayer.deletedNodes) n = this.idToChart[e], n && (delete this.idToChart[e], this.removeChart(n));
                        for (var r = 0, s = this.nodes(); r < s.length; r++) {
                            var i = s[r];
                            n = this.idToChart[i.id], n && this.updateXY(n, i)
                        }
                    }, i.prototype.paint = function (t) {}, i.prototype.createChart = function (e) {
                        var i = this.layerSettings.chartType,
                            n = this.getChartSettings(e);
                        if (!n) return null;
                        n.parentChart = this.chart.api, n.area ? n.area.width || (n.area.width = 100, n.area.height = 100) : n.area = {
                            width: 100,
                            height: 100
                        };
                        var r;
                        return r = "piechart" === i ? new t.PieChart(n) : "facetchart" === i ? new t.FacetChart(n) : "timechart" === i ? new t.TimeChart(n) : null
                    }, i.prototype.getChartSettings = function (t) {
                        return this.layerSettings.settingsFunction ? this.layerSettings.settingsFunction(t, t.data) : this.layerSettings.settings
                    }, i.prototype.updateChart = function (t, e) {
                        var i = this.getChartSettings(e);
                        t.updateSettings(i)
                    }, i.prototype.removeChart = function (t) {
                        t.remove()
                    }, i.prototype.updateXY = function (t, e) {
                        var i = this.scene.toDisplay(e.x, e.y),
                            n = i.x,
                            r = i.y,
                            s = 0,
                            a = 0,
                            o = t._impl.settings.area;
                        if (this.layerSettings.autoSize) throw "TODO: implement autoSize";
                        s = o.width, a = o.height;
                        var l = n - s / 2,
                            h = r - a / 2;
                        o.left === l && o.top === h && o.width === s && o.height === a || t.updateSettings({
                            area: {
                                left: n - s / 2,
                                top: r - a / 2,
                                width: s,
                                height: a
                            }
                        })
                    }, i.prototype.remove = function () {
                        for (var t in this.idToChart) this.removeChart(this.idToChart[t]);
                        this.idToChart = {}
                    }, i
                }(Q);
                e.ChartsLayer = J;
                var K = function () {
                        function t(t, e, i, n) {
                            this.drilldownId = n, this.layerSettings = i, this.data = e, this.chart = t, this.loading = !0, this.scene = t.scene, this.layer = this.createLayer(), this.layer.drilldownId = this.drilldownId, this.dataBounds = d.Rect.createEmpty(), this.expandedNode = null
                        }
                        return t.calculateShapeCentroid = function (t) {
                            var e, i, n = 0,
                                r = 0;
                            for (e = 0; e < t.coordinates.length; e++) i = d.Geometry.calculatePolyArea(t.coordinates[e]), Math.abs(i) > Math.abs(r) && (r = i, n = e);
                            if (0 === r) return t.x = (t.bounds.x0 + t.bounds.x1) / 2, void(t.y = (t.bounds.y0 + t.bounds.y1) / 2);
                            var s = d.Geometry.calculatePolyCentroid(t.coordinates[n], r);
                            t.x = s.x, t.y = s.y
                        }, t.prototype.createLayer = function () {
                            return "shapes" === this.layerSettings.type ? new X(this.scene, this.layerSettings) : "items" === this.layerSettings.type ? new e.NodesLayer(this.chart, this.layerSettings, !1) : null
                        }, t.prototype.onSceneChange = function (t) {
                            var e, i, n, r = this.data.dataSettings,
                                s = this.layerSettings,
                                a = r.prefetchRatio;
                            r.perBoundsData ? (e = this.chart.scene.getVisibleBounds(), i = e.clone().inflate(1 + a / 2), n = e.clone().inflate(1 + a)) : i = n = e = this.data.getProjectedBounds();
                            var o = t.changes.geoChartDataNodesIds ? (t.changes.geoChartDataNodesIds[r.id] || {})[this.drilldownId || ""] : null,
                                l = s instanceof E && s.aggregation.enabled;
                            if (this.dataBounds.isEmpty() || o || !e.isInside(this.dataBounds) || t.changes.zoom && (r.perZoomData || l)) {
                                this.loading = !1, this.data.setViewParams(r.aggregationGridSize / this.scene.zoom, this.scene.zoomLevel, e, i, n);
                                var h = this.data.getData(this.drilldownId),
                                    u = h.nodes,
                                    c = h.links,
                                    d = h.hasData,
                                    p = h.loading,
                                    f = u.length;
                                if (d || f > 0) {
                                    if (this.chart.log("Layer " + this.layerSettings.id + ": Updating view rect to " + i + ", contains " + f + " objects"), l) {
                                        var g = new M(s.aggregation, this.scene, this.chart),
                                            m = g.aggregate(u, c);
                                        u = m.nodes, c = m.links
                                    }
                                    this.applyVisibleNodes(this.layer, u, c, null), this.dataBounds = i
                                }
                                this.loading = p
                            } else e.area() * (1 + a) * (1 + a) < this.dataBounds.area() / 5 && (i = e.inflate(1 + a), this.chart.log("Layer " + this.layerSettings.id + ": Shrinking view to " + i), this.shrinkVisibleBounds(i), this.dataBounds = i);
                            if (s.perZoomStyle && t.changes.zoom) {
                                for (var v = 0, y = this.layer.nodes(); v < y.length; v++) this.layer.touchNode(y[v]);
                                for (var S = 0, b = this.layer.links(); S < b.length; S++) this.layer.touchLink(b[S])
                            }
                        }, t.prototype.updateStyle = function (t) {
                            this.layer.setBounds(this.scene.x0, this.scene.y0, this.scene.x0 + this.scene.width, this.scene.y0 + this.scene.height), this.layer.updateStyle(t)
                        }, t.prototype.postprocessStyle = function (t) {
                            this.layer.postprocessStyle(t)
                        }, t.prototype.remove = function () {}, t.prototype.paint = function (t) {
                            this.layer.paint(t)
                        }, t.prototype.findObjectAt = function (t, e, i) {
                            return this.layer.findObjectAt(t, e, i)
                        }, t.prototype.findObjectById = function (t) {
                            return this.layer.findObjectById(t)
                        }, t.prototype.touchObject = function (t) {
                            var e = this.layer,
                                i = e.findObjectById(t);
                            i && e.touchNodeOrLink(i)
                        }, t.prototype.setExpandedNode = function (t) {
                            this.expandedNode && (this.expandedNode.expanded = !1, this.layer.touchNode(this.expandedNode), this.expandedNode = null), t && (this.expandedNode = this.layer.idToNode[t], this.expandedNode && (this.expandedNode.expanded = !0, this.layer.touchNode(this.expandedNode)))
                        }, t.prototype.applyVisibleNodes = function (e, i, n, r) {
                            for (var s = e.idToNode, a = {}, o = {}, l = "shapes" === this.layerSettings.type, h = 0; h < i.length; h++) {
                                var u = i[h],
                                    c = l && u._coordinates || !l && u.hasOwnProperty("_x");
                                if (c) {
                                    var d = u.id;
                                    a[d] = !0;
                                    var p = e.addNode(d);
                                    p.data = u, l && (p.coordinates = u._coordinates, p.bounds = u._bounds, t.calculateShapeCentroid(p)), p.parentNode = r
                                }
                            }
                            for (var f = 0; f < n.length; f++) {
                                var g = n[f],
                                    m = e.addLink(g.id, g.from, g.to);
                                m.data = g, o[m.id] = !0
                            }
                            for (var d in s) {
                                var p = s[d];
                                if (!a.hasOwnProperty(d)) {
                                    e.removeNode(p);
                                    for (var v = 0; v < p.links.length; v++) e.removeLink(p.links[v])
                                }
                            }
                            var y = e.idToLink;
                            for (var d in y) o.hasOwnProperty(d) || e.removeLink(y[d])
                        }, t.prototype.shrinkVisibleBounds = function (t) {
                            for (var e in this.layer.idToNode) {
                                var i = this.layer.idToNode[e];
                                i.data._bounds.isOutside(t) && this.layer.removeNode(i)
                            }
                        }, t
                    }(),
                    $ = function () {
                        function t(t, e, i, n) {
                            this.data = null, this.drilldownId = n, this.layerSettings = i, this.baseLayer = e, this.chart = t, this.scene = t.scene, this.loading = !1, this.layer = this.createLayer()
                        }
                        return t.prototype.createLayer = function () {
                            return "charts" === this.layerSettings.type ? new J(this.scene, this.baseLayer.layer, this.layerSettings, this.chart) : null
                        }, t.prototype.onSceneChange = function (t) {}, t.prototype.updateStyle = function (t) {
                            this.layer.updateStyle(t)
                        }, t.prototype.postprocessStyle = function (t) {
                            this.layer.postprocessStyle(t)
                        }, t.prototype.setExpandedNode = function (t) {}, t.prototype.paint = function (t) {
                            this.layer.paint(t)
                        }, t.prototype.findObjectAt = function (t, e, i) {
                            return null
                        }, t.prototype.findObjectById = function (t) {
                            return null
                        }, t.prototype.touchObject = function (t) {}, t.prototype.remove = function () {
                            this.layer.remove()
                        }, t
                    }(),
                    tt = function () {
                        function t(t, e, i, n, r) {
                            this.firstTime = !0, this.drilldownId = r, this.layerSettings = n, this.data = i, this.baseLayer = e, this.chart = t, this.loading = !0, this.scene = t.scene, this.dataBounds = d.Rect.createEmpty(), this.nodeToAggregated = {}, this.pendingNodes = {}
                        }
                        return t.prototype.onSceneChange = function (t) {
                            if (this.firstTime || this.layerSettings.perZoomStyle && t.changes.zoom || t.changes.data) {
                                this.firstTime = !1;
                                for (var e = this.baseLayer.layer, i = 0, n = e.nodes(); i < n.length; i++) e.touchNode(n[i]);
                                for (var r = 0, s = e.links(); r < s.length; r++) e.touchLink(s[r])
                            }
                        }, t.prototype.updateStyle = function (t) {
                            var e = this.data.dataSettings,
                                i = this.layerSettings,
                                n = this.baseLayer.layer.modifiedNodes,
                                r = t.changes.geoChartDataNodesIds ? (t.changes.geoChartDataNodesIds[e.id] || {})[this.drilldownId || ""] : null;
                            if (d.Helpers.hasProperties(n) || d.Helpers.hasProperties(r)) {
                                var s = i.styleFunction;
                                for (var a in n) {
                                    var o = n[a];
                                    this.nodeToAggregated.hasOwnProperty(o.id) ? s(o, this.nodeToAggregated[o.id]) : this.pendingNodes[a] = o
                                }
                                if (!d.Helpers.hasProperties(this.pendingNodes)) return void(this.loading = !1);
                                var l;
                                if (e.perBoundsData) {
                                    l = d.Rect.createEmpty();
                                    for (var a in this.pendingNodes) {
                                        var o = this.pendingNodes[a];
                                        l.addRect(o.data._bounds)
                                    }
                                } else l = this.data.getProjectedBounds();
                                this.data.setViewParams(e.aggregationGridSize / this.scene.zoom, this.scene.zoomLevel, l, l, l);
                                var h = this.data.getData(this.drilldownId),
                                    u = h.nodes,
                                    c = h.loading;
                                if (!c) {
                                    for (var a in this.pendingNodes) {
                                        var o = this.pendingNodes[a],
                                            p = this.computeAggr(o.data._bounds, o.data._coordinates, u);
                                        this.nodeToAggregated[o.id] = p, s && s(o, p)
                                    }
                                    this.pendingNodes = {}
                                }
                                this.loading = c
                            }
                        }, t.prototype.postprocessStyle = function (t) {}, t.prototype.computeAggr = function (t, e, i) {
                            var n = this.layerSettings;
                            if (n.aggregationFunction) {
                                for (var r = new Array, s = 0; s < i.length; s++) {
                                    var a = i[s],
                                        o = a._x,
                                        l = a._y;
                                    t.containsPoint(o, l) && d.Geometry.isInsidePolygon(o, l, e) && r.push(a)
                                }
                                return n.aggregationFunction(r)
                            }
                            var h = n.aggregation,
                                u = n.aggregationField,
                                c = 0,
                                p = function () {
                                    for (; c < i.length && (!t.containsPoint(i[c]._x, i[c]._y) || !d.Geometry.isInsidePolygon(i[c]._x, i[c]._y, e));) c += 1;
                                    return c < i.length
                                },
                                f = function () {
                                    var t = i[c][u];
                                    return c += 1, t
                                };
                            return d.Helpers.aggregate(h, p, f)
                        }, t.prototype.setExpandedNode = function (t) {}, t.prototype.paint = function (t) {}, t.prototype.findObjectAt = function (t, e, i) {
                            return null
                        }, t.prototype.findObjectById = function (t) {
                            return null
                        }, t.prototype.touchObject = function (t) {}, t.prototype.remove = function () {}, t
                    }(),
                    et = function () {
                        function t(t, e, i, n) {
                            this.layers = [], this.firstTime = !0, this.layerSettings = n, this.data = i, this.renderer = e, this.chart = t, this.loading = !0, this.scene = t.scene
                        }
                        return t.prototype.onSceneChange = function (t) {
                            if (t.changes.navigation || this.firstTime) {
                                this.firstTime = !1;
                                for (var e = this.scene.stack, i = 0; i < Math.min(this.layers.length, e.length) && e[i] === this.layers[i].drilldownId;) i += 1;
                                for (; this.layers.length > i;) {
                                    var n = this.layers.pop();
                                    this.renderer.removeSimpleLayer(n);
                                    var r = this.layers.length > 0 ? this.layers[this.layers.length - 1] : null;
                                    r && r.setExpandedNode(null)
                                }
                                for (; this.layers.length < e.length;) {
                                    var s = e[this.layers.length],
                                        r = this.layers.length > 0 ? this.layers[this.layers.length - 1] : null;
                                    r && r.setExpandedNode(s);
                                    var n = this.renderer.createSimpleLayer(this.data, this.layerSettings, s);
                                    if (!n) break;
                                    this.layers.push(n)
                                }
                            }
                            this.loading = !1;
                            for (var a = 0; a < this.layers.length; a++) {
                                var o = this.layers[a];
                                o.onSceneChange(t), this.loading = this.loading || o.loading
                            }
                        }, t.prototype.updateStyle = function (t) {
                            for (var e = 0; e < this.layers.length; e++) {
                                var i = this.layers[e];
                                i.updateStyle(t)
                            }
                        }, t.prototype.postprocessStyle = function (t) {
                            for (var e = 0; e < this.layers.length; e++) {
                                var i = this.layers[e];
                                i.postprocessStyle(t)
                            }
                        }, t.prototype.paint = function (t) {
                            for (var e = 0; e < this.layers.length; e++) {
                                var i = this.layers[e];
                                i.paint(t)
                            }
                        }, t.prototype.findObjectAt = function (t, e, i) {
                            for (var n = this.layers.length - 1; n >= 0; n--) {
                                var r = this.layers[n].findObjectAt(t, e, i);
                                if (r && r.object) return r
                            }
                            return null
                        }, t.prototype.findObjectById = function (t) {
                            for (var e = this.layers.length - 1; e >= 0; e--) {
                                var i = this.layers[e].findObjectById(t);
                                if (i) return i
                            }
                            return null
                        }, t.prototype.touchObject = function (t) {
                            for (var e = 0; e <= this.layers.length; e++) this.layers[e].touchObject(t)
                        }, t.prototype.remove = function () {
                            for (var t = 0; t < this.layers.length; t++) {
                                var e = this.layers[t];
                                this.renderer.removeSimpleLayer(e)
                            }
                            this.layers = []
                        }, t
                    }(),
                    it = function (t) {
                        function e(e) {
                            var i = t.call(this) || this;
                            return i.animationOrder = 900, i.paintOrder = 10, i.updateOrder = 10, i.layers = [], i.idToLayer = {}, i.idToSimpleLayer = {}, i.drilldownLayer = null, i.chart = e, i.scene = e.scene, i.events = e.events, i
                        }
                        return n(e, t), e.prototype.createData = function (t) {
                            var e = null;
                            return t.id && (e = this.chart.getData(t.id)), e
                        }, e.prototype.createSimpleLayer = function (t, e, i) {
                            var n;
                            if (e instanceof R) {
                                var r = this.idToSimpleLayer[e.shapesLayer + i];
                                if (!r) return this.chart.error("ItemsOnShape layer: shapesLayer " + e.shapesLayer + " not found, must come first in the layers array."), null;
                                "charts" === e.type ? n = new $(this.chart, r, e, i) : "aggregateOnShapes" === e.type && (n = new tt(this.chart, r, t, e, i))
                            } else n = new K(this.chart, t, e, i);
                            return this.idToSimpleLayer[e.id + i] = n, n
                        }, e.prototype.removeLayer = function (t) {
                            t instanceof et ? t.remove() : this.removeSimpleLayer(t)
                        }, e.prototype.removeSimpleLayer = function (t) {
                            t.remove();
                            var e = t.layerSettings.id + t.drilldownId;
                            delete this.idToSimpleLayer[e]
                        }, e.prototype.onSceneChange = function (t) {
                            var e = !1,
                                i = t.changes,
                                n = i.settingsChanges;
                            if (n && (n.layers || n.layerTypes)) {
                                for (var r in n.layers) {
                                    var s = this.idToLayer[r];
                                    s && (this.removeLayer(s), delete this.idToLayer[r])
                                }
                                e = !0
                            } else(i.zoom || i.data) && (e = !0);
                            if (e) {
                                var a = this.idToLayer;
                                this.layers = [], this.idToLayer = {};
                                var o = this.scene.zoomLevel;
                                this.drilldownLayer = null;
                                for (var l = this.scene.settings.navigation.drilldownLayer, h = 0; h < this.chart.settings._computedLayers.length; h++) {
                                    var u = this.chart.settings._computedLayers[h],
                                        c = u.enabled && u.minZoom <= o && u.maxZoom >= o,
                                        d = a[u.id];
                                    if (c) {
                                        var p = this.createData(u.data),
                                            f = !1;
                                        if (p && p.dataSettings.perDrilldownData && (f = !0), u instanceof R) {
                                            var g = this.idToLayer[u.shapesLayer];
                                            if (!g) {
                                                this.chart.error("Overlay layer: shapeLayer " + u.shapesLayer + " not found, must come first in the layers array.");
                                                continue
                                            }
                                            d && d.baseLayer !== g && (this.removeLayer(d), d = null), f = f || g.data.dataSettings.perDrilldownData
                                        }
                                        var s = void 0;
                                        if (d && d.data === p) s = d;
                                        else if (d && this.removeLayer(d), f) s = new et(this.chart, this, p, u);
                                        else if (s = this.createSimpleLayer(p, u, null), !s) continue;
                                        u.id === l && (this.drilldownLayer = s), this.layers.push(s), this.idToLayer[u.id] = s
                                    } else d && this.removeLayer(d)
                                }
                                for (var r in a) {
                                    var s = a[r];
                                    this.idToLayer.hasOwnProperty(r) || this.removeLayer(s)
                                }
                            }
                            for (var m = 0; m < this.layers.length; m++) {
                                var s = this.layers[m];
                                s.onSceneChange(t)
                            }
                        }, e.prototype.doAnimations = function (t) {
                            for (var e = 0; e < this.layers.length; e++) {
                                var i = this.layers[e];
                                i.updateStyle(t)
                            }
                            for (var n = !1, e = 0; e < this.layers.length; e++) {
                                var i = this.layers[e];
                                i.postprocessStyle(t), n = n || i.loading
                            }
                            this.scene.loading = n
                        }, e.prototype.paintScene = function (t) {
                            d.Graphics.pushClip(t, this.scene.x0, this.scene.y0, this.scene.width, this.scene.height);
                            for (var e = !1, i = 0; i < this.layers.length; i++) {
                                var n = this.layers[i];
                                n.paint(t), e = e || n.loading
                            }
                            d.Graphics.popClip(t), this.scene.loading = e
                        }, e.prototype.findObjectById = function (t) {
                            for (var e = this.layers.length - 1; e >= 0; e--) {
                                var i = this.layers[e],
                                    n = i.findObjectById(t);
                                if (n) return n
                            }
                            return null
                        }, e.prototype.touchObjects = function (t) {
                            for (var e = this.layers.length - 1; e >= 0; e--)
                                for (var i = this.layers[e], n = 0; n < t.length; n++) i.touchObject(t[n])
                        }, e.prototype.findObjectAt = function (t, e, i) {
                            for (var n = this.layers.length - 1; n >= 0; n--) {
                                var r = this.layers[n],
                                    s = r.findObjectAt(t, e, i);
                                if (s && s.object) return s
                            }
                            return null
                        }, e
                    }(d.ChartElement);
                e.Renderer = it;
                var nt = function (t) {
                    function e(e) {
                        var i = t.call(this) || this;
                        return i.animationOrder = 1e3, i.paintOrder = 5, i.updateOrder = 1300, i.chart = e, i.scene = i.chart.scene, i
                    }
                    return n(e, t), e.prototype.showInitialNodes = function () {
                        var t = this.scene.settings.navigation.initialDrilldown;
                        return this.scene.stack = t, this.chart.events.notifySceneChanges({
                            navigation: !0
                        })
                    }, e.prototype.onPanZoom = function () {}, e.prototype.onNewDataObject = function () {}, e.prototype.expandNode = function (t) {
                        var e = t.layer.drilldownId,
                            i = t.id;
                        if (i === this.scene.peek()) return !1;
                        for (; this.scene.peek() !== e;) this.scene.pop();
                        return this.scene.push(i), this.chart.events.notifySceneChanges({
                            navigation: !0
                        }), !0
                    }, e.prototype.collapseNode = function (t) {
                        throw "Not implemented"
                    }, e
                }(d.Navigator);
                e.Navigator = nt;
                var rt = !1,
                    st = function (t) {
                        function e(e, i) {
                            var n = t.call(this, new I(e), new Y, i) || this;
                            return n.events.forceFloating = !0, n._map = n._map || null, n._pendingZoomLevel = null, n._pendingLatitude = null, n._pendingBounds = null, n.navigator = n.events.addElement(new nt(n)), n.menu = n.events.addElement(new u.Menu(n)), n.info = n.events.addElement(new u.InfoPopup(n)), n.selection = n.events.addElement(new G(n)), n._map && (n.renderer = n.events.addElement(new it(n))), n.navigator.showInitialNodes(), n.finalInitialize(), n
                        }
                        return n(e, t), e.prototype.getMap = function () {
                            return this._map
                        }, e.prototype.domLayerCreated = function () {
                            return rt || (d.Helpers.compareVersions(L.version, [0, 7]) || this.error("ZoomCharts requires Leaflet.js version 0.7.0 or newer. The loaded version is " + L.version), rt = !0), this._map ? void this.applyGestureSettings() : (this._map = this._domLayer.map, null != this._pendingLatitude ? this.setView(this._pendingLatitude, this._pendingLongitude, this._pendingZoomLevel) : (null !== this.settings.navigation.initialLat && this.setView(this.settings.navigation.initialLat, this.settings.navigation.initialLng, this.settings.navigation.initialZoom), null != this._pendingZoomLevel && this.setZoomLevel(this._pendingZoomLevel)), null != this._pendingBounds && this.setBounds(this._pendingBounds), this.events && (this.renderer = this.events.addElement(new it(this)), this.events.notifySceneChanges({
                                settings: !0,
                                settingsChanges: this.settings,
                                zoom: !0,
                                bounds: !0
                            })), this.applyGestureSettings(), void(this.scene.loading = !1))
                        }, e.prototype.createDomLayer = function () {
                            return this._domLayer = new k(this), this._domLayer
                        }, e.prototype.createDataObj = function (t) {
                            return new x(this, t)
                        }, e.prototype.getData = function (e) {
                            return t.prototype.getData.call(this, e)
                        }, e.prototype.onSettingsChanged = function (t) {
                            var e = {},
                                i = t.navigation && t.navigation.initialDrilldown;
                            i && this.navigator.showInitialNodes(), t.filters && (e.filters = !0), t.style && (e.style = !0), this.events.notifySceneChanges(e)
                        }, e.prototype.saveNavigation = function () {
                            return this._map ? this.scene.getVisibleBoundsLatLon() : null
                        }, e.prototype.restoreNavigation = function (t) {
                            this.setBounds(t)
                        }, e.prototype.save = function () {
                            return ""
                        }, e.prototype.restore = function (t, e) {}, e.prototype.setZoomLevel = function (t) {
                            this._map ? this._map.setZoom(t) : this._pendingZoomLevel = t
                        }, e.prototype.setView = function (t, e, i) {
                            this._map ? this._map.setView(L.latLng(t, e), i) : (this._pendingLatitude = t, this._pendingLongitude = e, this._pendingZoomLevel = i)
                        }, e.prototype.setBounds = function (t) {
                            if (this._map) {
                                var e = t;
                                if (void 0 !== e.east) this._map.fitBounds(L.latLngBounds(L.latLng(e.south, e.west), L.latLng(e.north, e.east)));
                                else {
                                    var i = t;
                                    this._map.fitBounds(L.latLngBounds(L.latLng(i.y1, i.x0), L.latLng(i.y0, i.x1)))
                                }
                            } else this._pendingBounds = t
                        }, e.prototype.getNodeDimensions = function (t) {
                            var e = t;
                            if (d.Helpers.isString(t) && (e = this.getNode(t)), !e) return null;
                            var i = this.scene.toDisplay(e.x, e.y),
                                n = i.x,
                                r = i.y,
                                s = e.hHeight * this.scene.zoom,
                                a = e.hWidth * this.scene.zoom;
                            return {
                                x: n,
                                y: r,
                                radius: s,
                                hwidth: a
                            }
                        }, e.prototype.expandNode = function (t) {
                            var e = null;
                            e = d.Helpers.isString(t) ? this.getNode(t) : t, this.navigator.expandNode(e)
                        }, e.prototype.collapseNode = function (t) {
                            var e = null;
                            e = d.Helpers.isString(t) ? this.getNode(t) : t, this.navigator.collapseNode(e)
                        }, e.prototype.getNode = function (t) {
                            var e = this.renderer ? this.renderer.findObjectById(t) : null;
                            return e instanceof u.Node || (e = null), e
                        }, e.prototype.getLink = function (t) {
                            var e = this.renderer ? this.renderer.findObjectById(t) : null;
                            return e instanceof u.Link || (e = null), e
                        }, e.prototype.hideMenu = function () {
                            this.menu.hideMenu()
                        }, e.prototype.defaultClick = function (t, e) {
                            var i = "drilldown" === this.settings.interaction.mode,
                                n = e.clickNode;
                            i && n && n.expandable && this.navigator.expandNode(n) && (this.setBounds(this.scene.unprojectRect(n.data._bounds)), t.preventDefault())
                        }, e.prototype.defaultRightClick = function (t, e) {
                            e.clickNode && (this.menu.toggleNodeMenu(e.clickNode), t.preventDefault()), e.clickLink && (this.menu.toggleLinkMenu(t.x, t.y, e.clickLink), t.preventDefault())
                        }, e.prototype.applyGestureSettings = function () {
                            var t = this._map;
                            this.settings.interaction.zooming.zoomInOnDoubleClick === !1 && t.doubleClickZoom.disable()
                        }, e
                    }(u.Impl);
                e.Impl = st
            }(r = i.GeoChart || (i.GeoChart = {}))
    }(i = t.Internal || (t.Internal = {})),
    function (t) {
        var e;
        ! function (t) {
            t[t.always = 2] = "always", t[t.disabled = 0] = "disabled", t[t.hovered = 1] = "hovered", t[t.selected = 3] = "selected"
        }(e = t.GeoChartSettingsAggregatedShapeStyleMode || (t.GeoChartSettingsAggregatedShapeStyleMode = {}));
        var i;
        ! function (t) {
            t[t.always = 2] = "always", t[t.auto = 1] = "auto", t[t.never = 0] = "never"
        }(i = t.LinearChartSettingsValueAxisBaseLineLabelMode || (t.LinearChartSettingsValueAxisBaseLineLabelMode = {}))
    }(e = t.Configuration || (t.Configuration = {}));
    var r = function (t) {
        function e(n) {
            var r = t.call(this) || this;
            return r.typeName = "NetChart", e.chartFactoryMethod ? r._impl = e.chartFactoryMethod(function (t) {
                return new i.NetChart.Impl(t, r)
            }, n) : r._impl = new i.NetChart.Impl(n, r), r
        }
        return n(e, t), e.prototype.updateSettings = function (e) {
            return t.prototype.updateSettings.call(this, e), this
        }, e.prototype.replaceSettings = function (e) {
            return t.prototype.replaceSettings.call(this, e), this
        }, e.prototype.addData = function (t, e) {
            null == e && (e = "default"), this._impl.addData(t, e)
        }, e.prototype.removeData = function (t, e) {
            null == e && (e = "default"), this._impl.removeData(t, e)
        }, e.prototype.replaceData = function (t, e) {
            null == e && (e = "default"), this._impl.replaceData(t, e)
        }, e.prototype.hideMenu = function () {
            return this._impl.hideMenu(), this
        }, e.prototype.updateStyle = function (t) {
            t ? (this._impl.touchObjects(t), this._impl.events.requestPaint()) : this._impl.updateStyle(null)
        }, e.prototype.getNode = function (t) {
            return this._impl.getNode(t)
        }, e.prototype.getLink = function (t) {
            return this._impl.getLink(t)
        }, e.prototype.showNode = function (t) {
            return this._impl.showNode(t)
        }, e.prototype.hideNode = function (t) {
            return this._impl.hideNode(t)
        }, e.prototype.expandNode = function (t) {
            return this._impl.expandNode(t)
        }, e.prototype.addFocusNode = function (t, e) {
            return void 0 === e && (e = -1), null == e && (e = -1), this._impl.addFocusNode(t, e)
        }, e.prototype.removeFocusNode = function (t) {
            return this._impl.removeFocusNode(t)
        }, e.prototype.clearFocus = function () {
            return this._impl.clearFocus()
        }, e.prototype.collapseNode = function (t) {
            return this._impl.collapseNode(t)
        }, e.prototype.closeNode = function (t) {
            return this._impl.closeNode(t)
        }, e.prototype.lockNode = function (t, e, i) {
            return this._impl.lockNode(t, e, i)
        }, e.prototype.unlockNode = function (t) {
            return this._impl.unlockNode(t)
        }, e.prototype.zoom = function (t, e) {
            return void 0 === e && (e = !0), null != t && this._impl.setZoom(t, !!e), this._impl.scene.zoom
        }, e.prototype.resetLayout = function () {
            return this._impl.resetLayout()
        }, e.prototype.selection = function (t) {
            return t && this._impl.setSelection(t), this._impl.scene.selection
        }, e.prototype.zoomIn = function (t, e) {
            return void 0 === e && (e = !0), this.scrollIntoView(t)
        }, e.prototype.nodes = function () {
            return this._impl.getCurrentNodes()
        }, e.prototype.links = function () {
            return this._impl.getCurrentLinks()
        }, e.prototype.getNodeDimensions = function (t) {
            return this._impl.getNodeDimensions(t)
        }, e.prototype.exportData = function (t, e) {
            return void 0 === t && (t = !0), void 0 === e && (e = !0), this._impl.exportData(!!t, !!e)
        }, e.prototype.scrollIntoView = function (t, e) {
            this._impl.scrollIntoView(t, e)
        }, e.prototype.on = function (e, i) {
            t.prototype.on.call(this, e, i)
        }, e
    }(i.Base.Api);
    r.themes = {
        flat: i.NetChart.Settings.FlatTheme,
        dark: i.NetChart.Settings.DarkTheme
    }, r.chartFactoryMethod = null, t.NetChart = r, i.Base.Helpers.exportSymbol("NetChart", t.NetChart);
    var s = function (t) {
        function e(n) {
            var r = t.call(this) || this;
            return r._cachedApiCalls = [], r.typeName = "TimeChart", e.chartFactoryMethod ? r._impl = e.chartFactoryMethod(function (t) {
                return new i.TimeChart.Impl(t, r)
            }, n) : r._impl = new i.TimeChart.Impl(n, r), r
        }
        return n(e, t), e.prototype._notifyAssetsLoaded = function () {
            var t = this._cachedApiCalls;
            if (null !== t) {
                this._cachedApiCalls = null;
                for (var e = 0; e < t.length; e++) t[e]()
            }
        }, e.prototype.updateSettings = function (e) {
            return t.prototype.updateSettings.call(this, e), this
        }, e.prototype.replaceSettings = function (e) {
            return t.prototype.replaceSettings.call(this, e), this
        }, e.prototype.on = function (e, i) {
            t.prototype.on.call(this, e, i)
        }, e.prototype.time = function (t, e, n) {
            var r = this;
            void 0 === n && (n = !0);
            var s = this._impl,
                a = s.scene,
                o = i.TimeChart.TimeStep.timeUnitDiffs,
                l = !s.displayUnit || o[s.displayUnit.unit] < o.d;
            if (null != t && null != e) {
                if (this._cachedApiCalls) return this._cachedApiCalls.push(function () {
                    r.time(t, e, n)
                }), [null, null];
                s.setTimeRange(a.timestampToInternal(+t, l), a.timestampToInternal(+e, l), n)
            }
            return [a.timestampFromInternal(s.timeStart, l), a.timestampFromInternal(s.timeEnd, l)]
        }, e.prototype.targetTime = function () {
            var t = this._impl,
                e = t.scene,
                n = t.scrolling,
                r = i.TimeChart.TimeStep.timeUnitDiffs,
                s = n.targetUnit || t.displayUnit;
            if (!s) return [null, null];
            var a = !t.displayUnit || r[t.displayUnit.unit] < r.d;
            return [e.timestampFromInternal(n.getFrom(), a), e.timestampFromInternal(n.getTo(), a)]
        }, e.prototype.targetDisplayUnit = function () {
            var t = this._impl,
                e = t.scrolling.targetUnit || t.displayUnit || t.scene.displayUnit;
            return e ? e.toString() : null;
        }, e.prototype.addData = function (t, e) {
            null == e && (e = "default"), this._impl.addData(t, e)
        }, e.prototype.replaceData = function (t, e) {
            null == e && (e = "default"), this._impl.replaceData(t, e)
        }, e.prototype.setDisplayPeriod = function (t, e, i) {
            var n = this;
            return void 0 === i && (i = !0), this._cachedApiCalls ? void this._cachedApiCalls.push(function () {
                n.setDisplayPeriod(t, e, i)
            }) : void this._impl.setDisplayPeriod(t, e, null, i)
        }, e.prototype.displayUnit = function (t, e, n) {
            var r = this;
            if (void 0 === e && (e = !0), void 0 !== n && i.Base.Helpers.warn("TimeChart.displayUnit() no longer supports the `rescale` parameter."), t) {
                if (this._cachedApiCalls) return this._cachedApiCalls.push(function () {
                    r.displayUnit(t, e)
                }), null;
                this._impl.setDisplayUnit(t, e, "api", !0)
            }
            return this._impl.displayUnit ? this._impl.displayUnit.toString() : null
        }, e.prototype.selection = function (t, e) {
            var n = this,
                r = this._impl,
                s = r.scene,
                a = i.TimeChart.TimeStep.timeUnitDiffs,
                o = !r.displayUnit || a[r.displayUnit.unit] < a.d;
            if (void 0 !== t && void 0 !== e) {
                if (this._cachedApiCalls) return this._cachedApiCalls.push(function () {
                    n.selection(t, e)
                }), [null, null];
                r.setSelection(null === t ? null : s.timestampToInternal(+t, o), null === e ? null : s.timestampToInternal(+e, o))
            }
            return [s.timestampFromInternal(r.scene.selectionStart, o), s.timestampFromInternal(r.scene.selectionEnd, o)]
        }, e.prototype.scroll = function (t, e, i) {
            return void 0 === e && (e = !0), void 0 === i && (i = !1), this._impl.scroll(t, e)
        }, e.prototype.zoomOut = function (t, e) {
            var n = this;
            return void 0 === e && (e = !0), this._cachedApiCalls ? void this._cachedApiCalls.push(function () {
                n.zoomOut(t, e)
            }) : void this._impl.zoomOut(e, "api", i.TimeChart.TimeStep.parse(t))
        }, e.prototype.zoomIn = function (t, e, n) {
            var r = this;
            if (void 0 === e && (e = null), void 0 === n && (n = !0), this._cachedApiCalls) return void this._cachedApiCalls.push(function () {
                r.zoomIn(t, e, n)
            });
            var s = this._impl,
                a = i.TimeChart.TimeStep.parse(t);
            if (null != e) {
                var o = a || s.displayUnit,
                    l = i.TimeChart.TimeStep.timeUnitDiffs,
                    h = !o || l[o.unit] < l.d;
                e = s.scene.timestampToInternal(+e, h)
            }
            s.zoomIn(a, e, n, "api")
        }, e.prototype.replaceSeries = function (t) {
            return this._impl.deprecated("replaceSeries", "replaceSettings"), this.replaceSettings({
                series: t
            })
        }, e.prototype.exportVisibleData = function () {
            return this._impl.exportVisibleData()
        }, e.prototype.showInfoPopup = function (t, e, n) {
            var r = this;
            if (this._cachedApiCalls) return void this._cachedApiCalls.push(function () {
                r.showInfoPopup(t, e, n)
            });
            var s = this._impl,
                a = s.scene,
                o = i.TimeChart.TimeStep.timeUnitDiffs,
                l = !s.displayUnit || o[s.displayUnit.unit] < o.d;
            s.showInfoPopup(null == t ? null : a.timestampToInternal(+t, l), null == e ? null : a.timestampToInternal(+e, l), n)
        }, e.prototype.getEnabledSeries = function () {
            return this._impl.getEnabledSeries()
        }, e.prototype.getSeries = function () {
            return this._impl.getSeries()
        }, e
    }(i.Base.Api);
    s.themes = {
        flat: i.TimeChart.Settings.FlatTheme,
        round: i.TimeChart.Settings.RoundTheme,
        gradient: i.TimeChart.Settings.GradientTheme,
        static: i.TimeChart.Settings.StaticChart,
        dark: i.TimeChart.Settings.DarkTheme
    }, s.chartFactoryMethod = null, t.TimeChart = s, i.Base.Helpers.exportSymbol("TimeChart", t.TimeChart);
    var a = function (t) {
        function e(n) {
            var r = t.call(this) || this;
            return r.typeName = "PieChart", e.chartFactoryMethod ? r._impl = e.chartFactoryMethod(function (t) {
                return new i.PieChart.Impl(t, r)
            }, n) : r._impl = new i.PieChart.Impl(n, r), r
        }
        return n(e, t), e.prototype.updateSettings = function (e) {
            return t.prototype.updateSettings.call(this, e), this
        }, e.prototype.replaceSettings = function (e) {
            return t.prototype.replaceSettings.call(this, e), this
        }, e.prototype.updateFilter = function () {
            return this._impl.updateFilter(), this
        }, e.prototype.addData = function (t, e) {
            null == e && (e = "default"), this._impl.addData(t, e)
        }, e.prototype.replaceData = function (t, e) {
            null == e && (e = "default"), this._impl.replaceData(t, e)
        }, e.prototype.selection = function (t) {
            if (t)
                if (Array.isArray(t)) {
                    for (var e = t.slice(), n = 0; n < e.length; n++) {
                        var r = e[n];
                        r instanceof i.PieChart.Slice ? e[n] = r.id : i.Base.Helpers.isString(r) || this._impl.error("PieChart.selection() - the argument must be an array of PieChart.Slice objects or strings.")
                    }
                    this._impl.setSelection(e)
                } else this._impl.error("PieChart.selection() - the argument must be an array of PieChart.Slice objects or strings.");
            return this._impl.scene.selection.slice()
        }, e.prototype.getPie = function () {
            return this._impl.getPie()
        }, e.prototype.getPieOffset = function () {
            return this._impl.navigator.getPieOffset()
        }, e.prototype.setPie = function (t, e) {
            return void 0 === e && (e = 0), null == e && (e = 0), this._impl.setPie(t, e), this
        }, e.prototype.setPieOffset = function (t) {
            return this._impl.setPieOffset(t), this
        }, e.prototype.getActiveSlices = function () {
            return this._impl.getActiveSlices()
        }, e.prototype.getActivePies = function () {
            return this._impl.getActivePies()
        }, e.prototype.getActivePie = function () {
            var t = this._impl.getActivePies();
            return t[t.length - 1]
        }, e.prototype.expandSlice = function (t) {
            return this._impl.expandSlice(t, "api")
        }, e.prototype.getSliceDimensions = function (t, e) {
            return void 0 === e && (e = !1), null == e && (e = !1), this._impl.getSliceDimensions(t, e)
        }, e.prototype.on = function (e, i) {
            t.prototype.on.call(this, e, i)
        }, e
    }(i.Base.Api);
    a.themes = {
        dark: i.PieChart.Settings.DarkTheme,
        flat: i.PieChart.Settings.FlatTheme,
        bevel: i.PieChart.Settings.BevelTheme,
        gradient: i.PieChart.Settings.GradientTheme,
        raised: i.PieChart.Settings.CanTheme
    }, a.chartFactoryMethod = null, t.PieChart = a, i.Base.Helpers.exportSymbol("PieChart", t.PieChart);
    var o = function (t) {
        function e(n) {
            var r = t.call(this) || this;
            return r.typeName = "FacetChart", e.chartFactoryMethod ? r._impl = e.chartFactoryMethod(function (t) {
                return new i.FacetChart.Impl(t, r)
            }, n) : r._impl = new i.FacetChart.Impl(n, r), r
        }
        return n(e, t), e.prototype.updateSettings = function (e) {
            return t.prototype.updateSettings.call(this, e), this
        }, e.prototype.replaceSettings = function (e) {
            return t.prototype.replaceSettings.call(this, e), this
        }, e.prototype.addData = function (t, e) {
            null == e && (e = "default"), this._impl.addData(t, e)
        }, e.prototype.replaceData = function (t, e) {
            null == e && (e = "default"), this._impl.replaceData(t, e)
        }, e.prototype.updateFilter = function () {
            return this._impl.updateFilter(), this
        }, e.prototype.selection = function (t) {
            if (t)
                if (Array.isArray(t)) {
                    for (var e = t.slice(), n = 0; n < e.length; n++) {
                        var r = e[n];
                        r instanceof i.FacetChart.Item ? e[n] = r.id : i.Base.Helpers.isString(r) || this._impl.error("FacetChart.selection() - the argument must be an array of FacetChart.Item objects or strings.")
                    }
                    this._impl.setSelection(e)
                } else this._impl.error("FacetChart.selection() - the argument must be an array of FacetChart.Item objects or strings.");
            return this._impl.scene.selection.slice()
        }, e.prototype.setPie = function (t, e, i) {
            return void 0 === e && (e = 0), void 0 === i && (i = null), Array.isArray(t) || (t = [t]), this._impl.setPie(t, e, i), this
        }, e.prototype.getPie = function () {
            return this._impl.getPie()
        }, e.prototype.getPieOffset = function () {
            return this._impl.getPieOffset()
        }, e.prototype.getActiveItems = function () {
            return this._impl.getActiveItems()
        }, e.prototype.getActiveFacets = function () {
            return this._impl.getActiveFacets()
        }, e.prototype.getActiveFacet = function () {
            var t = this._impl.getActiveFacets();
            return t[t.length - 1]
        }, e.prototype.expandSlice = function (t) {
            return this._impl.expandItem(t, "api")
        }, e.prototype.replaceSeries = function (t) {
            return this._impl.deprecated("replaceSeries", "replaceSettings"), this.replaceSettings({
                series: t
            })
        }, e.prototype.on = function (e, i) {
            t.prototype.on.call(this, e, i)
        }, e.prototype.getEnabledSeries = function () {
            return this._impl.getEnabledSeries()
        }, e.prototype.getSeries = function () {
            return this._impl.getSeries()
        }, e
    }(i.Base.Api);
    o.themes = {
        dark: i.FacetChart.Settings.DarkTheme
    }, o.chartFactoryMethod = null, t.FacetChart = o, i.Base.Helpers.exportSymbol("FacetChart", t.FacetChart);
    var l = function (t) {
        function e(n) {
            var r = t.call(this) || this;
            return r.typeName = "GeoChart", e.chartFactoryMethod ? r._impl = e.chartFactoryMethod(function (t) {
                return new i.GeoChart.Impl(t, r)
            }, n) : r._impl = new i.GeoChart.Impl(n, r), r
        }
        return n(e, t), e.prototype.updateSettings = function (e) {
            return t.prototype.updateSettings.call(this, e), this
        }, e.prototype.replaceSettings = function (e) {
            return t.prototype.replaceSettings.call(this, e), this
        }, e.prototype.addData = function (t, e) {
            null == e && (e = "default"), this._impl.addData(t, e)
        }, e.prototype.replaceData = function (t, e) {
            null == e && (e = "default"), this._impl.replaceData(t, e)
        }, e.prototype.hideMenu = function () {
            return this._impl.hideMenu(), this
        }, e.prototype.getNode = function (t) {
            return this._impl.getNode(t)
        }, e.prototype.updateStyle = function (t) {
            t ? this._impl.renderer && (this._impl.renderer.touchObjects(t), this._impl.events.requestPaint()) : this._impl.updateStyle(null)
        }, e.prototype.selection = function (t) {
            return t && this._impl.setSelection(t), this._impl.scene.selection
        }, e.prototype.bounds = function (t) {
            t && this._impl.setBounds(t);
            var e = this._impl.scene.getVisibleBoundsLatLon();
            return {
                east: e.x1,
                north: e.y1,
                west: e.x0,
                south: e.y0
            }
        }, e.prototype.back = function () {
            return this._impl.back(), this
        }, e.prototype.zoomLevel = function (t) {
            return t && this._impl.setZoomLevel(t), this._impl.scene.zoomLevel
        }, e.prototype.getNodeDimensions = function (t) {
            return this._impl.getNodeDimensions(t)
        }, e.prototype.leaflet = function () {
            return this._impl.getMap()
        }, e.prototype.on = function (e, i) {
            t.prototype.on.call(this, e, i)
        }, e
    }(i.Base.Api);
    l.themes = {
        flat: i.GeoChart.Settings.FlatTheme
    }, l.chartFactoryMethod = null, t.GeoChart = l, i.Base.Helpers.exportSymbol("GeoChart", t.GeoChart)
}(ZoomCharts || (ZoomCharts = {}));